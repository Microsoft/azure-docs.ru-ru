---
title: Запрос данных о графе двойника
titleSuffix: Azure Digital Twins
description: Дополнительные сведения см. в статье запрос к графу двойников двойника в Azure Digital.
author: baanders
ms.author: baanders
ms.date: 11/19/2020
ms.topic: how-to
ms.service: digital-twins
ms.custom: contperf-fy21q2
ms.openlocfilehash: 3a5c98b3fad76d2206d1fcba79663063e22ecdbc
ms.sourcegitcommit: c27a20b278f2ac758447418ea4c8c61e27927d6a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/03/2021
ms.locfileid: "101737976"
---
# <a name="query-the-azure-digital-twins-twin-graph"></a>Запрос к графу Azure Digital двойников двойника

В этой статье приведены примеры запросов и подробные инструкции по использованию **языка запросов Azure Digital двойников** для запроса информации о [двойника Graph](concepts-twins-graph.md) . (Общие сведения о языке запросов и полный список его возможностей см. в разделе [*Основные понятия: язык запросов*](concepts-query-language.md).)

Эта статья начинается с примеров запросов, иллюстрирующих языковую структуру запросов и общие операции запросов для Digital двойников. Затем в нем описывается, как выполнять запросы после их записи с помощью [API запросов](/rest/api/digital-twins/dataplane/query) цифровых двойников Azure или [пакета SDK](how-to-use-apis-sdks.md#overview-data-plane-apis).

> [!NOTE]
> Если вы выполняете примеры запросов, приведенные ниже с помощью вызова API или пакета SDK, необходимо сжать текст запроса в одну строку.

## <a name="show-all-digital-twins"></a>Показывать все цифровые двойников

Ниже приведен базовый запрос, который возвращает список всех цифровых двойников в экземпляре:

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="GetAllTwins":::

## <a name="query-by-property"></a>Запрос по свойству

Получение цифровых двойников по **свойствам** (включая идентификатор и метаданные):

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="QueryByProperty1":::

> [!NOTE]
> Идентификатор цифрового двойника запрашивается с помощью поля метаданных `$dtId`.

Вы также можете получить двойников в зависимости от **того, определено ли определенное свойство**. Ниже приведен запрос, который получает двойников с определенным свойством *Location* :

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="QueryByProperty2":::

Это может помочь получить двойников по их свойствам *тегов* , как описано в разделе [Добавление тегов в Digital двойников](how-to-use-tags.md). Ниже приведен запрос, который получает все двойников, помеченные *красным цветом*:

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="QueryMarkerTags1":::

Можно также получить двойников на основе **типа свойства**. Ниже приведен запрос, который получает двойников, свойство *температуры* которого является числом:

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="QueryByProperty3":::

>[!TIP]
> Если свойство имеет тип `Map` , ключи и значения сопоставлений можно использовать непосредственно в запросе следующим образом:
> :::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="QueryByProperty4":::

## <a name="query-by-model"></a>Запрос по модели

`IS_OF_MODEL`Оператор можно использовать для фильтрации на основе [**модели**](concepts-models.md)двойника.

Он учитывает [наследование](concepts-models.md#model-inheritance) и [Управление версиями](how-to-manage-model.md#update-models)модели и вычисляет **значение true** для заданного двойника, если двойника соответствует одному из следующих условий:

* Двойника напрямую реализует модель, предоставленную в `IS_OF_MODEL()` , а номер версии модели на двойника *больше или равен* номеру версии указанной модели.
* Двойника реализует модель, которая *расширяет* модель, предоставленную в `IS_OF_MODEL()` , а номер версии расширенной модели двойника *больше или равен* номеру версии указанной модели.

Например, при запросе двойников модели `dtmi:example:widget;4` запрос возвратит все двойников, основанные на **версии 4 или выше** модели **мини** -приложения, а также двойников на основе **моделей, наследующих от Widget**. 

`IS_OF_MODEL` может принимать несколько различных параметров, и остальная часть этого раздела будет отделена от различных вариантов перегрузки.

Простейший способ использования `IS_OF_MODEL` принимает только `twinTypeName` параметр: `IS_OF_MODEL(twinTypeName)` .
Ниже приведен пример запроса, который передает значение в этом параметре:

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="QueryByModel1":::

Чтобы указать коллекцию двойника для поиска при наличии нескольких элементов (например, если `JOIN` используется), добавьте `twinCollection` параметр: `IS_OF_MODEL(twinCollection, twinTypeName)` .
Ниже приведен пример запроса, который добавляет значение для этого параметра:

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="QueryByModel2":::

Чтобы выполнить точное соответствие, добавьте `exact` параметр: `IS_OF_MODEL(twinTypeName, exact)` .
Ниже приведен пример запроса, который добавляет значение для этого параметра:

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="QueryByModel3":::

Можно также передать все три аргумента вместе: `IS_OF_MODEL(twinCollection, twinTypeName, exact)` .
Ниже приведен пример запроса, в котором указывается значение для всех трех параметров:

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="QueryByModel4":::

## <a name="query-by-relationship"></a>Запрос по связям

При выполнении запросов на основе **отношений** Digital двойников язык запросов Azure Digital двойников имеет специальный синтаксис.

Связи извлекаются в область запроса в предложении `FROM`. Важное отличие от "классических" языков SQL-типов заключается в том, что каждое выражение в этом `FROM` предложении не является таблицей; вместо этого `FROM` предложение выражает прохождение межсущностного отношения и записывается с помощью версии Azure Digital двойников `JOIN` .

Вспомним, что с возможностями [модели](concepts-models.md) цифровых двойников Azure отношения не существуют независимо от двойников. Это означает, что `JOIN` языка запросов Azure Digital Twins немного отличается от общего `JOIN` SQL, так как связи здесь не могут запрашивать отдельно и должны быть привязаны к двойнику.
Чтобы внедрить это различие, ключевое слово `RELATED` используется в предложении `JOIN` для ссылки на набор связей двойника.

В следующем разделе приведены несколько примеров того, как это выглядит.

> [!TIP]
> По сути, эта функция имитирует функции CosmosDB, ориентированные на документы, где `JOIN` их можно выполнять с дочерними объектами в документе. CosmosDB использует `IN` ключевое слово, чтобы указать, что `JOIN` предназначено для итерации элементов массива в текущем контексте документа.

### <a name="relationship-based-query-examples"></a>Примеры запросов на основе связей

Чтобы получить набор данных, включающий связи, используйте одну `FROM` инструкцию, за которой следует оператор N `JOIN` , где `JOIN` Операторы выражают связи с результатом предыдущей `FROM` `JOIN` инструкции или.

Ниже приведен пример запроса на основе связей. Этот фрагмент кода выбирает все цифровые двойников со свойством *ID* "ABC", а все цифровые двойников, связанные с этими цифровыми двойников через отношение *Contains* .

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="QueryByRelationship1":::

> [!NOTE]
> Разработчику не нужно сопоставлять этот `JOIN` объект со значением ключа в `WHERE` предложении (или указать значение ключа с `JOIN` определением). Система вычисляет эту корреляцию автоматически, так как сами свойства связи определяют целевую сущность.

### <a name="query-the-properties-of-a-relationship"></a>Запрос свойств связи

Аналогично тому, как свойства цифровых двойников описываются с помощью DTDL, связи могут также иметь свойства. Вы можете запросить двойников **в зависимости от свойств их отношений**.
Язык запросов Azure Digital двойников позволяет фильтровать и проекцию связей путем назначения псевдонима связи в `JOIN` предложении.

В качестве примера рассмотрим *сервицедби* связь со свойством *репортедкондитион* . В следующем запросе этой связи присваивается псевдоним "R" для ссылки на его свойство.

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="QueryByRelationship2":::

В приведенном выше примере обратите внимание на то, как *репортедкондитион* является свойством отношения *сервицедби* (не некоторых цифровых двойника с отношением *сервицедби* ).

### <a name="query-with-multiple-joins"></a>Запрос с несколькими ОБЪЕДИНЕНИЯми

`JOIN`В одном запросе поддерживаются до пяти s. Это позволяет одновременно просматривать несколько уровней связей.

Ниже приведен пример запроса с несколькими объединениями, который получает все лампочки, содержащиеся в светлых панелях 1 и 2.

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="QueryByRelationship3":::

## <a name="count-items"></a>Количество элементов

Количество элементов в результирующем наборе можно подсчитать с помощью `Select COUNT` предложения:

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="SelectCount1":::

Добавьте `WHERE` предложение для подсчета количества элементов, соответствующих определенным критериям. Ниже приведены некоторые примеры инвентаризации с примененным фильтром на основе типа модели двойника (Дополнительные сведения об этом синтаксисе см. в разделе [*запрос по модели*](#query-by-model) ниже).

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="SelectCount2":::

Также можно использовать `COUNT` вместе с `JOIN` предложением. Ниже приведен запрос, который подсчитывает все лампочки, содержащиеся в светлых панелях комнат 1 и 2:

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="SelectCount3":::

## <a name="filter-results-select-top-items"></a>Фильтрация результатов: выбор верхних элементов

С помощью предложения можно выбрать несколько "верхних" элементов в запросе `Select TOP` .

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="SelectTop":::

## <a name="filter-results-specify-return-set-with-projections"></a>Фильтрация результатов: определение возвращаемого набора с проекциями

Используя проекции в `SELECT` инструкции, можно выбрать, какие столбцы будут возвращены запросом.

>[!NOTE]
>В настоящее время сложные свойства не поддерживаются. Чтобы обеспечить допустимость свойств проекции, объедините проекции с помощью `IS_PRIMITIVE` проверки.

Ниже приведен пример запроса, который использует проекцию для возврата двойников и связей. Следующий запрос проецирует *потребитель*, *фабрику* и *ребро* из сценария, в котором *фабрика* с идентификатором *ABC* связана с *потребителем* через связь *фабрики. Customer*, и эта связь представлена в качестве *границы*.

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="Projections1":::

Можно также использовать проекцию для возвращения свойства двойника. Следующий запрос проецирует свойство *Name* объектов- *получателей* , связанных с *фабрикой* , с идентификатором *ABC* с помощью связи *фабрики. Customer*.

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="Projections2":::

Можно также использовать проекцию для возврата свойства связи. Как и в предыдущем примере, следующий запрос проецирует свойство *Name* *потребителей* , связанных с *фабрикой* , с идентификатором *ABC* через связь *Factory. Customer*; но теперь он также возвращает два свойства этой связи: *Prop1* и *Prop2*. Это достигается путем именования *границы* связи и сбора ее свойств.  

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="Projections3":::

Можно также использовать псевдонимы для упрощения запросов с помощью проекции.

Следующий запрос выполняет те же операции, что и предыдущий пример, но присваивает имена свойств `consumerName` , `first` , `second` и `factoryArea` .

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="Projections4":::

Вот похожий запрос, который запрашивает тот же набор, что и приведенный выше, но проецирует только свойство *Consumer.Name* как и `consumerName` проецирует готовую *фабрику* как двойника.

:::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="Projections5":::

## <a name="build-efficient-queries-with-the-in-operator"></a>Создание эффективных запросов с помощью оператора IN

Можно значительно сократить количество необходимых запросов, создав массив двойников и выполнив запросы с помощью `IN` оператора. 

Например, рассмотрим ситуацию, в которой *здания* содержат *Пол* и *этаж* , содержащие *комнаты*. Для поиска комнат в рамках сборки, которые являются горячими, один из способов состоит в выполнении этих действий.

1. Поиск этажей в построении на основе `contains` связи.

    :::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="INOperatorWithout":::

2. Чтобы найти комнаты, вместо того чтобы рассматривать пол по одному и выполнить `JOIN` запрос для поиска комнат для каждого из них, можно выполнить запрос с помощью коллекции этажей в здании (именованное *основание* в запросе ниже).

    В клиентском приложении:
    
    ```csharp
    var floors = "['floor1','floor2', ..'floorn']"; 
    ```
    
    В запросе:
    
    :::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="INOperatorWith":::

## <a name="other-compound-query-examples"></a>Другие примеры составных запросов

Любой из приведенных выше типов запросов можно **объединить** с помощью сочетаний операторов, чтобы включить более подробные сведения в один запрос. Ниже приведены некоторые дополнительные примеры составных запросов, которые одновременно запрашивают более одного типа дескриптора двойника.

* На устройствах, которые имеют *место 123* , возвращаются устройства MxChip, обслуживающие роль оператора.
    :::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="OtherExamples1":::
* Получить двойников, имеющую связь с именем, которая *содержит* другой ДВОЙНИКА с идентификатором *id1*
    :::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="OtherExamples2":::
* Получение всех комнат этой модели комнаты, содержащихся в *floor11*
    :::code language="sql" source="~/digital-twins-docs-samples/queries/queries.sql" id="OtherExamples3":::

## <a name="run-queries-with-the-api"></a>Выполнение запросов с помощью API

После выбора строки запроса ее необходимо выполнить, вызвав [**API запроса**](/rest/api/digital-twins/dataplane/query).

Вы можете напрямую вызывать API или использовать один из [пакетов SDK](how-to-use-apis-sdks.md#overview-data-plane-apis) , доступных для Azure Digital двойников.

В следующем фрагменте кода показан вызов [пакета SDK .NET (C#)](/dotnet/api/overview/azure/digitaltwins/client?view=azure-dotnet&preserve-view=true) из клиентского приложения:

:::code language="csharp" source="~/digital-twins-docs-samples/sdks/csharp/queries.cs" id="RunQuery":::

Запрос, используемый в этом вызове, возвращает список цифровых двойников, представленный в приведенном выше примере с объектами [басикдигиталтвин](/dotnet/api/azure.digitaltwins.core.basicdigitaltwin?view=azure-dotnet&preserve-view=true) . Тип возвращаемых данных для каждого запроса будет зависеть от условий, указанных в `SELECT` инструкции.
* Запросы, начинающиеся с, `SELECT * FROM ...` будут возвращать список цифровых двойников (которые могут быть сериализованы как `BasicDigitalTwin` объекты или другие пользовательские типы цифровых двойника, которые могли быть созданы).
* Запросы, начинающиеся в формате, `SELECT <A>, <B>, <C> FROM ...` будут возвращать словарь с ключами `<A>` , `<B>` и `<C>` .
* Другие форматы `SELECT` инструкций могут быть сформированы для возврата пользовательских данных. Вы можете создать собственные классы для управления очень настраиваемыми результирующими наборами. 

### <a name="query-with-paging"></a>Запрос с разбиением на страницы

Вызовы запросов поддерживают разбиение на страницы. Ниже приведен полный пример использования `BasicDigitalTwin` в качестве типа результата запроса с обработкой ошибок и разбиением на страницы.

:::code language="csharp" source="~/digital-twins-docs-samples/sdks/csharp/queries.cs" id="FullQuerySample":::

## <a name="next-steps"></a>Дальнейшие действия

Узнайте больше о [API-интерфейсах и пакетах SDK для цифровых двойников Azure](how-to-use-apis-sdks.md), включая API запросов, который используется для выполнения запросов из этой статьи.
