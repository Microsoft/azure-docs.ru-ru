---
title: Балансировка нагрузки секций между несколькими экземплярами в концентраторах событий Azure | Документация Майкрософт
description: Описывает, как сбалансировать нагрузку секций между несколькими экземплярами приложения с помощью обработчика событий и пакета SDK концентраторов событий Azure.
ms.topic: conceptual
ms.date: 06/23/2020
ms.openlocfilehash: af307058d0eda6b96c0811bccc245c09e2bdd27d
ms.sourcegitcommit: 867cb1b7a1f3a1f0b427282c648d411d0ca4f81f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "95025050"
---
# <a name="balance-partition-load-across-multiple-instances-of-your-application"></a>Балансировка нагрузки секций между несколькими экземплярами приложения
Чтобы масштабировать приложение обработки событий, можно запустить несколько экземпляров приложения и распределить нагрузку между ними. В более ранних версиях [EventProcessorHost](event-hubs-event-processor-host.md) позволили сбалансировать нагрузку между несколькими экземплярами программы и событиями контрольной точки при получении. В более новых версиях (5,0 и выше) **евентпроцессорклиент** (.NET и Java) или **евенсубконсумерклиент** (Python и JavaScript) позволяют делать то же самое. Модель разработки упрощается с помощью событий. Подпишитесь на интересующие вас события, зарегистрировав обработчик событий. Если вы используете старую версию клиентской библиотеки, см. следующие руководства по миграции: [.NET](https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/eventhub/Azure.Messaging.EventHubs/MigrationGuide.md), [Java](https://github.com/Azure/azure-sdk-for-java/blob/master/sdk/servicebus/azure-messaging-servicebus/migration-guide.md), [Python](https://github.com/Azure/azure-sdk-for-python/blob/master/sdk/servicebus/azure-servicebus/migration_guide.md)и [JavaScript](https://github.com/Azure/azure-sdk-for-js/blob/master/sdk/servicebus/service-bus/migrationguide.md).

В этой статье описывается пример сценария использования нескольких экземпляров для чтения событий из концентратора событий, а затем предоставляются сведения о функциях клиента обработчика событий, что позволяет одновременно получить события из нескольких секций и сбалансировать нагрузку с другими потребителями, которые используют тот же концентратор событий и группу потребителей.

> [!NOTE]
> Масштабирование в Центрах событий базируется на идее секционированных потребителей. В отличие от шаблона [конкурирующих потребителей](/previous-versions/msp-n-p/dn568101(v=pandp.10)), секционированный потребительский шаблон обеспечивает высокий уровень масштабирования путем удаления конфликтного узкого места и упрощения сквозного параллелизма.

## <a name="example-scenario"></a>Пример сценария

В качестве примера рассмотрим компанию по обеспечению безопасности дома, которая отслеживает 100 000 домов. Каждую минуту она получает данные из различных датчиков, таких как детектор движения, Открытый датчик открытия дверцы или окна, детектор прозрачного стекла и т. д., установленный в каждом домашнем компьютере. Компания предоставляет веб-сайт для жителей, чтобы наблюдать за деятельностью своего дома почти в реальном времени.

Каждый датчик отправляет данные в концентратор событий. Концентратор событий настроен на 16 секций. В конечном итоге нужен механизм, который может считывать эти события, консолидировать их (фильтровать, агрегировать и т. д.) и выгружать статистическое выражение в хранилище BLOB-объектов, которое затем проецируется на удобную для пользователя страницу.

## <a name="write-the-consumer-application"></a>Написание приложения-потребителя

При создании потребителя в распределенной среде сценарий должен удовлетворять следующие требования:

1. **Масштаб.** Создайте несколько потребителей и каждый потребитель возьмет на себя ответственность за чтение нескольких секций Центров событий.
2. **Балансировка нагрузки.** Изменяйте количество потребителей динамически. Например, при добавлении нового типа датчика в каждый дом (например, детектора угарного газа) увеличивается число событий. В этом случае оператор (человек) увеличивает число экземпляров потребителя. Затем пул потребителей может перебалансировать количество секций, которыми они владеют, для распределения нагрузки на вновь добавленных потребителей.
3. **Простое возобновление при сбоях:** Если потребитель (**потребитель a**) завершается сбоем (например, виртуальная машина, на которой размещается потребитель, неожиданно завершает работу), другие потребители могут выбрать секции, принадлежащие **потребителю a** , и продолжить. Кроме того, точка продолжения, называемая *контрольной точкой* или *смещением*, должна находиться в точке пересечения, в которой произошел сбой **потребителя А**, или немного раньше этого.
4. **Использовать события:** Хотя предыдущие три точки связаны с управлением потребителем, необходим код для использования событий и выполнения каких-либо полезных действий с ним. Например, вычислить его и передать в хранилище BLOB-объектов.

## <a name="event-processor-or-consumer-client"></a>Обработчик событий или клиент-потребитель

Вам не нужно создавать собственное решение для удовлетворения этих требований. Эти функции предоставляются пакетами SDK концентраторов событий Azure. В пакетах SDK для .NET или Java используется клиент обработчика событий (Евентпроцессорклиент), а в пакетах SDK для Python и JavaScript используется Евенсубконсумерклиент. В старой версии пакета SDK использовался узел обработчика событий (EventProcessorHost), который поддерживал эти функции.

В большинстве рабочих сценариев рекомендуется использовать клиент обработчика событий для чтения и обработки событий. Клиент процессора предназначен для обеспечения надежной работы при обработке событий во всех секциях концентратора событий в работоспособном и отказоустойчивом режиме, предоставляя средства для создания контрольной точки хода выполнения. Клиенты обработчика событий могут работать совместно в контексте группы потребителей для заданного концентратора событий. Клиенты будут автоматически управлять распределением и балансировкой работы по мере того, как экземпляры становятся доступными или недоступными для группы.

## <a name="partition-ownership-tracking"></a>Отслеживание владения секциями

Экземпляр обработчика событий обычно владеет и обрабатывает события из одной или нескольких секций. Владение секциями равномерно распределяется среди всех активных экземпляров обработчика событий, связанных с сочетанием концентратора событий и группы потребителей. 

Каждому обработчику событий присваивается уникальный идентификатор и право владения секциями путем добавления или обновления записи в хранилище контрольных точек. Все экземпляры обработчиков событий периодически взаимодействуют с этим хранилищем для обновления своего состояния обработки, а также для получения сведений о других активных экземплярах. Эти данные затем используются для балансировки нагрузки между активными процессорами. Новые экземпляры могут присоединиться к пулу обработки для увеличения масштаба. Когда экземпляры отключаются из-за сбоев или уменьшения масштаба, владение секцией корректно передается другим активным процессорам.

Записи владения секциями в хранилище контрольных точек отслеживают пространство имен концентраторов событий, имя концентратора событий, группу потребителей, идентификатор обработчика событий (также известный как владелец), идентификатор секции и время последнего изменения.



| пространство имен Центров событий;               | имя концентратора событий; | **Группа потребителей** | Владелец                                | Partition ID | Время последнего изменения  |
| ---------------------------------- | -------------- | :----------------- | :----------------------------------- | :----------- | :------------------ |
| mynamespace.servicebus.windows.net | myeventhub     | миконсумерграуп    | 3be3f9d3-9d9e-4c50-9491-85ece8334ff6 | 0            | 2020-01-15T01:22:15 |
| mynamespace.servicebus.windows.net | myeventhub     | миконсумерграуп    | f5cc5176-ce96-4bb4-bbaa-a0e3a9054ecf | 1            | 2020-01-15T01:22:17 |
| mynamespace.servicebus.windows.net | myeventhub     | миконсумерграуп    | 72b980e9-2efc-4ca7-ab1b-ffd7bece8472 | 2            | 2020-01-15T01:22:10 |
|                                    |                | :                  |                                      |              |                     |
|                                    |                | :                  |                                      |              |                     |
| mynamespace.servicebus.windows.net | myeventhub     | миконсумерграуп    | 844bd8fb-1f3a-4580-984d-6324f9e208af | 15           | 2020-01-15T01:22:00 |

Каждый экземпляр обработчика событий получает владение секцией и начинает обработку секции из последней известной [контрольной точки](# Checkpointing). Если произошел сбой процессора (виртуальная машина завершает работу), другие экземпляры обнаруживают его, просмотрев время последнего изменения. Другие экземпляры пытаются стать владельцем секций, которые ранее принадлежали неактивному экземпляру, а хранилище контрольных точек гарантирует, что только один из экземпляров будет выполнен в результате запроса на владение секцией. Таким образом, в любой момент времени существует не более одного процессора, который получает события из секции.

## <a name="receive-messages"></a>Получение сообщений

При создании обработчика событий указываются функции, которые будут обрабатывать события и ошибки. Каждый вызов функции, обрабатывающей события, доставляет одно событие из определенной секции. Вы отвечаете за обработку этого события. Если вы хотите убедиться, что потребитель обрабатывает каждое сообщение по крайней мере один раз, необходимо написать собственный код с помощью логики повторных попыток. Но учитывайте при этом возможность получения поврежденных сообщений.

Рекомендуется выполнять задачи относительно быстро. То есть, как можно меньше обработки. Если вам нужно писать в хранилище и выполнить некоторую маршрутизацию, лучше использовать две группы потребителей и два обработчика событий.

## <a name="checkpointing"></a>Назначение контрольных точек

*Контрольные точки* — это процесс, с помощью которого обработчик событий помечает или фиксирует расположение последней успешной обработки события в секции. Пометка контрольной точки обычно выполняется внутри функции, которая обрабатывает события и выполняется для каждого раздела в группе потребителей. 

Если обработчик событий отключается от секции, другой экземпляр может возобновить обработку секции на контрольной точке, которая ранее была зафиксирована последним процессором этого раздела в этой группе потребителей. При подключении процессора передает смещение концентратору событий, чтобы указать расположение, с которого начинается чтение. Таким образом можно использовать контрольные точки для пометки событий как "завершенных" подчиненными приложениями и обеспечения устойчивости при отключении обработчика событий. Можно вернуться к старым данным, указав меньшее смещение от этого процесса создания контрольных точек. 

Когда выполняется контрольная точка для пометки события как обработанного, запись в хранилище контрольных точек добавляется или обновляется с использованием смещения и порядкового номера события. Пользователи должны выбрать частоту обновления контрольной точки. Обновление после каждого успешно обработанного события может повлиять на производительность и затраты, так как оно запускает операцию записи в базовое хранилище контрольных точек. Кроме того, контрольные точки для каждого отдельного события свидетельствуют о шаблоне обмена сообщениями в очереди, для которого очередь служебной шины может быть лучшим вариантом, чем концентратор событий. Идея Центров событий заключается в том, что вы получаете доставку по принципу "хотя бы раз" в масштабе. Сделав нижестоящие системы идемпотентными, можно легко выполнить восстановление после сбоев или перезапусков, приводящих к тому, что события получаются несколько раз.

> [!NOTE]
> Если вы используете хранилище BLOB-объектов Azure в качестве хранилища контрольных точек в среде, которая поддерживает другую версию пакета SDK для большого двоичного объекта хранилища, чем обычно доступно в Azure, необходимо использовать код, чтобы изменить версию API службы хранилища до определенной версии, поддерживаемой этой средой. Например, если вы используете [концентраторы событий в Azure Stack Hub версии 2002](/azure-stack/user/event-hubs-overview), самая высокая доступная версия для службы хранилища — версия 2017-11-09. В этом случае необходимо использовать код для настройки API службы хранилища до версии 2017-11-09. Пример назначения конкретной версии API хранилища см. в следующих примерах на сайте GitHub: 
> - [.NET](https://github.com/Azure/azure-sdk-for-net/tree/master/sdk/eventhub/Azure.Messaging.EventHubs.Processor/samples/). 
> - [Java](https://github.com/Azure/azure-sdk-for-java/blob/master/sdk/eventhubs/azure-messaging-eventhubs-checkpointstore-blob/src/samples/java/com/azure/messaging/eventhubs/checkpointstore/blob/)
> - [JavaScript](https://github.com/Azure/azure-sdk-for-js/blob/master/sdk/eventhub/eventhubs-checkpointstore-blob/samples/javascript) или  [TypeScript](https://github.com/Azure/azure-sdk-for-js/blob/master/sdk/eventhub/eventhubs-checkpointstore-blob/samples/typescript)
> - [Python](https://github.com/Azure/azure-sdk-for-python/blob/master/sdk/eventhub/azure-eventhub-checkpointstoreblob-aio/samples/)

## <a name="thread-safety-and-processor-instances"></a>Потокобезопасность и экземпляры процессора

По умолчанию функция, которая обрабатывает события, вызывается последовательно для данной секции. Последующие события и вызовы этой функции из одной и той же очереди секционирования по мере того, как конвейер событий продолжит выполняться в фоновом режиме в других потоках. События из разных секций могут обрабатываться параллельно, и любое общее состояние, доступное в секциях, должно быть синхронизировано.

## <a name="next-steps"></a>Дальнейшие действия
См. следующие краткие руководства.

- [.NET Core](event-hubs-dotnet-standard-getstarted-send.md)
- [Java](event-hubs-java-get-started-send.md)
- [Python](event-hubs-python-get-started-send.md)
- [JavaScript](event-hubs-node-get-started-send.md)
