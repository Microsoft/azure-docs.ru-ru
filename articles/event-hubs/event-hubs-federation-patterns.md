---
title: Шаблоны задач "Репликация событий" — концентраторы событий Azure | Документация Майкрософт
description: В этой статье содержатся подробные инструкции по реализации конкретных шаблонов задач репликации событий.
ms.topic: article
ms.date: 12/12/2020
ms.openlocfilehash: 7702b1987faabfce8d97e7b5c9b18766df72caad
ms.sourcegitcommit: 7e97ae405c1c6c8ac63850e1b88cf9c9c82372da
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/29/2020
ms.locfileid: "97803992"
---
# <a name="event-replication-tasks-patterns"></a>Шаблоны задач репликации событий

Общие сведения [о Федерации](event-hubs-federation-overview.md) и [функции репликатора](event-hubs-federation-replicator-functions.md) описывают причину и основные элементы задач репликации, поэтому рекомендуется ознакомиться с ними перед тем, как продолжить работу с этой статьей.

В этой статье подробно описываются рекомендации по реализации некоторых шаблонов, выделенных в разделе Обзор.

## <a name="replication"></a>Репликация

Шаблон репликации копирует события из одного концентратора событий в следующий или из концентратора событий в другое назначение, например в очередь служебной шины. События пересылаются без внесения изменений в полезные данные события.

Реализация этого шаблона охватывается [репликацией событий между концентраторами событий](https://github.com/Azure-Samples/azure-messaging-replication-dotnet/tree/main/functions/config/EventHubCopy) и [репликацией событий между концентраторами событий и примерами служебной шины](https://github.com/Azure-Samples/azure-messaging-replication-dotnet/tree/main/functions/config/EventHubCopyToServiceBus) .

### <a name="streams-and-order-preservation"></a>Сохранение потоков и порядка

Репликация с помощью функций Azure или Azure Stream Analytics не позволяет гарантировать создание 1:1 точных клонов исходного концентратора событий в целевом концентраторе событий, но нацелено на сохранение относительных последовательностей событий, где это требуется приложению. Приложение обменивается данными с этим событием, группируя связанные события с одним ключом секции, а [концентраторы событий упорядочивают сообщения с одним и тем же ключом секции последовательно в одной секции](event-hubs-features.md#partitions).

> [!IMPORTANT] 
> Сведения о смещении уникальны для каждого концентратора событий, а смещения для одних и тех же событий будут отличаться в экземплярах концентратора событий. Чтобы найти положение в копируемом потоке событий, используйте смещения на основе времени и обратитесь к [распространенным метаданным, назначенным службе](#service-assigned-metadata).
>
> Смещение на основе времени. Начните приемник в конкретный момент времени:
> - *Евентпоситион. фромстарт ()* — чтение всех хранящихся данных.
> - *Евентпоситион. фроменд ()* — чтение всех новых данных с момента подключения.
> - *Евентпоситион. фроменкуеуедтиме (DateTime)* — все данные, начиная с заданной даты и времени.
>
> В EventProcessor расположение задается через Инитиалоффсетпровидер на Евентпроцессороптионс. При использовании других API-интерфейсов приемника это расположение передается через конструктор. 


Готовые вспомогательные функции репликации, [предоставляемые в качестве примеров](https://github.com/Azure-Samples/azure-messaging-replication-dotnet/tree/main/src/Azure.Messaging.Replication) , используемых в руководстве по функциям Azure, гарантируют, что потоки событий с одним и тем же ключом секции, извлеченными из исходной секции, передаются в целевой концентратор событий как пакет в исходном потоке и с тем же ключом секции.

Если количество секций исходного и целевого концентраторов событий идентично, все потоки в целевом объекте будут сопоставляться с теми же секциями, которые были в источнике.
Если число секций отличается, что имеет значение в некоторых других шаблонах, описанных ниже, сопоставление будет отличаться, но потоки всегда будут храниться вместе и по порядку.

Относительный порядок событий, принадлежащих разным потокам или независимым событиям без ключа секции в целевой секции, может всегда отличаться от исходной секции.

### <a name="service-assigned-metadata"></a>Метаданные, назначенные службе

Присвоенные службе метаданные события, полученные из исходного концентратора событий, исходного времени очереди, порядкового номера и смещения, заменяются новыми значениями, назначенными службой в целевом концентраторе событий, но с [вспомогательными функциями](https://github.com/Azure-Samples/azure-messaging-replication-dotnet/tree/main/src/Azure.Messaging.Replication), задачами репликации, предоставляемыми в примерах, исходные значения сохраняются в свойствах пользователя: `repl-enqueue-time` (ISO8601 String), `repl-sequence` , `repl-offset` .

Эти свойства имеют тип String и содержат значение переведенные соответствующих исходных свойств. Если событие пересылается несколько раз, к уже существующим свойствам добавляются метаданные немедленного источника, назначенные службе, со значениями, разделенными точкой с запятой.

### <a name="failover"></a>Отработка отказа

Если вы используете репликацию для аварийного восстановления, чтобы защититься от региональных событий доступности в службе концентраторов событий или к перерывам в сети, любой такой сценарий сбоя потребует выполнения отработки отказа из одного концентратора событий в следующий, указывая производителям и (или) потребителям использовать вторичную конечную точку.

Для всех сценариев отработки отказа предполагается, что необходимые элементы пространств имен структурно идентичны, то есть концентраторы событий и группы потребителей идентичны именам, а правила подписи общего доступа и/или правила управления доступом на основе ролей настраиваются одинаковым образом. Вы можете создать (и обновить) дополнительное пространство имен, следуя [указаниям по перемещению пространств имен](move-across-regions.md) и пропущению шага очистки.

Чтобы принудительно переключиться производителями и потребителями, необходимо предоставить сведения о том, какое пространство имен использовать доступно для поиска в расположении, которое легко достигать и обновление. Если производители или потребители сталкиваются с частыми или постоянными ошибками, они должны обратиться к этому расположению и изменить конфигурацию. Существует множество способов совместного использования этой конфигурации, но мы разносимся на две из следующих: DNS и общие файловые ресурсы.

#### <a name="dns-based-failover-configuration"></a>Конфигурация отработки отказа на основе DNS

Одним из потенциальных подходов является хранение информации в DNS SRV-записях в управляемом DNS и указание соответствующих конечных точек концентратора событий. 

> [!IMPORTANT] 
> Обратите внимание, что концентраторы событий не допускают присвоения конечным точкам напрямую псевдонимов с записями CNAME. Это означает, что вы будете использовать DNS в качестве механизма отказоустойчивого поиска адресов конечных точек, а не для непосредственного разрешения IP-адресов.

Предположим, что вы владеете доменом `example.com` и, для своего приложения, зоной `test.example.com` . Для двух альтернативных концентраторов событий вы создадите две вложенные зоны и запись SRV в каждой из них.

Записи SRV — это, согласно общему стандартному соглашению, с префиксом `_azure_eventhubs._amqp` и хранением двух записей конечных точек: одна для AMQP-over-TLS через порт 5671, а другой для AMQP через сокеты через порт 443, указывают на конечную точку концентраторов событий пространства имен, соответствующего зоне.

| Зона                   | Запись SRV                                                                                                                                                            |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `eh1.test.example.com` | **`_azure_servicebus._amqp.eh1.test.example.com`**<br>`1 1 5671 eh1-test-example-com.servicebus.windows.net`<br>`2 2 443 eh1-test-example-com.servicebus.windows.net` |
| `eh2.test.example.com` | **`_azure_servicebus._amqp.eh2.test.example.com`**<br>`1 1 5671 eh2-test-example-com.servicebus.windows.net`<br>`2 2 443 eh2-test-example-com.servicebus.windows.net` |

В зоне приложения вы создадите запись CNAME, которая указывает на подчиненную зону, соответствующую вашему основному концентратору событий:

| Запись CNAME                | Псевдоним                    |
| --------------------------- | ------------------------ |
| `eventhub.test.example.com` | `test1.test.example.com` |

Используя DNS-клиент, который позволяет явно запрашивать записи CNAME и SRV (встроенные клиенты Java и .NET разрешают только простое разрешение имен в IP-адреса), вы можете разрешить нужную конечную точку. Например, с помощью [DnsClient.NET](https://dnsclient.michaco.net/)функция уточняющего запроса имеет следующее:

```C#
static string GetEventHubName(string aliasName)
{
    const string SrvRecordPrefix = "_azure_eventhub._amqp.";
    LookupClient lookup = new LookupClient();

    return (from CNameRecord alias in (lookup.Query(aliasName, QueryType.CNAME).Answers)
            from SrvRecord srv in lookup.Query(SrvRecordPrefix + alias.CanonicalName, QueryType.SRV).Answers
            where srv.Port == 5671
            select srv.Target).FirstOrDefault()?.Value.TrimEnd('.');
}
```

Функция возвращает имя целевого узла, зарегистрированное для порта 5671 зоны, в настоящее время псевдонимом которых является CNAME, как показано выше.

Для выполнения отработки отказа необходимо изменить запись CNAME и указать ее на альтернативную зону.

Преимущество использования DNS и, в частности [Azure DNS](../dns/dns-overview.md), состоит в том, что Azure DNS информация глобально реплицируется и, следовательно, устойчива к простоям одной области.

Эта процедура аналогична работе [географического аварийного восстановления концентраторов событий](event-hubs-geo-dr.md) , но полностью размещается в собственном элементе управления, а также работает с активными и активными сценариями.

#### <a name="file-share-based-failover-configuration"></a>Конфигурация отработки отказа на основе общей папки

Самый простой альтернативой использованию DNS для предоставления сведений о конечной точке является помещение имени основной конечной точки в обычный текстовый файл и обслуживание файла из инфраструктуры, которая является надежной по отношению к сбоям и по-прежнему позволяет выполнять обновления.

Если вы уже запустили инфраструктуру веб-сайтов высокой надежности с глобальной репликацией доступности и содержимого, добавьте такой файл и повторно опубликуйте его, если требуется параметр.

> [!CAUTION]
> Вы должны опубликовать имя конечной точки только таким образом, а не полную строку подключения, включая секреты.

#### <a name="extra-considerations-for-failing-over-consumers"></a>Дополнительные рекомендации для отработки отказа потребителей

Для потребителей концентратора событий дальнейшие рекомендации по стратегии отработки отказа зависят от потребностей обработчика событий.

Если возникает сбой, требующий перестроения системы, включая базы данных, из резервной копии, а базы данных передаются напрямую или через промежуточную обработку из событий, хранящихся в концентраторе событий, необходимо восстановить резервную копию, а затем запустить воспроизведение событий в системе с момента создания резервной копии базы данных, а не из момента уничтожения исходной системы.

Если сбой влияет только на срез системы или только на один концентратор событий, который стал недоступным, то, скорее всего, потребуется продолжить обработку событий из примерно того места, где обработка была прервана.

Чтобы реализовать любой сценарий и использовать обработчик событий соответствующего пакета SDK для Azure, [Создайте новое хранилище контрольных точек](event-processor-balance-partition-load.md#checkpointing) и укажите начальную координату секции на основе _метки времени_ , из которой нужно возобновить обработку.

Если у вас по-прежнему есть доступ к хранилищу контрольных точек концентратора событий, с которого вы отменяем, [распространенные метаданные](#service-assigned-metadata) , описанные выше, помогут пропустить события, которые уже были обработаны и возобновлены точно с того места, где вы остановились.

## <a name="merge"></a>Объединить

Шаблон слияния содержит одну или несколько задач репликации, указывающих на одну цель, возможно, одновременно с обычными производителями, которые также отправляют события в один и тот же целевой объект.

Варианты этих шаблонов:

- Две или более функции репликации одновременно задают события из отдельных источников и отправляют их в один и тот же целевой объект.
- Еще одна функция репликации, получающая события из источника, в то время как целевой объект также используется непосредственно производителями.
- Более ранний шаблон, но отраженный между двумя или более концентраторами событий, в результате чего концентраторы событий содержат одни и те же потоки, независимо от того, где создаются события.

Первые два варианта шаблона являются тривиальными и не отличаются от обычных задач репликации.

Последний сценарий требует, чтобы за исключением уже реплицированных событий выполнялась повторная репликация. Этот метод демонстрируется и описывается в примере [евенсубтоевенсубмерже](https://github.com/Azure-Samples/azure-messaging-replication-dotnet/tree/main/functions/code/EventHubMerge) .

## <a name="editor"></a>Редактор

Шаблон редактора строится на схеме [репликации](#replication) , но сообщения изменяются до их пересылки. 

Ниже приведены примеры таких изменений.

- **_Перекодирование_** — если содержимое события (также называемое "телом" или "полезная нагрузка") поступает из источника, закодированного с помощью формата _Apache Avro_ или какого-либо собственного формата сериализации, но ожидание системы, владеющей целевым объектом, заключается в том, что для кодирования содержимого в формате _JSON_ она сначала десериализует полезные данные из _Apache Avro_ в граф объектов в памяти, а затем сериализует этот граф в формат _JSON_ для перенаправляемого события. Перекодирование также включает задачи **сжатия и распаковки содержимого** .
- **_Преобразование_** — события, содержащие структурированные данные, могут потребовать перерисовки этих данных для упрощения использования нижестоящими потребителями. Это может затрагивать работу, например сведение вложенных структур, очистку лишних элементов данных или изменение формы полезной нагрузки в соответствии с заданной схемой.
- **_Пакетирование_** — события могут быть получены в пакетах (несколько событий в одной передачи) из источника, но должны перенаправляться в целевой объект или наоборот. Таким образом, задача может пересылать несколько событий на основе одной передачи входных событий или объединять набор событий, которые затем передаются вместе.
- При **_проверке_** данных о событиях из внешних источников часто требуется проверить, соответствуют ли они набору правил, прежде чем они могут быть перенаправлены. Правила могут быть выражены с помощью схем или кода. События, которые не должны быть соблюдены в соответствии с требованиями, могут быть удалены, с проблемой, указанной в журналах, или перенаправлены в специальное целевое назначение для дальнейшей работы.
- **** Дополнительные сведения о событиях, поступающих из некоторых источников, могут потребовать обогащения с другим контекстом, чтобы его можно было использовать в целевых системах. Это может привести к поиску эталонных данных и внедрению этих данных с помощью события или добавлению сведений об источнике, известном задаче репликации, но не содержащихся в событиях.
- **_Фильтрация_** . Некоторые события, поступающие из источника, могут быть удержаны от целевого объекта на основе какого-либо правила. Фильтр проверяет событие на соответствие правилу и удаляет событие, если оно не соответствует правилу. Фильтрация повторяющихся событий путем наблюдения за определенными критериями и удаления последующих событий с теми же значениями является формой фильтрации.
- **_Шифрование_** — задача репликации может попытаться расшифровать содержимое, поступающие от источника, или шифровать содержимое, перенаправленное в целевой объект, и (или) проверить целостность содержимого и метаданных относительно подписи, переданной в событии, или присоединить такую подпись.
- **_Аттестация_** . Задача репликации может прикреплять метаданные, потенциально защищенные цифровой подписью, к событию, которое подтверждает, что событие было получено через конкретный канал или в определенное время.
- **_Цепочка_** . Задача репликации может применять подписи к потокам событий таким же, что целостность потока защищена, и могут быть обнаружены отсутствующие события.

Шаблоны преобразования, пакетирования и обогащения обычно лучше всего реализуются с помощью [Azure Stream Analyticsных](../stream-analytics/stream-analytics-introduction.md) заданий. 

Все эти шаблоны можно реализовать с помощью функций Azure, используя [триггер концентраторов событий](../azure-functions/functions-bindings-event-hubs-trigger.md) для получения событий и [выходную привязку концентратора событий](../azure-functions/functions-bindings-event-hubs-output.md) для их доставки.

## <a name="routing"></a>Маршрутизация

Шаблон маршрутизации строится на схеме [репликации](#replication) , но вместо одного источника и одного целевого объекта задача репликации имеет несколько целевых объектов, показанных здесь в C#:

```csharp
[FunctionName("EH2EH")]
public static async Task Run(
    [EventHubTrigger("source", Connection = "EventHubConnectionAppSetting")] EventData[] events,
    [EventHub("dest1", Connection = "EventHubConnectionAppSetting")] EventHubClient output1,
    [EventHub("dest2", Connection = "EventHubConnectionAppSetting")] EventHubClient output2,
    ILogger log)
{
    foreach (EventData eventData in events)
    {
        // send to output1 and/or output2 based on criteria
        EventHubReplicationTasks.ConditionalForwardToEventHub(input, output1, log, (eventData) => {
            return ( inputEvent.SystemProperties.SequenceNumber%2==0 ) ? inputEvent : null;
        });
        EventHubReplicationTasks.ConditionalForwardToEventHub(input, output2, log, (eventData) => {
            return ( inputEvent.SystemProperties.SequenceNumber%2!=0 ) ? inputEvent : null;
        });
    }
}
```

Функция маршрутизации будет учитывать метаданные сообщения и (или) полезные данные сообщения, а затем выбрать одно из доступных назначений для отправки.

В Azure Stream Analytics можно добиться того же результата, определив несколько выходов, а затем выполнив запрос на выход.

```sql
select * into dest1Output from inputSource where Info = 1
select * into dest2Output from inputSource where Info = 2
```


## <a name="log-projection"></a>Проекция журнала

Шаблон проекции журнала выполняет сведение потока событий в индексированную базу данных, при этом события становятся записями в базе данных. Как правило, события добавляются в ту же коллекцию или таблицу, а ключ секции концентратора событий становится субъектом первичного ключа, который ищет уникальную запись.

Проекция журнала может создавать historian временных рядов данных событий или сжатого представления, в результате чего для каждого ключа секции сохраняется только Последнее событие. Форма целевой базы данных, в конечном итоге, нужна вам и вашим потребностям вашего приложения. Этот шаблон также называется "источники событий".

> [!TIP]
> Вы можете легко создавать проекции журналов в [базе данных SQL Azure](../stream-analytics/sql-database-output.md) и [Azure Cosmos DB](../stream-analytics/azure-cosmos-db-output.md) в Azure Stream Analytics и предпочтительнее использовать этот вариант.

Следующая функция Azure проецирует содержимое концентратора событий, сжатого в коллекцию CosmosDB Azure.

```C#
[FunctionName("Eh1ToCosmosDb1Json")]
[ExponentialBackoffRetry(-1, "00:00:05", "00:05:00")]
public static async Task Eh1ToCosmosDb1Json(
    [EventHubTrigger("eh1", ConsumerGroup = "Eh1ToCosmosDb1", Connection = "Eh1ToCosmosDb1-source-connection")] EventData[] input,
    [CosmosDB(databaseName: "SampleDb", collectionName: "foo", ConnectionStringSetting = "CosmosDBConnection")] IAsyncCollector<object> output,
    ILogger log)
{
    foreach (var ev in input)
    {
        if (!string.IsNullOrEmpty(ev.SystemProperties.PartitionKey))
        {
            var record = new
            {
                id = ev.SystemProperties.PartitionKey,
                data = JsonDocument.Parse(ev.Body),
                properties = ev.Properties
            };
            await output.AddAsync(record);
        }
    }
}
```

## <a name="next-steps"></a>Дальнейшие действия

- [Приложения репликатора событий в функциях Azure][1]
- [Репликация событий между концентраторами событий][2]
- [Репликация событий в служебную шину Azure][3]

[1]: event-hubs-federation-replicator-functions.md
[2]: https://github.com/Azure-Samples/azure-messaging-replication-dotnet/tree/main/functions/config/EventHubCopy
[3]: https://github.com/Azure-Samples/azure-messaging-replication-dotnet/tree/main/functions/config/EventHubCopyToServiceBus
