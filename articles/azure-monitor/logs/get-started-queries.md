---
title: Начало работы с запросами журнала в Azure Monitor | Документация Майкрософт
description: В этой статье содержится руководство по началу работы по написанию запросов журнала в Azure Monitor.
ms.topic: tutorial
author: bwren
ms.author: bwren
ms.date: 10/24/2019
ms.openlocfilehash: c87b70c74a5de9cc4b6c48935b93fdd13295f0f8
ms.sourcegitcommit: 867cb1b7a1f3a1f0b427282c648d411d0ca4f81f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/20/2021
ms.locfileid: "102052336"
---
# <a name="get-started-with-log-queries-in-azure-monitor"></a>Начало работы с запросами журналов Azure Monitor

> [!NOTE]
> Вы можете выполнить это упражнение в своей среде, если собираете данные, по крайней мере, с одной виртуальной машины. Если нет, используйте нашу [демонстрационную среду](https://ms.portal.azure.com/#blade/Microsoft_Azure_Monitoring_Logs/DemoLogsBlade), которая содержит большое количество образцов данных.  Если вы уже знакомы с тем, как выполнять запросы в KQL, и вам всего лишь нужно быстро создать запросы на основе типов ресурсов, см. [панель с сохраненными примерами запросов](../logs/example-queries.md).

В этом руководстве рассматривается написание запросов журналов в Azure Monitor. Вы научитесь:

- понимать структуру запросов;
- сортировать результаты запроса;
- фильтровать результаты запроса;
- указывать диапазон времени;
- выбирать поля для включения в результаты;
- определять и использовать настраиваемые поля;
- вычислять и группировать результаты.

Руководство по использованию Log Analytics на портале Azure см. в разделе [Начало работы со службой Log Analytics в Azure Monitor](./log-analytics-tutorial.md).<br>
Дополнительные сведения о запросах журналов в Azure Monitor см. в разделе [Общие сведения о запросах журналов в Azure Monitor](../logs/log-query-overview.md).

Ниже приведена видео-версия этого руководства.

> [!VIDEO https://www.microsoft.com/videoplayer/embed/RE42pGX]

## <a name="writing-a-new-query"></a>Создание запроса

Запросы могут начинаться с имени таблицы или команды *search*. Начните с имени таблицы, так как это определит четкую область запроса и повысит как производительность запроса, так и релевантность результатов.

> [!NOTE]
> Azure Monitor использует язык запросов Kusto с учетом регистра. Ключевые слова языка обычно пишутся строчными буквами. При использовании имен таблиц или столбцов в запросе обязательно используйте правильный регистр, как показано в области схемы.

### <a name="table-based-queries"></a>Запросы на основе таблиц

Azure Monitor упорядочивает данные журнала в таблицы, каждая из которых состоит из нескольких столбцов. На портале Analytics в области схемы в Log Analytics отображаются все таблицы и столбцы. Определите интересующую вас таблицу, а затем взгляните на часть данных:

```Kusto
SecurityEvent
| take 10
```

Запрос, показанный выше, возвращает 10 результатов из таблицы *SecurityEvent* в произвольном порядке. Это очень распространенный способ взглянуть на таблицу и понять ее структуру и содержимое. Давайте рассмотрим структуру запроса:

* Запрос начинается с имени таблицы *SecurityEvent* — эта часть определяет область запроса.
* Символ вертикальной черты (|) разделяет команды, поэтому выходные данные первой команды содержатся во входных данных следующей команды. Можно добавить любое число элементов, разделенных этой чертой.
* За вертикальной чертой следует команда **take**, которая возвращает указанное количество произвольных записей из таблицы.

Мы фактически могли выполнить запрос даже без добавления `| take 10`. Такой запрос тоже действительный, но он может вернуть до 10 000 результатов.

### <a name="search-queries"></a>Поисковые запросы

Поисковые запросы менее структурированы и, как правило, более подходят для поиска записей, которые содержат указанное значение в любом из столбцов:

```Kusto
search in (SecurityEvent) "Cryptographic"
| take 10
```

Этот поисковый запрос выполняет в таблице *SecurityEvent* поиск записей, содержащих фразу "Cryptographic". Из этих записей будут возвращены и показаны 10. Если опустить часть `in (SecurityEvent)` и просто запустить `search "Cryptographic"`, поиск пройдет по *всем* таблицам. Это будет дольше и менее эффективно.

> [!WARNING]
> Поисковые запросы обычно выполняются медленнее, чем запросы на основе таблиц, поскольку они обрабатывают больше данных. 

## <a name="sort-and-top"></a>Операторы sort и top
Хотя команда **take** и полезна для получения нескольких записей, но результаты выбираются и отображаются в произвольном порядке. Чтобы получить упорядоченное представление, можно выполнить команду **sort** по предпочтительному столбцу:

```Kusto
SecurityEvent   
| sort by TimeGenerated desc
```

Такой запрос может вернуть слишком много результатов и занять некоторое время. Приведенный выше запрос сортирует *всю* таблицу SecurityEvent по столбцу TimeGenerated. Портал аналитики ограничивает отображение для вывода только 10 000 записей. Такой подход, конечно же, не оптимален.

Лучшим способом получить только последние 10 записей является использование оператора **top**, который сортирует таблицу целиком на стороне сервера, а затем возвращает первые записи:

```Kusto
SecurityEvent
| top 10 by TimeGenerated
```

Порядок сортировки по убыванию используется по умолчанию, поэтому мы обычно опускаем аргумент **desc**. Результат будет выглядеть следующим образом:

![Первые 10](media/get-started-queries/top10.png)


## <a name="where-filtering-on-a-condition"></a>Оператор where: фильтрация по условию
Фильтры, как очевидно из названия, фильтруют данные по указанному условию. Это самый распространенный способ ограничения результатов запроса для получения соответствующей информации.

Чтобы добавить фильтр к запросу, используйте оператор **where**, за которым следует одно или несколько условий. Например, следующий запрос возвращает только записи *SecurityEvent*, где _Level_ равняется _8_:

```Kusto
SecurityEvent
| where Level == 8
```

При написании условий фильтра вы можете использовать следующие выражения:

| Выражение | Описание | Пример |
|:---|:---|:---|
| == | Проверка на равенство<br>(с учетом регистра) | `Level == 8` |
| =~ | Проверка на равенство<br>(без учета регистра) | `EventSourceName =~ "microsoft-windows-security-auditing"` |
| !=, <> | Проверка на неравенство<br>(оба выражения идентичны) | `Level != 4` |
| *and*, *or* | Требуется между условиями| `Level == 16 or CommandLine != ""` |

Чтобы отфильтровать по нескольким условиям, можно использовать оператор **and**:

```Kusto
SecurityEvent
| where Level == 8 and EventID == 4672
```

Для этого также можно включить несколько элементов **where**, разделенных вертикальной чертой:

```Kusto
SecurityEvent
| where Level == 8 
| where EventID == 4672
```
    
> [!NOTE]
> Значения могут иметь разные типы, поэтому может потребоваться привести их в правильный тип для выполнения сравнения. Например, столбец *Level* таблицы SecurityEvent имеет строчный тип, поэтому необходимо привести его в числовой тип, например *int* или *long*, прежде чем вы сможете использовать его с числовыми операторами: `SecurityEvent | where toint(Level) >= 10`

## <a name="specify-a-time-range"></a>указывать диапазон времени;

### <a name="time-picker"></a>Средство выбора времени

Рядом с кнопкой запуска находится элемент выбора времени, указывающий, что мы запрашиваем только записи за последние 24 часа. Этот диапазон времени по умолчанию применяется ко всем запросам. Чтобы получить только записи за последний час, выберите _последний час_ и повторно запустите запрос.

![Средство выбора времени](media/get-started-queries/timepicker.png)


### <a name="time-filter-in-query"></a>Фильтр времени в запросе

Вы также можете определить ваш собственный диапазон времени, добавив фильтр времени к запросу. Лучше всего поместить фильтр времени сразу после имени таблицы: 

```Kusto
SecurityEvent
| where TimeGenerated > ago(30m) 
| where toint(Level) >= 10
```

Указанный фильтр времени `ago(30m)` означает "30 минут назад", поэтому этот запрос возвращает только записи за последние 30 минут. Другие единицы времени включают в себя дни (2d), минуты (25m) и секунды (10s).


## <a name="project-and-extend-select-and-compute-columns"></a>Операторы project и extend. Выбор и вычисление столбцов

Используйте оператор **project**, чтобы выбрать конкретные столбцы, которые нужно включить в результаты:

```Kusto
SecurityEvent 
| top 10 by TimeGenerated 
| project TimeGenerated, Computer, Activity
```

Предыдущий пример создает такие выходные данные:

![Запрос результатов проекта](media/get-started-queries/project.png)

С помощью **project** также можно переименовать столбцы и определить новые. В примере ниже project используется для выполнения следующих действий:

* Выбор только исходных столбцов *Computer* и *TimeGenerated*.
* Отображает столбец *Activity* как *EventDetails*.
* Создание столбца *EventCode*. Функция **substring()** используется для получения только первых четырех символов из поля Activity.


```Kusto
SecurityEvent
| top 10 by TimeGenerated 
| project Computer, TimeGenerated, EventDetails=Activity, EventCode=substring(Activity, 0, 4)
```

**extend** отслеживает все исходные столбцы в результирующем наборе, а также определяет дополнительные. Следующий запрос использует **extend**, чтобы добавить столбец *EventCode*. Обратите внимание, что эта колонка может не отображаться в конце таблицы, и в этом случае для ее просмотра вам понадобится раскрыть подробности записи.

```Kusto
SecurityEvent
| top 10 by TimeGenerated
| extend EventCode=substring(Activity, 0, 4)
```

## <a name="summarize-aggregate-groups-of-rows"></a>Оператор summarize. Агрегирование групп строк
С помощью оператора **summarize** можно определить группы записей в соответствии с одним или несколькими столбцами и применить к ним статистические вычисления. Поэтому с **summarize** чаще всего применяется функция *count*, которая возвращает число результатов в каждой группе.

Следующий запрос проверяет все записи в таблице *Perf* за последний час, группирует их по столбцу *ObjectName* и подсчитывает количество записей в каждой группе: 
```Kusto
Perf
| where TimeGenerated > ago(1h)
| summarize count() by ObjectName
```

Иногда имеет смысл определить группы по нескольким измерениям. Каждое уникальное сочетание этих значений определяет отдельную группу:

```Kusto
Perf
| where TimeGenerated > ago(1h)
| summarize count() by ObjectName, CounterName
```

Другое распространенное использование — выполнять математические или статистические вычисления в каждой группе. Например, следующий фрагмент вычисляет среднее значение *CounterValue* для каждого компьютера:

```Kusto
Perf
| where TimeGenerated > ago(1h)
| summarize avg(CounterValue) by Computer
```

К сожалению, результаты этого запроса бессмысленны, так как мы смешали разные счетчики производительности. Чтобы это имело смысл, следует рассчитывать среднее значение отдельно для каждого сочетания *CounterName* и *Computer*:

```Kusto
Perf
| where TimeGenerated > ago(1h)
| summarize avg(CounterValue) by Computer, CounterName
```

### <a name="summarize-by-a-time-column"></a>Суммирование по столбцу времени
Результаты также можно группировать по столбцу времени или другому непрерывному значению. В результате простого суммирования `by TimeGenerated` будут созданы группы для каждой миллисекунды за определенный период времени, так как речь идет об уникальных значениях. 

Чтобы создать группы на основании непрерывных значений, рекомендуется разбить диапазон на управляемые единицы с помощью **bin**. Следующий запрос анализирует записи *Perf* с данными об измерении свободной памяти (*доступная память в МБ*) на указанном компьютере. Он рассчитывает среднее значение каждого периода в 1 час за последние 7 дней:

```Kusto
Perf 
| where TimeGenerated > ago(7d)
| where Computer == "ContosoAzADDS2" 
| where CounterName == "Available MBytes" 
| summarize avg(CounterValue) by bin(TimeGenerated, 1h)
```

Чтобы сделать выходные данные более понятными, выберите отображение в виде диаграммы времени, показывающую объем доступной памяти с течением времени:

![Запрос памяти с течением времени](media/get-started-queries/chart.png)



## <a name="next-steps"></a>Дальнейшие действия

- Дополнительные сведения об использовании строкового типа данных в запросе журнала см. в статье [Работа со строками в запросах журнала Azure Monitor](/azure/data-explorer/kusto/query/samples?&pivots=azuremonitor#string-operations).
- Дополнительные сведения об агрегировании данных в запросе журнала см. в статье [Расширенное агрегирование в запросах журнала Azure Monitor](/azure/data-explorer/write-queries#advanced-aggregations).
- Дополнительные сведения об объединении данных из нескольких таблиц см. в статье [Объединения в запросах журнала Azure Monitor](/azure/data-explorer/kusto/query/samples?&pivots=azuremonitor#joins).
- Ознакомьтесь с документацией по всему языку запросов Kusto в [справочнике по языку KQL](/azure/kusto/query/).