---
title: Выбор столбцов распределения — масштабирование (Цитус) — база данных Azure для PostgreSQL
description: Узнайте, как выбрать столбцы распределения в типичных сценариях в базе данных Azure для PostgreSQL-Scale (Цитус).
author: jonels-msft
ms.author: jonels
ms.service: postgresql
ms.subservice: hyperscale-citus
ms.topic: conceptual
ms.date: 05/06/2019
ms.openlocfilehash: 129eff8c954c0c5469d3607e6ae16ce3202630ed
ms.sourcegitcommit: 772eb9c6684dd4864e0ba507945a83e48b8c16f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "91929342"
---
# <a name="choose-distribution-columns-in-azure-database-for-postgresql--hyperscale-citus"></a>Выбор столбцов распределения в базе данных Azure для PostgreSQL — масштабирование (Цитус)

Выбор столбца распределения каждой таблицы является одним из важнейших решений при моделировании, принимаемых вами. Служба "база данных Azure для PostgreSQL — масштабирование" (Цитус) хранит строки в сегментах на основе значения столбца распределения строк.

Правильные группы выбора связывают данные на одних и тех же физических узлах, что делает запросы быстрыми и добавляет поддержку всех функций SQL. Неверный вариант заставляет систему работать медленно и не поддерживать все функции SQL на всех узлах.

В этой статье приводятся советы по использованию столбцов распределения для двух наиболее распространенных сценариев масштабирования (Цитус).

### <a name="multi-tenant-apps"></a>Мультитенантные приложения

Архитектура с несколькими клиентами использует иерархическую модель моделирования баз данных для распределения запросов между узлами в группе серверов. Верхняя часть иерархии данных называется *идентификатором клиента* и должна храниться в столбце в каждой таблице.

Масштабирование (Цитус) проверяет запросы, чтобы узнать, какой идентификатор клиента они используют, и находит соответствующий сегмент таблицы. Он направляет запрос на один рабочий узел, содержащий сегмент. Выполнение запроса со всеми соответствующими данными, размещенными на том же узле, называется совместное размещение.

На следующей схеме показано совместное размещение в модели данных с несколькими клиентами. Она содержит две таблицы, учетные записи и кампании, распределенные по `account_id` . Затененные поля представляют сегменты. Зеленые сегменты хранятся на одном рабочем узле, а синие сегменты хранятся на другом рабочем узле. Обратите внимание, что запрос на соединение между учетными записями и кампаниями содержит все необходимые данные на одном узле, если обе таблицы ограничены одним идентификатором учетной записи \_ .

![Совместное размещение нескольких клиентов](media/concepts-hyperscale-choosing-distribution-column/multi-tenant-colocation.png)

Чтобы применить эту схему в собственной схеме, укажите, что представляет собой клиент в приложении. К общим экземплярам относятся компания, учетная запись, организация или клиент. Имя столбца будет выглядеть примерно так `company_id` : или `customer_id` . Изучите каждый запрос и запросите себя, будет ли он работать, если у него есть дополнительные предложения WHERE для ограничения всех таблиц, вовлеченных в строки с одинаковым ИДЕНТИФИКАТОРом клиента?
Запросы в модели с несколькими клиентами ограничены клиентом. Например, для запросов к продажам или инвентаризации используется область в определенном хранилище.

#### <a name="best-practices"></a>Рекомендации

-   **Секционирование распределенных таблиц по общему \_ столбцу идентификаторов клиентов.** Например, в приложении SaaS, где клиенты являются компаниями, идентификатор клиента, \_ скорее всего, будет \_ идентификатором компании.
-   **Преобразование небольших таблиц между клиентами в ссылочные таблицы.** Если несколько клиентов совместно используют небольшую таблицу данных, распространите их в виде ссылочной таблицы.
-   **Ограничить фильтр всех запросов приложений по \_ идентификатору клиента.** Каждый запрос должен запрашивать сведения для одного клиента за раз.

Ознакомьтесь с [руководством по нескольким клиентам](./tutorial-design-database-hyperscale-multi-tenant.md) для примера того, как создать приложение такого типа.

### <a name="real-time-apps"></a>Приложения в режиме реального времени

Архитектура с несколькими клиентами представляет иерархическую структуру и использует совместное размещение данных для маршрутизации запросов на каждого клиента. В отличие от этого, архитектуры в режиме реального времени зависят от конкретных свойств распределения своих данных, чтобы добиться высокой параллельной обработки.

Идентификатор сущности используется в качестве термина для столбцов распределения в модели реального времени. Типичными сущностями являются пользователи, узлы или устройства.

Запросы в режиме реального времени обычно запрашивают числовые статистические выражения, сгруппированные по датам или категориям. Масштабирование (Цитус) отправляет эти запросы в каждый сегмент для получения частичных результатов и собирает окончательный ответ на узле координатора. Запросы выполняются быстрее, когда количество узлов может быть максимально возможным, и если ни один узел не должен выполнять непропорциональное количество операций.

#### <a name="best-practices"></a>Рекомендации

-   **Выберите столбец с большим количеством элементов в качестве столбца распределения.** Для сравнения поле состояния в таблице заказа со значениями New, оплачено и отгружено плохо выбирает столбец распределения. В нем предполагается только несколько значений, которые ограничивают количество сегментов, которые могут содержать данные, и количество узлов, которые могут их обработать. Между столбцами с большим количеством элементов также удобно выбрать столбцы, которые часто используются в предложениях GROUP-BY или в качестве ключей объединения.
-   **Выберите столбец с четным распределением.** Если таблица распределяется по столбцу, смещенному по определенным общим значениям, данные в таблице будут накапливаться в определенных сегментах. Узлы, которые содержат эти сегменты, в итоге выполняют больше работы, чем другие узлы.
-   **Распределите таблицы фактов и измерений по общим столбцам.**
    У вашей таблицы фактов может быть только один ключ распределения. Таблицы, которые присоединяются к другому ключу, не будут совместно размещаться с таблицей фактов. Выберите одно измерение для совместного размещения в зависимости от частоты его соединения и размера соединяемых строк.
-   **Замените некоторые таблицы измерений на ссылочные таблицы.** Если таблица измерения не может быть совместно размещена с таблицей фактов, можно повысить производительность запросов, выполнив распространение копий таблицы измерения на все узлы в форме ссылочной таблицы.

Пример создания приложения такого типа см. в руководстве по работе с [панелями мониторинга в реальном времени](./tutorial-design-database-hyperscale-realtime.md) .

### <a name="time-series-data"></a>Данные временных рядов

В рабочей нагрузке временных рядов приложения запрашивают последние сведения во время архивации старых данных.

Наиболее распространенной ошибкой при моделировании сведений о ряде времени в подмасштабировании (Цитус) является использование отметки времени в качестве столбца распределения. Хэш-распределение, основанное на времени, при этом распределяется случайным образом на разные сегменты, а не на сегменты времени в сегментах. Запросы, в которых используются время, как правило, представляют собой ссылки на диапазон времени, например самые последние данные. Этот тип хэш-распределения приводит к сетевым издержкам.

#### <a name="best-practices"></a>Рекомендации

-   **Не выбирайте отметку времени в качестве столбца распределения.** Выберите другой столбец распределения. В приложении с несколькими клиентами используйте идентификатор клиента или в приложении в режиме реального времени используйте идентификатор сущности.
-   **Вместо этого используйте секционирование таблиц PostgreSQL в течение времени.** Секционирование таблиц используется для разбиения большой таблицы данных, упорядоченных по времени, на несколько наследуемых таблиц с каждой таблицей, содержащей разные диапазоны времени. При распределении postgres секционированной таблицы в масштабе (Цитус) создаются сегменты для наследуемых таблиц.

## <a name="next-steps"></a>Дальнейшие действия
- Узнайте, как совместное [Размещение](concepts-hyperscale-colocation.md) между распределенными данными помогает быстро выполнять запросы.
