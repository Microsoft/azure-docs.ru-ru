---
title: Использование CI/CD в Azure Dev Spaces
services: azure-dev-spaces
author: DrEsteban
ms.author: stevenry
ms.date: 12/17/2018
ms.topic: conceptual
manager: gwallace
description: Узнайте, как настроить непрерывную интеграцию и непрерывное развертывание с помощью Azure DevOps с Azure Dev Spaces
keywords: Docker, Kubernetes, Azure, AKS, Azure Container Service, containers
ms.openlocfilehash: 142f01a04066b919a81e1ad1ea95efa31f51f6ca
ms.sourcegitcommit: e6de1702d3958a3bea275645eb46e4f2e0f011af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/20/2021
ms.locfileid: "102548739"
---
# <a name="use-cicd-with-azure-dev-spaces"></a>Использование CI/CD в Azure Dev Spaces

[!INCLUDE [Azure Dev Spaces deprecation](../../../includes/dev-spaces-deprecation.md)]

Из этой статьи вы узнаете, как настроить непрерывную интеграцию и непрерывное развертывание (CI/CD) для Службы Azure Kubernetes (AKS) с поддержкой Azure Dev Spaces. CI/CD для AKS позволяет автоматически развертывать обновления приложений при каждой отправке зафиксированного кода в исходный репозиторий. Благодаря CI/CD и поддержке Dev Spaces кластер сохраняет актуальность базовых показателей приложения, чтобы разработчики могли работать с ними.

![Пример схемы CI/CD](../media/common/ci-cd-simple.png)

В этой статье описывается использование Azure DevOps, но те же принципы применяются и к другим системам непрерывной интеграции и непрерывного развертывания, таким как Jenkins, TeamCity и т. д.

## <a name="prerequisites"></a>Предварительные условия
* Кластер Службы Azure Kubernetes (AKS) с поддержкой Azure Dev Spaces.
* [Установленный интерфейс командной строки Azure Dev Spaces](upgrade-tools.md).
* [Организация Azure DevOps с проектом](/azure/devops/user-guide/sign-up-invite-teammates).
* [Реестр контейнеров Azure (ACR)](../../container-registry/container-registry-get-started-azure-cli.md).
    * Доступные данные [учетной записи администратора](../../container-registry/container-registry-authentication.md#admin-account) Реестра контейнеров Azure.
* [Кластер AKS с разрешениями на извлечение данных из Реестра контейнеров Azure](../../aks/cluster-container-registry-integration.md).

## <a name="download-sample-code"></a>Скачивание образца кода
Ради экономии времени создадим вилку примера кода из репозитория GitHub. Перейдите на страницу https://github.com/Azure/dev-spaces и щелкните **Fork** (Вилка). После создания вилки **клонируйте** версию вилки репозитория локально. По умолчанию будет извлечена ветвь _master_, но мы включили несколько изменений в ветвь _azds_updates_, которую также следует перенести во время создания вилки. Эти изменения позволят сэкономить время. Ветвь _azds_updates_ содержит обновления, которые следует внести вручную, как описано в разделах руководства по Dev Spaces, а также некоторые готовые файлы YAML и JSON для оптимизации развертывания системы CI/CD. С помощью команды `git checkout -b azds_updates origin/azds_updates` можно извлечь ветвь _azds_updates_ в локальном репозитории.

## <a name="dev-spaces-setup"></a>Настройка Dev Spaces
Создайте новое пространство с именем _dev_ с помощью команды `azds space select`. Ваш конвейер CI/CD будет использовать пространство _dev_ для передачи изменений кода. Также оно будет использоваться для создания _дочерних пространств_ на основе _dev_.

```cmd
azds space select -n dev
```

При появлении запроса на выбор родительского пространства разработки выберите _\<none\>_ .

После создания пространства разработки необходимо определить суффикс узла. Используйте `azds show-context` команду, чтобы отобразить суффикс узла Azure dev Spaces входящего контроллера.

```cmd
$ azds show-context
Name   ResourceGroup    DevSpace  HostSuffix
-----  ---------------  --------  ----------------------
MyAKS  MyResourceGroup  dev       fedcba098.eus.azds.io
```

В приведенном выше примере суффиксом узла является _fedcba098.EUS.azds.IO_. Это значение используется позже при создании определения выпуска.

Пространство _dev_ всегда будет содержать последнее состояние репозитория — базовое значение. Таким образом, разработчики могут создавать _дочерние пространства_ на основе _dev_ для тестирования отдельных изменений в контексте приложения большего размера. Эта концепция более подробно описана в руководствах по Dev Spaces.

## <a name="creating-the-build-definition"></a>Создание определения сборки
Откройте командный проект Azure DevOps в веб-браузере и перейдите в раздел _Pipelines_ (Конвейеры). Сначала щелкните фотографию профиля в правом верхнем углу на сайте Azure DevOps, откройте панель предварительной версии функций и отключите параметр _Новый интерфейс для создания конвейеров YAML_:

![Панель предварительной версии функций](../media/common/preview-feature-open.png)

Отключение параметра:

![Параметр "Новый интерфейс для создания конвейеров YAML"](../media/common/yaml-pipeline-preview-feature.png)

> [!Note]
> Сейчас предварительная версия функции Azure DevOps _Новый интерфейс для создания конвейеров YAML_ конфликтует с созданием предварительно определенных конвейеров сборки. Прежде чем развернуть предварительно определенный конвейер сборки, необходимо отключить эту функцию.

Мы включили в ветвь _azds_updates_ простую схему [YAML конвейеров Azure](/azure/devops/pipelines/yaml-schema?tabs=schema), которая определяет необходимые шаги для сборки *mywebapi* и *webfrontend*.

В зависимости от выбранного языка схема YAML конвейера извлекается в путь, схожий со следующим: `samples/dotnetcore/getting-started/azure-pipelines.dotnetcore.yml`

Чтобы создать конвейер из этого файла, сделайте следующее:
1. На главной странице проекта DevOps перейдите к конвейерам > сборки.
1. Выберите этот параметр, чтобы создать **Новый** конвейер сборки.
1. Выберите **GitHub** в качестве источника, Авторизуйте учетную запись GitHub, если это необходимо, и выберите ветвь _azds_updates_ из разветвленной версии репозитория примера приложения для _разработки пространств_ .
1. Выберите **конфигурацию в качестве кода** или **YAML** в качестве шаблона.
1. Теперь появится страница конфигурации для конвейера сборки. Как упоминалось выше, перейдите к указанному для конкретного языка пути к **файлу YAML** с помощью кнопки **...** . Например, `samples/dotnetcore/getting-started/azure-pipelines.dotnet.yml`.
1. Перейдите на вкладку **переменные** .
1. Вручную добавьте _dockerId_ в качестве переменной, которая является именем пользователя вашей [учетной записи администратора для Реестра контейнеров Azure](../../container-registry/container-registry-authentication.md#admin-account) (см. предварительные требования в начале статьи).
1. Вручную добавьте _dockerPassword_ в качестве переменной, которая является паролем вашей [учетной записи администратора для Реестра контейнеров Azure](../../container-registry/container-registry-authentication.md#admin-account). Не забудьте указать _dockerPassword_ в качестве секрета (щелкнув значок замка) в целях безопасности.
1. Выберите **Сохранить очередь &**.

Теперь у вас есть решение непрерывной интеграции, которое автоматически выполняет сборку *mywebapi* и *webfrontend* для любого обновления, отправленного в ветвь _azds_updates_ вилки GitHub. Вы можете проверить, что образы DOCKER отправлены, перейдя к портал Azure, выбрав реестр контейнеров Azure и перейдя на вкладку **репозитории** . Создание образов и их последующее отображение в реестре контейнеров может занять несколько минут.

![Репозитории Реестра контейнеров Azure](../media/common/ci-cd-images-verify.png)

## <a name="creating-the-release-definition"></a>Создание определения выпуска

1. На главной странице проекта DevOps последовательно выберите Pipelines (Конвейеры) > Releases (Выпуски).
1. Если вы работаете в новом проекте DevOps, который еще не содержит определение выпуска, необходимо сначала создать пустое определение выпуска. Параметр "Импорт" не отображается в пользовательском интерфейсе, пока не появится существующее определение выпуска.
1. В левой части экрана нажмите кнопку **+ создать** , а затем щелкните **Импорт конвейера**.
1. Нажмите кнопку **Обзор** и выберите `samples/release.json` проект.
1. Нажмите кнопку **OK**. Обратите внимание, что панель конвейера загрузилась со страницей редактирования определения выпуска. Также обратите внимание на красные значки предупреждения, указывающие на связанные с кластером сведения, которые должны быть настроены.
1. В левой части панели конвейера щелкните кружок **Добавить артефакт**.
1. В раскрывающемся списке **источник** выберите созданный ранее конвейер сборки.
1. В качестве **версии по умолчанию** выберите **Последняя из ветви создать конвейер по умолчанию с тегами**.
1. Оставлять **теги** пустыми.
1. Для параметра **Псевдоним источника** укажите `drop`. Значение **псевдонима источника** используется предопределенными задачами выпуска, поэтому оно должно быть задано.
1. Нажмите кнопку **Добавить**.
1. Теперь щелкните значок молнии на только что созданном источнике артефакта `drop`, как показано ниже:

    ![Настройка непрерывного развертывания артефакта выпуска](../media/common/release-artifact-cd-setup.png)
1. Включите **Триггер непрерывного развертывания**.
1. Наведите указатель на вкладку **задачи** рядом с пунктом **конвейер** и нажмите кнопку _Разработка_ , чтобы изменить задачи этапа _разработки_ .
1. Убедитесь, что в поле **тип соединения** выбрано **Azure Resource Manager** . Вы увидите три элемента управления "раскрывающийся список", выделенные красным цветом: ![ Настройка определения выпуска](../media/common/release-setup-tasks.png)
1. Выберите подписку Azure, которую вы используете с Azure Dev Spaces. Также может потребоваться нажать кнопку **авторизовать**.
1. Выберите группу ресурсов и кластер, которые вы используете с Azure Dev Spaces.
1. Щелкните **Задание агента**.
1. Выберите **размещенная Ubuntu 1604** в **пуле агентов**.
1. Наведите указатель мыши на селектор **задач** в верхней части страницы, щелкните " _произ_ .", чтобы изменить задачи _рабочей области._
1. Убедитесь, что в поле **тип соединения** выбрано **Azure Resource Manager** . и выберите подписку Azure, группу ресурсов и кластер, которые вы используете с Azure Dev Spaces.
1. Щелкните **Задание агента**.
1. Выберите **размещенная Ubuntu 1604** в **пуле агентов**.
1. Перейдите на вкладку **переменные** , чтобы обновить переменные для выпуска.
1. Измените значение **девспацешостсуффикс** с **UPDATE_ME** на суффикс узла. Суффикс узла отображается при выполнении `azds show-context` команды ранее.
1. Нажмите кнопку **Сохранить** в правом верхнем углу и кнопку **ОК**.
1. Щелкните **+ Выпуск** (рядом с кнопкой "Сохранить") и **Создать выпуск**.
1. Убедитесь, что в разделе **артефакты** выбрана последняя сборка из конвейера сборки.
1. Нажмите кнопку **Создать**.

Теперь начнется процесс автоматического выпуска и развертывание диаграмм *mywebapi* и *webfrontend* в кластер Kubernetes в пространстве верхнего уровня _dev_. Ход выполнения выпуска можно отслеживать на веб-портале Azure DevOps.

1. Перейдите к разделу **выпусков** в разделе **конвейеры**.
1. Щелкните конвейер выпуска для примера приложения.
1. Щелкните имя последнего выпуска.
1. Наведите указатель мыши на рамку **разработки** в разделе **этапы** и щелкните **журналы**.

Выпуск выполняется после завершения всех задач.

> [!TIP]
> Если выпуск завершается сбоем с сообщением об ошибке, например *UPGRADE FAILED: timed out waiting for the condition* (НЕ УДАЛОСЬ ОБНОВИТЬ: истекло время ожидания условия), проверьте объекты pod в кластере [с помощью панели мониторинга Kubernetes](../../aks/kubernetes-dashboard.md). Если вы видите, что модули не удается запустить с сообщениями об ошибках, такими как *сбой извлечения образа "azdsexample.azurecr.IO/mywebapi:122": Ошибка RPC: код = неизвестный DESC = сообщение об ошибке от управляющей программы: Get HTTPS: \/ /azdsexample.azurecr.IO/v2/mywebapi/manifests/122: несанкционированный: требуется проверка подлинности*, возможно, ваш кластер не авторизован для извлечения из реестра контейнеров Azure. Убедитесь, что предварительное требование о наличии [кластера AKS с разрешениями на извлечение данных из Реестра контейнеров Azure](../../aks/cluster-container-registry-integration.md) выполнено.

Теперь у вас есть полностью автоматизированный конвейер CI/CD для вилки GitHub примеров приложений Dev Spaces. Каждый раз при фиксации и отправке кода конвейер сборки будет создавать и отправлять образы *mywebapi* и *webfrontend* в ваш экземпляр ACR. Затем конвейер выпуска будет развертывать диаграмму Helm для каждого приложения в пространстве _dev_ кластера с поддержкой Dev Spaces.

## <a name="accessing-your-_dev_-services"></a>Доступ к службе _dev_
После развертывания доступ к _dev_-версии *webfrontend* может осуществляться с общедоступного URL-адреса, например `http://dev.webfrontend.fedcba098.eus.azds.io`. Этот URL-адрес можно найти, выполнив `azds list-uri` команду: 

```cmd
$ azds list-uris

Uri                                           Status
--------------------------------------------  ---------
http://dev.webfrontend.fedcba098.eus.azds.io  Available
```

## <a name="deploying-to-production"></a>Развертывание в рабочей среде

Чтобы вручную повысить уровень определенного выпуска до _prod_ в системе CI/CD, созданной в этом руководстве, выполните следующие действия:
1. Перейдите к разделу **выпусков** в разделе **конвейеры**.
1. Щелкните конвейер выпуска для примера приложения.
1. Щелкните имя последнего выпуска.
1. Наведите указатель мыши на поле " **произв** ." в разделе " **этапы** " и нажмите кнопку **развернуть**.
    ![Повышение уровня до рабочей среды](../media/common/prod-promote.png)
1. Снова наведите указатель на поле **произ** . в разделе **этапы** и щелкните **журналы**.

Выпуск выполняется после завершения всех задач.

На _этапе Рабочей_ нагрузки конвейера CI/CD для предоставления доступа к службам _производственных_ услуг вместо контроллера входящего пространства разработки используется балансировщик. Службы, развернутые в _рабочей области,_ доступны как IP-адреса вместо DNS-имен. В рабочей среде вы можете создать собственный контроллер входящего трафика для размещения служб на основе собственной конфигурации DNS.

Чтобы определить IP-адрес службы WebService, щелкните шаг "  **Печать общедоступного IP-** интерфейса", чтобы развернуть выходные данные журнала. Используйте IP-адрес, отображаемый в выходных данных журнала, для доступа к приложению- **интерфейсу** .

```cmd
...
2019-02-25T22:53:02.3237187Z webfrontend can be accessed at http://52.170.231.44
2019-02-25T22:53:02.3320366Z ##[section]Finishing: Print webfrontend public IP
...
```

## <a name="dev-spaces-instrumentation-in-production"></a>Инструментирование Dev Spaces в рабочей среде
Хотя инструментирование Dev Spaces создавалось, чтобы _не_ препятствовать нормальной работе вашего приложения, мы рекомендуем запускать рабочие нагрузки для рабочих сред в пространстве имен Kubernetes, которое не поддерживает Dev Spaces. С этим типом пространства имен Kubernetes вам следует либо создать пространство имен для рабочей среды с помощью интерфейса командной строки `kubectl`, либо разрешить системе CI/CD создать его при первом развертывании Helm. _Выбрав_ или создав пространство с помощью инструментов Dev Spaces, вы таким образом добавите инструментирование Dev Spaces в это пространство имен.

Ниже приведен пример структуры пространства имен, которая поддерживает разработку функций, среду "dev" _и_ рабочую среду в одном кластере Kubernetes:

![Пример структуры пространства имен](../media/common/cicd-namespaces.png)

> [!Tip]
> Если вы уже создали пространство `prod` и хотите исключить его из инструментирования Dev Spaces (но не удалять!), это можно сделать с помощью приведенной ниже команды в интерфейсе командной строки Dev Spaces:
>
> `azds space remove -n prod --no-delete`
>
> После этого может потребоваться удалить все объекты pod в пространстве имен `prod`, чтобы их можно было воссоздать без инструментирования Dev Spaces.

## <a name="next-steps"></a>Дальнейшие действия

Узнайте больше о принципах работы Azure Dev Spaces.

> [!div class="nextstepaction"]
> [Принцип работы Azure Dev Spaces](../how-dev-spaces-works.md)
