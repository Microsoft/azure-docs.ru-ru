---
title: Как работает код с Azure Dev Spaces
services: azure-dev-spaces
ms.date: 03/24/2020
ms.topic: conceptual
description: Описание процессов выполнения кода в службе Azure Kubernetes с Azure Dev Spaces
keywords: аздс. YAML, Azure Dev Spaces, пространства разработки, Docker, Kubernetes, Azure, AKS, служба Azure Kubernetes, контейнеры
ms.openlocfilehash: 1cace325f9415d46210636e5c04cc2d75589cc11
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "96014437"
---
# <a name="how-running-your-code-with-azure-dev-spaces-works"></a>Как работает код с Azure Dev Spaces

[!INCLUDE [Azure Dev Spaces deprecation](../../includes/dev-spaces-deprecation.md)]

Azure Dev Spaces предоставляет несколько способов быстро перебора и отладки приложений Kubernetes, а также совместной работы в кластере Службы Azure Kubernetes (AKS). После [подготовки проекта к работе в пространстве разработки][how-it-works-prep]можно использовать пространства разработки для создания и запуска проекта в кластере AKS.

В этой статье описывается, что происходит при выполнении кода в AKS с пространствами разработки.

## <a name="run-your-code"></a>Выполнение кода

Чтобы выполнить код в пространстве разработки, выполните `up` команду в том же каталоге, где находится `azds.yaml` файл:

```cmd
azds up
```

`up`Команда отправляет исходные файлы приложения и другие артефакты, необходимые для сборки и запуска проекта в пространстве разработки. В этом случае контроллер в сфере разработки:

1. Создает объекты Kubernetes для развертывания приложения.
1. Создает контейнер для приложения.
1. Развертывает приложение в пространстве разработки.
1. Создает общедоступное DNS-имя для конечной точки приложения, если оно настроено.
1. Использует *переадресацию через порт* для предоставления доступа к конечной точке приложения с помощью http://localhost .
1. перенаправляет выводы stdout и stderr на клиентские средства;


## <a name="starting-a-service"></a>Запуск службы

При запуске службы в пространстве разработки клиентские средства и контроллер работают в координации для синхронизации исходных файлов, создания контейнеров и объектов Kubernetes и запуска приложения.

На более детальном уровне ниже показано, что происходит при запуске `azds up` :

1. [Файлы синхронизируются][sync-section] с компьютера пользователя в хранилище файлов Azure, которое является уникальным для кластера AKS пользователя. Передаются исходный код, диаграмма Helm и файлы конфигурации.
1. Контроллер создает запрос на запуск нового сеанса. Этот запрос содержит несколько свойств, включая уникальный идентификатор, имя пространства, путь к исходному коду и флаг отладки.
1. Контроллер заменяет заполнитель *$ (Tag)* в диаграмме Helm уникальным идентификатором сеанса и устанавливает диаграмму Helm для службы. Добавление ссылки на уникальный идентификатор сеанса в диаграмму Helm позволяет связать контейнер, развернутый в кластере AKS, с этим конкретным сеансом, чтобы он был связан с запросом сеанса и связанной информацией.
1. Во время установки диаграммы Helm сервер допуска веб-перехватчика Kubernetes добавляет дополнительные контейнеры в модуль приложения для инструментирования и доступа к исходному коду проекта. Добавляются контейнеры девспацес-proxy и девспацес-proxy-init, чтобы обеспечить трассировку HTTP и маршрутизацию пространства. Контейнер девспацес-Build добавляется, чтобы предоставить Pod доступ к экземпляру DOCKER и исходному коду проекта для создания контейнера приложения.
1. Когда запускается модуль приложения, контейнер девспацес-Build и девспацес-proxy-init используются для построения контейнера приложения. Затем будут запущены контейнеры приложений и контейнеры девспацес-proxy.
1. После запуска контейнера приложений функция на стороне клиента использует функцию *переадресации порта* Kubernetes, чтобы предоставить доступ к приложению по протоколу HTTP http://localhost . Этот порт перенаправления подключает компьютер разработчика к службе в пространстве разработки.
1. Когда все контейнеры в модуле Pod запущены, служба выполняется. На этом этапе Клиентская функция начинает потоковую передачу трассировок HTTP, stdout и stderr. Эти сведения отображаются клиентской функциональностью для разработчика.

## <a name="updating-a-running-service"></a>Обновление работающей службы

Во время работы службы Azure Dev Spaces может обновить эту службу, если какой-либо из исходных файлов проекта изменится. Пространства разработки также обрабатывают обновление службы по-разному в зависимости от типа изменяемого файла. Существует три способа, с помощью которых пространства разработки могут обновлять работающую службу:

* Непосредственное обновление файла
* Перестроение и перезапуск процесса приложения в контейнере выполняющегося приложения
* Перестроение и повторное развертывание контейнера приложения

![Azure Dev Spaces синхронизации файлов](media/how-dev-spaces-works/file-sync.svg)

Некоторые файлы проектов, являющиеся статическими ресурсами, такие как файлы HTML, CSS и CSHTML, можно обновлять непосредственно в контейнере приложения, не перезапуская ничего. При изменении статического ресурса новый файл синхронизируется с пространством разработки, а затем используется работающим контейнером.

Изменения в файлах, таких как исходный код или файлы конфигурации приложения, могут быть применены путем перезапуска процесса приложения в работающем контейнере. После синхронизации этих файлов процесс приложения перезапускается в запущенном контейнере с помощью процесса *девхостажент* . При первоначальном создании контейнера приложения контроллер заменяет команду запуска приложения другим процессом, именуемым *девхостажент*. Фактический процесс приложения запускается как дочерний процесс в разделе *девхостажент*, и его выходные данные исправляются с помощью выходных данных *девхостажент*. Процесс *девхостажент* также является частью пространств разработки и может выполнять команды в работающем контейнере от имени пространств разработки. При выполнении перезапуска *девхостажент*:

* Останавливает текущий процесс или процессы, связанные с приложением
* Перестраивает приложение
* Перезапускает процесс или процессы, связанные с приложением

Способ, которым *девхостажент* выполняет предыдущие шаги, [настраивается `azds.yaml` в][azds-yaml-section].

Для обновления файлов проекта, таких как файлы dockerfile, CSPROJ или любая часть диаграммы Helm, требуется перестроение и повторное развертывание контейнера приложения. Когда один из этих файлов синхронизируется с пространством разработки, контроллер выполняет команду [обновления Helm][helm-upgrade] , а контейнер приложения перестраивается и развертывается повторно.

## <a name="file-synchronization"></a>Синхронизация файлов

При первом запуске приложения в пространстве разработки передаются все исходные файлы приложения. Пока приложение выполняется, а затем перезапускается, передаются только измененные файлы. Для координации этого процесса используются два файла: файл на стороне клиента и файл на стороне контроллера.

Файл на стороне клиента хранится во временном каталоге и именуется на основе хэша каталога проекта, который выполняется в пространствах разработки. Например, в Windows для вашего проекта будет иметься такой файл, как *Users\USERNAME\AppData\Local\Temp\1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef.synclog* . В Linux файл на стороне клиента хранится в каталоге */tmp* . Каталог в macOS можно найти, выполнив `echo $TMPDIR` команду.

Этот файл имеет формат JSON и содержит:

* Запись для каждого файла проекта, который синхронизируется с пространством разработки
* ИДЕНТИФИКАТОР синхронизации
* Метка времени последней операции синхронизации

Каждая запись файла проекта содержит путь к файлу и его метку времени.

Файл на стороне контроллера хранится в кластере AKS. Он содержит идентификатор синхронизации и метку времени последней синхронизации.

Синхронизация происходит, когда метки времени синхронизации между файлами на стороне клиента и на стороне контроллера не совпадают. Во время синхронизации средства клиентской стороны перебирает записи файлов в файле на стороне клиента. Если метка времени файла находится после метки времени синхронизации, этот файл синхронизируется с пространством разработки. После завершения синхронизации отметка времени синхронизации обновляется как на стороне клиента, так и на стороне контроллера.

Если файл на стороне клиента отсутствует, все файлы проекта синхронизируются. Такое поведение позволяет принудительно выполнить полную синхронизацию, удалив клиентский файл.

## <a name="how-running-your-code-is-configured"></a>Как выполняется настройка кода

Azure Dev Spaces использует `azds.yaml` файл для установки и настройки службы. Контроллер использует `install` свойство в `azds.yaml` файле для установки диаграммы Helm и создания объектов Kubernetes:

```yaml
...
install:
  chart: charts/webfrontend
  values:
  - values.dev.yaml?
  - secrets.dev.yaml?
  set:
    replicaCount: 1
    image:
      repository: webfrontend
      tag: $(tag)
      pullPolicy: Never
    ingress:
      annotations:
        kubernetes.io/ingress.class: traefik-azds
      hosts:
      # This expands to [space.s.][rootSpace.]webfrontend.<random suffix>.<region>.azds.io
      # Customize the public URL by changing the 'webfrontend' text between the $(rootSpacePrefix) and $(hostSuffix) tokens
      # For more information see https://aka.ms/devspaces/routing
      - $(spacePrefix)$(rootSpacePrefix)webfrontend$(hostSuffix)
...
```

По умолчанию `prep` команда создаст диаграмму Helm. Он также устанавливает свойство *install. Chart* в каталог диаграммы Helm. Если вы хотите использовать диаграмму Helm в другом расположении, можно обновить это свойство, чтобы использовать это расположение.

При установке диаграмм Helm Azure Dev Spaces предоставляет способ переопределения значений в диаграмме Helm. Значения по умолчанию для диаграммы Helm находятся в `charts/APP_NAME/values.yaml` .

С помощью свойства *install. Values* можно перечислить один или несколько файлов, определяющих значения, которые необходимо заменить на диаграмме Helm. Например, если требуется настроить имя узла или базы данных, особенно при запуске приложения в пространстве разработки, можно использовать эту функцию переопределения. Вы также можете добавить *?* в конце любого имени файла, чтобы задать его как необязательный.

Свойство *install. Set* позволяет настроить одно или несколько значений, которые необходимо заменить на диаграмме Helm. Любые значения, настроенные в *install. Set* , переопределяют значения, настроенные в файлах, перечисленных в файле *install. Values*. Свойства в *install. Set* зависят от значений в Helm диаграмме и могут отличаться в зависимости от созданной диаграммы Helm.

В приведенном выше примере свойство *install. Set. replicaCount* указывает контроллеру, сколько экземпляров приложения нужно запустить в пространстве разработки. В зависимости от сценария вы можете увеличить это значение, но оно повлияет на подключение отладчика к модулю приложения. Дополнительные сведения см. в [статье Устранение неполадок][troubleshooting].

В созданной диаграмме Helm образ контейнера имеет значение *{{. Values. Image. репозиторий}}: {{. Значения. Image. Tag}}*. `azds.yaml`Файл определяет свойство *install. Set. Image. Tag* как *$ (Tag)* по умолчанию, которое используется как значение для *{{. Значения. Image. Tag}}*. Если задать свойство *install. Set. Image. Tag* таким образом, то при запуске Azure dev Spaces образ контейнера для приложения можно помечать по отдельности. В этом конкретном случае образ помечается как *\<value from image.repository> $ (Tag)*. Необходимо использовать переменную *$ (Tag)* в качестве значения   *install. Set. Image. Tag* , чтобы пространства разработки распознавать и найти контейнер в кластере AKS.

В приведенном выше примере `azds.yaml` определяет *install. Set. входящий. Hosts*. Свойство *install. Set. входящий. Hosts* определяет формат имени узла для общедоступных конечных точек. В этом свойстве также используются *$ (спацепрефикс)*, *$ (рутспацепрефикс)* и *$ (хостсуффикс)*, которые являются значениями, предоставленными контроллером.

*$ (Спацепрефикс)* — это имя дочернего пространства разработки, которое принимает форму *спаценаме. s*. *$ (Рутспацепрефикс)* — это имя родительского пространства. Например, если *azureuser* является дочерним пространством *по умолчанию*, значение параметра *$ (рутспацепрефикс)* *по умолчанию* , а значение *$ (спацепрефикс)* — *azureuser. s*. Если пространство не является дочерним, *$ (спацепрефикс)* пусто. Например, если пространство *по умолчанию* не имеет родительского пространства, значение *$ (рутспацепрефикс)* будет *по умолчанию* , а значение *$ (спацепрефикс)* — пустым. *$ (Хостсуффикс)* — это DNS-суффикс, указывающий на Azure dev Spaces контроллер входящего трафика, который выполняется в кластере AKS. Например, этот DNS-суффикс соответствует DNS-записи с подстановочными знаками *\* . RANDOM_VALUE. ЕУС. аздс. IO*, который был создан при добавлении контроллера Azure dev Spaces в кластер AKS.

В приведенном выше `azds.yaml` файле можно также обновить *install. Set. входящий. Hosts* , чтобы изменить имя узла приложения. Например, если требуется упростить имя узла приложения из *$ (спацепрефикс) $ (рутспацепрефикс) веб-интерфейс $ (хостсуффикс)* в *$ (спацепрефикс) $ (рутспацепрефикс) Web $ (хостсуффикс)*.

Чтобы создать контейнер для приложения, контроллер использует следующие разделы `azds.yaml` файла конфигурации:

```yaml
build:
  context: .
  dockerfile: Dockerfile
...
configurations:
  develop:
    build:
      dockerfile: Dockerfile.develop
      useGitIgnore: true
      args:
        BUILD_CONFIGURATION: ${BUILD_CONFIGURATION:-Debug}
...
```

Контроллер использует Dockerfile для сборки и запуска приложения.

Свойство *Build. Context* содержит каталог, в котором существует файлы dockerfile. Свойство *build.docкерфиле* определяет имя Dockerfile для создания рабочей версии приложения. Свойство *configurations.develop.build.docкерфиле* настраивает имя Dockerfile для версии разработки приложения.

Наличие различных файлы dockerfile для разработки и рабочей среды позволяет включать определенные вещи во время разработки и отключать эти элементы для рабочих развертываний. Например, можно включить отладку или более подробное ведение журнала во время разработки и отключить в рабочей среде. Вы также можете обновить эти свойства, если файлы dockerfile имеют разные имена или находятся в другом расположении.

Для ускорения итераций во время разработки Azure Dev Spaces синхронизирует изменения из локального проекта и постепенно обновляет приложение. Следующий раздел `azds.yaml` файла конфигурации используется для настройки синхронизации и обновления.

```yaml
...
configurations:
  develop:
    ...
    container:
      sync:
      - "**/Pages/**"
      - "**/Views/**"
      - "**/wwwroot/**"
      - "!**/*.{sln,csproj}"
      command: [dotnet, run, --no-restore, --no-build, --no-launch-profile, -c, "${BUILD_CONFIGURATION:-Debug}"]
      iterate:
        processesToKill: [dotnet, vsdbg]
        buildCommands:
        - [dotnet, build, --no-restore, -c, "${BUILD_CONFIGURATION:-Debug}"]
...
```

Файлы и каталоги, которые будут синхронизировать изменения, перечислены в свойстве *Configurations. Разработка. контейнер. Синхронизация* . Эти каталоги изначально синхронизируются при выполнении `up` команды, а также при обнаружении изменений. Если имеются дополнительные или разные каталоги, которые вы хотите синхронизировать с пространством разработки, это свойство можно изменить.

Свойство *Configurations. Development. Container. REBUILD. буилдкоммандс* определяет способ сборки приложения в сценарии разработки. Свойство *Configurations. разработать. Container. Command* предоставляет команду для запуска приложения в сценарии разработки. Может потребоваться обновить любое из этих свойств, если имеются дополнительные флаги сборки или времени выполнения, которые вы хотите использовать во время разработки.

В параметре *Configurations. разработать. Container. reитерация. процессестокилл* перечислены процессы, которые нужно уничтожить, чтобы остановить приложение. Если вы хотите изменить поведение приложения во время разработки, может потребоваться обновить это свойство. Например, если вы обновили параметры *. Разработка. Container* . restart. буилдкоммандс или *Configurations. Разработка. контейнер. команда* для изменения способа построения или запуска приложения, может потребоваться изменить процессы, которые останавливаются.

При подготовке кода с помощью `azds prep` команды можно добавить `--enable-ingress` флажок. При добавлении `--enable-ingress` флага создается общедоступный URL-адрес приложения. Если опустить этот флаг, приложение будет доступно только в пределах кластера или с помощью туннеля localhost. После выполнения `azds prep` команды можно изменить этот параметр, изменив свойство входящий *. Enabled* в `charts/APPNAME/values.yaml` :

```yaml
ingress:
  enabled: true
```

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о сетях и способах маршрутизации запросов в Azure Dev Spaces см. в статье [как маршрутизация работает с Azure dev Spaces][how-it-works-routing].

Дополнительные сведения о быстром переборе и разработке с помощью Kubernetes см. в статье [как работают мосты в Kubernetes][how-it-works-bridge-to-kubernetes] и [как выполняется удаленная отладка кода с Azure dev Spaces][how-it-works-remote-debugging].


[azds-yaml-section]: #how-running-your-code-is-configured
[helm-upgrade]: https://helm.sh/docs/intro/using_helm/#helm-upgrade-and-helm-rollback-upgrading-a-release-and-recovering-on-failure
[how-it-works-bridge-to-kubernetes]: /visualstudio/containers/overview-bridge-to-kubernetes
[how-it-works-prep]: how-dev-spaces-works-prep.md
[how-it-works-remote-debugging]: how-dev-spaces-works-remote-debugging.md
[how-it-works-routing]: how-dev-spaces-works-routing.md
[sync-section]: #file-synchronization
[troubleshooting]: troubleshooting.md