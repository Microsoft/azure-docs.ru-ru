---
title: Поиск по большим двоичным объектам JSON
titleSuffix: Azure Cognitive Search
description: Сканирование больших двоичных объектов Azure JSON для текстового содержимого с помощью индексатора больших двоичных объектов Azure Когнитивный поиск. Индексаторы автоматизируют прием данных из выбранных источников, таких как хранилище BLOB-объектов Azure.
manager: nitinme
author: HeidiSteen
ms.author: heidist
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 02/01/2021
ms.openlocfilehash: 8156966e9a1c000701a5cc1c68a70c4ee048c738
ms.sourcegitcommit: d49bd223e44ade094264b4c58f7192a57729bada
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/02/2021
ms.locfileid: "99259056"
---
# <a name="how-to-index-json-blobs-using-a-blob-indexer-in-azure-cognitive-search"></a>Индексация больших двоичных объектов JSON с помощью индексатора больших двоичных объектов в Azure Когнитивный поиск

В этой статье показано, как [настроить индексатор больших двоичных объектов](search-howto-indexing-azure-blob-storage.md) , состоящий из документов JSON. Большие двоичные объекты JSON в хранилище BLOB-объектов Azure обычно предполагают любую из следующих форм:

+ Один документ JSON
+ Документ JSON, содержащий массив элементов JSON правильного формата.
+ Документ JSON, содержащий несколько сущностей, разделенных символом новой строки

Индексатор больших двоичных объектов предоставляет **`parsingMode`** параметр для оптимизации выходных данных документа поиска, основанного на режимах анализа структуры, состоит из следующих параметров.

| parsingMode | Документ JSON | Описание |
|--------------|-------------|--------------|
| **`json`** | Один на большой двоичный объект | параметры Анализирует большие двоичные объекты JSON как единый фрагмент текста. Каждый большой двоичный объект JSON преобразуется в один документ поиска. |
| **`jsonArray`** | Несколько на большой двоичный объект | Анализирует массив JSON в большом двоичном объекте, где каждый элемент массива преобразуется в отдельный документ поиска.  |
| **`jsonLines`** | Несколько на большой двоичный объект | Анализирует большой двоичный объект, содержащий несколько сущностей JSON (также массив), с отдельными элементами, разделенными символом новой строки. После каждой новой строки индексатор начинает новый поисковый документ. |

Как для **`jsonArray`** , так и для того **`jsonLines`** , [чтобы получить много поисковых документов, необходимо просмотреть индексирование одного большого двоичного объекта](search-howto-index-one-to-many-blobs.md) , чтобы понять, как индексатор больших двоичных объектов обрабатывает ключ документа для нескольких документов поиска, полученных из одного большого двоичного объекта.

В определении индексатора при необходимости можно установить [сопоставления полей](search-indexer-field-mappings.md) , чтобы выбрать свойства ИСХОДНОГО документа JSON, используемые для заполнения целевого индекса поиска. Например, при использовании **`jsonArray`** режима синтаксического анализа, если массив существует как свойство более низкого уровня, можно задать **`document root`** свойство, указывающее место размещения массива в большом двоичном объекте.

В следующих разделах каждый режим описан более подробно. Если вы не знакомы с клиентами и концепциями индексаторов, см. раздел [Создание индексатора поиска](search-howto-create-indexers.md). Кроме того, следует ознакомиться с подробными сведениями о [базовой конфигурации индексатора больших двоичных объектов](search-howto-indexing-azure-blob-storage.md), которая здесь не повторяется.

<a name="parsing-single-blobs"></a>

## <a name="index-single-json-documents-one-per-blob"></a>Индексировать отдельные документы JSON (по одному на большой двоичный объект)

По умолчанию индексаторы BLOB-объектов анализируют большие двоичные объекты JSON как один фрагмент текста, один документ поиска для каждого большого двоичного объекта в контейнере. Если формат JSON структурирован, документ поиска может отражать эту структуру с отдельными элементами, представленными в виде отдельных полей. Например, предположим, что в хранилище BLOB-объектов Azure имеется следующий документ JSON:

```http
{
    "article" : {
        "text" : "A hopefully useful article explaining how to parse JSON blobs",
        "datePublished" : "2020-04-13",
        "tags" : [ "search", "storage", "howto" ]    
    }
}
```

Индексатор больших двоичных объектов анализирует документ JSON в единый поисковый документ, загружая индекс, сопоставляя "Text", "datePublished" и "Tags" из источника с одинаково именованными и типизированными полями целевого индекса. Если имеется индекс с полями "text", "datePublished и "tags", индексатор больших двоичных объектов может определить правильное сопоставление без наличия сопоставления полей в запросе.

Хотя поведение по умолчанию — один документ поиска для каждого большого двоичного объекта JSON, установка режима синтаксического анализа JSON изменяет сопоставления внутренних полей для содержимого, повышая поля внутри `content` до фактических полей в индексе поиска. Пример определения индексатора для **`json`** режима синтаксического анализа может выглядеть следующим образом:

```http
POST https://[service name].search.windows.net/indexers?api-version=2020-06-30
Content-Type: application/json
api-key: [admin key]

{
    "name" : "my-json-indexer",
    "dataSourceName" : "my-blob-datasource",
    "targetIndexName" : "my-target-index",
    "parameters" : { "configuration" : { "parsingMode" : "json" } }
}
```

> [!NOTE]
> Как и в случае со всеми индексаторами, если поля не совпадают, следует явно указывать отдельные [сопоставления полей](search-indexer-field-mappings.md) , если только не используются сопоставления неявных полей, доступные для содержимого и метаданных BLOB-объектов, как описано в разделе [Базовая конфигурация индексатора больших двоичных объектов](search-howto-indexing-azure-blob-storage.md).

### <a name="json-example-single-hotel-json-files"></a>пример JSON (отдельные файлы JSON в одном отеле)

[Набор данных документа JSON для Гостиницы](https://github.com/Azure-Samples/azure-search-sample-data/tree/master/hotel-json-documents) в GitHub полезен для тестирования синтаксического анализа JSON, где каждый большой двоичный объект представляет структурированный файл JSON. Вы можете передать файлы данных в хранилище BLOB-объектов и использовать мастер **импорта данных** , чтобы быстро оценить, как это содержимое будет анализироваться в отдельные поисковые документы. 

Набор данных состоит из пяти больших двоичных объектов, каждый из которых содержит документ отеля с коллекцией адресов и коллекцией помещений. Индексатор больших двоичных объектов определяет обе коллекции и отражает структуру входных документов в схеме индекса.

<a name="parsing-arrays"></a>

## <a name="parse-json-arrays"></a>Анализ массивов JSON

Кроме того, можно использовать параметр массива JSON. Этот параметр полезен, если большие двоичные объекты содержат массив объектов JSON правильного формата, и каждый элемент должен стать отдельным документом поиска. **`jsonArrays`** При использовании следующий большой двоичный объект JSON создает три отдельных документа, каждый из которых имеет `"id"` `"text"` поля и.  

```text
[
    { "id" : "1", "text" : "example 1" },
    { "id" : "2", "text" : "example 2" },
    { "id" : "3", "text" : "example 3" }
]
```

**`parameters`** Свойство в индексаторе содержит значения режима синтаксического анализа. Для массива JSON определение индексатора должно выглядеть, как в следующем примере.

```http
POST https://[service name].search.windows.net/indexers?api-version=2020-06-30
Content-Type: application/json
api-key: [admin key]

{
    "name" : "my-json-indexer",
    "dataSourceName" : "my-blob-datasource",
    "targetIndexName" : "my-target-index",
    "parameters" : { "configuration" : { "parsingMode" : "jsonArray" } }
}
```

### <a name="jsonarrays-example-clinical-trials-sample-data"></a>Пример Жсонаррайс (демонстрационные данные клинической практике-пробных версий)

[Набор данных JSON клинической практике число_испытаний](https://github.com/Azure-Samples/azure-search-sample-data/tree/master/clinical-trials-json) в GitHub полезен для тестирования анализа массива JSON. Вы можете передать файлы данных в хранилище BLOB-объектов и использовать мастер **импорта данных** , чтобы быстро оценить, как это содержимое будет анализироваться в отдельные поисковые документы. 

Набор данных состоит из восьми больших двоичных объектов, каждый из которых содержит массив сущностей JSON, для всего 100 сущностей. Сущности зависят от того, какие поля заполняются, но конечный результат — один документ поиска на сущность из всех массивов во всех больших двоичных объектах.

<a name="nested-json-arrays"></a>

### <a name="parsing-nested-json-arrays"></a>Синтаксический анализ вложенных массивов JSON

Для массивов JSON, имеющих вложенные элементы, можно указать, **`documentRoot`** чтобы указать многоуровневая структура. Например, если большой двоичный объект выглядит следующим образом:

```http
{
    "level1" : {
        "level2" : [
            { "id" : "1", "text" : "Use the documentRoot property" },
            { "id" : "2", "text" : "to pluck the array you want to index" },
            { "id" : "3", "text" : "even if it's nested inside the document" }  
        ]
    }
}
```

Используйте эту конфигурацию для индексации массива, содержащегося в свойстве `level2`:

```http
{
    "name" : "my-json-array-indexer",
    ... other indexer properties
    "parameters" : { "configuration" : { "parsingMode" : "jsonArray", "documentRoot" : "/level1/level2" } }
}
```

## <a name="parse-json-entities-separated-by-newlines"></a>Анализ сущностей JSON, разделенных символами новой строки

Если большой двоичный объект содержит несколько сущностей JSON, разделенных новой строкой, и требуется, чтобы каждый элемент стал отдельным документом поиска, используйте **`jsonLines`** .

```text
{ "id" : "1", "text" : "example 1" }
{ "id" : "2", "text" : "example 2" }
{ "id" : "3", "text" : "example 3" }
```

Для строк JSON определение индексатора должно выглядеть примерно так, как показано в следующем примере.

```http
POST https://[service name].search.windows.net/indexers?api-version=2020-06-30
Content-Type: application/json
api-key: [admin key]

{
    "name" : "my-json-indexer",
    "dataSourceName" : "my-blob-datasource",
    "targetIndexName" : "my-target-index",
    "parameters" : { "configuration" : { "parsingMode" : "jsonLines" } }
}
```

### <a name="jsonlines-example-caselaw-sample-data"></a>Пример Жсонлинес (пример данных каселав)

[Набор данных JSON каселав](https://github.com/Azure-Samples/azure-search-sample-data/tree/master/caselaw) в GitHub полезен для тестирования синтаксического анализа новой строки JSON. Как и в других примерах, вы можете передать эти данные в хранилище BLOB-объектов и использовать мастер **импорта данных** , чтобы быстро оценить влияние режима анализа на отдельные большие двоичные объекты.

Набор данных состоит из одного большого двоичного объекта, содержащего 10 сущностей JSON, разделенных на новую строку, где каждая сущность описывает одиночный юридический случай. Конечным результатом является один документ поиска на сущность.

## <a name="map-json-fields-to-search-fields"></a>Сопоставьте поля JSON с полями поиска

Сопоставления полей используются для связи исходного поля с полем назначения в ситуациях, когда имена и типы полей не идентичны. Однако сопоставления полей также можно использовать для сопоставления частей документа JSON и "пребиваются" в поля верхнего уровня документа поиска.

Этот сценарий показан в следующем примере. Дополнительные сведения о сопоставлениях полей в целом см. в разделе [сопоставления полей](search-indexer-field-mappings.md).

```http
{
    "article" : {
        "text" : "A hopefully useful article explaining how to parse JSON blobs",
        "datePublished" : "2016-04-13"
        "tags" : [ "search", "storage", "howto" ]    
    }
}
```

Допустим, что у вас есть индекс поиска со следующими полями: `text` типа `Edm.String`, `date` типа `Edm.DateTimeOffset` и `tags` типа `Collection(Edm.String)`. Обратите внимание на несоответствие между полем "datePublished" в источнике и полем `date` в индексе. Чтобы сопоставить JSON с необходимой формой, используйте следующие сопоставления полей:

```http
"fieldMappings" : [
    { "sourceFieldName" : "/article/text", "targetFieldName" : "text" },
    { "sourceFieldName" : "/article/datePublished", "targetFieldName" : "date" },
    { "sourceFieldName" : "/article/tags", "targetFieldName" : "tags" }
    ]
```

Исходные поля указываются с помощью нотации [указателя JSON](https://tools.ietf.org/html/rfc6901) . Укажите косую черту (корень документа JSON) и путь до нужного свойства (на произвольном уровне вложенности), разделяя элементы пути косой чертой.

Также можно ссылаться на отдельные элементы массива, используя отсчитываемый от нуля индекс. Например, чтобы выбрать первый элемент массива "tags" из приведенного выше примера, используйте следующее сопоставление полей:

```http
{ "sourceFieldName" : "/article/tags/0", "targetFieldName" : "firstTag" }
```

> [!NOTE]
> Если **`sourceFieldName`** ссылается на свойство, которое отсутствует в большом двоичном ОБЪЕКТЕ JSON, это сопоставление пропускается без ошибок. Такое поведение позволяет индексирование продолжаться для больших двоичных объектов JSON, имеющих другую схему (что является распространенным вариантом использования). Так как проверка не выполняется, внимательно проверяйте сопоставления, чтобы не потерять документы по неправильной причине.
>

## <a name="next-steps"></a>Дальнейшие действия

+ [Настройка индексаторов BLOB-объектов](search-howto-indexing-azure-blob-storage.md)
+ [Определение сопоставлений полей](search-indexer-field-mappings.md)
+ [Общие сведения о индексаторах](search-indexer-overview.md)
+ [Индексация больших двоичных объектов CSV с помощью индексатора больших двоичных объектов](search-howto-index-csv-blobs.md)
+ [Учебник. Поиск частично структурированных данных из хранилища BLOB-объектов Azure](search-semi-structured-data.md)