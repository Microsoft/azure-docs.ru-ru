---
title: Поиск по большим двоичным объектам JSON
titleSuffix: Azure Cognitive Search
description: Сканирование больших двоичных объектов Azure JSON для текстового содержимого с помощью индексатора больших двоичных объектов Azure Когнитивный поиск. Индексаторы автоматизируют прием данных из выбранных источников, таких как хранилище BLOB-объектов Azure.
manager: nitinme
author: HeidiSteen
ms.author: heidist
ms.devlang: rest-api
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 09/25/2020
ms.openlocfilehash: 1fc6c7086917f2bcd6e4991d2dac37ea24cbfa83
ms.sourcegitcommit: aacbf77e4e40266e497b6073679642d97d110cda
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/12/2021
ms.locfileid: "98116388"
---
# <a name="how-to-index-json-blobs-using-a-blob-indexer-in-azure-cognitive-search"></a>Индексация больших двоичных объектов JSON с помощью индексатора больших двоичных объектов в Azure Когнитивный поиск

В этой статье показано, как настроить [индексатор](search-indexer-overview.md) больших двоичных объектов Azure когнитивный Поиск для извлечения структурированного содержимого из документов JSON в хранилище BLOB-объектов Azure и сделать его поиском в Azure когнитивный Поиск. Этот рабочий процесс создает индекс Azure Когнитивный поиск и загружает его с помощью существующего текста, извлеченного из больших двоичных объектов JSON. 

Вы можете использовать [портал](#json-indexer-portal), [REST API](#json-indexer-rest) или [пакет SDK для .NET](#json-indexer-dotnet) для индексирования содержимого JSON. Общие для всех подходов — документы JSON находятся в контейнере больших двоичных объектов в учетной записи хранения Azure. Рекомендации по отправке документов JSON из других платформ, не относящихся к Azure, см. [в статье Импорт данных в azure когнитивный Поиск](search-what-is-data-import.md).

Большие двоичные объекты JSON в хранилище BLOB-объектов Azure обычно являются одним документом JSON (режимом анализа `json` ) или коллекцией сущностей JSON. Для коллекций большой двоичный объект может иметь **массив** элементов JSON правильного формата (режим анализа — `jsonArray` ). Большие двоичные объекты также могут состоять из нескольких отдельных сущностей JSON, разделенных символом новой строки (режимом анализа является `jsonLines` ). Параметр **parsingMode** в запросе определяет выходные структуры.

> [!NOTE]
> Дополнительные сведения об индексировании нескольких поисковых документов из одного большого двоичного объекта см. в разделе [индексирование "один ко многим](search-howto-index-one-to-many-blobs.md)".

<a name="json-indexer-portal"></a>

## <a name="use-the-portal"></a>Использование портала

Самый простой способ индексирования документов JSON — использование мастера на [портале Azure](https://portal.azure.com/). Путем синтаксического анализа метаданных в контейнере больших двоичных объектов Azure мастер [**импорта данных**](search-import-data-portal.md) может создать индекс по умолчанию, сопоставить поля источника с целевыми полями индекса и загрузить индекс в рамках одной операции. В зависимости от размера и сложности исходных данных можно создать рабочий индекс полнотекстового поиска за считаные минуты.

Мы рекомендуем использовать один и тот же регион или расположение для Azure Когнитивный поиск и службы хранилища Azure для снижения задержки и избежания расходов на пропускную способность.

### <a name="1---prepare-source-data"></a>1. Подготовка исходных данных

[Войдите в портал Azure](https://portal.azure.com/) и [создайте контейнер больших двоичных объектов](../storage/blobs/storage-quickstart-blobs-portal.md) , который будет содержать ваши данные. Для общего уровня доступа можно задать любое из его допустимых значений.

Для получения данных в мастере **импорта данных** потребуется имя учетной записи хранения, имя контейнера и ключ доступа.

### <a name="2---start-import-data-wizard"></a>2. Запуск мастера импорта данных

На странице Обзор службы поиска можно [запустить мастер](search-import-data-portal.md) с панели команд.

   :::image type="content" source="media/search-import-data-portal/import-data-cmd2.png" alt-text="Команда &quot;Импорт данных&quot; на портале" border="false":::

### <a name="3---set-the-data-source"></a>3. Настройка источника данных

На странице **Источник данных** должен быть указан источник **Хранилище BLOB-объектов Azure** со следующими спецификациями.

+ Для параметра **Извлекаемые данные** выберите *Контент и метаданные*. При выборе этого варианта мастер может определить схему индекса и сопоставить поля для импорта.
   
+ Для **режима синтаксического анализа** необходимо задать значение *JSON*, *массив JSON* или *строки JSON*. 

  *JSON* определяет каждый большой двоичный объект как один поисковой документ, отображающийся как независимый элемент в результатах поиска. 

  *Массив JSON* предназначен для больших двоичных объектов, содержащих правильно сформированные данные JSON — формат JSON правильного формата соответствует массиву объектов или имеет свойство, являющееся массивом объектов, и требуется, чтобы каждый элемент был определен как отдельный, независимый документ поиска. Если большие двоичные объекты являются составными и вы не выберете *Массив JSON*, весь большой двоичный объект будет обработан как один документ.

  *Строки JSON* используются для больших двоичных объектов, состоящих из нескольких сущностей JSON, разделенных новой строкой, где каждая сущность должна располагаться как автономный независимый документ поиска. Если большие двоичные объекты являются сложными и вы не выбираете режим синтаксического анализа *JSON-строк* , то весь большой двоичный объект принимается как один документ.
   
+ Для параметра **Контейнер хранилища** укажите свою учетную запись хранения и контейнер или строку подключения, которая разрешается к контейнеру. Строки подключения можно получить на странице портала службы BLOB-объектов.

   :::image type="content" source="media/search-howto-index-json/import-wizard-json-data-source.png" alt-text="Определение источника данных BLOB-объектов" border="false":::

### <a name="4---skip-the-enrich-content-page-in-the-wizard"></a>4. Пропустите страницу "обогащение содержимого" в мастере

Добавление неученых навыков (или обогащения) не является требованием импорта. Если нет необходимости [добавлять обогащение искусственного интеллекта](cognitive-search-concept-intro.md) в конвейер индексирования, этот шаг следует пропустить.

Чтобы пропустить этот шаг, щелкните синюю кнопку в нижней части страницы для "Далее" и "пропустить".

### <a name="5---set-index-attributes"></a>5. Настройка атрибутов индекса

На странице **Индекс** вы увидите список полей с типом данных и ряд флажков для настройки атрибутов индекса. Мастер может создать список полей на основе метаданных и выборки исходных данных. 

Можно выполнить групповое выделение атрибутов, установив флажок в верхней части столбца атрибута. Выберите возможность **извлечения** и **поиска** для каждого поля, которое должно быть возвращено клиентскому приложению и которое подлежит обработке полнотекстового поиска. Вы заметите, что целые числа не являются полным текстом или нечеткими для поиска (числа оцениваются буквально и часто используются в фильтрах).

Дополнительные сведения см. в описании [атрибутов индекса](/rest/api/searchservice/create-index#bkmk_indexAttrib) и [языковых анализаторов](/rest/api/searchservice/language-support) . 

Просмотрите выбранные параметры. После запуска мастера создаются структуры физических данных и вы не сможете изменить эти поля без удаления и повторного создания всех объектов.

   :::image type="content" source="media/search-howto-index-json/import-wizard-json-index.png" alt-text="Определение индексов больших двоичных объектов" border="false":::

### <a name="6---create-indexer"></a>6. Создание индексатора

Полностью настроенный мастер создает три разных объекта в службе поиска. Объект источника данных и объект индекса сохраняются как именованные ресурсы в службе Когнитивный поиск Azure. На последнем шаге создает объект индексатора. Если присвоить индексатору имя, он будет существовать как отдельный ресурс, который можно запланировать и контролировать независимо от индекса и объекта источника данных, созданных в том же процессе мастера.

Если вы не знакомы с индексаторами, *индексатором* является ресурс в когнитивный Поиск Azure, который обходит внешний источник данных для поиска содержимого. Выходные данные мастера **импорта данных** — это индексатор, который обходит источник данных JSON, извлекает содержимое, доступное для поиска, и импортирует его в индекс на когнитивный Поиск Azure.

   :::image type="content" source="media/search-howto-index-json/import-wizard-json-indexer.png" alt-text="Определение индексатора больших двоичных объектов" border="false":::

Нажмите кнопку **OK** для запуска мастера и создания всех объектов. Индексирование начинается немедленно.

Вы можете отслеживать импорт данных на страницах портала. Уведомления о ходе выполнения указывают состояние индексирования и количество передаваемых документов. 

По завершении индексирования можно использовать [Проводник поиска](search-explorer.md), чтобы отправить запрос индексу.

> [!NOTE]
> Если вы не видите нужные данные, может потребоваться задать дополнительные атрибуты для дополнительных полей. Удалите индекс и индексатор, которые вы только что создали, и снова пошаговые инструкции мастера, изменив параметры индексов на шаге 5. 

<a name="json-indexer-rest"></a>

## <a name="use-rest-apis"></a>Использование REST API

Вы можете использовать REST API для индексации больших двоичных объектов JSON, следуя рабочему процессу из трех частей, общему для всех индексаторов в Azure Когнитивный поиск: создание источника данных, создание индекса и создание индексатора. Извлечение данных из хранилища BLOB-объектов происходит при отправке запроса на создание индексатора. После завершения этого запроса у вас будет индекс с запросом. 

Вы можете ознакомиться с [кодом примера оставшейся](#rest-example) в конце этого раздела, в котором показано, как создать все три объекта. В этом разделе также содержатся сведения о [режимах синтаксического анализа JSON](#parsing-modes), [отдельных больших двоичных](#parsing-single-blobs)объектах, [массивах JSON](#parsing-arrays)и [вложенных массивах](#nested-json-arrays).

Для индексации JSON на основе кода используйте [POST](search-get-started-rest.md) или [Visual Studio Code](search-get-started-vs-code.md) и REST API для создания этих объектов:

+ [index](/rest/api/searchservice/create-index)
+ [Источник данных](/rest/api/searchservice/create-data-source)
+ [Индексатор](/rest/api/searchservice/create-indexer)

Порядок операций требует создания и вызова объектов в этом порядке. В отличие от рабочего процесса портала, для реализации кода требуется доступный индекс для приема документов JSON, отправленных через запрос на **Создание индексатора** .

Большие двоичные объекты JSON в хранилище BLOB-объектов Azure обычно представляют собой один документ JSON или JSON-массив. Индексатор больших двоичных объектов в Azure Когнитивный поиск может выполнить синтаксический анализ любой конструкции в зависимости от того, как в запросе задан параметр **parsingMode** .

| Документ JSON | parsingMode | Описание | Доступность |
|--------------|-------------|--------------|--------------|
| Один на большой двоичный объект | `json` | Анализирует большие двоичные объекты JSON как отдельный блок текста. Каждый большой двоичный объект JSON преобразуется в один документ Azure Когнитивный поиск. | Общедоступно в [интерфейсе API и в](/rest/api/searchservice/indexer-operations) пакете SDK для [.NET](/dotnet/api/azure.search.documents.indexes.models.searchindexer) . |
| Несколько на большой двоичный объект | `jsonArray` | Анализирует массив JSON в большом двоичном объекте, где каждый элемент массива преобразуется в отдельный документ Azure Когнитивный поиск.  | Общедоступно в [интерфейсе API и в](/rest/api/searchservice/indexer-operations) пакете SDK для [.NET](/dotnet/api/azure.search.documents.indexes.models.searchindexer) . |
| Несколько на большой двоичный объект | `jsonLines` | Анализирует большой двоичный объект, который содержит несколько сущностей JSON ("Array"), разделенных новой строкой, где каждая сущность превращается в отдельный документ Azure Когнитивный поиск. | Общедоступно в [интерфейсе API и в](/rest/api/searchservice/indexer-operations) пакете SDK для [.NET](/dotnet/api/azure.search.documents.indexes.models.searchindexer) . |

### <a name="1---assemble-inputs-for-the-request"></a>1. формирование входных данных для запроса

Для каждого запроса необходимо указать имя службы и ключ администратора для Azure Когнитивный поиск (в заголовке POST), а также имя и ключ учетной записи хранения для хранилища BLOB-объектов. Для отправки HTTP-запросов в Azure Когнитивный поиск можно использовать [средство тестирования веб-API](search-get-started-rest.md) .

Скопируйте следующие четыре значения в блокнот, чтобы их можно было вставить в запрос:

+ Имя службы Когнитивный поиск Azure
+ Ключ администратора Когнитивный поиск Azure
+ Имя учетной записи хранения Azure
+ Ключ учетной записи хранения Azure

Эти значения можно найти на портале:

1. На страницах портала Когнитивный поиск Azure скопируйте URL-адрес службы поиска на странице Обзор.

2. В левой области навигации щелкните **ключи** , а затем скопируйте либо первичный, либо вторичный ключ (они эквивалентны).

3. Перейдите на страницу портала для своей учетной записи хранения. В области навигации слева в разделе **Параметры** щелкните **ключи доступа**. На этой странице указаны имя и ключ учетной записи. Скопируйте имя учетной записи хранения и один из ключей в Блокнот.

### <a name="2---create-a-data-source"></a>2. Создание источника данных

Этот шаг предоставляет сведения о соединении с источником данных, используемые индексатором. Источник данных — это именованный объект в Когнитивный поиск Azure, сохраняющий сведения о соединении. Тип источника данных определяет, `azureblob` какие поведения извлечения данных вызываются индексатором. 

Замените допустимые значения для имени службы, ключа администратора, учетной записи хранения и заполнители ключа учетной записи.

```http
    POST https://[service name].search.windows.net/datasources?api-version=2020-06-30
    Content-Type: application/json
    api-key: [admin key for Azure Cognitive Search]

    {
        "name" : "my-blob-datasource",
        "type" : "azureblob",
        "credentials" : { "connectionString" : "DefaultEndpointsProtocol=https;AccountName=<account name>;AccountKey=<account key>;" },
        "container" : { "name" : "my-container", "query" : "optional, my-folder" }
    }   
```

### <a name="3---create-a-target-search-index"></a>3. Создание целевого индекса поиска 

Индексаторы связываются со схемой индекса. При использовании API-интерфейса (а не портала) необходимо предварительно подготовить индекс для указания в операции индексатора.

В индексе хранится контент, поддерживающий поиск, в Когнитивный поиск Azure. Чтобы создать индекс, предоставьте схему, которая задает поля в документе, атрибуты и другие компоненты, которые определяют процедуру поиска. Если вы создаете индекс, который имеет те же имена полей и типы данных в качестве источника, индексатор будет сопоставлять поля источника и назначения и вам не придется явным образом сопоставлять эти поля.

В следующем примере показан запрос [Создать индекс](/rest/api/searchservice/create-index). У индекса будет доступное для поиска поле `content` для хранения текста, извлеченного из больших двоичных объектов:   

```http
    POST https://[service name].search.windows.net/indexes?api-version=2020-06-30
    Content-Type: application/json
    api-key: [admin key for Azure Cognitive Search]

    {
          "name" : "my-target-index",
          "fields": [
            { "name": "id", "type": "Edm.String", "key": true, "searchable": false },
            { "name": "content", "type": "Edm.String", "searchable": true, "filterable": false, "sortable": false, "facetable": false }
          ]
    }
```


### <a name="4---configure-and-run-the-indexer"></a>4. Настройка и запуск индексатора

Как и в случае с индексом и источником данных, индексатор также является именованным объектом, который создается и повторно используется в службе Когнитивный поиск Azure. Полностью указанный запрос на создание индексатора может выглядеть следующим образом:

```http
    POST https://[service name].search.windows.net/indexers?api-version=2020-06-30
    Content-Type: application/json
    api-key: [admin key for Azure Cognitive Search]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "json" } }
    }
```

Конфигурация индексатора находится в тексте запроса. Для этого требуется источник данных и пустой целевой индекс, который уже существует в Когнитивный поиск Azure. 

Расписание и параметры являются необязательными. Если опустить их, индексатор выполняется немедленно, используя в `json` качестве режима анализа.

Этот конкретный индексатор не включает сопоставления полей. В определении индексатора можно оставить **сопоставления полей** , если свойства ИСХОДНОГО документа JSON соответствуют полям целевого индекса поиска. 


### <a name="rest-example"></a>Пример для RESTFUL

В этом разделе приведен краткий обзор всех запросов, используемых для создания объектов. Описание частей компонентов см. в предыдущих разделах этой статьи.

### <a name="data-source-request"></a>Запрос к источнику данных

Для всех индексаторов требуется объект источника данных, который предоставляет сведения о соединении с существующими данными. 

```http
    POST https://[service name].search.windows.net/datasources?api-version=2020-06-30
    Content-Type: application/json
    api-key: [admin key for Azure Cognitive Search]

    {
        "name" : "my-blob-datasource",
        "type" : "azureblob",
        "credentials" : { "connectionString" : "DefaultEndpointsProtocol=https;AccountName=<account name>;AccountKey=<account key>;" },
        "container" : { "name" : "my-container", "query" : "optional, my-folder" }
    }  
```

### <a name="index-request"></a>Запрос индекса

Для всех индексаторов требуется целевой индекс, который получает данные. Текст запроса определяет схему индекса, состоящую из полей с атрибутами, поддерживающими требуемое поведение в индексе с возможностью поиска. При запуске индексатора этот индекс должен быть пустым. 

```http
    POST https://[service name].search.windows.net/indexes?api-version=2020-06-30
    Content-Type: application/json
    api-key: [admin key for Azure Cognitive Search]

    {
          "name" : "my-target-index",
          "fields": [
            { "name": "id", "type": "Edm.String", "key": true, "searchable": false },
            { "name": "content", "type": "Edm.String", "searchable": true, "filterable": false, "sortable": false, "facetable": false }
          ]
    }
```

### <a name="indexer-request"></a>Запрос индексатора

Этот запрос показывает полностью указанный индексатор. Он включает сопоставления полей, которые были пропущены в предыдущих примерах. Помните, что «Schedule», «Parameters» и «Фиелдмаппингс» являются необязательными, если доступно по умолчанию. Пропуск "Schedule" приводит к немедленному запуску индексатора. Пропуск "parsingMode" приводит к тому, что индекс использует значение по умолчанию "JSON".

Создание индексатора в Azure Когнитивный поиск инициирует импорт данных. Он выполняется немедленно, а затем по расписанию, если вы предоставили его.

```http
    POST https://[service name].search.windows.net/indexers?api-version=2020-06-30
    Content-Type: application/json
    api-key: [admin key for Azure Cognitive Search]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "json" } },
      "fieldMappings" : [
        { "sourceFieldName" : "/article/text", "targetFieldName" : "text" },
        { "sourceFieldName" : "/article/datePublished", "targetFieldName" : "date" },
        { "sourceFieldName" : "/article/tags", "targetFieldName" : "tags" }
        ]
    }
```

<a name="json-indexer-dotnet"></a>

## <a name="use-net-sdk"></a>Использование пакета SDK для .NET

Пакет SDK для .NET полностью использует четность с REST API. Мы рекомендуем прочитать предыдущий раздел о REST API, чтобы ознакомиться с концепциями, рабочим процессом и требованиями. Используйте следующую справочную документацию по .NET API для реализации индексатора JSON в управляемом коде.

+ [azure.search.docументс. indexes. Models. сеарчиндексердатасаурцеконнектион](/dotnet/api/azure.search.documents.indexes.models.searchindexerdatasourceconnection)
+ [azure.search.docументс. indexes. Models. сеарчиндексердатасаурцетипе](/dotnet/api/azure.search.documents.indexes.models.searchindexerdatasourcetype) 
+ [azure.search.docументс. indexes. Models. сеарчиндекс](/dotnet/api/azure.search.documents.indexes.models.searchindex) 
+ [azure.search.docументс. indexes. Models. сеарчиндексер](/dotnet/api/azure.search.documents.indexes.models.searchindexer)

<a name="parsing-modes"></a>

## <a name="parsing-modes"></a>Режимы анализа

Большие двоичные объекты JSON могут полагаться на несколько форм. Параметр **parsingMode** индексатора JSON определяет способ синтаксического анализа и структурирования содержимого больших двоичных объектов JSON в индексе Azure когнитивный Поиск:

| parsingMode | Описание |
|-------------|-------------|
| `json`  | Индексировать каждый BLOB-объект как отдельный документ. Это значение по умолчанию. |
| `jsonArray` | Выберите этот режим, если большие двоичные объекты состоят из массивов JSON, и каждый элемент массива должен стать отдельным документом в Когнитивный поиск Azure. |
|`jsonLines` | Выберите этот режим, если большие двоичные объекты состоят из нескольких сущностей JSON, разделенных новой строкой, и требуется, чтобы каждая сущность стала отдельным документом в Когнитивный поиск Azure. |

Документ можно представить себе как отдельный элемент в результатах поиска. Если требуется, чтобы каждый элемент в массиве отображался в результатах поиска как независимый элемент, используйте `jsonArray` параметр или `jsonLines` соответствующим образом.

В определении индексатора можно использовать [сопоставление полей](search-indexer-field-mappings.md) для выбора свойств исходного документа JSON, применяемых для заполнения целевого индекса поиска. В `jsonArray` режиме синтаксического анализа, если массив существует как свойство более низкого уровня, можно задать корневой каталог документа, указывающий, где массив помещается в большой двоичный объект.

> [!IMPORTANT]
> При использовании `json` `jsonArray` или `jsonLines` режиме синтаксического анализа Azure когнитивный Поиск предполагает, что все большие двоичные объекты в источнике данных содержат JSON. Если необходима поддержка как объектов JSON, так и других объектов в одном источнике данных, сообщите нам об этом на [нашем сайте UserVoice](https://feedback.azure.com/forums/263029-azure-search).


<a name="parsing-single-blobs"></a>

## <a name="parse-single-json-blobs"></a>Анализ единичных больших двоичных объектов JSON

По умолчанию [индексатор BLOB-объектов когнитивный Поиск Azure](search-howto-indexing-azure-blob-storage.md) анализирует большие двоичные объекты JSON как один фрагмент текста. Часто требуется сохранить структуру документов JSON. Например, предположим, что в хранилище BLOB-объектов Azure имеется следующий документ JSON:

```http
    {
        "article" : {
            "text" : "A hopefully useful article explaining how to parse JSON blobs",
            "datePublished" : "2016-04-13",
            "tags" : [ "search", "storage", "howto" ]    
        }
    }
```

Индексатор больших двоичных объектов анализирует документ JSON в отдельный документ Azure Когнитивный поиск. Индексатор загружает индекс, сопоставляя значения text, datePublished и tags из источника с идентичными по названию и типу целевыми полями индекса.

Как уже отмечалось, сопоставления полей необязательны. Если имеется индекс с полями "text", "datePublished и "tags", индексатор больших двоичных объектов может определить правильное сопоставление без наличия сопоставления полей в запросе.

<a name="parsing-arrays"></a>

## <a name="parse-json-arrays"></a>Анализ массивов JSON

Кроме того, можно использовать параметр массива JSON. Этот параметр полезен, если большие двоичные *объекты содержат массив объектов JSON правильного формата*, и каждый элемент должен стать отдельным документом когнитивный Поиск Azure. Например, при наличии следующего большого двоичного объекта JSON можно заполнить индекс Azure Когнитивный поиск тремя отдельными документами, каждый из которых имеет поля "ID" и "Text".  

```text
    [
        { "id" : "1", "text" : "example 1" },
        { "id" : "2", "text" : "example 2" },
        { "id" : "3", "text" : "example 3" }
    ]
```

Для массива JSON определение индексатора должно выглядеть, как в следующем примере. Обратите внимание, что параметр parsingMode указывает средство синтаксического анализа `jsonArray`. Указание правильного средства синтаксического анализа и ввод правильного ввода данных — единственные требования к массиву для индексирования больших двоичных объектов JSON.

```http
    POST https://[service name].search.windows.net/indexers?api-version=2020-06-30
    Content-Type: application/json
    api-key: [admin key]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "jsonArray" } }
    }
```

Снова отметим, что сопоставления полей необязательны. Если имеется индекс с полями с аналогичными именами id и text, индексатор больших двоичных объектов может определить правильное сопоставление без явного списка сопоставления полей.

<a name="nested-json-arrays"></a>

## <a name="parse-nested-arrays"></a>Анализ вложенных массивов
Для массивов JSON, имеющих вложенные элементы, можно указать, `documentRoot` чтобы указать многоуровневая структура. Например, если большой двоичный объект выглядит следующим образом:

```http
    {
        "level1" : {
            "level2" : [
                { "id" : "1", "text" : "Use the documentRoot property" },
                { "id" : "2", "text" : "to pluck the array you want to index" },
                { "id" : "3", "text" : "even if it's nested inside the document" }  
            ]
        }
    }
```

Используйте эту конфигурацию для индексации массива, содержащегося в свойстве `level2`:

```http
    {
        "name" : "my-json-array-indexer",
        ... other indexer properties
        "parameters" : { "configuration" : { "parsingMode" : "jsonArray", "documentRoot" : "/level1/level2" } }
    }
```

## <a name="parse-blobs-separated-by-newlines"></a>Анализ больших двоичных объектов, разделенных символами новой строки

Если ваш большой двоичный объект содержит несколько сущностей JSON, разделенных новой строкой, и требуется, чтобы каждый элемент стал отдельным документом Когнитивный поиск Azure, можно выбрать параметр JSON Lines. Например, при наличии следующего большого двоичного объекта (в котором есть три различные сущности JSON) можно заполнить индекс Azure Когнитивный поиск тремя отдельными документами, каждый из которых имеет поля "ID" и "Text".

```text
{ "id" : "1", "text" : "example 1" }
{ "id" : "2", "text" : "example 2" }
{ "id" : "3", "text" : "example 3" }
```

Для строк JSON определение индексатора должно выглядеть примерно так, как показано в следующем примере. Обратите внимание, что параметр parsingMode указывает средство синтаксического анализа `jsonLines`. 

```http
    POST https://[service name].search.windows.net/indexers?api-version=2020-06-30
    Content-Type: application/json
    api-key: [admin key]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "jsonLines" } }
    }
```

Опять же, обратите внимание, что сопоставления полей можно опустить, как в `jsonArray` режиме синтаксического анализа.

## <a name="add-field-mappings"></a>Добавление сопоставлений полей

Если исходные и целевые поля не полностью согласованы, можно определить область сопоставления полей в тексте запроса для их явного сопоставления.

В настоящее время Azure Когнитивный поиск не может индексировать произвольные документы JSON напрямую, так как поддерживает только типы данных-примитивы, массивы строк и геометрические точки. Однако с помощью **сопоставления полей** можно выбирать части документа JSON и "поднимать" до полей верхнего уровня документа поиска. Сведения об основных понятиях сопоставления полей см. [в разделе сопоставления полей в Azure когнитивный Поиск индексаторы](search-indexer-field-mappings.md).

Вернемся к нашему примеру документа JSON:

```http
    {
        "article" : {
            "text" : "A hopefully useful article explaining how to parse JSON blobs",
            "datePublished" : "2016-04-13"
            "tags" : [ "search", "storage", "howto" ]    
        }
    }
```

Допустим, что у вас есть индекс поиска со следующими полями: `text` типа `Edm.String`, `date` типа `Edm.DateTimeOffset` и `tags` типа `Collection(Edm.String)`. Обратите внимание на несоответствие между полем "datePublished" в источнике и полем `date` в индексе. Чтобы сопоставить JSON с необходимой формой, используйте следующие сопоставления полей:

```http
    "fieldMappings" : [
        { "sourceFieldName" : "/article/text", "targetFieldName" : "text" },
        { "sourceFieldName" : "/article/datePublished", "targetFieldName" : "date" },
        { "sourceFieldName" : "/article/tags", "targetFieldName" : "tags" }
      ]
```

Имена полей источника в сопоставлениях задаются с помощью нотации [указателя JSON](https://tools.ietf.org/html/rfc6901) . Укажите косую черту (корень документа JSON) и путь до нужного свойства (на произвольном уровне вложенности), разделяя элементы пути косой чертой.

Также можно ссылаться на отдельные элементы массива, используя отсчитываемый от нуля индекс. Например, чтобы выбрать первый элемент массива "tags" из приведенного выше примера, используйте следующее сопоставление полей:

```http
    { "sourceFieldName" : "/article/tags/0", "targetFieldName" : "firstTag" }
```

> [!NOTE]
> Если имя поля источника в пути сопоставления полей ссылается на свойство, которое не существует в JSON, это сопоставление пропускается без ошибки. Это необходимо для поддержки документов с разными схемами (что часто встречается на практике). Поскольку проверка на ошибки не выполняется, будьте внимательны и не допускайте опечаток в спецификации сопоставления полей.
>

## <a name="help-us-make-azure-cognitive-search-better"></a>Помогите нам сделать Azure Когнитивный поиск лучше
Если вам нужна какая-либо функция или у вас есть идеи, которые можно было бы реализовать, сообщите об этом на [сайте UserVoice](https://feedback.azure.com/forums/263029-azure-search/). Если вам нужна помощь с использованием существующего компонента, опубликуйте свой вопрос на [Stack overflow](https://stackoverflow.microsoft.com/questions/tagged/18870).

## <a name="see-also"></a>См. также раздел

+ [Indexers in Azure Cognitive Search](search-indexer-overview.md) (Индексаторы в службе "Когнитивный поиск Azure")
+ [Индексирование хранилища BLOB-объектов Azure с помощью Azure Когнитивный поиск](search-howto-index-json-blobs.md)
+ [Индексирование больших двоичных объектов CSV с помощью индексатора BLOB-объектов Когнитивный поиск Azure](search-howto-index-csv-blobs.md)
+ [Учебник. Поиск частично структурированных данных из хранилища BLOB-объектов Azure](search-semi-structured-data.md)