---
title: Настройка индексатора больших двоичных объектов
titleSuffix: Azure Cognitive Search
description: Настройка индексатора больших двоичных объектов Azure для автоматизации индексирования содержимого BLOB-объектов для операций полнотекстового поиска в Azure Когнитивный поиск.
manager: nitinme
author: MarkHeff
ms.author: maheff
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 02/03/2021
ms.openlocfilehash: 266538a7aff11bff0b6dc5c2d2b6a7a3d25c18ab
ms.sourcegitcommit: 445ecb22233b75a829d0fcf1c9501ada2a4bdfa3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/02/2021
ms.locfileid: "99474987"
---
# <a name="how-to-configure-blob-indexing-in-cognitive-search"></a>Настройка индексирования BLOB-объектов в Когнитивный поиск

В этой статье показано, как настроить индексатор больших двоичных объектов для индексирования текстовых документов (например, документов PDF, Microsoft Office документы и др.) в Когнитивный поиск Azure. Если вы не знакомы с понятиями индексатора, начните с [индексаторов в Azure когнитивный Поиск](search-indexer-overview.md) и [Создайте индексатор поиска](search-howto-create-indexers.md) , прежде чем углубляться в индексирование BLOB-объектов.

<a name="SupportedFormats"></a>

## <a name="supported-document-formats"></a>Поддерживаемые форматы документов

Индексатор больших двоичных объектов Azure Когнитивный поиск может извлекать текст из следующих форматов документов:

[!INCLUDE [search-blob-data-sources](../../includes/search-blob-data-sources.md)]

## <a name="data-source-definitions"></a>Определения источников данных

Различие между индексатором больших двоичных объектов и любым другим индексатором — это определение источника данных, назначенное индексатору. Источник данных инкапсулирует все свойства, указывающие тип, соединение и расположение индексируемого содержимого.

Определение источника данных большого двоичного объекта похоже на пример ниже:

```http
{
    "name" : "my-blob-datasource",
    "type" : "azureblob",
    "credentials" : { "connectionString" : "DefaultEndpointsProtocol=https;AccountName=<account name>;AccountKey=<account key>;" },
    "container" : { "name" : "my-container", "query" : "<optional-virtual-directory-name>" }
}
```

`"credentials"`Свойство может быть строкой подключения, как показано в приведенном выше примере, или одним из альтернативных подходов, описанных в следующем разделе. `"container"`Свойство предоставляет расположение содержимого в службе хранилища Azure и `"query"` используется для указания вложенной папки в контейнере. Дополнительные сведения об определениях источников данных см. в разделе [Create Data Source (остальное)](/rest/api/searchservice/create-data-source).

<a name="Credentials"></a>

## <a name="credentials"></a>Учетные данные

Учетные данные для контейнера BLOB-объектов можно указать одним из описанных ниже способов.

**Строка подключения управляемого удостоверения**: `{ "connectionString" : "ResourceId=/subscriptions/<your subscription ID>/resourceGroups/<your resource group name>/providers/Microsoft.Storage/storageAccounts/<your storage account name>/;" }`

Для этой строки подключения не требуется ключ учетной записи, но необходимо выполнить инструкции по [настройке подключения к учетной записи хранения Azure с помощью управляемого удостоверения](search-howto-managed-identities-storage.md).

**Строка подключения учетной записи хранения с полным доступом**: `{ "connectionString" : "DefaultEndpointsProtocol=https;AccountName=<your storage account>;AccountKey=<your account key>;" }`

Строку подключения можно получить на портале Azure, перейдя в колонку учетной записи хранения и щелкнув "Параметры" > "Ключи" (для классических учетных записей хранения) или "Параметры" > "Ключи доступа" (для учетных записей хранения Azure Resource Manager).

Строка подключения для **подписи общего доступа к учетной записи хранения** (SAS):`{ "connectionString" : "BlobEndpoint=https://<your account>.blob.core.windows.net/;SharedAccessSignature=?sv=2016-05-31&sig=<the signature>&spr=https&se=<the validity end time>&srt=co&ss=b&sp=rl;" }`

Подписанный URL-адрес должен иметь разрешения "Список" и "Чтение" для контейнеров и объектов (в данном случае — больших двоичных объектов).

**Подписанный URL для общего доступа**: `{ "connectionString" : "ContainerSharedAccessUri=https://<your storage account>.blob.core.windows.net/<container name>?sv=2016-05-31&sr=c&sig=<the signature>&se=<the validity end time>&sp=rl;" }`

Подписанный URL-адрес должен иметь разрешения "Список" и "Чтение" для контейнера. Дополнительные сведения о подписанных URL для общего доступа см. в разделе [использование подписанных](../storage/common/storage-sas-overview.md)URL.

> [!NOTE]
> Если используются учетные данные SAS, то необходимо периодически обновлять учетные данные источника данных с помощью обновленных подписей, чтобы не истек их срок действия. Если срок действия учетных данных SAS истек, индексатор завершится ошибкой с сообщением об ошибке "учетные данные, указанные в строке подключения, недопустимы или истек срок их действия".  

## <a name="index-definitions"></a>Определения индексов

Индекс задает поля в документе, атрибуты, и другие компоненты, которые определяют процедуру поиска. В следующем примере создается простой индекс, использующий [Создание индекса (REST API)](/rest/api/searchservice/create-index). 

```http
POST https://[service name].search.windows.net/indexes?api-version=2020-06-30
Content-Type: application/json
api-key: [admin key]

{
      "name" : "my-target-index",
      "fields": [
        { "name": "id", "type": "Edm.String", "key": true, "searchable": false },
        { "name": "content", "type": "Edm.String", "searchable": true, "filterable": false, "sortable": false, "facetable": false }
      ]
}
```

Для определения индекса необходимо, чтобы одно поле в `"fields"` коллекции действовало как ключ документа. Определения индексов также должны включать поля для содержимого и метаданных.

**`content`** Поле используется для хранения текста, извлеченного из больших двоичных объектов. Определение этого поля может выглядеть примерно так, как показано выше. Использовать это имя не обязательно, но это позволяет использовать преимущества неявных сопоставлений полей. Индексатор больших двоичных объектов может отправить содержимое большого двоичного объекта в EDM. поле строки в индексе, а сопоставления полей не требуются.

Можно также добавить поля для любых метаданных BLOB-объектов, которые необходимо включить в индекс. Индексатор может считывать пользовательские свойства метаданных, стандартные свойства [метаданных](#indexing-blob-metadata) и свойства метаданных, [относящиеся к содержимому](search-blob-metadata-properties.md) . Дополнительные сведения о индексах см. [в разделе Создание индекса](search-what-is-an-index.md).

<a name="DocumentKeys"></a>

### <a name="defining-document-keys-and-field-mappings"></a>Определение ключей документа и сопоставлений полей

В индексе поиска ключ документа однозначно определяет каждый документ. Выбранное поле должно иметь тип `Edm.String` . Для содержимого больших двоичных объектов Лучшие кандидаты на ключ документа являются свойствами метаданных в большом двоичном объекте.

+ **`metadata_storage_name`** — Это свойство является кандидатом, но только в том случае, если имена уникальны для всех контейнеров и индексируемых папок. Независимо от расположения больших двоичных объектов, конечный результат заключается в том, что ключ документа (имя) должен быть уникальным в индексе поиска после индексирования всего содержимого. 

  Еще одна потенциальная ошибка, связанная с именем хранилища, заключается в том, что она может содержать символы, недопустимые для ключей документов, например тире. С помощью `base64Encode` [функции сопоставления полей](search-indexer-field-mappings.md#base64EncodeFunction)можно управлять недопустимыми символами. При этом не забудьте также кодировать ключи документов при передаче их в вызовы API, такие как [документ подстановки (остальное)](/rest/api/searchservice/lookup-document). В .NET для кодирования символов можно использовать [Метод UrlTokenEncode](/dotnet/api/system.web.httpserverutility.urltokenencode) .

+ **`metadata_storage_path`** — Использование полного пути гарантирует уникальность, но путь определенно содержит `/` символы, [недопустимые в ключе документа](/rest/api/searchservice/naming-rules). Как и ранее, функцию можно использовать `base64Encode` [](search-indexer-field-mappings.md#base64EncodeFunction) для кодирования символов.

+ Третьим вариантом является добавление пользовательского свойства метаданных в большие двоичные объекты. Этот параметр требует, чтобы процесс передачи больших двоичных объектов добавил это свойство метаданных ко всем большим двоичным объектам. Так как ключ является обязательным, все большие двоичные объекты, в которых отсутствует значение, не будут индексироваться.

> [!IMPORTANT]
> Если для ключевого поля в индексе нет явного сопоставления, Azure Когнитивный поиск автоматически использует `metadata_storage_path` в качестве ключа, а Base-64 кодирует значения ключей (второй параметр выше).
>

#### <a name="example"></a>Пример

В следующем примере демонстрируется использование `metadata_storage_name` ключа документа. Предположим, что у индекса есть ключевое поле с именем `key` и другое поле с именем `fileSize` для хранения размера документа. [Сопоставления полей](search-indexer-field-mappings.md) в определении индексатора устанавливают связи полей и `metadata_storage_name` имеют [ `base64Encode` функцию сопоставления полей](search-indexer-field-mappings.md#base64EncodeFunction) для управления неподдерживаемыми символами.

```http
PUT https://[service name].search.windows.net/indexers/my-blob-indexer?api-version=2020-06-30
Content-Type: application/json
api-key: [admin key]

{
  "dataSourceName" : "my-blob-datasource ",
  "targetIndexName" : "my-target-index",
  "schedule" : { "interval" : "PT2H" },
  "fieldMappings" : [
    { "sourceFieldName" : "metadata_storage_name", "targetFieldName" : "key", "mappingFunction" : { "name" : "base64Encode" } },
    { "sourceFieldName" : "metadata_storage_size", "targetFieldName" : "fileSize" }
  ]
}
```

#### <a name="how-to-make-an-encoded-field-searchable"></a>Как сделать закодированное поле "с возможностью поиска"

Иногда требуется использовать закодированную версию поля `metadata_storage_path` , например, в качестве ключа, но также требуется, чтобы это поле было доступно для поиска (без кодирования) в индексе поиска. Для поддержки обоих вариантов использования можно выполнить сопоставление `metadata_storage_path` с двумя полями: одно для ключа (с кодировкой), а второе — для поля пути, которое мы можем предположить как «с возможностью поиска» в схеме индекса. В приведенном ниже примере показаны два сопоставления полей для `metadata_storage_path` .

```http
PUT https://[service name].search.windows.net/indexers/blob-indexer?api-version=2020-06-30
Content-Type: application/json
api-key: [admin key]

{
  "dataSourceName" : " blob-datasource ",
  "targetIndexName" : "my-target-index",
  "schedule" : { "interval" : "PT2H" },
  "fieldMappings" : [
    { "sourceFieldName" : "metadata_storage_path", "targetFieldName" : "key", "mappingFunction" : { "name" : "base64Encode" } },
    { "sourceFieldName" : "metadata_storage_path", "targetFieldName" : "path" }
  ]
}
```

<a name="PartsOfBlobToIndex"></a>

## <a name="index-content-and-metadata"></a>Содержимое индекса и метаданные

BLOB-объекты содержат содержимое и метаданные. Вы можете выбрать, какие части большого двоичного объекта необходимо индексировать, с помощью параметра конфигурации `dataToExtract`. Этот параметр может принимать перечисленные ниже значения.

+ `contentAndMetadata` — указывает, что необходимо индексировать все метаданные и текстовое содержимое, извлеченное из большого двоичного объекта. Это значение по умолчанию.

+ `storageMetadata` — указывает, что необходимо индексировать только [стандартные свойства большого двоичного объекта и метаданные, определяемые пользователем](../storage/blobs/storage-blob-container-properties-metadata.md).

+ `allMetadata` — Указывает, что стандартные свойства больших двоичных объектов и [метаданные для найденных типов содержимого](search-blob-metadata-properties.md) извлекаются из содержимого BLOB-объектов и индексируются.

Например, чтобы индексировать только метаданные хранилища, используйте следующую команду:

```http
PUT https://[service name].search.windows.net/indexers/[indexer name]?api-version=2020-06-30
Content-Type: application/json
api-key: [admin key]

{
  ... other parts of indexer definition
  "parameters" : { "configuration" : { "dataToExtract" : "storageMetadata" } }
}
```

<a name="how-azure-search-indexes-blobs"></a>

### <a name="indexing-blob-content"></a>Индексирование содержимого BLOB-объектов

По умолчанию большие двоичные объекты с структурированным содержимым, например JSON или CSV, индексируются как один фрагмент текста. Но если документы JSON или CSV имеют внутреннюю структуру (разделители), можно назначить режимы анализа для создания отдельных поисковых документов для каждой строки или элемента. Дополнительные сведения см. в разделе [индексирование больших двоичных объектов JSON](search-howto-index-json-blobs.md) и [индексирование больших двоичных объектов CSV](search-howto-index-csv-blobs.md).

Составной или внедренный документ (например, ZIP-архив, документ Word с внедренным электронным сообщением Outlook, содержащий вложения) или. MSG-файл с вложениями) также индексируется как один документ. Например, все изображения, извлеченные из вложений. Файл MSG будет возвращен в поле normalized_images.

Текстовое содержимое документа извлекается в строковое поле `content`.

  > [!NOTE]
  > Azure Когнитивный поиск ограничивает объем извлекаемого текста в зависимости от ценовой категории. Текущие [ограничения службы](search-limits-quotas-capacity.md#indexer-limits) — 32 000 символов для уровня Free, 64 000 для Basic, 4 000 000 для standard, 8 000 000 для Standard S2 и 16 000 000 для уровня Standard S3. Предупреждение об усеченных документах отобразится в возвращенном состоянии индексатора.  

<a name="indexing-blob-metadata"></a>

### <a name="indexing-blob-metadata"></a>Индексация метаданных BLOB-объектов

Индексаторы также могут индексировать метаданные больших двоичных объектов. Во-первых, все свойства метаданных, заданные пользователем, можно извлечь буквально. Чтобы получить значения, необходимо определить поле в индексе поиска типа `Edm.String` с тем же именем, что и ключ метаданных большого двоичного объекта. Например, если у большого двоичного объекта есть ключ метаданных `Sensitivity` со значением `High` , необходимо определить поле с именем `Sensitivity` в индексе поиска, которое будет заполнено значением `High` .

Во-вторых, свойства стандартных метаданных BLOB-объекта можно извлечь в указанные ниже поля. Индексатор BLOB-объектов автоматически создает внутренние сопоставления полей для этих свойств метаданных больших двоичных объектов. По-прежнему необходимо добавить поля, в которых будет использоваться определение индекса, но можно опустить Создание сопоставлений полей в индексаторе.

  + **metadata_storage_name** ( `Edm.String` ) — имя файла большого двоичного объекта. Например, для большого двоичного объекта /my-container/my-folder/subfolder/resume.pdf значение этого поля — `resume.pdf`.

  + **metadata_storage_path** ( `Edm.String` ) — полный универсальный код ресурса (URI) большого двоичного объекта, включая учетную запись хранения. Например: `https://myaccount.blob.core.windows.net/my-container/my-folder/subfolder/resume.pdf`

  + **metadata_storage_content_type** ( `Edm.String` ) — тип содержимого, указанный в коде, который использовался для отправки большого двоичного объекта. Например, `application/octet-stream`.

  + **metadata_storage_last_modified** ( `Edm.DateTimeOffset` ) — метка времени последнего изменения для большого двоичного объекта. Когнитивный поиск Azure использует эту метку времени для обнаружения измененных больших двоичных объектов, чтобы избежать повторного индексирования всех объектов после первоначального индексирования.

  + **metadata_storage_size** ( `Edm.Int64` ) — размер большого двоичного объекта в байтах.

  + **metadata_storage_content_md5** ( `Edm.String` ) — хэш MD5 содержимого большого двоичного объекта, если он доступен.

  + **metadata_storage_sas_token** ( `Edm.String` ) — временный маркер SAS, который может использоваться [пользовательскими навыками](cognitive-search-custom-skill-interface.md) для получения доступа к большому двоичному объекту. Этот токен не должен храниться для дальнейшего использования, так как срок его действия может истечь.

Наконец, все свойства метаданных, относящиеся к формату документа больших двоичных объектов, которые вы индексируете, также можно представить в схеме индекса. Дополнительные сведения о метаданных, связанных с содержимым, см. в разделе [Свойства метаданных содержимого](search-blob-metadata-properties.md).

Важно отметить, что не нужно определять поля для всех указанных выше свойств в индексе поиска. просто запишите свойства, необходимые для приложения.

<a name="WhichBlobsAreIndexed"></a>

## <a name="how-to-control-which-blobs-are-indexed"></a>Как управлять индексацией больших двоичных объектов

Вы можете управлять тем, какие большие двоичные объекты индексируются, а какие — нет, по типу файлов больших двоичных объектов или задав свойства самого большого двоичного объекта, что приводит к тому, что индексатор пропускает их.

### <a name="include-specific-file-extensions"></a>Включить определенные расширения файлов

Используйте `indexedFileNameExtensions` , чтобы предоставить разделенный запятыми список расширений файлов для индексирования (с начальной точкой). Например, чтобы индексировать только большие двоичные объекты PDF и DOCX, выполните следующую команду:

```http
PUT https://[service name].search.windows.net/indexers/[indexer name]?api-version=2020-06-30
Content-Type: application/json
api-key: [admin key]

{
  ... other parts of indexer definition
  "parameters" : { "configuration" : { "indexedFileNameExtensions" : ".pdf,.docx" } }
}
```

### <a name="exclude-specific-file-extensions"></a>Исключить определенные расширения файлов

Используйте `excludedFileNameExtensions` , чтобы предоставить разделенный запятыми список расширений файлов, которые нужно пропустить (опять же, с помощью начальной точки). Например, для индексации всех больших двоичных объектов, кроме объектов с расширениями PNG и JPEG, выполните следующую команду:

```http
PUT https://[service name].search.windows.net/indexers/[indexer name]?api-version=2020-06-30
Content-Type: application/json
api-key: [admin key]

{
  ... other parts of indexer definition
  "parameters" : { "configuration" : { "excludedFileNameExtensions" : ".png,.jpeg" } }
}
```

Если оба `indexedFileNameExtensions` параметра и указаны `excludedFileNameExtensions` , индексатор сначала просматривает `indexedFileNameExtensions` , а затем по адресу `excludedFileNameExtensions` . Если одно и то же расширение файла содержится в обоих списках, оно будет исключено из индексирования.

### <a name="add-skip-metadata-the-blob"></a>Добавить метаданные "Skip" для большого двоичного объекта

Параметры конфигурации индексатора применяются ко всем BLOB-объектам в контейнере или папке. Иногда требуется управлять индексацией *отдельных больших двоичных объектов* . Это можно сделать, добавив следующие свойства и значения метаданных в большие двоичные объекты в хранилище BLOB-объектов. Когда индексатор встречает эти свойства, он будет пропускать большой двоичный объект или его содержимое в ходе выполнения индексирования.

| Имя свойства | Значение свойства | Описание |
| ------------- | -------------- | ----------- |
| `AzureSearch_Skip` |`"true"` |Указывает индексатору больших двоичных объектов пропустить весь большой двоичный объект. Не извлекаются ни метаданные, ни содержимое. Это полезно, когда обработка определенного большого двоичного объекта постоянно завершается сбоем и индексирование прерывается. |
| `AzureSearch_SkipContent` |`"true"` |Это эквивалент параметра `"dataToExtract" : "allMetadata"`, описанного [выше](#PartsOfBlobToIndex), относящегося к определенному большому двоичному объекту. |

## <a name="index-large-datasets"></a>Индексирование больших наборов данных

Индексирование больших двоичных объектов может занимать много времени. В случаях, когда вы используете миллионы больших двоичных объектов для индексирования, вы можете ускорить индексирование, разбейте данные на разделы и используя несколько индексаторов для [параллельной обработки данных](search-howto-large-index.md#parallel-indexing). Вот как это можно сделать.

+ Секционируйте данные в несколько контейнеров больших двоичных объектов или виртуальных папок.

+ Настройте несколько источников данных, по одному на контейнер или папку. Чтобы указать папку большого двоичного объекта, используйте параметр `query`:

    ```json
    {
        "name" : "blob-datasource",
        "type" : "azureblob",
        "credentials" : { "connectionString" : "<your storage connection string>" },
        "container" : { "name" : "my-container", "query" : "my-folder" }
    }
    ```

+ Создайте соответствующий индексатор для каждого источника данных. Все индексаторы должны указывать на один и тот же целевой индекс поиска.  

+ Одна единица поиска в службе в определенный момент времени может запустить один индексатор. Создание нескольких индексаторов, как описано выше, полезно только при их фактическом параллельном выполнении.

  Для параллельного выполнения нескольких индексаторов следует увеличить масштаб службы поиска, создав достаточное число секций и реплик. Например, если служба поиска содержит 6 единиц поиска (скажем, 2 секции x 3 реплики), то параллельно могут выполняться 6 индексаторов. Это позволяет достичь шестикратного увеличения пропускной способности индексации. Дополнительные сведения о масштабировании и планировании емкости см. в статье [Настройка емкости службы когнитивный Поиск Azure](search-capacity-planning.md).

<a name="DealingWithErrors"></a>

## <a name="handling-errors"></a>Обработка ошибок

Ошибки, которые обычно возникают во время индексирования, включают неподдерживаемые типы содержимого, отсутствующие содержимое или большие двоичные объекты с большими размерами.

По умолчанию индексатор больших двоичных объектов останавливается, как только обнаружит большой двоичный объект с неподдерживаемым типом содержимого (например, изображение). Можно использовать параметр, `excludedFileNameExtensions` чтобы пропустить определенные типы содержимого. Однако может потребоваться выполнить индексирование, чтобы продолжать работу даже при возникновении ошибок, а затем отлаживать отдельные документы позже. Дополнительные сведения об ошибках индексатора см. в разделе [Устранение распространенных проблем с индексатором](search-indexer-troubleshooting.md) и [ошибок индексатора и предупреждений](cognitive-search-common-errors-warnings.md).

### <a name="respond-to-errors"></a>Реагирование на ошибки

Существует четыре свойства индексатора, которые управляют откликом индексатора при возникновении ошибок. В следующих примерах показано, как задать эти свойства в определении индексатора. Если индексатор уже существует, можно добавить эти свойства, отредактировав определение на портале.

#### <a name="maxfaileditems-and-maxfaileditemsperbatch"></a>`"maxFailedItems"` и `"maxFailedItemsPerBatch"`

Продолжать индексирование, если ошибки возникают в любой точке обработки, во время синтаксического анализа больших двоичных объектов или при добавлении документов в индекс. Задайте для этих свойств количество допустимых сбоев. Значение разрешает обработку независимо от того, сколько `-1` ошибок произошло. В противном случае значение является положительным целым числом.

```http
PUT https://[service name].search.windows.net/indexers/[indexer name]?api-version=2020-06-30
Content-Type: application/json
api-key: [admin key]

{
  ... other parts of indexer definition
  "parameters" : { "maxFailedItems" : 10, "maxFailedItemsPerBatch" : 10 }
}
```

#### <a name="failonunsupportedcontenttype-and-failonunprocessabledocument"></a>`"failOnUnsupportedContentType"` и `"failOnUnprocessableDocument"` 

Для некоторых больших двоичных объектов Когнитивный поиск Azure не может определить тип содержимого или обработать документ с типом содержимого, поддерживаемым другим способом. Чтобы пропустить эти условия сбоя, задайте для параметров конфигурации значение `false` :

```http
PUT https://[service name].search.windows.net/indexers/[indexer name]?api-version=2020-06-30
Content-Type: application/json
api-key: [admin key]

{
  ... other parts of indexer definition
  "parameters" : { "configuration" : { "failOnUnsupportedContentType" : false, "failOnUnprocessableDocument" : false } }
}
```

### <a name="relax-indexer-constraints"></a>Смягчить ограничения индексатора

Можно также задать [Свойства конфигурации большого двоичного объекта](/rest/api/searchservice/create-indexer#blob-configuration-parameters) , которые эффективно определяют, существует ли условие ошибки. Следующее свойство может ослабить ограничения, подавление ошибок, которые могли бы произойти в противном случае.

+ `"indexStorageMetadataOnlyForOversizedDocuments"` для индексирования метаданных хранилища для содержимого большого двоичного объекта, которое слишком велико для обработки. Большие двоичные объекты слишком большого размера по умолчанию считаются ошибками. Ограничения на размер большого двоичного объекта см. в разделе [ограничения службы](search-limits-quotas-capacity.md).

## <a name="see-also"></a>См. также раздел

+ [Indexers in Azure Cognitive Search](search-indexer-overview.md) (Индексаторы в службе "Когнитивный поиск Azure")
+ [Создание индексатора](search-howto-create-indexers.md)
+ [Обзор искусственного интеллекта для больших двоичных объектов](search-blob-ai-integration.md)
+ [Обзор поиска по большим двоичным объектам](search-blob-storage-integration.md)