---
title: Устранение неполадок фильтров коллекции OData
titleSuffix: Azure Cognitive Search
description: Узнайте о подходах к устранению ошибок фильтров коллекции OData в запросах Когнитивный поиск Azure.
manager: nitinme
author: brjohnstmsft
ms.author: brjohnst
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 11/04/2019
translation.priority.mt:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pt-br
- ru-ru
- zh-cn
- zh-tw
ms.openlocfilehash: 3050f701c11773207aa6054d4d08d908d87b2ce7
ms.sourcegitcommit: 772eb9c6684dd4864e0ba507945a83e48b8c16f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "88932072"
---
# <a name="troubleshooting-odata-collection-filters-in-azure-cognitive-search"></a>Устранение неполадок фильтров коллекции OData в Azure Когнитивный поиск

Для [фильтрации](query-odata-filter-orderby-syntax.md) по полям коллекции в когнитивный Поиск Azure можно использовать [ `any` `all` операторы и](search-query-odata-collection-operators.md) вместе с **лямбда-выражениями**. Лямбда-выражение — это вложенный фильтр, применяемый к каждому элементу коллекции.

Не все функции выражений фильтров доступны внутри лямбда-выражения. Доступные функции различаются в зависимости от типа данных поля коллекции, которое необходимо отфильтровать. Это может привести к ошибке при попытке использовать функцию в лямбда-выражении, которое не поддерживается в этом контексте. Если при попытке записи сложного фильтра по полям коллекции возникают такие ошибки, эта статья поможет вам устранить проблему.

## <a name="common-collection-filter-errors"></a>Распространенные ошибки фильтра коллекции

В следующей таблице перечислены ошибки, которые могут возникнуть при попытке выполнить фильтр коллекции. Эти ошибки возникают при использовании функции выражений фильтров, которые не поддерживаются внутри лямбда-выражения. Каждая ошибка дает некоторые рекомендации о том, как можно переписать фильтр, чтобы избежать ошибки. В таблице также содержится ссылка на соответствующий раздел этой статьи, где содержатся дополнительные сведения о том, как избежать этой ошибки.

| Сообщение об ошибке | Ситуация | Дополнительные сведения см. в разделе |
| --- | --- | --- |
| Функция "несоответствие" не имеет параметров, привязанных к переменной диапазона ". Внутри лямбда-выражений ("Any" или "ALL") поддерживаются только ссылки на связанные поля. Измените фильтр так, чтобы функция "не совпала" находилась за пределами лямбда-выражения, и повторите попытку. | Использование `search.ismatch` или `search.ismatchscoring` в лямбда-выражении | [Правила фильтрации сложных коллекций](#bkmk_complex) |
| Недопустимое лямбда-выражение. Обнаружена проверка на равенство или неравенство в лямбда-выражении, которое выполняет итерацию по полю коллекции типа (EDM. String). Для Any используйте выражения вида "x EQ y" или "search.in (...)". Для "ALL" используйте выражения в форме "x Ne y", "not (x EQ y)" или "not search.in (...)". | Фильтрация по полю типа `Collection(Edm.String)` | [Правила фильтрации коллекций строк](#bkmk_strings) |
| Недопустимое лямбда-выражение. Обнаружена неподдерживаемая форма сложного логического выражения. Для Any используйте выражения, которые имеют вид "or of and", также известный как Дисжунктиве обычная форма. Например: "(a и b) или (c и d)", где a, b, c и d являются подвыражениями сравнения или равенства. Для "ALL" используйте выражения, которые имеют вид "and of or", также известный как был соединительным обычная форма. Например: "(a или b) и (c или d)", где a, b, c и d являются подвыражениями сравнения или неравенства. Примеры выражений сравнения: "x gt 5", "x Le 2". Пример выражения равенства: "x EQ 5". Пример выражения неравенства: "x Ne 5". | Фильтрация по полям типа `Collection(Edm.DateTimeOffset)` , `Collection(Edm.Double)` , `Collection(Edm.Int32)` или `Collection(Edm.Int64)` | [Правила фильтрации сравниваемых коллекций](#bkmk_comparables) |
| Недопустимое лямбда-выражение. Обнаружено неподдерживаемое использование Geo. Distance () или Geo. intersects в лямбда-выражении, которое выполняет итерацию по полю коллекции типа (EDM. GeographyPoint). Для Any убедитесь, что вы сравниваете Geo. Distance () с помощью операторов "lt" или "Le" и убедитесь, что любое использование Geo. intersects () не имеет отрицания. Для "ALL" убедитесь, что вы сравниваете Geo. Distance () с помощью операторов "gt" или "GE" и убедитесь, что любое использование Geo. intersects () имеет отрицание. | Фильтрация по полю типа `Collection(Edm.GeographyPoint)` | [Правила фильтрации GeographyPointных коллекций](#bkmk_geopoints) |
| Недопустимое лямбда-выражение. Сложные логические выражения не поддерживаются в лямбда-выражениях, которые выполняют итерации по полям типа Collection (EDM. GeographyPoint). Для Any необходимо объединить подвыражения с "или"; "and" не поддерживается. Для "ALL" необходимо объединить подвыражения с "и"; "или" не поддерживается. | Фильтрация по полям типа `Collection(Edm.String)` или `Collection(Edm.GeographyPoint)` | [Правила фильтрации коллекций строк](#bkmk_strings) <br/><br/> [Правила фильтрации GeographyPointных коллекций](#bkmk_geopoints) |
| Недопустимое лямбда-выражение. Обнаружен оператор сравнения (один из "lt", "Le", "gt" или "GE"). В лямбда-выражениях, которые просматривают поля коллекции типа (EDM. String), допускаются только операторы равенства. Для Any используйте выражения вида "x EQ y". Для "ALL" используйте выражения в форме "x Ne y" или "not (x EQ y)". | Фильтрация по полю типа `Collection(Edm.String)` | [Правила фильтрации коллекций строк](#bkmk_strings) |

<a name="bkmk_examples"></a>

## <a name="how-to-write-valid-collection-filters"></a>Написание допустимых фильтров коллекции

Правила записи допустимых фильтров коллекции различаются для каждого типа данных. В следующих разделах описываются правила, в которых показаны примеры поддерживаемых функций фильтров, а какие нет:

- [Правила фильтрации коллекций строк](#bkmk_strings)
- [Правила фильтрации логических коллекций](#bkmk_bools)
- [Правила фильтрации GeographyPointных коллекций](#bkmk_geopoints)
- [Правила фильтрации сравниваемых коллекций](#bkmk_comparables)
- [Правила фильтрации сложных коллекций](#bkmk_complex)

<a name="bkmk_strings"></a>

## <a name="rules-for-filtering-string-collections"></a>Правила фильтрации коллекций строк

В лямбда-выражениях для коллекций строк можно использовать только операторы сравнения `eq` и `ne` .

> [!NOTE]
> Когнитивный Поиск Azure не поддерживает `lt` / `le` / `gt` / `ge` операторы для строк, как внутри, так и за пределами лямбда-выражения.

Текст `any` может проверяться на равенство только в том случае, если текст `all` может проверяться на неравенство.

Можно также объединить несколько выражений `or` , используя в теле `any` , и через `and` в теле `all` . Поскольку `search.in` функция эквивалентна объединению проверок равенства с `or` , она также разрешена в теле `any` . И наоборот, `not search.in` допускается в теле `all` .

Например, следующие выражения разрешены:

- `tags/any(t: t eq 'books')`
- `tags/any(t: search.in(t, 'books, games, toys'))`
- `tags/all(t: t ne 'books')`
- `tags/all(t: not (t eq 'books'))`
- `tags/all(t: not search.in(t, 'books, games, toys'))`
- `tags/any(t: t eq 'books' or t eq 'games')`
- `tags/all(t: t ne 'books' and not (t eq 'games'))`

Хотя эти выражения не допускаются:

- `tags/any(t: t ne 'books')`
- `tags/any(t: not search.in(t, 'books, games, toys'))`
- `tags/all(t: t eq 'books')`
- `tags/all(t: search.in(t, 'books, games, toys'))`
- `tags/any(t: t eq 'books' and t ne 'games')`
- `tags/all(t: t ne 'books' or not (t eq 'games'))`

<a name="bkmk_bools"></a>

## <a name="rules-for-filtering-boolean-collections"></a>Правила фильтрации логических коллекций

Тип `Edm.Boolean` поддерживает только `eq` `ne` операторы и. Таким образом, не имеет смысла разрешать сочетание таких предложений, которые проверяют ту же переменную диапазона, с `and` / `or` момента, когда это всегда приведет к таутологиес или противоречию.

Ниже приведены некоторые примеры фильтров для логических коллекций, которые разрешены:

- `flags/any(f: f)`
- `flags/all(f: f)`
- `flags/any(f: f eq true)`
- `flags/any(f: f ne true)`
- `flags/all(f: not f)`
- `flags/all(f: not (f eq true))`

В отличие от коллекций строк, логические коллекции не имеют ограничений на то, какой оператор можно использовать в лямбда-выражении. `eq`И, и `ne` могут использоваться в теле `any` или `all` .

Следующие выражения не допускаются для логических коллекций:

- `flags/any(f: f or not f)`
- `flags/any(f: f or f)`
- `flags/all(f: f and not f)`
- `flags/all(f: f and f eq true)`

<a name="bkmk_geopoints"></a>

## <a name="rules-for-filtering-geographypoint-collections"></a>Правила фильтрации GeographyPointных коллекций

Значения типа `Edm.GeographyPoint` в коллекции не могут сравниваться напрямую друг с другом. Вместо этого они должны использоваться в качестве параметров `geo.distance` `geo.intersects` функций и. `geo.distance`Функция, в свою очередь, должна сравниваться со значением расстояния с помощью одного из операторов сравнения `lt` ,, `le` `gt` или `ge` . Эти правила также применяются к полям EDM. GeographyPoint, не относящимся к коллекции.

Как и коллекции строк, `Edm.GeographyPoint` коллекции имеют некоторые правила для использования геопространственных функций и объединения в различных типах лямбда-выражений.

- Операторы сравнения, которые можно использовать с `geo.distance` функцией, зависят от типа лямбда-выражения. Для `any` можно использовать только `lt` или `le` . Для `all` можно использовать только `gt` или `ge` . Можно инвертировать выражения, включающие `geo.distance` , но необходимо изменить оператор сравнения (он `geo.distance(...) lt x` станет `not (geo.distance(...) ge x)` и `geo.distance(...) le x` станет `not (geo.distance(...) gt x)` ).
- В теле `all` `geo.intersects` функции функция должна быть инвертирована. И наоборот, в теле `any` `geo.intersects` функции не следует инвертировать отрицание.
- В тексте `any` геопространственных выражений можно комбинировать с помощью `or` . В тексте `all` такие выражения можно комбинировать с помощью `and` .

Указанные выше ограничения существуют по тем же причинам, что и ограничения на равенство и неравенство в коллекциях строк. Более подробные сведения по этим причинам см. в статье [Знакомство с фильтрами коллекции OData в когнитивный Поиск Azure](search-query-understand-collection-filters.md) .

Ниже приведены некоторые примеры фильтров для `Edm.GeographyPoint` коллекций, которые разрешены:

- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') lt 10)`
- `locations/any(l: not (geo.distance(l, geography'POINT(-122 49)') ge 10) or geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') ge 10 and not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`

Следующие выражения не разрешены для `Edm.GeographyPoint` коллекций:

- `locations/any(l: l eq geography'POINT(-122 49)')`
- `locations/any(l: not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') gt 10)`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') lt 10)`
- `locations/any(l: geo.distance(l, geography'POINT(-122 49)') lt 10 and geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`
- `locations/all(l: geo.distance(l, geography'POINT(-122 49)') le 10 or not geo.intersects(l, geography'POLYGON((-122.031577 47.578581, -122.031577 47.678581, -122.131577 47.678581, -122.031577 47.578581))'))`

<a name="bkmk_comparables"></a>

## <a name="rules-for-filtering-comparable-collections"></a>Правила фильтрации сравниваемых коллекций

Этот раздел относится ко всем следующим типам данных:

- `Collection(Edm.DateTimeOffset)`
- `Collection(Edm.Double)`
- `Collection(Edm.Int32)`
- `Collection(Edm.Int64)`

Типы, такие как `Edm.Int32` и, `Edm.DateTimeOffset` поддерживают все шесть операторов сравнения: `eq` , `ne` , `lt` , `le` , `gt` и `ge` . Лямбда-выражения над коллекциями этих типов могут содержать простые выражения, использующие любой из этих операторов. Это относится и к `any` , и к `all` . Например, эти фильтры разрешены:

- `ratings/any(r: r ne 5)`
- `dates/any(d: d gt 2017-08-24T00:00:00Z)`
- `not margins/all(m: m eq 3.5)`

Однако существуют ограничения на то, как такие выражения сравнения могут быть объединены в более сложные выражения в лямбда-выражении:

- Правила для `any` :
  - Простые выражения неравенства не могут быть полезны вместе с другими выражениями. Например, это выражение разрешено:
    - `ratings/any(r: r ne 5)`

    но это выражение не так:
    - `ratings/any(r: r ne 5 and r gt 2)`

    и хотя это выражение разрешено, оно не полезно, поскольку условия перекрываются:
    - `ratings/any(r: r ne 5 or r gt 7)`
  - Простые выражения сравнения, включающие,,, `eq` `lt` или, `le` `gt` `ge` могут сочетаться с `and` / `or` . Пример:
    - `ratings/any(r: r gt 2 and r le 5)`
    - `ratings/any(r: r le 5 or r gt 7)`
  - Выражения сравнения, Объединенные с `and` (объединения), можно объединять с помощью `or` . Эта форма известна в логической логике как "[Дисжунктиве обычная форма](https://en.wikipedia.org/wiki/Disjunctive_normal_form)" (ДНФ). Пример:
    - `ratings/any(r: (r gt 2 and r le 5) or (r gt 7 and r lt 10))`
- Правила для `all` :
  - Простые выражения равенства не могут быть полезны вместе с другими выражениями. Например, это выражение разрешено:
    - `ratings/all(r: r eq 5)`

    но это выражение не так:
    - `ratings/all(r: r eq 5 or r le 2)`

    и хотя это выражение разрешено, оно не полезно, поскольку условия перекрываются:
    - `ratings/all(r: r eq 5 and r le 7)`
  - Простые выражения сравнения, включающие,,, `ne` `lt` или, `le` `gt` `ge` могут сочетаться с `and` / `or` . Пример:
    - `ratings/all(r: r gt 2 and r le 5)`
    - `ratings/all(r: r le 5 or r gt 7)`
  - Выражения сравнения в сочетании с `or` (дизъюнкции) можно объединять с помощью `and` . Эта форма известна в логической логике как "[был соединительным обычная форма](https://en.wikipedia.org/wiki/Conjunctive_normal_form)" (cnf). Пример:
    - `ratings/all(r: (r le 2 or gt 5) and (r lt 7 or r ge 10))`

<a name="bkmk_complex"></a>

## <a name="rules-for-filtering-complex-collections"></a>Правила фильтрации сложных коллекций

Лямбда-выражения над сложными коллекциями поддерживают гораздо более гибкий синтаксис, чем лямбда-выражения над коллекциями примитивных типов. В таком лямбда-выражении можно использовать любую конструкцию фильтра, которую можно использовать за пределами, за исключением двух исключений.

Сначала функции `search.ismatch` и `search.ismatchscoring` не поддерживаются внутри лямбда-выражений. Дополнительные сведения см. [в разделе Основные сведения о фильтрах коллекции OData в когнитивный Поиск Azure](search-query-understand-collection-filters.md).

Во-вторых, не допускаются ссылки на поля, которые не *привязаны* к переменной диапазона (так называемые *свободные переменные*). Например, рассмотрим следующие два эквивалентных выражения фильтра OData:

1. `stores/any(s: s/amenities/any(a: a eq 'parking')) and details/margin gt 0.5`
1. `stores/any(s: s/amenities/any(a: a eq 'parking' and details/margin gt 0.5))`

Первое выражение будет разрешено, а вторая форма будет отклонена, так как `details/margin` не привязана к переменной диапазона `s` .

Это правило также распространяется на выражения, которые имеют переменные, привязанные во внешней области. Такие переменные свободны по отношению к области, в которой они отображаются. Например, первое выражение разрешено, а второе эквивалентное выражение не допускается, так как `s/name` является свободным по отношению к области переменной диапазона `a` :

1. `stores/any(s: s/amenities/any(a: a eq 'parking') and s/name ne 'Flagship')`
1. `stores/any(s: s/amenities/any(a: a eq 'parking' and s/name ne 'Flagship'))`

Это ограничение не должно быть проблемой на практике, поскольку всегда можно создавать фильтры таким, чтобы лямбда-выражения содержали только привязанные переменные.

## <a name="cheat-sheet-for-collection-filter-rules"></a>Лист Памятка по для правил фильтра коллекции

В следующей таблице перечислены правила построения допустимых фильтров для каждого типа данных коллекции.

[!INCLUDE [Limitations on OData lambda expressions in Azure Cognitive Search](../../includes/search-query-odata-lambda-limitations.md)]

Примеры создания допустимых фильтров для каждого варианта см. [в разделе как записать допустимые фильтры коллекции](#bkmk_examples).

Если вы часто пишете фильтры и понимаете, что правила из первых принципов могли бы помочь вам больше, чем просто запомнить их, см. раздел [Общие сведения о фильтрах коллекции OData в когнитивный Поиск Azure](search-query-understand-collection-filters.md).

## <a name="next-steps"></a>Дальнейшие действия  

- [Основные сведения о фильтрах коллекции OData в Azure Когнитивный поиск](search-query-understand-collection-filters.md)
- [Фильтры в Когнитивный поиск Azure](search-filters.md)
- [Общие сведения о языке выражений OData для Azure Когнитивный поиск](query-odata-filter-orderby-syntax.md)
- [Справочник по синтаксису выражений OData для Azure Когнитивный поиск](search-query-odata-syntax-reference.md)
- [Поиск документов &#40;Azure Когнитивный поиск REST API&#41;](/rest/api/searchservice/Search-Documents)