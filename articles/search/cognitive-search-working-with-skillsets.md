---
title: Основные понятия и рабочий процесс для набора навыков
titleSuffix: Azure Cognitive Search
description: Наборы навыков используются для создания конвейера обогащения с помощью искусственного интеллекта в Когнитивном поиске Azure. Изучите важные понятия и сведения о составлении набора навыков.
manager: nitinme
author: vkurpad
ms.author: vikurpad
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 06/15/2020
ms.openlocfilehash: b5a893ee1923ba4b2bec53b20fb164337bd65902
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "96558119"
---
# <a name="skillset-concepts-in-azure-cognitive-search"></a>Концепции набора навыков в Azure Когнитивный поиск

Эта статья предназначена для разработчиков, которым требуется более глубокое понимание концепций и принципов составления навыков, и предполагается знание процесса обогащения искусственного интеллекта. Если вы не знакомы с этой концепцией, начните с [обогащения искусственного интеллекта в Azure когнитивный Поиск](cognitive-search-concept-intro.md).

## <a name="introducing-skillsets"></a>Знакомство с навыков

Набор навыков — это многократно используемый ресурс в Azure Когнитивный поиск, который прикрепляется к индексатору и указывает набор навыков, используемых для анализа, преобразования и дополнения содержимого текста или изображения во время индексирования. Навыки имеют входные и выходные данные, и часто выходные данные одного навыка становятся входными данными другого в цепочке или последовательности процессов.

Набор навыков имеет три основных свойства:

+ `skills`, неупорядоченная коллекция навыков, для которой платформа определяет последовательность выполнения на основе входных данных, необходимых для каждого навыка.
+ `cognitiveServices`— ключ ресурса Cognitive Services, который выполняет обработку изображений и текста для навыков, включая встроенные навыки.
+ `knowledgeStore`(необязательно) учетная запись хранения Azure, в которой будут проецированы ваши документы. Расширенные документы также используются индексами поиска.

Наборы навыков создаются в формате JSON. Ниже приведен пример незначительной упрощенной версии набора [навыков рецензирования](https://github.com/Azure-Samples/azure-search-sample-data/blob/master/hotelreviews/HotelReviews_skillset.json), который используется для иллюстрации концепций, описанных в этой статье. 

Ниже показаны первые два опыта.

+ Навык #1 — это [навык разбиения текста](cognitive-search-skill-textsplit.md) , который принимает содержимое поля "reviews_text" в качестве входных данных и разбивает содержимое на "Pages" из 5000 символов в качестве выходных данных.
+ Навык #2 — это [навык обнаружения тональности](cognitive-search-skill-sentiment.md) , принимающий "страницы" в качестве входных данных, и создает новое поле с именем "тональности" в качестве выходных данных, которое содержит результаты анализа тональности.


```json
{
    "skills": [
        {
            "@odata.type": "#Microsoft.Skills.Text.SplitSkill",
            "name": "#1",
            "description": null,
            "context": "/document/reviews_text",
            "defaultLanguageCode": "en",
            "textSplitMode": "pages",
            "maximumPageLength": 5000,
            "inputs": [
                {
                    "name": "text",
                    "source": "/document/reviews_text"
                }
            ],
            "outputs": [
                {
                    "name": "textItems",
                    "targetName": "pages"
                }
            ]
        },
        {
            "@odata.type": "#Microsoft.Skills.Text.SentimentSkill",
            "name": "#2",
            "description": null,
            "context": "/document/reviews_text/pages/*",
            "defaultLanguageCode": "en",
            "inputs": [
                {
                    "name": "text",
                    "source": "/document/reviews_text/pages/*",
                }
            ],
            "outputs": [
                {
                    "name": "score",
                    "targetName": "Sentiment"
                }
            ]
        },
  "cognitiveServices": null,
  "knowledgeStore": {  }
}
```
> [!NOTE]
> Вы можете создавать сложные навыков с помощью циклов и ветвления, используя [Условный навык](cognitive-search-skill-conditional.md) для создания выражений. Синтаксис основан на нотации пути к [указателю JSON](https://tools.ietf.org/html/rfc6901) и состоит из нескольких изменений для обозначения узлов в дереве обогащения. Оператор `"/"` позволяет опуститься в дереве на уровень ниже, а `"*"` выступает в качестве оператора for-each в контексте. Многочисленные примеры в этой статье иллюстрируют синтаксис. 

### <a name="enrichment-tree"></a>Дерево обогащения

В ходе выполнения [действий в конвейере обогащения](cognitive-search-concept-intro.md#enrichment-steps)содержимое обрабатывается на этапе *взлома документа* , где текст и изображения извлекаются из источника. Затем содержимое изображения может маршрутизироваться к навыкам, определяющим обработку изображений, а текстовое содержимое помещается в очередь для обработки текста. Для исходных документов, содержащих большие объемы текста, можно установить *режим анализа* в индексаторе, чтобы сегментировать текст на небольшие фрагменты для более оптимальной обработки. 

![Хранилище знаний на схеме конвейера](./media/knowledge-store-concept-intro/knowledge-store-concept-intro.svg "Хранилище знаний на схеме конвейера")

После прохождения конвейера обогащения документ представляется в виде дерева содержимого и связанных результатов обогащения. Экземпляр этого дерева создается в результате распознавания документа.  Формат дерева обогащения позволяет конвейеру обогащения прикреплять метаданные к одинаковым примитивным типам данных. Хотя такое дерево и не является допустимым объектом JSON, его можно спроецировать в допустимый формат JSON. В следующей таблице показано состояние документа, поступающего в конвейер обогащения.

|Источник данных и режим анализа|По умолчанию|JSON, строки JSON и CSV|
|---|---|---|
|Хранилище BLOB-объектов|/document/content<br>/document/normalized_images/*<br>…|/document/{key1}<br>/document/{key2}<br>…|
|SQL|/document/{column1}<br>/document/{column2}<br>…|Недоступно |
|Cosmos DB|/document/{key1}<br>/document/{key2}<br>…|Недоступно|

 По мере выполнения навыков они добавляют новые узлы в дерево обогащения. Эти новые узлы затем можно использовать в качестве входных данных для подчиненных навыков, проецирования в хранилище знаний или сопоставления с полями индекса. Результаты обогащения остаются неизменными: узлы нельзя изменять после создания. По мере усложнения набора навыков усложняется и дерево обогащения, но помещать все его узлы в индекс или хранилище знаний не обязательно. 

В них можно выборочно сохранить только подмножество результатов обогащения.

### <a name="context"></a>Контекст

Для каждого навыка требуется контекст. Контекст определяет следующие характеристики.

+ Количество выполнений навыка на основе выбранных узлов. Для значений контекста типа "Коллекция" добавление `/*` в конце приведет к тому, что навык будет вызываться один раз для каждого экземпляра в коллекции. 

+ Место добавления выходных данных навыков в дерево обогащения. Выходные данные всегда добавляются в дерево как дочерние узлы для узла контекста. 

+ Форма входных данных. В случае коллекций с несколькими уровнями установка контекста для родительской коллекции влияет на форму входных данных для навыка. Например, если у вас есть дерево обогащения со списком стран или регионов, каждый из которых содержит список состояний, содержащих список почтовых индексов.

|Контекст|Входные данные|Форма входных данных|Вызов навыка|
|-------|-----|--------------|----------------|
|`/document/countries/*` |`/document/countries/*/states/*/zipcodes/*` |Список всех почтовых индексов в стране или регионе |По одному разу для страны или региона |
|`/document/countries/*/states/*` |'/документ/каунтриес/*/статес/*/зипкодес/* ' ' |Список ZIP-кодов в состоянии | Один раз для каждого сочетания страны или региона и штата, области или края|

## <a name="generate-enriched-data"></a>Создание обогащенных данных 

Используя набор [квалификационных проверок в отеле](https://github.com/Azure-Samples/azure-search-sample-data/blob/master/hotelreviews/HotelReviews_skillset.json) , мы будем рассматривать следующие материалы:

+ Принцип развития дерева обогащения за счет выполнения каждого навыка
+ Как работает контекст и входные данные, чтобы определить, сколько раз выполняется навык
+ Какая форма входных данных основана на контексте

"Документ" в процессе обогащения представляет одну строку (проверку отеля) в файле исходного кода hotel_reviews.csv.

### <a name="skill-1-split-skill"></a>Навык № 1. Навык разделения

Если исходное содержимое состоит из больших фрагментов текста, полезно разбить его на более мелкие компоненты для большей точности определения языка, тональности и ключевых фраз. Доступно два детализации: страницы и предложения. Страница состоит из приблизительно 5000 символов.

Навык разбиения текста, как правило, является первым в наборе навыков.

```json
      "@odata.type": "#Microsoft.Skills.Text.SplitSkill",
      "name": "#1",
      "description": null,
      "context": "/document/reviews_text",
      "defaultLanguageCode": "en",
      "textSplitMode": "pages",
      "maximumPageLength": 5000,
      "inputs": [
        {
          "name": "text",
          "source": "/document/reviews_text"
        }
      ],
      "outputs": [
        {
          "name": "textItems",
          "targetName": "pages"
        }
```

В контексте навыка `"/document/reviews_text"` , навык разделения будет выполняться один раз для `reviews_text` . Выводимый навык — это список, в котором `reviews_text` разбивается на сегменты размером 5000 символов. Выходные данные из навыка разбиения называются `pages` и добавляются в дерево обогащения. Признак `targetName` позволяет переименовать выходные данные навыка перед их добавлением в дерево обогащения.

Дерево обогащения теперь содержит новый узел, находящийся в контексте навыка. Этот узел доступен любому сопоставлению навыков, проекций или выходных полей. По сути, дерево выглядит следующим образом:

![Дерево обогащения после распознавания документа](media/cognitive-search-working-with-skillsets/enrichment-tree-doc-cracking.png "Дерево обогащения после распознавания документа перед выполнением навыков")

Корневой узел для всех результатов обогащения — `"/document"`. При работе с индексаторами больших двоичных объектов узел `"/document"` будет иметь дочерние узлы `"/document/content"` и `"/document/normalized_images"`. При работе с данными в формате CSV (как в этом примере) имена столбцов будут сопоставляться с узлами, расположенными под `"/document"`. 

Чтобы получить доступ к любому из результатов обогащения, добавленных в узел навыком, требуется полный путь для обогащения. Например, если вы хотите использовать текст из узла ```pages``` в качестве входных данных для другого навыка, необходимо указать его как ```"/document/reviews_text/pages/*"```.
 
 ![Дерево обогащения после применения навыка № 1](media/cognitive-search-working-with-skillsets/enrichment-tree-skill1.png "Дерево обогащения после выполнения навыка № 1")

### <a name="skill-2-language-detection"></a>Навык № 2. Определение языка

Документы проверки отеля содержат Отзывы клиентов, выражаются на нескольких языках. Используемый язык определяется навыками определения языка. Затем результат передается в извлечение ключевых фраз и тональности обнаружение, при этом учитывается язык при обнаружении тональности и фраз.

Хотя навык определения языка задан в наборе навыков третьим (навык № 3), он выполняется следующим. Так как он не блокируется, поскольку не требует наличия входных данных, он будет выполняться параллельно с предыдущим навыком. Как и в случае с предыдущим навыком разделения, навык определения языка также вызывается один раз для каждого документа. Дерево обогащения теперь содержит новый узел для языка.

 ![Дерево обогащения после применения навыка № 2](media/cognitive-search-working-with-skillsets/enrichment-tree-skill2.png "Дерево обогащения после выполнения навыка № 2")
 
 ### <a name="skill-3-key-phrases-skill"></a>Навык № 3. Навык ключевых фраз 

При наличии контекста `/document/reviews_text/pages/*` навык ключевых фраз будет вызываться один раз для каждого элемента в коллекции `pages`. Результатом выполнения навыка будет узел под соответствующим элементом page. 

 Теперь вы можете изучить остальные навыки в наборе навыков и представить, как будет расти дерево обогащения с учетом выполнения каждого навыка. Некоторые навыки, например навык слияния и навык определения формы, также создают новые узлы, но используют данные только из имеющихся узлов и не создают абсолютно новые результаты обогащения.

![Дерево обогащения после применения всех навыков](media/cognitive-search-working-with-skillsets/enrichment-tree-final.png "Дерево обогащения после применения всех навыков")

Различные цвета соединителей в показанном выше дереве указывают на то, что результаты обогащения созданы различными навыками, поэтому узлы должны обрабатываться по отдельности. Они не будут входить в состав объекта, возвращаемого при выборе родительского узла.

## <a name="save-enrichments"></a>Сохраняйте дополнения

В Когнитивный поиск Azure индексатор сохраняет создаваемые им выходные данные. Один из выходных данных всегда является [индексом с возможностью поиска](search-what-is-an-index.md). Указание индекса является обязательным условием, а при присоединении набора навыков данные, принимаемые индексом, включают в себя вещество. Обычно выходные данные конкретных навыков, такие как ключевые фразы или тональностиные оценки, принимаются в индекс в поле, созданном для этой цели.

При необходимости индексатор также может отправить выходные данные в [хранилище знаний](knowledge-store-concept-intro.md) для использования в других средствах или процессах. Хранилище знаний определяется как часть набора навыков. Определение определяет, проецируется ли ваш обогащенный документ как таблицы или объекты (файлы или большие двоичные объекты). Табличные проекции хорошо подходят для интерактивного анализа в таких средствах, как Power BI, тогда как файлы и большие двоичные объекты обычно используются в процессе обработки и анализа данных или аналогичных процессов. В этом разделе вы узнаете, как композиция набора навыков может формировать таблицы или объекты, которые требуется проецировать.

### <a name="projections"></a>Проекции

Для содержимого, предназначенного для хранилища знаний, необходимо учитывать структуру содержимого. *Проекция* — это процесс выбора узлов из дерева обогащения и создания физического выражения в хранилище знаний. Проекции представляют собой настраиваемые формы документа (содержимое и результаты обогащения), которые могут выводиться как табличные или объектные проекции. Дополнительные сведения о работе с проекциями см. в статье о [работе с проекциями](knowledge-store-projection-overview.md).

![Параметры сопоставления полей](./media/cognitive-search-working-with-skillsets/field-mapping-options.png "Параметры сопоставления полей для конвейера обогащения")

### <a name="sourcecontext"></a>SourceContext

`sourceContext`Элемент используется только в качестве входных данных и проекций навыков. Применяется для создания многоуровневых вложенных объектов. Возможно, вам потребуется создать новый объект, чтобы передать его в хранилище знаний в качестве входных данных для навыка или проекта. Так как узлы обогащения в дереве обогащения не обязательно являются допустимыми объектами JSON и при ссылке на узел в дереве возвращается только состояние этого узла на момент его создания, при использовании результатов обогащения в качестве входных данных или проекций навыков требуется создать объект JSON с правильным форматом. `sourceContext` позволяет создать иерархический объект анонимного типа. Если использовался только контекст, для этого потребуется несколько навыков. 

`sourceContext`В следующих примерах показано использование функции. Проанализируйте выходные данные навыка, которые создали обогащение, чтобы определить, являются ли они допустимым объектом JSON, а не примитивным типом.

### <a name="slicing-projections"></a>Создание срезов проекций

При определении группы табличных проекций один узел в дереве обогащения может быть разделен на срезы в виде нескольких связанных таблиц. При добавлении таблицы с исходным путем, дочерним по отношению к имеющейся проекции таблицы, полученный дочерний узел не будет дочерним элементом имеющейся проекции таблицы, а будет спроектирован в новую связанную таблицу. Этот метод создания срезов позволяет определить один узел в навыке определения формы, который может служить источником для всех табличных проекций. 

### <a name="shaping-projections"></a>Формирование проекций

Существует два способа определения проекции:

+ Для создания нового узла, который является корневым для всех проектов, для которых выполняется проецирование, используйте навык "текстовый элемент". Затем в проекциях нужно будет просто сослаться на выходные данные навыка определения формы.

+ Используйте встроенную фигурную проекцию в самом определении проекции.

Определение формы требует большей детализации по сравнению со встраиванием, однако такой подход гарантирует, что все изменения дерева обогащения остаются в пределах навыков, а выходные данные представляют собой объект, пригодный для повторного использования. В отличие от этого, встроенная форма позволяет создать необходимую форму, но является анонимным объектом и доступна только для проекции, для которой она определена. Эти подходы можно использовать вместе или отдельно. В наборе навыков, созданном для вас в рабочем процессе портала, используются оба варианта. Навык определения формы используется в нем для табличных проекций, а встроенная форма применяется для проецирования таблицы ключевых фраз.

Чтобы расширить этот пример, можно удалить встроенную форму и использовать навык определения формы для создания нового узла для ключевых фраз. Форму, проецируемую в три таблицы, а именно `hotelReviewsDocument`, `hotelReviewsPages` и `hotelReviewsKeyPhrases`, можно создать двумя способами, описанными в следующих разделах.

#### <a name="shaper-skill-and-projection"></a>Навык определения формы и проекция

> [!Note]
> Некоторые из столбцов таблицы документа были удалены из этого примера для краткости.
>
```json
{
    "@odata.type": "#Microsoft.Skills.Util.ShaperSkill",
    "name": "#5",
    "description": null,
    "context": "/document",
    "inputs": [        
        {
            "name": "reviews_text",
            "source": "/document/reviews_text",
            "sourceContext": null,
            "inputs": []
        },
        {
            "name": "reviews_title",
            "source": "/document/reviews_title",
            "sourceContext": null,
            "inputs": []
        },
        {
            "name": "AzureSearch_DocumentKey",
            "source": "/document/AzureSearch_DocumentKey",
            "sourceContext": null,
            "inputs": []
        },  
        {
            "name": "pages",
            "source": null,
            "sourceContext": "/document/reviews_text/pages/*",
            "inputs": [
                {
                    "name": "SentimentScore",
                    "source": "/document/reviews_text/pages/*/Sentiment",
                    "sourceContext": null,
                    "inputs": []
                },
                {
                    "name": "LanguageCode",
                    "source": "/document/Language",
                    "sourceContext": null,
                    "inputs": []
                },
                {
                    "name": "Page",
                    "source": "/document/reviews_text/pages/*",
                    "sourceContext": null,
                    "inputs": []
                },
                {
                    "name": "keyphrase",
                    "sourceContext": "/document/reviews_text/pages/*/Keyphrases/*",
                    "inputs": [
                        {
                            "source": "/document/reviews_text/pages/*/Keyphrases/*",
                            "name": "Keyphrases"
                        }
                    ]
                }
            ]
        }
    ],
    "outputs": [
        {
            "name": "output",
            "targetName": "tableprojection"
        }
    ]
}
```

Благодаря узлу `tableprojection`, определенному выше в разделе `outputs`, теперь для проецирования частей узла `tableprojection` в различные таблицы можно воспользоваться функцией среза.

> [!Note]
> Это только фрагмент проекции в конфигурации хранилища знаний.
>
```json
"projections": [
    {
        "tables": [
            {
                "tableName": "hotelReviewsDocument",
                "generatedKeyName": "Documentid",
                "source": "/document/tableprojection"
            },
            {
                "tableName": "hotelReviewsPages",
                "generatedKeyName": "Pagesid",
                "source": "/document/tableprojection/pages/*"
            },
            {
                "tableName": "hotelReviewsKeyPhrases",
                "generatedKeyName": "KeyPhrasesid",
                "source": "/document/tableprojection/pages/*/keyphrase/*"
            }
        ]
    }
]
```

#### <a name="inline-shaping-projections"></a>Проекции со встроенной формой

Подход встраивания формы не требует использования навыка определения формы, так как все формы, необходимые для проекций, создаются в тот момент, когда они требуются. При проецировании тех же данных, что и в предыдущем примере, с использованием встраивания в проекцию результат будет выглядеть следующим образом:

```json
"projections": [
    {
        "tables": [
            {
                "tableName": "hotelReviewsInlineDocument",
                "generatedKeyName": "Documentid",
                "sourceContext": "/document",     
                "inputs": [
                    {
                        "name": "reviews_text",
                        "source": "/document/reviews_text"
                    },
                    {
                        "name": "reviews_title",
                        "source": "/document/reviews_title"
                    },
                    {
                        "name": "AzureSearch_DocumentKey",
                        "source": "/document/AzureSearch_DocumentKey"
                    }                             
                ]
            },
            {
                "tableName": "hotelReviewsInlinePages",
                "generatedKeyName": "Pagesid",
                "sourceContext": "/document/reviews_text/pages/*",
                "inputs": [
                        {
                    "name": "SentimentScore",
                    "source": "/document/reviews_text/pages/*/Sentiment"
                    },
                    {
                        "name": "LanguageCode",
                        "source": "/document/Language"
                    },
                    {
                        "name": "Page",
                        "source": "/document/reviews_text/pages/*"
                    }
                ]
            },
            {
                "tableName": "hotelReviewsInlineKeyPhrases",
                "generatedKeyName": "KeyPhraseId",
                "sourceContext": "/document/reviews_text/pages/*/Keyphrases/*",
                "inputs": [
                    {
                        "name": "Keyphrases",
                        "source": "/document/reviews_text/pages/*/Keyphrases/*"
                    }
                ]
            }
        ]
    }
]
```
  
Отличительной особенностью обоих этих подходов является то, как значения `"Keyphrases"` проецируются с использованием `"sourceContext"`. Узел `"Keyphrases"`, содержащий коллекцию строк, сам по себе является дочерним по отношению к тексту в объекте page. Однако, поскольку для проекций требуется объект JSON, а page является примитивом (строкой), для заключения ключевой фразы в объект с именованным свойством используется `"sourceContext"`. Этот метод позволяет независимо проектировать даже примитивы.

## <a name="next-steps"></a>Дальнейшие действия

Следующий шаг — создание своего первого набора навыков с помощью когнитивных навыков.

> [!div class="nextstepaction"]
> [Создайте свой первый набор навыков](cognitive-search-defining-skillset.md).
