---
title: Создание индекса поиска
titleSuffix: Azure Cognitive Search
description: Содержит основные понятия и средства индексирования в Когнитивный поиск Azure, включая определения схемы и физическую структуру данных.
manager: nitinme
author: HeidiSteen
ms.author: heidist
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 07/15/2020
ms.openlocfilehash: 3d5663177bb087e936a49dd7289659b684d85860
ms.sourcegitcommit: aacbf77e4e40266e497b6073679642d97d110cda
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/12/2021
ms.locfileid: "98116200"
---
# <a name="create-a-basic-search-index-in-azure-cognitive-search"></a>Создание базового индекса поиска в Azure Когнитивный поиск

В Azure Когнитивный поиск поиск содержимого, используемого для полнотекстового поиска и фильтрованных запросов, сохраняется в *индексе поиска* . Индекс определяется схемой и сохраняется в службе, при этом импорт данных производится на втором шаге. 

Индексы содержат *документы*. Документ представляет собой единый блок доступных для поиска данных в индексе. У розничного продавца может быть документ для каждого продукта, Организация новостей может иметь документ для каждой статьи и т. д. Сопоставление этих концепций с более привычными эквивалентами баз данных: *индекс поиска* эквивалентен *таблице*, а *документы* примерно эквивалентны *строкам* в таблице.

Физическая структура индекса определяется схемой с полями, помеченными как "с возможностью поиска", что приводит к созданию инвертированного индекса, созданного для этого поля. 

Вы можете создать индекс со следующими инструментами и API:

* В портал Azure используйте мастер **добавления индекса** или **импорта данных** .
* Использование [создания индекса (REST API)](/rest/api/searchservice/create-index)
* Использование [пакета SDK для .NET](./search-get-started-dotnet.md)

Это проще изучить с помощью средства портала. Портал применяет требования и правила схемы для конкретных типов данных, например запрещает возможность полнотекстового поиска по числовым полям. Когда у вас есть рабочий индекс, можно перейти к коду, извлекая определение JSON из службы с помощью функции [получить индекс (REST API)](/rest/api/searchservice/get-index) и добавив его в решение.

## <a name="recommended-workflow"></a>Рекомендуемый рабочий процесс

Поступающий на окончательный проект индекса является итеративным процессом. Проще всего начать с портала, чтобы создать исходный индекс, а затем переключиться на код, чтобы поместить индекс в систему управления версиями.

1. Определите, можно ли использовать [**Импорт данных**](search-import-data-portal.md). Мастер выполняет индексирование на основе индексатора "все в одном", если исходные данные из [поддерживаемого типа источника данных в Azure](search-indexer-overview.md#supported-data-sources).

1. Если вы не можете использовать **Импорт данных**, начните с **добавления индекса** , чтобы определить схему.

   ![Команда "добавить индекс"](media/search-what-is-an-index/add-index.png "Команда "добавить индекс"")

1. Укажите имя и ключ, используемые для уникальной идентификации каждого документа поиска в индексе. Ключ является обязательным и должен иметь тип EDM. String. Во время импорта следует запланировать сопоставление уникального поля в источнике данных с этим полем. 

   Портал предоставляет `id` поле для ключа. Чтобы переопределить значение по умолчанию `id` , создайте новое поле (например, новое определение поля с именем `HotelId` ), а затем выберите его в **разделе ключ**.

   ![Заполнить обязательные свойства](media/search-what-is-an-index//field-attributes.png "Заполнить обязательные свойства")

1. Добавьте дополнительные поля. На портале отображаются [атрибуты полей](#index-attributes) , доступные для различных типов данных. Это удобно, если вы впервые проектируете индекс.

   Если входящие данные являются иерархическими, назначьте тип данных [сложного типа](search-howto-complex-data-types.md) для представления вложенных структур. Встроенный набор данных в гостиницах иллюстрирует сложные типы с использованием адреса (содержит несколько вложенных полей), которые имеют связь "один к одному" с каждым Гостиницы, и сложную коллекцию комнат, в которой несколько комнат связаны с каждым гостиницы. 

1. Перед созданием индекса назначьте все [анализаторы](#analyzers) строковым полям. Сделайте то же самое для [предложений](#suggesters) , если хотите включить автозаполнение для конкретных полей.

1. Нажмите кнопку **создать** , чтобы создать физические структуры в службе поиска.

1. После создания индекса используйте дополнительные команды для просмотра определений или добавления элементов.

   ![Страница «Добавление индекса» с атрибутами по типу данных](media/search-what-is-an-index//field-definitions.png "Страница «Добавление индекса» с атрибутами по типу данных")

1. Скачайте схему индекса с помощью инструкции [Get index (REST API)](/rest/api/searchservice/get-index) и средства веб-тестирования, например [POST](search-get-started-rest.md). Теперь у вас есть представление JSON индекса, которое можно адаптировать для кода.

1. [Загрузите данные в индекс](search-what-is-data-import.md). Когнитивный поиск Azure принимает документы JSON. Для программной загрузки данных можно использовать Postman с добавлением документов JSON в полезные данные запроса. Если данные сложно представить в формате JSON, то этот шаг будет наиболее трудоемким. 

    После загрузки индекса с данными для большинства изменений в существующих полях потребуется удалить и перестроить индекс.

1. Отправляйте запросы к индексу, проверяйте результаты и выполняйте дальнейшие итерации со схемой индекса, пока не добьетесь ожидаемых результатов. Для отправки запросов к индексу можно использовать [**проводник поиска**](search-explorer.md) или Postman.

Во время разработки спланируйте частые перестроение. Так как физические структуры создаются в службе, [Удаление и повторное создание индексов](search-howto-reindex.md) необходимы для большинства изменений в определении существующего поля. Можно рассмотреть возможность использования подмножества данных, чтобы ускорить перестроение. 

> [!Tip]
> Код, а не подход на портале, рекомендуется для одновременной работы с проектированием индекса и импортом данных. В качестве альтернативы такие средства, как [posts](search-get-started-rest.md) или [Visual Studio Code](search-get-started-vs-code.md) , полезны для проверки концепции, когда проекты разработки по-прежнему находятся на ранних стадиях. Можно внести добавочные изменения в определение индекса в тексте запроса, и затем отправить запрос к службе для повторного создания индекса с помощью обновленной схемы.

## <a name="index-schema"></a>Схема индекса

Индекс должен иметь имя и одно заданное ключевое поле (объекта EDM. String) в коллекции Fields. [*Коллекция полей*](#fields-collection) обычно будет самой крупной частью индекса. Здесь каждому полю присвоены имя, тип и атрибуты, обозначающие допустимые поведения и порядок использования полей. 

Другие [элементы включают в](#suggesters)себя средства подбора, [Профили оценки](#scoringprofiles), [анализаторы](#analyzers) , используемые для обработки строк в токенах в соответствии с лингвистическими правилами или другими характеристиками, поддерживаемыми анализатором, и настройками [удаленного создания сценариев (CORS) для разных источников](#corsoptions) .

```json
{
  "name": (optional on PUT; required on POST) "name_of_index",
  "fields": [
    {
      "name": "name_of_field",
      "type": "Edm.String | Collection(Edm.String) | Edm.Int32 | Edm.Int64 | Edm.Double | Edm.Boolean | Edm.DateTimeOffset | Edm.GeographyPoint",
      "searchable": true (default where applicable) | false (only Edm.String and Collection(Edm.String) fields can be searchable),
      "filterable": true (default) | false,
      "sortable": true (default where applicable) | false (Collection(Edm.String) fields cannot be sortable),
      "facetable": true (default where applicable) | false (Edm.GeographyPoint fields cannot be facetable),
      "key": true | false (default, only Edm.String fields can be keys),
      "retrievable": true (default) | false,
      "analyzer": "name_of_analyzer_for_search_and_indexing", (only if 'searchAnalyzer' and 'indexAnalyzer' are not set)
      "searchAnalyzer": "name_of_search_analyzer", (only if 'indexAnalyzer' is set and 'analyzer' is not set)
      "indexAnalyzer": "name_of_indexing_analyzer", (only if 'searchAnalyzer' is set and 'analyzer' is not set)
      "synonymMaps": [ "name_of_synonym_map" ] (optional, only one synonym map per field is currently supported)
    }
  ],
  "suggesters": [
    {
      "name": "name of suggester",
      "searchMode": "analyzingInfixMatching",
      "sourceFields": ["field1", "field2", ...]
    }
  ],
  "scoringProfiles": [
    {
      "name": "name of scoring profile",
      "text": (optional, only applies to searchable fields) {
        "weights": {
          "searchable_field_name": relative_weight_value (positive #'s),
          ...
        }
      },
      "functions": (optional) [
        {
          "type": "magnitude | freshness | distance | tag",
          "boost": # (positive number used as multiplier for raw score != 1),
          "fieldName": "...",
          "interpolation": "constant | linear (default) | quadratic | logarithmic",
          "magnitude": {
            "boostingRangeStart": #,
            "boostingRangeEnd": #,
            "constantBoostBeyondRange": true | false (default)
          },
          "freshness": {
            "boostingDuration": "..." (value representing timespan leading to now over which boosting occurs)
          },
          "distance": {
            "referencePointParameter": "...", (parameter to be passed in queries to use as reference location)
            "boostingDistance": # (the distance in kilometers from the reference location where the boosting range ends)
          },
          "tag": {
            "tagsParameter": "..." (parameter to be passed in queries to specify a list of tags to compare against target fields)
          }
        }
      ],
      "functionAggregation": (optional, applies only when functions are specified) 
        "sum (default) | average | minimum | maximum | firstMatching"
    }
  ],
  "analyzers":(optional)[ ... ],
  "charFilters":(optional)[ ... ],
  "tokenizers":(optional)[ ... ],
  "tokenFilters":(optional)[ ... ],
  "defaultScoringProfile": (optional) "...",
  "corsOptions": (optional) {
    "allowedOrigins": ["*"] | ["origin_1", "origin_2", ...],
    "maxAgeInSeconds": (optional) max_age_in_seconds (non-negative integer)
  },
  "encryptionKey":(optional){
    "keyVaultUri": "azure_key_vault_uri",
    "keyVaultKeyName": "name_of_azure_key_vault_key",
    "keyVaultKeyVersion": "version_of_azure_key_vault_key",
    "accessCredentials":(optional){
      "applicationId": "azure_active_directory_application_id",
      "applicationSecret": "azure_active_directory_application_authentication_key"
    }
  }
}
```

<a name="fields-collection"></a>

## <a name="fields-collection-and-field-attributes"></a>Коллекции полей и атрибуты поля

Поля имеют имя, тип, который классифицирует хранимые данные, и атрибуты, указывающие, как это поле используется.

### <a name="data-types"></a>Типы данных

| Тип | Описание |
|------|-------------|
| Edm.String |Текст, который при необходимости может быть разбит на лексемы для полнотекстового поиска (разбиение на слова, выделение корней и т. д.). |
| Collection(Edm.String) |Список строк, которые при необходимости могут быть снабжены маркером для полнотекстового поиска. Для количества элементов в коллекции не предусмотрен теоретический верхний предел, но к коллекциям применяется верхний предел для объема полезных данных — 16 МБ. |
| Edm.Boolean |Содержит значения True или False. |
| Edm.Int32 |32-разрядные целочисленные значения. |
| Edm.Int64 |64-разрядные целочисленные значения. |
| Edm.Double |Числовые данные с двойной точностью. |
| Edm.DateTimeOffset |Значения даты и времени в формате OData V4 (например, `yyyy-MM-ddTHH:mm:ss.fffZ` или `yyyy-MM-ddTHH:mm:ss.fff[+/-]HH:mm`). |
| Edm.GeographyPoint |Точка, представляющая географическое расположение. |

Дополнительные сведения см. в разделе [Поддерживаемые типы данных](/rest/api/searchservice/Supported-data-types).

<a name="index-attributes"></a>

### <a name="attributes"></a>Атрибуты

Атрибуты поля определяют, как используется поле, например, используется ли полнотекстовый поиск, фасетная навигация, операции сортировки и т д. 

Строковые поля часто помечаются как "доступные для поиска" и "могут быть извлечены". Поля, используемые для ограничения результатов поиска, включают "сортируемый", "фильтруемый" и "многогранный".

|attribute|Описание|  
|---------------|-----------------|  
|возможностью поиска |Полнотекстовый поиск, подлежащий лексическому анализу, такому как разбиения на слова во время индексации. Если, например, задать для поля, поддерживающего поиск, значение sunny day (солнечный день), оно будет разделено на элементы sunny и day. Дополнительные сведения см. в статье [Как работает полнотекстовый поиск в службе поиска Azure](search-lucene-query-architecture.md).|  
|Фильтруемые |Указывается в запросах $filter. Для фильтруемых полей типа `Edm.String` и `Collection(Edm.String)` не выполняется разбиение на слова, поэтому они могут попасть в результаты поиска только по точному совпадению. Например, если для такого поля задать значение sunny day, запрос `$filter=f eq 'sunny'` не вернет совпадений, а запрос — `$filter=f eq 'sunny day'` вернет. |  
|Сортируемый |По умолчанию система сортирует результаты по их оценке, однако можно настроить сортировку на основе полей в документах. Поля типа `Collection(Edm.String)` не могут быть отсортированы. |  
|аспектируемый |Обычно используется в представлении результатов поиска, включающих количество обращений по категориям (например, отелей в определенном городе). Этот параметр не предназначен для использования с полями типа `Edm.GeographyPoint`. Поля типа `Edm.String` , доступные для фильтрации, "сортируемый" или "Facet", могут иметь длину не более 32 КБ. Дополнительные сведения см. в статье [Create Index (Azure Search Service REST API)](/rest/api/searchservice/create-index) (Создание индекса в REST API службы Поиска Azure).|  
|раздел |Уникальный идентификатор для документов в индексе. Только одно поле должно быть выбрано ключевым и оно должно иметь тип `Edm.String`.|  
|извлекаемые |Определяет, включается ли поле в возвращаемые поиском результаты. Этот атрибут полезен, когда поле (например, *показатель прибыльности*) нужно использовать для фильтрации, сортировки или оценки, но оно не должно отображаться конечному пользователю. У полей с установленным свойством `true` for `key` .|  

Несмотря на то что вы в любой момент можете добавить новые поля, имеющиеся определения полей блокируются на время существования индекса. По этой причине разработчики обычно используют портал для создания простых индексов, тестирования идей или используют страницы портала для поиска параметра. Частая итерация по структуре индекса более эффективна, если следовать подходу на основе кода для легкой перестройки индекса.

> [!NOTE]
> API-интерфейсы, используемые для построения индекса, имеют различные поведения по умолчанию. Для [интерфейсов API остальной части](/rest/api/searchservice/Create-Index)по умолчанию включены большинство атрибутов (например, "доступные для поиска" и "извлечение" для строковых полей), и часто их нужно задавать только в том случае, если их нужно отключить. Для пакета SDK для .NET противоположным является true. В любом свойстве, которое не задано явно, по умолчанию следует отключить соответствующее поведение поиска, если только вы не включили его явным образом.

## `analyzers`

Элемент анализатора задает имя анализатора языка, который нужно использовать для поля. Дополнительные сведения о доступных анализаторах см. в статье [Добавление анализаторов в индекс Azure когнитивный Поиск](search-analyzers.md). Анализаторы могут использоваться только для доступных для поиска полей. После назначения полю анализатора его невозможно изменить без перестроения индекса.

## `suggesters`

Средством подбора называется часть схемы, которая определяет, какие поля в индексе используются для поддержки автозавершения и упреждающего ввода запросов при поиске. Как правило, строки частичного поиска отправляются в [предложения (REST API)](/rest/api/searchservice/suggestions) , пока пользователь вводит поисковый запрос, а API возвращает набор предлагаемых документов или фраз. 

Поля, добавленные в средство подбора, используются для создания терминов для упреждающего поиска. Все термины для поиска создаются во время индексирования и хранятся отдельно. Дополнительные сведения о создании структуры средства подбора см. в разделе [Добавление средств подбора в индекс службы "Поиск Azure"](index-add-suggesters.md).

## `corsOptions`

По умолчанию клиентский код JavaScript не может обращаться к API, так как браузер блокирует все запросы между разными источниками. Чтобы разрешить запросы между источниками к нужному индексу, включите CORS (Cross-Origin Resource Sharing — общий доступ к ресурсам независимо от источника), установив атрибут **corsOptions**. По соображениям безопасности технологию CORS поддерживают только интерфейсы API запросов. 

Для технологии CORS можно настроить перечисленные ниже параметры.

+ **allowedOrigins** (обязательно) — это список источников, которым будет предоставлен доступ к индексу. Это означает, что любой код JavaScript из такого источника сможет отправлять запросы к этому индексу (при условии, что указан правильный ключ API). Источники здесь обычно задаются в формате `protocol://<fully-qualified-domain-name>:<port>`, хотя `<port>` часто опускается. Дополнительные сведения см. в статье Википедии [о предоставлении ресурсов для нескольких источников](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing).

  Если вы хотите разрешить доступ всем источникам, добавьте в массив **allowedOrigins** единственный элемент `*`. *Этот вариант не рекомендуется для служб поиска в рабочей среде*, но часто он удобен для разработки и отладки.

+ **maxAgeInSeconds** (необязательно): браузеры используют это значение для определения длительности (в секундах) для кэширования предпечатных ответов CORS. Это значение должно быть целой неотрицательной величиной. Чем оно больше, чем выше производительность, однако при этом применение изменений в политике CORS занимает больше времени. Если это значение не задано, длительность по умолчанию составляет 5 минут.

## `scoringProfiles`

[Профиль оценки](index-add-scoring-profiles.md) — это раздел схемы, который определяет поведение настраиваемой оценки, позволяющее повлиять на то, какие элементы появляются в результатах поиска выше. Профили оценки состоят из взвешенных полей и функций. Чтобы использовать их, необходимо задать профиль по имени в строке запроса.

Профиль оценки по умолчанию вычисляет оценку поиска для каждого элемента в результирующем наборе в фоновом режиме. Можно использовать внутренний профиль оценки без имени. Кроме того, можно установить **дефаултскорингпрофиле** для использования пользовательского профиля по умолчанию, вызываемого всякий раз, когда в строке запроса не задан пользовательский профиль.

<a name="index-size"></a>

## <a name="attributes-and-index-size-storage-implications"></a>Атрибуты и размер индекса (проблемы с хранилищем)

Размер индекса определяется размером отправляемых документов, а также конфигурацией индекса, например включением предложений и определением атрибутов для отдельных полей. 

На следующем снимке экрана показаны шаблоны хранения индекса, полученные в результате различных сочетаний атрибутов. Индекс основан на **образце индекса** недвижимости, который можно легко создать с помощью мастера импорта данных. Хотя схемы индексов не показаны, атрибуты можно определить на основе имени индекса. Например, индекс *Realestate-* Indexed имеет выбранный атрибут "с возможностью поиска", и ничего другого, *Realestate-извлечение* индекса не имеет выбранного атрибута "извлечь" и ничего другого и т. д.

![Размер индекса на основе выбора атрибута](./media/search-what-is-an-index/realestate-index-size.png "Размер индекса на основе выбора атрибута")

Хотя эти варианты индекса являются искусственными, они подходят для общего сравнения влияния различных атрибутов на размер хранилища. Устанавливает ли параметр "получение" размера индекса? Нет. Добавляет ли поле к **предложению** для увеличения размера индекса? Да.

Индексы, поддерживающие фильтрацию и сортировку, пропорционально больше индексов, поддерживающих только полнотекстовый поиск. Это связано с тем, что операции фильтрации и сортировки просматривают точные совпадения, что требует наличия строк буквального текста. В отличие от этого, доступные для поиска поля, поддерживающие полнотекстовые запросы, используют Инвертированные индексы, заполненные маркерами, которые потребляют меньше места по сравнению с документами в целом. 

> [!Note]
> Архитектура хранилища считается подробной реализацией Azure Когнитивный поиск и может измениться без предварительного уведомления. Нет никакой гарантии, что ее текущее поведение будет сохранено в будущем.

## <a name="next-steps"></a>Дальнейшие действия

Разобравшись со структурой индекса, вы можете перейти на портал и создать свой первый индекс. Мы рекомендуем начать с мастера **импорта данных** , выбрав источники данных, размещенные в *Realestate-US-sample* или *Отели-Samples* .

> [!div class="nextstepaction"]
> [Мастер импорта данных (портал)](search-get-started-portal.md)

Для обоих наборов данных мастер может вывести схему индекса, импортировать данные и вывести индекс с возможностью поиска, который можно запросить с помощью обозревателя поиска. Эти источники данных можно найти на странице **Подключение к данным** мастера **импорта данных** .

   ![Создание образца индекса](media/search-what-is-an-index//import-wizard-sample-data.png "Создание образца индекса")