---
title: Руководство по использованию Python и искусственного интеллекта с большими двоичными объектами Azure
titleSuffix: Azure Cognitive Search
description: Узнайте, как выполнять извлечение текста и обработку естественного языка по содержимому хранилища больших двоичных объектов с помощью записной книжки Jupyter Python и REST API Когнитивного поиска Azure.
manager: nitinme
author: HeidiSteen
ms.author: heidist
ms.service: cognitive-search
ms.devlang: python
ms.topic: tutorial
ms.date: 09/25/2020
ms.custom: devx-track-python
ms.openlocfilehash: ea1cc022cbea7dbf3d1fa12cb83cfe3084b28560
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "92788089"
---
# <a name="tutorial-use-python-and-ai-to-generate-searchable-content-from-azure-blobs"></a>Руководство по использованию Python и искусственного интеллекта для создания доступного для поиска содержимого на основе больших двоичных объектов Azure

Если у вас есть неструктурированный текст или изображения в хранилище BLOB-объектов Azure, [конвейер обогащения с помощью искуственного интелекта](cognitive-search-concept-intro.md) поможет извлекать информацию и создавать содержимое, применимое для сценариев полнотекстового поиска и интеллектуального анализа. Хотя конвейер может обрабатывать изображения, в этом учебнике для Python внимание уделяется созданию полей на основе распознавания языка и обработки естественного языка. Все это позволит вам использовать информацию в запросах, аспектах и фильтрах.

В этом руководстве используется Python и [REST API поиска](/rest/api/searchservice/), чтобы выполнять следующие задачи:

> [!div class="checklist"]
> * Начните работу с целых документов (с неструктурированным текстом), таких как PDF, HTML, DOCX и PPTX, размещенных в хранилище BLOB-объектов Azure.
> * Определите конвейер, который извлекает текст, а также распознает язык, сущности и ключевые фразы.
> * Определите индекс для хранения выходных данных (необработанное содержимое и созданные конвейером пары "имя — значение").
> * Выполните конвейер, чтобы начать преобразования и анализ, а также создать и загрузить индекс.
> * Изучите результаты с помощью полнотекстового поиска и расширенного синтаксиса запросов.

Если у вас еще нет подписки Azure, [создайте бесплатную учетную запись Azure](https://azure.microsoft.com/free/?WT.mc_id=A261C142F), прежде чем начинать работу.

## <a name="prerequisites"></a>Предварительные требования

+ [Хранилище Azure](https://azure.microsoft.com/services/storage/)
+ [Anaconda 3.7](https://www.anaconda.com/distribution/#download-section)
+ [Создайте службу поиска](search-create-service-portal.md) или [найдите существующую службу](https://ms.portal.azure.com/#blade/HubsExtension/BrowseResourceBlade/resourceType/Microsoft.Search%2FsearchServices) 

> [!Note]
> Для выполнения инструкций из этого руководства вы можете использовать бесплатную версию службы. В бесплатной версии вы можете использовать не более трех индексов, трех индексаторов и трех источников данных. В этом руководстве создается по одному объекту из каждой категории. Перед началом работы убедитесь, что у службы есть достаточно места, чтобы принять новые ресурсы.

## <a name="download-files"></a>Загрузка файлов

1. Откройте эту [папку OneDrive](https://1drv.ms/f/s!As7Oy81M_gVPa-LCb5lC_3hbS-4) и щелкните **Скачать** вверху слева, чтобы скопировать файлы на локальный компьютер. 

1. Щелкните ZIP-файл правой кнопкой мыши и выберите **Извлечь все**. Доступно 14 файлов разных типов. В этом примере вам потребуются семь из них.

## <a name="1---create-services"></a>1\. Создание служб

В этом учебнике используются Когнитивный поиск Azure для индексирования и создания запросов, сервер Cognitive Services — для обогащения с помощью искусственного интеллекта и хранилище BLOB-объектов Azure — для предоставления данных. В этом учебнике остается свободное выделение 20 транзакций на индексатор в день в Cognitive Services, поэтому необходимо создать только службы поиска и хранения.

Желательно создать все службы в одном регионе и одной группе ресурсов, чтобы упростить взаимодействие и управление. В реальной системе учетная запись хранения Azure может находиться в любом регионе.

### <a name="start-with-azure-storage"></a>Служба хранилища Azure

1. [Войдите на портал Azure](https://portal.azure.com/) и щелкните **+ Создать ресурс**.

1. Выполните поиск по строке *учетная запись хранения* и выберите "Учетная запись хранения Microsoft".

   :::image type="content" source="media/cognitive-search-tutorial-blob/storage-account.png" alt-text="Создание учетной записи хранения" border="false":::

1. На вкладке "Основные сведения" нужно ввести следующие сведения. Сохраните значения по умолчанию для остальных параметров.

   + **Группа ресурсов**. Вы можете выбрать существующую группу ресурсов или создать новую, но для всех служб это должна быть одна и та же группа для совместного управления.

   + **Имя учетной записи хранения.** Если вы ожидаете, что у вас будет несколько ресурсов одного типа, используйте имена, которые будут четко определять тип и регион, например *blobstoragewestus*. 

   + **Расположение.** Желательно выбрать то же расположение, которое использовалось для Когнитивного поиска Azure и Cognitive Services. При использовании одного расположения плата за трафик не взимается.

   + **Тип учетной записи.** Выберите значение по умолчанию *StorageV2 (общего назначения версии 2)* .

1. Щелкните **Просмотреть и создать**, чтобы создать службу.

1. По завершении процесса щелкните **Перейти к ресурсу** чтобы открыть страницу со сводкой.

1. Щелкните службу **Большие двоичные объекты**.

1. Щелкните **+ Контейнер**, чтобы создать контейнер, и присвойте ему имя *cog-search-demo*.

1. Выберите *cog-search-demo* и щелкните **Отправить**, чтобы открыть папку с сохраненными файлами для скачивания. Выберите все файлы, не являющиеся изображениями. Их должно быть семь. Щелкните **ОК**, чтобы начать отправку.

   :::image type="content" source="media/cognitive-search-tutorial-blob/sample-files.png" alt-text="Отправка образцов файлов" border="false":::

1. Прежде чем выйти из службы хранилища Azure, получите строку подключения для создания подключения в Когнитивном поиске Azure. 

   1. Вернитесь на страницу со сводкой об учетной записи хранения (в качестве примера мы использовали *blobstragewestus*). 
   
   1. В области навигации слева выберите **Ключи доступа** и скопируйте одну из строк подключения. 

   Строка подключения — это URL-адрес в следующем формате:

      ```http
      DefaultEndpointsProtocol=https;AccountName=<storageaccountname>;AccountKey=<your account key>;EndpointSuffix=core.windows.net
      ```

1. Сохраните эту строку подключения в Блокноте. Она понадобится позже при настройке подключения к источнику данных.

### <a name="cognitive-services"></a>Cognitive Services

Обогащение ИИ основано на платформе Cognitive Services, которая включает службы "Анализ текста" для обработки естественного языка и "Компьютерное зрение" для обработки изображений. Если бы вы создавали реальный прототип или проект, на этом этапе нужно было бы создать Cognitive Services (в том же регионе, что и Когнитивный поиск Azure) для связывания с операциями индексирования.

В этом учебнике используется только 7 транзакций, поэтому подготовку ресурсов можно пропустить, так как Когнитивный поиск Azure может подключаться к Cognitive Services для получения 20 бесплатных транзакций для каждого выполнения индексатора. Свободного выделения будет достаточно. Для крупных проектов вам, скорее всего, нужно будет подготовить Cognitive Services на уровне S0 с оплатой по мере использования. См. сведения о [подключении Cognitive Services](cognitive-search-attach-cognitive-services.md).

### <a name="azure-cognitive-search"></a>Когнитивный поиск Azure

Третий компонент — Когнитивный поиск Azure, который вы можете [создать на портале](search-create-service-portal.md). Для выполнения действий в этом пошаговом руководстве можно использовать уровень "Бесплатный". 

Как и с хранилищем BLOB-объектов Azure, не забудьте сохранить ключ доступа. Позже, когда вы начнете структурировать запросы, адрес конечной точки и административный ключ интерфейса нужно будет указывать в каждом запросе для проверки подлинности.

### <a name="get-an-admin-api-key-and-url-for-azure-cognitive-search"></a>Получение ключа API и URL-адреса конечной точки для администрирования Когнитивного поиска Azure

1. [Войдите на портал Azure](https://portal.azure.com/) и на странице **Обзор** для службы поиска получите ее имя. Имя службы можно проверить, просмотрев URL-адрес конечной точки. Если URL-адрес конечной точки имеет вид `https://mydemo.search.windows.net`, значит служба называется `mydemo`.

2. В разделе **Параметры** > **Ключи** получите ключ администратора, чтобы обрести полные права на службу. Существуют два взаимозаменяемых ключа администратора, предназначенных для обеспечения непрерывности бизнес-процессов на случай, если вам потребуется сменить один из них. Вы можете использовать первичный или вторичный ключ для выполнения запросов на добавление, изменение и удаление объектов.

   Получите также ключ запроса. Мы рекомендуем создавать запросы с доступом только для чтения.

   :::image type="content" source="media/search-get-started-javascript/service-name-and-keys.png" alt-text="Получение имени службы, ключей запросов и администратора" border="false":::

Для выполнения любого запроса к службе нужно включить ключ API в заголовок. Действительный ключ устанавливает для каждого запроса отношения доверия между приложением, которое отправляет запрос, и службой, которая его обрабатывает.

## <a name="2---start-a-notebook"></a>2\. Запуск записной книжки

Создайте записную книжку, выполнив приведенные ниже инструкции, или скачайте готовую записную книжку из репозитория [Azure-Search-python-samples](https://github.com/Azure-Samples/azure-search-python-samples/tree/master/Tutorial-AI-Enrichment).

Используйте Anaconda Navigator, чтобы запустить Jupyter Notebook и создать новую записную книжку для Python 3.

Запустите этот скрипт в своей записной книжке, чтобы загрузить библиотеки, используемые для работы с JSON и формулировки HTTP-запросов.

```python
import json
import requests
from pprint import pprint
```

В той же записной книжке определите имена для источника данных, индекса, индексатора и набора навыков. Запустите этот скрипт, чтобы задать имена для работы с этим учебником.

```python
# Define the names for the data source, skillset, index and indexer
datasource_name = "cogsrch-py-datasource"
skillset_name = "cogsrch-py-skillset"
index_name = "cogsrch-py-index"
indexer_name = "cogsrch-py-indexer"
```

В следующем скрипте замените заполнители службы поиска (YOUR-SEARCH-SERVICE-NAME) и ключа API администратора (YOUR-ADMIN-API-KEY), а затем запустите его, чтобы настроить конечную точку службы поиска.

```python
# Setup the endpoint
endpoint = 'https://<YOUR-SEARCH-SERVICE-NAME>.search.windows.net/'
headers = {'Content-Type': 'application/json',
           'api-key': '<YOUR-ADMIN-API-KEY>'}
params = {
    'api-version': '2020-06-30'
}
```

## <a name="3---create-the-pipeline"></a>3\. Создание конвейера

В Когнитивном поиске Azure обработка ИИ выполняется во время индексирования (или приема данных). В этой части пошагового руководства описано, как создать четыре объекта: источник данных, определение индекса, набор навыков и индексатор. 

### <a name="step-1-create-a-data-source"></a>Шаг 1. Создание источника данных

[Объект источника данных](/rest/api/searchservice/create-data-source) предоставляет строку подключения к контейнеру больших двоичных объектов, который содержит файлы.

В следующем скрипте замените заполнитель YOUR-BLOB-RESOURCE-CONNECTION-STRING на строку подключения к большому двоичному объекту, созданному на предыдущем шаге. Замените текст заполнителя для контейнера. Затем запустите скрипт, чтобы создать источник данных с именем `cogsrch-py-datasource`.

```python
# Create a data source
datasourceConnectionString = "<YOUR-BLOB-RESOURCE-CONNECTION-STRING>"
datasource_payload = {
    "name": datasource_name,
    "description": "Demo files to demonstrate cognitive search capabilities.",
    "type": "azureblob",
    "credentials": {
        "connectionString": datasourceConnectionString
    },
    "container": {
        "name": "<YOUR-BLOB-CONTAINER-NAME>"
    }
}
r = requests.put(endpoint + "/datasources/" + datasource_name,
                 data=json.dumps(datasource_payload), headers=headers, params=params)
print(r.status_code)
```

Запрос должен вернуть код состояния 201, подтверждающий успешное выполнение.

На портале Azure на странице панели мониторинга службы поиска убедитесь, что источник cogsrch-py-datasource присутствует в списке **Источники данных**. Щелкните **Обновить**, чтобы обновить страницу.

:::image type="content" source="media/cognitive-search-tutorial-blob-python/py-data-source-tile.png" alt-text="Плитка источников данных на портале" border="false":::

### <a name="step-2-create-a-skillset"></a>Шаг 2. Создание набора навыков

На этом этапе вы определяете набор шагов обогащения, которые хотите применить к данным. Каждый шаг обогащения называется *навыком*, а набор шагов обогащения — *набором навыков*. В этом руководстве для набора навыков используются [встроенные когнитивные навыки](cognitive-search-predefined-skills.md):

+ [Распознавание сущностей](cognitive-search-skill-entity-recognition.md) для извлечения названий организаций из содержимого в контейнере больших двоичных объектов.

+ [Распознавание языка](cognitive-search-skill-language-detection.md) для определения языка содержимого.

+ [Разделение текста](cognitive-search-skill-textsplit.md) для разбиения большого объема содержимого на более мелкие фрагменты данных перед вызовом метода извлечения ключевой фразы. Этот метод принимает входные данные объемом 50 000 символов или меньше. Некоторые примеры файлов следует разделить, чтобы удовлетворить это ограничение.

+ [Извлечение ключевых фраз](cognitive-search-skill-keyphrases.md) для получения основных ключевых фраз. 

Выполните следующий скрипт, чтобы создать набор навыков `cogsrch-py-skillset`.

```python
# Create a skillset
skillset_payload = {
    "name": skillset_name,
    "description":
    "Extract entities, detect language and extract key-phrases",
    "skills":
    [
        {
            "@odata.type": "#Microsoft.Skills.Text.EntityRecognitionSkill",
            "categories": ["Organization"],
            "defaultLanguageCode": "en",
            "inputs": [
                {
                    "name": "text", 
                    "source": "/document/content"
                }
            ],
            "outputs": [
                {
                    "name": "organizations", 
                    "targetName": "organizations"
                }
            ]
        },
        {
            "@odata.type": "#Microsoft.Skills.Text.LanguageDetectionSkill",
            "inputs": [
                {
                    "name": "text", 
                    "source": "/document/content"
                }
            ],
            "outputs": [
                {
                    "name": "languageCode",
                    "targetName": "languageCode"
                }
            ]
        },
        {
            "@odata.type": "#Microsoft.Skills.Text.SplitSkill",
            "textSplitMode": "pages",
            "maximumPageLength": 4000,
            "inputs": [
                {
                    "name": "text",
                    "source": "/document/content"
                },
                {
                    "name": "languageCode",
                    "source": "/document/languageCode"
                }
            ],
            "outputs": [
                {
                    "name": "textItems",
                    "targetName": "pages"
                }
            ]
        },
        {
            "@odata.type": "#Microsoft.Skills.Text.KeyPhraseExtractionSkill",
            "context": "/document/pages/*",
            "inputs": [
                {
                    "name": "text", 
                    "source": "/document/pages/*"
                },
                {
                    "name": "languageCode", 
                    "source": "/document/languageCode"
                }
            ],
            "outputs": [
                {
                    "name": "keyPhrases",
                    "targetName": "keyPhrases"
                }
            ]
        }
    ]
}

r = requests.put(endpoint + "/skillsets/" + skillset_name,
                 data=json.dumps(skillset_payload), headers=headers, params=params)
print(r.status_code)
```

Запрос должен вернуть код состояния 201, подтверждающий успешное выполнение.

Для каждой страницы применяется навык извлечения ключевых фраз. Если установить контекст `"document/pages/*"`, средство обогащения будет выполнено для каждого элемента массива документов или страниц (для каждой страницы в документе).

Каждый навык выполняется в содержимом документа. Во время обработки служба "Когнитивный поиск Azure" разбивает каждый документ для чтения содержимого из разных форматов файлов. Найденный в исходном файле текст помещается в поле `content`, по одному для каждого документа. Таким образом, установите входные данные как `"/document/content"`.

Графическое представление набора навыков показано ниже.

:::image type="content" source="media/cognitive-search-tutorial-blob/skillset.png" alt-text="Общие сведения о наборе навыков" border="false":::

Выходные данные могут быть сопоставлены с индексом, используемым в качестве входных данных для нисходящего навыка, или к обоим, как в случае с кодом языка. В индексе код языка полезен для фильтрации. В качестве входных данных код языка используется навыками анализа текста, чтобы указать лингвистические правила для разбивки слов.

Общие сведения о наборах навыков см. в статье [How to create a skillset in an enrichment pipeline](cognitive-search-defining-skillset.md) (Способ создания набора навыков в конвейере обогащения).

### <a name="step-3-create-an-index"></a>Шаг 3. Создание индекса

В этом разделе вы определите схему индекса, указав поля для включения в индекс поиска, а также установите атрибуты поиска для каждого поля. Поля имеют тип и могут принимать атрибуты, определяющие их использование (поиск, сортировка и т. д.). Имена полей в индексе не обязательно должны точно соответствовать именам полей в источнике. На более позднем этапе вы добавите сопоставления полей в индексаторе для подключения полей "источник — назначение". Для этого шага определите индекс, используя соглашения об именовании полей, относящиеся к вашему поисковому приложению.

В этом упражнении используются следующие поля и типы полей:

| имена полей: | ID         | content   | languageCode | keyPhrases         | organizations     |
|--------------|----------|-------|----------|--------------------|-------------------|
| типы полей: | Edm.String|Edm.String| Edm.String| List<Edm.String>  | List<Edm.String>  |

Запустите этот скрипт, чтобы создать индекс с именем `cogsrch-py-index`.

```python
# Create an index
index_payload = {
    "name": index_name,
    "fields": [
        {
            "name": "id",
            "type": "Edm.String",
            "key": "true",
            "searchable": "true",
            "filterable": "false",
            "facetable": "false",
            "sortable": "true"
        },
        {
            "name": "content",
            "type": "Edm.String",
            "sortable": "false",
            "searchable": "true",
            "filterable": "false",
            "facetable": "false"
        },
        {
            "name": "languageCode",
            "type": "Edm.String",
            "searchable": "true",
            "filterable": "false",
            "facetable": "false"
        },
        {
            "name": "keyPhrases",
            "type": "Collection(Edm.String)",
            "searchable": "true",
            "filterable": "false",
            "facetable": "false"
        },
        {
            "name": "organizations",
            "type": "Collection(Edm.String)",
            "searchable": "true",
            "sortable": "false",
            "filterable": "false",
            "facetable": "false"
        }
    ]
}

r = requests.put(endpoint + "/indexes/" + index_name,
                 data=json.dumps(index_payload), headers=headers, params=params)
print(r.status_code)
```

Запрос должен вернуть код состояния 201, подтверждающий успешное выполнение.

Дополнительные сведения об определении индекса см. в статье [Create Index (Azure Search Service REST API)](/rest/api/searchservice/create-index) (Создание индексов (REST API службы "Поиск Azure")).

### <a name="step-4-create-and-run-an-indexer"></a>Шаг 4. Создание и запуск индексатора

[Индексатор](/rest/api/searchservice/create-indexer) управляет работой конвейера. Три компонента, которые вы создали ранее (источник данных, набор навыков и индекс) предоставляют входные данные для индексатора. Именно создание индексатора в Когнитивном поиске Azure является событием, которое запускает весь конвейер. 

Чтобы связать эти объекты вместе в индексаторе, необходимо определить сопоставления полей.

+ Обработка `"fieldMappings"` выполняется перед набором навыков, при этом исходные поля из источника данных сопоставляются с целевыми полями в индексе. Если имена и типы полей одинаковы в исходном и целевом расположениях, сопоставление не требуется.

+ Обработка `"outputFieldMappings"` выполняется после набора навыков, при этом добавляются ссылки на элементы `"sourceFieldNames"`, которые не существуют, пока они не будут созданы при распознавании или обогащении документов. `"targetFieldName"` — это поле в индексе.

Помимо привязки входных данных к выходным данным, можно также использовать сопоставления полей для преобразования структур данных в плоские структуры. Для получения дополнительных сведений см. раздел [Сопоставление обогащенных полей с индексом, поддерживающим поиск](cognitive-search-output-field-mapping.md).

Запустите этот скрипт, чтобы создать индексатор с именем `cogsrch-py-indexer`.

```python
# Create an indexer
indexer_payload = {
    "name": indexer_name,
    "dataSourceName": datasource_name,
    "targetIndexName": index_name,
    "skillsetName": skillset_name,
    "fieldMappings": [
        {
            "sourceFieldName": "metadata_storage_path",
            "targetFieldName": "id",
            "mappingFunction":
            {"name": "base64Encode"}
        },
        {
            "sourceFieldName": "content",
            "targetFieldName": "content"
        }
    ],
    "outputFieldMappings":
    [
        {
            "sourceFieldName": "/document/organizations",
            "targetFieldName": "organizations"
        },
        {
            "sourceFieldName": "/document/pages/*/keyPhrases/*",
            "targetFieldName": "keyPhrases"
        },
        {
            "sourceFieldName": "/document/languageCode",
            "targetFieldName": "languageCode"
        }
    ],
    "parameters":
    {
        "maxFailedItems": -1,
        "maxFailedItemsPerBatch": -1,
        "configuration":
        {
            "dataToExtract": "contentAndMetadata",
            "imageAction": "generateNormalizedImages"
        }
    }
}

r = requests.put(endpoint + "/indexers/" + indexer_name,
                 data=json.dumps(indexer_payload), headers=headers, params=params)
print(r.status_code)
```

В ближайшее время запрос должен вернуть код состояния 201, однако обработка может занять несколько минут. Хотя набор данных невелик, аналитические навыки, такие как анализ изображений, требуют значительных вычислительных ресурсов и занимают время.

Вы можете [отслеживать состояние индексатора](#check-indexer-status), чтобы определить, когда индексатор выполняется или завершен.

> [!TIP]
> Создание индексатора вызывает конвейер. Если есть проблемы с получением данных, сопоставлением входных и выходных данных или порядком операций, они появятся на этом этапе. Чтобы повторно запустить конвейер с изменениями кода или скрипта, вам может потребоваться сначала удалить объекты. Дополнительные сведения см. в статье [Руководство по вызову API-интерфейсов когнитивного поиска (предварительная версия)](#reset).

#### <a name="about-the-request-body"></a>Сведения о тексте запроса

Скрипт устанавливает значение -1 для `"maxFailedItems"`, которое инструктирует механизм индексирования игнорировать ошибки во время импорта данных. Это полезно, потому что в демонстрационном источнике данных мало документов. Для большего источника данных необходимо установить значение больше 0.

Также обратите внимание на оператор `"dataToExtract":"contentAndMetadata"` в параметрах конфигурации. Этот оператор указывает индексатору извлекать содержимое из разных форматов файлов, а также метаданные, относящиеся к каждому файлу.

Когда содержимое будет извлечено, вы можете установить `imageAction` для извлечения текста из изображений, найденных в источнике данных. Конфигурация `"imageAction":"generateNormalizedImages"` вместе с навыком распознавания текста и навыком объединения текста инструктирует индексатор извлекать текст из изображений (например слово "стоп" из знака остановки движения) и вставлять его как часть поля содержимого. Это поведение относится как к изображениям, встроенным в документы (например, изображение внутри PDF-файлов), так и к изображениям, найденным в источнике данных, например в JPG-файл.

<a name="check-indexer-status"></a>

## <a name="4---monitor-indexing"></a>4\. Мониторинг индексирования

После того как индексатор будет определен, он будет выполняться автоматически при отправке запроса. В зависимости от того, какие когнитивные навыки вы определили, индексирование может занять больше времени, чем вы ожидаете. Чтобы узнать, завершена ли обработка индексатора, запустите следующий скрипт.

```python
# Get indexer status
r = requests.get(endpoint + "/indexers/" + indexer_name +
                 "/status", headers=headers, params=params)
pprint(json.dumps(r.json(), indent=1))
```

В ответе отслеживайте `"lastResult"` по значениям `"status"` и `"endTime"`. Периодически запускайте скрипт для проверки состояния. Когда индексатор завершит работу, состояние будет иметь значение success, будет указано значение endTime, а в ответ будут включены все ошибки и предупреждения, которые произошли во время обогащения.

:::image type="content" source="media/cognitive-search-tutorial-blob-python/py-indexer-is-created.png" alt-text="Индексатор создан" border="false":::

Предупреждения часто возникают с некоторыми исходными файлами и комбинациями навыков и не всегда указывают на проблему. Многие предупреждения являются безвредными. Например, если вы индексируете JPEG-файл без текста, на этом экране отобразится предупреждение.

:::image type="content" source="media/cognitive-search-tutorial-blob-python/py-indexer-warning-example.png" alt-text="Пример предупреждения индексатора" border="false":::

## <a name="5---search"></a>5\. Поиск

После завершения индексации выполните запросы, возвращающие содержимое отдельных полей. По умолчанию служба "Когнитивный поиск Azure" возвращает 50 лучших результатов. Примеры данных малы, поэтому параметр по умолчанию работает нормально. Однако при работе с большими наборами данных вам может потребоваться включить параметры в строку запроса, чтобы вернуть больше результатов. Инструкции см. в статье [How to work with search results in Azure Search](search-pagination-page-layout.md) (Работа с результатами поиска в службе "Поиск Azure").

В качестве проверки получите определение индекса, показывающее все поля.

```python
# Query the service for the index definition
r = requests.get(endpoint + "/indexes/" + index_name,
                 headers=headers, params=params)
pprint(json.dumps(r.json(), indent=1))
```

Результат должен выглядеть следующим образом: На снимке экрана показана только часть ответа.

:::image type="content" source="media/cognitive-search-tutorial-blob-python/py-query-index-for-fields.png" alt-text="Индекс запроса для всех полей" border="false":::

В результате будет возвращена схема индекса с именем и типом, а также атрибуты каждого поля.

Отправьте второй запрос с `"*"`, чтобы вернуть все содержимое одного поля, например `organizations`.

```python
# Query the index to return the contents of organizations
r = requests.get(endpoint + "/indexes/" + index_name +
                 "/docs?&search=*&$select=organizations", headers=headers, params=params)
pprint(json.dumps(r.json(), indent=1))
```

Результат должен выглядеть следующим образом: На снимке экрана показана только часть ответа.

:::image type="content" source="media/cognitive-search-tutorial-blob-python/py-query-index-for-organizations.png" alt-text="Индекс запроса для содержимого организаций" border="false":::

Повторите эти действия для дополнительных полей: `content`, `languageCode`, `keyPhrases` и `organizations` в этом упражнении. Вы можете возвратить несколько полей с помощью `$select`, используя разделенный запятыми список.

Можно использовать методы GET или POST, в зависимости от сложности и длины строки запроса. Дополнительные сведения см. в статье [Отправка запросов в индекс службы поиска Azure с помощью REST API](/rest/api/searchservice/search-documents).

<a name="reset"></a>

## <a name="reset-and-rerun"></a>Сброс и повторный запуск

На ранних экспериментальных этапах разработки самый практичный подход к итерации схемы — удалить все объекты из службы "Когнитивный поиск Azure" и восстановить их с помощью кода. Имена ресурсов являются уникальными. Удаление объекта позволяет воссоздать его с использованием того же имени.

Для удаления индексов, индексаторов, источников данных и наборов навыков можно использовать портал. Когда вы удаляете индексатор, вы можете по желанию одновременно выборочно удалить индекс, набор навыков и источник данных.

:::image type="content" source="media/cognitive-search-tutorial-blob-python/py-delete-indexer-delete-all.png" alt-text="Удаление объектов поиска на портале" border="false":::

Вы также можете удалить их, используя скрипт. В следующем сценарии показано, как удалить набор навыков. 

```python
# delete the skillset
r = requests.delete(endpoint + "/skillsets/" + skillset_name,
                    headers=headers, params=params)
pprint(json.dumps(r.json(), indent=1))
```

При успешном удалении возвращается код состояния 204.

## <a name="takeaways"></a>Общие выводы

В этом руководстве показаны основные шаги для построения обогащенного конвейера индексирования посредством создания компонентов: источника данных, набора навыков, индекса и индексатора.

Вы получили сведения о [встроенных навыках](cognitive-search-predefined-skills.md), а также об определениях наборов навыков и механизме построения цепочек навыков путем сопоставления входных и выходных данных. Вы также узнали, что `outputFieldMappings` в определении индексатора требуется для маршрутизации обогащенных значений из конвейера в индекс для поиска в службе "Когнитивный поиск Azure".

Наконец, вы узнали, как тестировать результаты и выполнять сброс системы для дальнейших итераций. Вы узнали, что отправка запросов к индексу возвращает результат, созданный обогащенным конвейером индексирования. В этом выпуске существует механизм просмотра внутренних конструкций (обогащенные документы, созданные системой). Вы также узнали, как проверить состояние индексатора и какие объекты нужно удалить перед повторным запуском конвейера.

## <a name="clean-up-resources"></a>Очистка ресурсов

Если вы работаете в своей подписке, после завершения проекта целесообразно удалить созданные ресурсы, которые вам больше не потребуются. Работающие ресурсы могут означать лишние затраты. Можно удалить отдельные ресурсы или удалить группу ресурсов, что позволит удалить весь набор ресурсов.

Просматривать ресурсы и управлять ими можно на портале с помощью ссылок "Все ресурсы" или "Группы ресурсов" в области навигации слева.

## <a name="next-steps"></a>Дальнейшие действия

Теперь, когда вы знакомы со всеми объектами в конвейере обогащения с помощью ИИ, давайте более подробно рассмотрим определения набора навыков и отдельные навыки.

> [!div class="nextstepaction"]
> [Создание набора навыков](cognitive-search-defining-skillset.md)