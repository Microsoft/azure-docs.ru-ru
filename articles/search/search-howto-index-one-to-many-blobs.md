---
title: Индексные BLOB-объекты, содержащие несколько документов
titleSuffix: Azure Cognitive Search
description: Сканирование больших двоичных объектов Azure для текстового содержимого с помощью индексатора больших двоичных объектов Azure Когнитивный поиск, где каждый большой двоичный объект может получить один или несколько документов поискового индекса.
manager: nitinme
author: arv100kri
ms.author: arjagann
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 02/01/2021
ms.openlocfilehash: ea22b3cff8a0303c4e6698db4090df0f5ed2153a
ms.sourcegitcommit: eb546f78c31dfa65937b3a1be134fb5f153447d6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/02/2021
ms.locfileid: "99430986"
---
# <a name="indexing-blobs-to-produce-multiple-search-documents"></a>Индексирование больших двоичных объектов для получения нескольких поисковых документов

По умолчанию индексатор BLOB-объектов будет рассматривать содержимое большого двоичного объекта как единый поисковый документ. Если требуется более детальное представление большого двоичного объекта в индексе поиска, можно задать значения **parsingMode** , чтобы создать несколько документов поиска из одного большого двоичного объекта. Значения **parsingMode** , которые приводят к большому числу документов поиска `delimitedText` , включают (для [CSV](search-howto-index-csv-blobs.md)) и `jsonArray` или `jsonLines` (для [JSON](search-howto-index-json-blobs.md)).

При использовании любого из этих режимов анализа новые документы поиска, которые поставляются, должны иметь уникальные ключи документов, и возникает проблема, связанная с определением места появления этого значения. Родительский большой двоичный объект имеет по крайней мере одно уникальное значение в форме `metadata_storage_path property` , но если оно вносит это значение в несколько документов поиска, ключ больше не уникален в индексе.

Чтобы устранить эту проблему, индексатор больших двоичных объектов создает `AzureSearch_DocumentKey` , однозначно определяющий каждый дочерний документ поиска, созданный из одного родителя большого двоичного объекта. В этой статье объясняется, как работает эта функция.

## <a name="one-to-many-document-key"></a>Ключ документа "один ко многим"

Каждый документ, который отображается в индексе Azure Когнитивный поиск, однозначно идентифицируется ключом документа. 

Если режим синтаксического анализа не указан и в определении индексатора отсутствует [явное сопоставление полей](search-indexer-field-mappings.md) для ключа документа поиска, индексатор BLOB-объектов автоматически сопоставляет его `metadata_storage_path property` как ключ документа. Это сопоставление гарантирует, что каждый большой двоичный объект будет выглядеть как отдельный документ поиска, и вы избавляете от необходимости самостоятельно создавать это сопоставление полей (как правило, автоматически сопоставляются только поля, имеющие идентичные имена и типы).

При использовании любого из перечисленных выше режимов синтаксического анализа один большой двоичный объект сопоставляется с "многими" документами поиска, что делает ключ документа исключительно на основе метаданных BLOB-объектов. Чтобы преодолеть это ограничение, Azure Когнитивный поиск способен создать ключ документа "один ко многим" для каждой отдельной сущности, извлеченной из большого двоичного объекта. Это свойство имеет имя AzureSearch_DocumentKey и добавляется к каждой отдельной сущности, извлеченной из большого двоичного объекта. Значение этого свойства гарантированно уникально для каждой отдельной сущности в больших двоичных объектах, и сущности будут отображаться как отдельные поисковые документы.

По умолчанию, если не указаны явные сопоставления полей для поля индекс ключа, с `AzureSearch_DocumentKey` помощью функции сопоставления полей сопоставляется с ним `base64Encode` .

## <a name="example"></a>Пример

Предположим, что у вас есть определение индекса со следующими полями:

+ `id`
+ `temperature`
+ `pressure`
+ `timestamp`

И контейнер больших двоичных объектов имеет большие двоичные объекты со следующей структурой:

_Blob1.jsна_

```json
{ "temperature": 100, "pressure": 100, "timestamp": "2020-02-13T00:00:00Z" }
{ "temperature" : 33, "pressure" : 30, "timestamp": "2020-02-14T00:00:00Z" }
```

_Blob2.jsна_

```json
{ "temperature": 1, "pressure": 1, "timestamp": "2019-01-12T00:00:00Z" }
{ "temperature" : 120, "pressure" : 3, "timestamp": "2017-05-11T00:00:00Z" }
```

Когда вы создаете индексатор и устанавливаете для **parsingMode** значение `jsonLines` -без указания явных сопоставлений полей для ключевого поля, следующее сопоставление будет применено неявно.

```http
{
    "sourceFieldName" : "AzureSearch_DocumentKey",
    "targetFieldName": "id",
    "mappingFunction": { "name" : "base64Encode" }
}
```

Эта установка приведет к неоднозначному получению ключей документов, как показано на следующем рисунке (код в кодировке Base64 сокращен для краткости).

| ID | Температура | давление | TIMESTAMP |
|----|-------------|----------|-----------|
| aHR0 ... ижеуаннвбжскс | 100 | 100 | 2020-02-13T00:00:00Z |
| aHR0 ... ижеуаннвбжси | 33 | 30 | 2020-02-14T00:00:00Z |
| aHR0 ... ижиуаннвбжскс | 1 | 1 | 2019-01-12T00:00:00Z |
| aHR0 ... ижиуаннвбжси | 120 | 3 | 2017-05-11T00:00:00Z |

## <a name="custom-field-mapping-for-index-key-field"></a>Сопоставление настраиваемых полей для поля ключа индекса

Предположим, что такое же определение индекса, что и в предыдущем примере, предполагает, что контейнер больших двоичных объектов содержит большие двоичные объекты со следующей структурой:

_Blob1.jsна_

```json
recordid, temperature, pressure, timestamp
1, 100, 100,"2019-02-13T00:00:00Z" 
2, 33, 30,"2019-02-14T00:00:00Z" 
```

_Blob2.jsна_

```json
recordid, temperature, pressure, timestamp
1, 1, 1,"2018-01-12T00:00:00Z" 
2, 120, 3,"2013-05-11T00:00:00Z" 
```

При создании индексатора с `delimitedText` **parsingMode** может быть естественным, чтобы настроить функцию сопоставления полей для ключевого поля следующим образом:

```http
{
    "sourceFieldName" : "recordid",
    "targetFieldName": "id"
}
```

Однако это сопоставление _не_ приведет к отображению 4 документов в индексе, так как поле не `recordid` является уникальным _для больших двоичных объектов_. Поэтому рекомендуется использовать неявное сопоставление полей, применяемое в `AzureSearch_DocumentKey` свойстве, к полю индекса ключа для режимов анализа "один ко многим".

Если вы хотите настроить явное сопоставление полей, убедитесь, что _саурцефиелд_ является уникальным для каждой отдельной сущности **во всех больших двоичных** объектах.

> [!NOTE]
> Подход, используемый для `AzureSearch_DocumentKey` обеспечения уникальности в извлеченной сущности, может изменяться, и поэтому не следует полагаться на его ценность для нужд вашего приложения.

## <a name="next-steps"></a>Дальнейшие действия

Если вы еще не знакомы с базовой структурой и рабочим процессом индексирования больших двоичных объектов, сначала следует ознакомиться [с индексацией хранилища BLOB-объектов Azure с помощью Azure когнитивный Поиск](search-howto-index-json-blobs.md) . Дополнительные сведения о режимах синтаксического анализа для различных типов содержимого BLOB-объектов см. в следующих статьях.

> [!div class="nextstepaction"]
> [Индексирование больших двоичных объектов CSV](search-howto-index-csv-blobs.md) 
>  [Индексирование больших двоичных объектов JSON](search-howto-index-json-blobs.md)
