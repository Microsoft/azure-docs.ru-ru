---
title: Простой синтаксис запросов
titleSuffix: Azure Cognitive Search
description: Справочник по синтаксису простого запроса, который используется для запросов полнотекстового поиска в Когнитивный поиск Azure.
manager: nitinme
author: brjohnstmsft
ms.author: brjohnst
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 12/14/2020
ms.openlocfilehash: f679d6fbab57bcbcccc09b722f6b2f670df49eb2
ms.sourcegitcommit: 772eb9c6684dd4864e0ba507945a83e48b8c16f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "97516578"
---
# <a name="simple-query-syntax-in-azure-cognitive-search"></a>Простой синтаксис запросов в Azure Когнитивный поиск

Когнитивный поиск Azure реализует два языка запросов на основе Lucene: [простое средство синтаксического анализа запросов](https://lucene.apache.org/core/6_6_1/queryparser/org/apache/lucene/queryparser/simple/SimpleQueryParser.html) и [средство синтаксического анализа запросов Lucene](https://lucene.apache.org/core/6_6_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html). Простой синтаксический анализатор является более гибким и попытается интерпретировать запрос, даже если он не был полностью составлен. Из-за этой гибкости это значение по умолчанию для запросов в Azure Когнитивный поиск.

Простой синтаксис используется для выражений запроса, передаваемых в **`search`** параметре запроса [поиска документов (REST API)](/rest/api/searchservice/search-documents) , не путать с [синтаксисом OData](query-odata-filter-orderby-syntax.md) , используемым для [**`$filter`**](search-filters.md) [**`$orderby`**](search-query-odata-orderby.md) выражений и в одном запросе. Параметры OData имеют разный синтаксис и правила для построения запросов, экранирования строк и т. д.

Хотя простой синтаксический анализатор основан на классе [простого средства синтаксического анализа Apache Lucene](https://lucene.apache.org/core/6_6_1/queryparser/org/apache/lucene/queryparser/simple/SimpleQueryParser.html) , реализация в когнитивный Поиск исключает нечеткий поиск. Если вам нужен [нечеткий поиск](search-query-fuzzy.md), вместо этого рассмотрите альтернативный [синтаксис полного запроса Lucene](query-lucene-syntax.md) .

## <a name="example-simple-syntax"></a>Пример (простой синтаксис)

Несмотря **`queryType`** на то, что задано ниже, это значение по умолчанию, и его можно опустить, если не выполняется возврат из альтернативного типа. Следующий пример является поиском по независимым терминам и требует, чтобы все соответствующие документы включали в себя "пул".

```http
POST https://{{service-name}}.search.windows.net/indexes/hotel-rooms-sample/docs/search?api-version=2020-06-30
{
  "queryType": "simple",
  "search": "budget hotel +pool",
  "searchMode": "all"
}
```

**`searchMode`** Параметр важен в этом примере. Каждый раз, когда в запросе используются логические операторы, следует, как правило, `searchMode=all` обеспечить соответствие *всех* критериев. В противном случае можно использовать значение по умолчанию `searchMode=any` , которое предпочитает отзыв, чем точность.

Дополнительные примеры см. в разделе [примеры простых синтаксиса запросов](search-query-simple-examples.md). Дополнительные сведения о запросе и параметрах запроса см. в разделе [Поиск документов (REST API)](/rest/api/searchservice/Search-Documents).

## <a name="keyword-search-on-terms-and-phrases"></a>Поиск по ключевым словам в терминах и фразах

Строки, передаваемые в **`search`** параметр, могут содержать термины или фразы на любом поддерживаемом языке, логических операторах, операторах очередности, символах-шаблонах или символах префикса для запросов "начинается с", escape-символов и символов кодировки URL. **`search`** Параметр является необязательным. Не указано, поиск ( `search=*` или `search=" "` ) возвращает первые 50 документов в произвольном (неранжированном) порядке.

+ *Поиск термина* — это запрос одного или нескольких терминов, где любое из условий считается совпадением.

+ *Поиск фраз* — это точная фраза, заключенная в кавычки `" "` . Например, хотя ```Roach Motel``` (без кавычек) будет искать документы, содержащие ```Roach``` и/или ```Motel``` в любом месте в любом порядке, ```"Roach Motel"``` (с кавычками) будет соответствовать только документам, содержащим всю эту фразу вместе и в этом порядке (лексическая аналитика по-прежнему применима). 

  В зависимости от клиента поиска может потребоваться экранирование кавычек в поиске фраз. Например, в запросе POST в запрос POST для поиска фразы `"Roach Motel"` в тексте запроса указывается значение `"\"Roach Motel\""` .

По умолчанию все термины или фразы, переданные в **`search`** параметре, проходят лексический анализ. Убедитесь, что вы понимаете поведение разметки анализатора, который вы используете. Часто, когда результаты запроса являются непредвиденными, причину можно отслеживать, обменяя условия при выполнении запроса.

Любой текст с одним или несколькими терминами считается допустимой отправной точкой для выполнения запроса. Когнитивный поиск Azure будет сопоставлять документы, содержащие любые или все условия, включая любые варианты, найденные во время анализа текста.

Так же, как это звучит, существует один аспект выполнения запросов в Azure Когнитивный поиск, который *может* привести к непредвиденным результатам, увеличивая, а не уменьшая результаты поиска по мере добавления в входную строку большего числа условий и операторов. Фактическое наличие этого расширения зависит от включения оператора NOT в сочетании с **`searchMode`** параметром, который определяет, как не интерпретируется в терминах поведения и или. Дополнительные сведения см. в описании оператора NOT в разделе [Boolean Operators](#boolean-operators).

## <a name="boolean-operators"></a>Логические операторы

Чтобы повысить точность совпадения, можно внедрить логические операторы в строку запроса. В простом синтаксисе логические операторы основаны на символах. Текстовые операторы, такие как слово и, не поддерживаются.

| Символ | Пример | Использование |
|----------- |--------|-------|
| `+` | `pool + ocean` | Операция и. Например, предполагает `pool + ocean` , что документ должен содержать оба условия.|
| `|` | `pool | ocean` | Операция OR находит совпадение при обнаружении одного из терминов. В этом примере обработчик запросов вернет совпадение для документов, содержащих либо или, либо и то, и `pool` `ocean` другое. Так как OR является оператором соединения по умолчанию, вы также можете его оставить, то есть `pool ocean` аналогично `pool | ocean`.|
| `-` | `pool – ocean` | Операция NOT возвращает совпадения для документов, исключая термин. <br/><br/>Чтобы получить ожидаемое поведение в выражении NOT, рассмотрите возможность установки **`searchMode=all`** для запроса. В противном случае в параметре по умолчанию **`searchMode=any`** будут получены совпадения `pool` , а также совпадения для всех документов, которые не содержат `ocean` , что может быть большим числом документов. **`searchMode`** Параметр в запросе запроса определяет, является ли термин с оператором NOT and или ORed с другими условиями в запросе (при условии, что `+` оператор OR отсутствует `|` в других терминах). Использование **`searchMode=all`** увеличивает точность запросов, включая меньше результатов, и по умолчанию интерпретируется как «and not». <br/><br/>При принятии решения о **`searchMode`** параметре следует учитывать закономерности взаимодействия с пользователем для запросов в различных приложениях. Пользователи, которые ищут информацию, скорее всего, включают оператор в запрос, а не сайты электронной коммерции с более встроенными структурами навигации. |

<a name="prefix-search"></a>

## <a name="prefix-queries"></a>Префиксные запросы

Для запросов "начинается с" добавьте оператор суффикса ( `*` ) в качестве заполнителя для оставшейся части термина. Перед добавлением оператора суффикса префиксный запрос должен начинаться по крайней мере с одним буквенно-цифровым символом.

| Символ | Пример | Использование |
|----------- |--------|-------|
| `*` | `lingui*` будет соответствовать "лингвистическим" или "лингуини" | Звездочка ( `*` ) представляет один или несколько символов произвольной длины без учета регистра.  |

Как и в случае с фильтрами, запрос префикса выполняет поиск точного совпадения. Таким образом, не существует оценки релевантности (все результаты получают оценку 1,0). Имейте в виду, что запросы с префиксом могут выполняться очень часто, особенно если индекс большой, а префикс состоит из небольшого числа символов. Альтернативная методология, например, разметка маркера в виде n-грамматики, может выполняться быстрее.

Простой синтаксис поддерживает только сопоставление префиксов. Для суффикса или инфиксные, соответствующего концу или середине условия, используйте [полный синтаксис Lucene для поиска с подстановочными знаками](query-lucene-syntax.md#bkmk_wildcard).

## <a name="escaping-search-operators"></a>Поисковые операторы экранирования  

В простом синтаксисе операторы поиска включают следующие символы: `+ | " ( ) ' \`  

Если какой-либо из этих символов является частью токена в индексе, необходимо построчно исправить его, добавив в запрос одну обратную косую черту ( `\` ). Например, предположим, что вы использовали пользовательский анализатор для разметки всего термина, а индекс содержит строку "люкс + гостиницы". Чтобы получить точное соответствие для этого маркера, вставьте escape-символ: `search=luxury\+hotel` .

Для упрощения более типичных случаев существует два исключения из этого правила, в которых не требуется экранирование.  

+ Оператор NOT `-` должен быть экранированным только в том случае, если он является первым символом после пробела. Если `-` отображается в середине (например, в `3352CDD0-EF30-4A2E-A512-3B30AF40F3FD` ), можно пропустить экранирование.

+ Оператор суффикса `*` должен быть экранированным только в том случае, если он является последним символом перед пробелом. Если `*` отображается в середине (например, в `4*4=16` ), экранирование не требуется.

> [!NOTE]  
> По умолчанию стандартный анализатор удалит и разбивает слова на дефисы, пробелы, амперсанды и другие символы во время [лексического анализа](search-lucene-query-architecture.md#stage-2-lexical-analysis). Если требуется, чтобы в строке запроса оставались специальные символы, может потребоваться анализатор, сохраняющий их в индексе. К некоторым вариантам относятся [анализаторы](index-add-language-analyzers.md)естественного языка (Майкрософт), которые сохраняют перенос слов или пользовательский анализатор для более сложных шаблонов. Дополнительные сведения см. в разделе [частичные термины, шаблоны и специальные символы](search-query-partial-matching.md).

## <a name="encoding-unsafe-and-reserved-characters-in-urls"></a>Кодирование небезопасных и зарезервированных знаков в URL-адресах

Убедитесь, что все ненадежные и зарезервированные символы кодируются в URL-адресе. Например, "#" является ненадежным символом, так как он является идентификатором фрагмента или привязки в URL-адресе. Знак должен быть закодирован как `%23`, если он используется в URL-адресе. "&" и "=" являются примерами зарезервированных символов, так как они разделяют параметры и указывают значения в Когнитивный поиск Azure. Дополнительные сведения см. в разделе [RFC1738: унифицированные указатели ресурсов (URL-адрес)](https://www.ietf.org/rfc/rfc1738.txt).

Небезопасными знаками являются: ``" ` < > # % { } | \ ^ ~ [ ]``. Зарезервированными знаками являются: `; / ? : @ = + &`.

## <a name="special-characters"></a>Специальные символы

В некоторых случаях может потребоваться найти специальный символ, например "❤" эмодзи или символ "€". В таких случаях убедитесь, что используемый анализатор не фильтрует эти символы. Стандартный анализатор обходит многие специальные символы, исключая их из индекса.

Анализаторы, которые подделят специальные символы, включают анализатор пробелов, который учитывает все последовательности символов, разделенные пробелами, как токены (поэтому строка "❤" будет считаться маркером). Кроме того, анализатор языка, такой как Microsoft English Analyzer ("en. Microsoft"), принимает строку "€" в качестве маркера. Анализатор можно [проверить](/rest/api/searchservice/test-analyzer) , чтобы узнать, какие маркеры он создает для данного запроса.

При использовании символов Юникода убедитесь, что символы правильно экранированы в URL-адресе запроса (например, для "❤" будет использовать управляющую последовательность `%E2%9D%A4+` ). После этого трансляция выполняется автоматически.  

## <a name="precedence-grouping"></a>Приоритет (группирование)

Вы можете использовать круглые скобки, чтобы создать вложенные запросы, включая операторы в заключенной в скобки инструкции. Например, `motel+(wifi|luxury)` будет выполнять поиск документов, содержащих термин "motel" и "wifi" или "luxury" (или оба).

## <a name="query-size-limits"></a>Ограничения размера запроса

Если приложение создает поисковые запросы программным способом, рекомендуется разрабатывать его таким образом, чтобы оно не создавало запросы неограниченного размера. 

+ Для GET длина URL-адреса не должна превышать 8 КБ.

+ Для POST (и любого другого запроса), где текст запроса включает `search` и другие параметры, такие как `filter` и `orderby` , максимальный размер равен 16 МБ, где максимальное число предложений в `search` (выражения, разделенные с помощью and, OR и т. д.) равно 1024. Кроме того, размер любого отдельного термина в запросе не может превышать 32 КБ. Дополнительные сведения см. в разделе [ограничения запросов API](search-limits-quotas-capacity.md#api-request-limits).

## <a name="next-steps"></a>Дальнейшие действия

Если вы будете создавать запросы программно, ознакомьтесь с [полнотекстовым поиском в когнитивный Поиск Azure](search-lucene-query-architecture.md) , чтобы понять этапы обработки запросов и влияние анализа текста.

Дополнительные сведения о построении запросов см. в следующих статьях:

+ [Примеры запросов для простого поиска](search-query-simple-examples.md)
+ [Примеры запросов для полного поиска в Lucene](search-query-lucene-examples.md)
+ [Search Documents (Azure Search Service REST API)](/rest/api/searchservice/Search-Documents) (Поиск по документам (REST API службы поиска Azure))
+ [Синтаксис запросов Lucene](query-lucene-syntax.md)
+ [Синтаксис выражений Filter и SELECT (OData)](query-odata-filter-orderby-syntax.md)