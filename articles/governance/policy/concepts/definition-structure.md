---
title: Сведения о структуре определения политики
description: Описывает, как определения политик используются для установки соглашений о ресурсах Azure в организации.
ms.date: 02/17/2021
ms.topic: conceptual
ms.openlocfilehash: 741cfce56554e05d0c5f5a9242a33502b8a6fbe6
ms.sourcegitcommit: c27a20b278f2ac758447418ea4c8c61e27927d6a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/03/2021
ms.locfileid: "101699425"
---
# <a name="azure-policy-definition-structure"></a>Структура определения службы "Политика Azure"

Политика Azure устанавливает соглашения о ресурсах. Определения политик описывают соответствие ресурсов [условия](#conditions) и последствия выполнения условий. Условие сравнивает [поле](#fields) свойства ресурса или [значение](#value) с требуемым значением. Доступ к полям свойств ресурсов осуществляется с помощью [псевдонимов](#aliases). Если поле свойства ресурса является массивом, Специальный [псевдоним массива](#understanding-the--alias) можно использовать для выбора значений из всех элементов массива и применения условия к каждому из них. Дополнительные сведения об [условиях](#conditions).

Это соглашения помогут вам контролировать расходы и управлять ресурсами. Например, можно указать, что разрешены только определенные типы виртуальных машин. Также можно потребовать, чтобы ресурсы имели определенный тег. Назначения политики наследуются дочерними ресурсами. Если назначение политики применяется к группе ресурсов, оно применяется ко всем ресурсам в этой группе ресурсов.

Схема определения политики _класс policyrule_ находится здесь: [https://schema.management.azure.com/schemas/2019-09-01/policyDefinition.json](https://schema.management.azure.com/schemas/2019-09-01/policyDefinition.json)

Для создания определения политики используется JSON. Определение политики содержит следующие элементы:

- display name
- description
- mode
- метаданные
- parameters
- policy rule
  - logical evaluation
  - effect

В следующем примере JSON показана политика, которая налагает ограничения на расположения для развертывания ресурсов.

```json
{
    "properties": {
        "displayName": "Allowed locations",
        "description": "This policy enables you to restrict the locations your organization can specify when deploying resources.",
        "mode": "Indexed",
        "metadata": {
            "version": "1.0.0",
            "category": "Locations"
        },
        "parameters": {
            "allowedLocations": {
                "type": "array",
                "metadata": {
                    "description": "The list of locations that can be specified when deploying resources",
                    "strongType": "location",
                    "displayName": "Allowed locations"
                },
                "defaultValue": [ "westus2" ]
            }
        },
        "policyRule": {
            "if": {
                "not": {
                    "field": "location",
                    "in": "[parameters('allowedLocations')]"
                }
            },
            "then": {
                "effect": "deny"
            }
        }
    }
}
```

Встроенные и шаблоны политики Azure приведены в [примерах политики Azure](../samples/index.md).

## <a name="display-name-and-description"></a>Отображаемое имя и описание

Параметры **displayName** и **description** позволяют идентифицировать определение политики и описать контекст для ее использования. Максимальная длина **displayName** составляет _128_ символов, а **description** — _512_ символов.

> [!NOTE]
> Во время создания или обновления определения политики **идентификатор**, **тип** и **имя** определяются свойствами, которые являются внешними по отношению к JSON и не обязательны в JSON-файле. Выборка определения политики с помощью пакета SDK возвращает **идентификатор**, **тип** и **имя** свойства как часть JSON, но все они являются сведениями только для чтения, относящимися к определению политики.

## <a name="type"></a>Тип

Хотя свойство **Type** не может быть задано, пакет SDK возвращает три значения, которые отображаются на портале:

- `Builtin`: Эти определения политик предоставляются и обслуживаются корпорацией Майкрософт.
- `Custom`: Все определения политик, созданные клиентами, имеют это значение.
- `Static`: Указывает определение политики [соответствия нормативным требованиям](./regulatory-compliance.md) с **владением** Майкрософт. Результаты проверки соответствия для этих определений политик являются результатами сторонних аудитов в инфраструктуре Майкрософт. В портал Azure это значение иногда отображается как **управляемое корпорацией Майкрософт**. Дополнительные сведения см. [в разделе Общая ответственность в облаке](../../../security/fundamentals/shared-responsibility.md).

## <a name="mode"></a>Режим

**Режим** настраивается в зависимости от того, нацелена ли политика на свойство Azure Resource Manager или на свойство поставщика ресурсов.

### <a name="resource-manager-modes"></a>Режимы Resource Manager

Этот **режим** определяет, какие типы ресурсов оцениваются для определения политики. Ниже приведены поддерживаемые режимы.

- `all`: оцениваются группы ресурсов, подписки и все типы ресурсов.
- `indexed`: оцениваются только типы ресурсов, которые поддерживают теги и расположение.

Например, ресурс `Microsoft.Network/routeTables` поддерживает теги и расположение и оценивается в обоих режимах. Однако ресурс `Microsoft.Network/routeTables/routes` нельзя помечать тегами и он не оценивается в режиме `Indexed`.

В большинстве случаев рекомендуется задать для параметра **mode** значение `all`. Во всех определениях политик, создаваемых на портале, используется режим `all`. Если используется PowerShell или Azure CLI, необходимо указать параметр **mode** вручную. Если определение политики не включает значение **mode**, в Azure PowerShell используется значение по умолчанию `all`, а в Azure CLI — `null`. Режим `null` является тем же, что и при использовании `indexed` для поддержки обратной совместимости.

`indexed` следует использовать при создании политик, которые будут принудительно применять теги или расположения. Это не обязательно, но помешает отображению ресурсов, которые не поддерживают теги и расположения, в качестве несоответствующих в результатах проверки соответствия. Исключением являются **группы ресурсов** и **подписки**. В определениях политик, которые принудительно применяют расположение или теги к группе ресурсов или подписке, следует задать для параметра **mode** значение `all` и явно указать целевой тип `Microsoft.Resources/subscriptions/resourceGroups` или `Microsoft.Resources/subscriptions`. Пример см. в разделе [Шаблон. Теги — пример#1](../samples/pattern-tags.md). Список ресурсов, поддерживающих теги, см. в разделе [Поддержка тегов для ресурсов Azure](../../../azure-resource-manager/management/tag-support.md).

### <a name="resource-provider-modes"></a>Режимы поставщиков ресурсов

Поддерживается следующий режим поставщика ресурсов:

- `Microsoft.Kubernetes.Data` для управления кластерами Kubernetes в Azure или вне Azure. В определениях, использующих этот режим поставщика ресурсов, используются эффекты _Audit_, _Deny_ и _disabled_. Использование влияния [енфорцеопаконстраинт](./effects.md#enforceopaconstraint) является _устаревшим_.

В настоящее время в качестве **предварительной версии** поддерживаются следующие режимы поставщика ресурсов:

- `Microsoft.ContainerService.Data` для управления правилами контроллера допуска в [Службе Azure Kubernetes](../../../aks/intro-kubernetes.md). Определения, использующие этот режим поставщика ресурсов, **должны** использовать [енфорцерегополициный](./effects.md#enforceregopolicy) результат. Этот режим является _устаревшим_.
- `Microsoft.KeyVault.Data` для управления хранилищами и сертификатами в [Azure Key Vault](../../../key-vault/general/overview.md). Дополнительные сведения об этих определениях политик см. в статье [интеграция Azure Key Vault с политикой Azure](../../../key-vault/general/azure-policy.md).

> [!NOTE]
> Режимы поставщиков ресурсов поддерживают только встроенные определения политик и не поддерживают [исключения](./exemption-structure.md).

## <a name="metadata"></a>Метаданные

Необязательное `metadata` свойство сохраняет сведения об определении политики. Клиенты могут определять любые свойства и значения, полезные для Организации в `metadata` . Однако существуют некоторые _Общие_ свойства, используемые политикой Azure и встроенными модулями. Длина каждого `metadata` Свойства ограничена 1024 символами.

### <a name="common-metadata-properties"></a>Общие свойства метаданных

- `version` (строка): отслеживает сведения о версии содержимого определения политики.
- `category` (строка): определяет, в какой категории в портал Azure отображается определение политики.
- `preview` (Boolean): флаг true или false для параметра, если определение политики является _предварительным_.
- `deprecated` (Boolean): флаг true или false для, если определение политики помечено как _нерекомендуемое_.

> [!NOTE]
> Служба Политика Azure использует свойства `version`, `preview` и `deprecated` для передачи уровня изменений встроенному определению политики или инициативе и состоянию. Формат `version` — `{Major}.{Minor}.{Patch}`. Конкретные состояния, такие как _устаревший_ или _предварительная версия_, добавляются к свойству `version` или в другом свойстве как **логическое значение**. Дополнительные сведения о способах встроенных версий политик Azure см. в разделе [Встроенная поддержка версий](https://github.com/Azure/azure-policy/blob/master/built-in-policies/README.md).

## <a name="parameters"></a>Параметры

Параметры помогают упростить управление политиками за счет сокращения числа определений политик. Параметры можно рассматривать как поля в форме: `name`, `address`, `city`, `state`. Эти параметры никогда не меняются, однако их значения изменяются в зависимости от того, как пользователь заполняет форму.
Точно так же параметры работают при создании политик. Добавив параметры в определение политики, вы сможете повторно использовать ее в различных сценариях, указывая разные значения.

> [!NOTE]
> Параметры могут быть добавлены к имеющемуся и назначенному определению. Новый параметр должен включать в себя свойство **defaultValue**. Это предотвращает косвенное использование существующих назначений политики или инициативы.

### <a name="parameter-properties"></a>Свойства параметра

Параметр имеет следующие свойства, которые используются в определении политики:

- `name`: Имя параметра. Используется функцией развертывания `parameters` в правиле политики. Дополнительные сведения см. в разделе [об использовании значения параметра](#using-a-parameter-value).
- `type`: Определяет, является ли параметр **строкой**, **массивом**, **объектом**, **логическим значением**, **целым числом**, **числом с плавающей запятой** или **значением даты/времени**.
- `metadata`: Определяет вложенное свойство, которое в основном используется для отображения понятной пользователям информации на портале Azure:
  - `description`: Объясняет назначение параметра. Можно использовать для примеров допустимых значений.
  - `displayName`: Понятное имя параметра, которое отображается на портале.
  - `strongType`: (Необязательно.) Используется при назначении определения политики через портал. Предоставляет список с учетом контекста. См. дополнительные сведения о [вложенном свойстве strongType](#strongtype).
  - `assignPermissions`: (Необязательно.) Установите на _true_, чтобы портал Azure создавал назначения ролей во время назначения политики. Это свойство полезно, если вы хотите назначить разрешения за пределами области назначения. Для каждого определения роли в политике (или определении роли во всех политиках в этой инициативе) существует одно назначение роли. Значение параметра должно быть допустимым ресурсом или областью.
- `defaultValue`: (Необязательно.) Устанавливает значение параметра в назначении, если значение не указано.
  Это свойство необходимо при обновлении существующего назначенного определения политики.
- `allowedValues`: (Необязательно.) Предоставляет массив значений, которые параметр принимает во время назначения.

Например, можно создать определение политики, чтобы ограничить расположения, в которых могут развертываться ресурсы. Для такого определения политики можно использовать параметр **allowedLocations**. Этот параметр будет использоваться каждым назначением определения политики для ограничения допустимых значений. Использование вложенного свойства **strongType** делает назначение через портал более удобным:

```json
"parameters": {
    "allowedLocations": {
        "type": "array",
        "metadata": {
            "description": "The list of allowed locations for resources.",
            "displayName": "Allowed locations",
            "strongType": "location"
        },
        "defaultValue": [ "westus2" ],
        "allowedValues": [
            "eastus2",
            "westus2",
            "westus"
        ]
    }
}
```

### <a name="using-a-parameter-value"></a>Использование значения параметра

В правилах политики полученные параметры используются со следующим синтаксисом функции `parameters`.

```json
{
    "field": "location",
    "in": "[parameters('allowedLocations')]"
}
```

В этом примере используется параметр **allowedLocations**, который рассматривался в разделе о [свойствах параметра](#parameter-properties).

### <a name="strongtype"></a>strongType

В свойстве `metadata` можно использовать вложенное свойство **strongType**, чтобы предоставить список для выбора параметров на портале Azure. **strongType** может быть поддерживаемым _типом ресурса_ или допустимым значением. Чтобы определить, допустим ли _тип ресурса_ для **strongType**, используйте [Get-AzResourceProvider](/powershell/module/az.resources/get-azresourceprovider). Для _типа ресурса_ **стронгтипе** имеет формат `<Resource Provider>/<Resource Type>` . Например, `Microsoft.Network/virtualNetworks/subnets`.

Некоторые поддерживаемые _типы ресурсов_ **Get-AzResourceProvider** не возвращает. Эти типы:

- `Microsoft.RecoveryServices/vaults/backupPolicies`

Допустимыми значениями, помимо _типов ресурсов_ для **strongType**, являются следующие.

- `location`
- `resourceTypes`
- `storageSkus`
- `vmSKUs`
- `existingResourceGroups`

## <a name="definition-location"></a>Расположение определения

При создании инициативы или политики необходимо указывать расположение определения. Расположение определения должно быть задано как группа управления или подписка. Расположение указывает область, которой можно назначить инициативу или политику. Ресурсы должны быть непосредственными членами или дочерними элементами в иерархии расположения определения для назначения.

Если расположение определения является

- Только для **подписки** на ресурсы в этой подписке можно назначить определение политики.
- Определение политики может быть назначено только для ресурсов **группы** управления в дочерних группах управления и дочерних подписках. Если вы планируете применить определение политики к нескольким подпискам, расположение должно быть группой управления, содержащей каждую подписку.

Дополнительные сведения см. [в разделе сведения о области в политике Azure](./scope.md#definition-location).

## <a name="policy-rule"></a>Правило политики

Правило политики состоит из блоков **If** и **Then**. В блоке **If** указываются одно или несколько условий. Они определяют, когда применяется эта политика. В этих условиях можно использовать логические операторы, чтобы точно определить сценарии для использования политики.

В блоке **Then** описываются результаты, которые вступают в силу при соблюдении условий из блока **If**.

```json
{
    "if": {
        <condition> | <logical operator>
    },
    "then": {
        "effect": "deny | audit | modify | append | auditIfNotExists | deployIfNotExists | disabled"
    }
}
```

### <a name="logical-operators"></a>Логические операторы

Ниже перечислены поддерживаемые логические операторы.

- `"not": {condition  or operator}`
- `"allOf": [{condition or operator},{condition or operator}]`
- `"anyOf": [{condition or operator},{condition or operator}]`

Оператор **not** инвертирует результат условия. Оператор **allOf** действует как логическая операция **And**, то есть требует соблюдения всех входящих в него условий. Оператор **anyOf** действует как логическая операция **Or**, то есть проверяет соблюдение хотя бы одного из входящих в него условий.

Допускается вложение логических операторов. В следующем примере представлена операция **not**, вложенная в операцию **allOf**.

```json
"if": {
    "allOf": [{
            "not": {
                "field": "tags",
                "containsKey": "application"
            }
        },
        {
            "field": "type",
            "equals": "Microsoft.Storage/storageAccounts"
        }
    ]
},
```

### <a name="conditions"></a>Условия

Условие проверяет, соответствует ли значение определенным критериям. Поддерживаются такие условия:

- `"equals": "stringValue"`
- `"notEquals": "stringValue"`
- `"like": "stringValue"`
- `"notLike": "stringValue"`
- `"match": "stringValue"`
- `"matchInsensitively": "stringValue"`
- `"notMatch": "stringValue"`
- `"notMatchInsensitively": "stringValue"`
- `"contains": "stringValue"`
- `"notContains": "stringValue"`
- `"in": ["stringValue1","stringValue2"]`
- `"notIn": ["stringValue1","stringValue2"]`
- `"containsKey": "keyName"`
- `"notContainsKey": "keyName"`
- `"less": "dateValue"` | `"less": "stringValue"` | `"less": intValue`
- `"lessOrEquals": "dateValue"` | `"lessOrEquals": "stringValue"` | `"lessOrEquals": intValue`
- `"greater": "dateValue"` | `"greater": "stringValue"` | `"greater": intValue`
- `"greaterOrEquals": "dateValue"` | `"greaterOrEquals": "stringValue"` |
  `"greaterOrEquals": intValue`
- `"exists": "bool"`

Для **less**, **lessOrEquals**, **greater** и **greaterOrEquals**, если тип свойства не совпадает с типом условия, выдается ошибка. Сравнение строк выполняется с помощью `InvariantCultureIgnoreCase`.

При использовании условий **like** и **notLike** можно указать в значении подстановочный знак `*`. Значение не должно содержать более одного подстановочного знака `*`.

При использовании условий **match** и **notMatch** укажите `#` для сопоставления цифры, `?` для буквы, `.` для сопоставления любого знака и любой другой знак для сопоставления соответствующего фактического знака. Хотя **Match** и **notMatch** учитывают регистр, все остальные условия, в которых вычисляется _StringValue_ , не учитывают регистр. Другие варианты без учета регистра доступны для условий **matchInsensitively** и **notMatchInsensitively**.

### <a name="fields"></a>Поля

Условия, определяющие, могут ли значения свойств в полезных данных запроса ресурса соответствовать определенным критериям, можно формировать с помощью выражения **поля** . Поддерживаются следующие поля.

- `name`
- `fullName`
  - Возвращает полное имя ресурса. Полное имя ресурса — это имя ресурса, к которому добавлены любые имена родительских ресурсов (например, myServer/myDatabase).
- `kind`
- `type`
- `location`
  - Поля расположения нормализованы для поддержки различных форматов. Например, `East US 2` считается равным `eastus2` .
  - Используйте **global** для ресурсов, которые зависят от расположения.
- `id`
  - Возвращает идентификатор ресурса, для которого выполняется оценка.
  - Например, `/subscriptions/06be863d-0996-4d56-be22-384767287aa2/resourceGroups/myRG/providers/Microsoft.KeyVault/vaults/myVault`.
- `identity.type`
  - Возвращает тип [управляемого удостоверения](../../../active-directory/managed-identities-azure-resources/overview.md), включенный в ресурс.
- `tags`
- `tags['<tagName>']`
  - Этот синтаксис в скобках поддерживает имена тегов, которые содержат такие знаки препинания, как дефис, точку или пробел.
  - Где **\<tagName\>** — имя тега, для которого проверяется условие.
  - Пример: `tags['Acct.CostCenter']`. **Acct.CostCenter** — это имя тега.
- `tags['''<tagName>''']`
  - Этот синтаксис в скобках поддерживает имена тегов, которые содержат апострофы благодаря использованию двойного апострофа.
  - Где **" \<tagName\> "** — это имя тега, для которого проверяется условие.
  - Пример: `tags['''My.Apostrophe.Tag''']`, где **'My.Apostrophe.Tag'** является именем тега.
- Список псевдонимов свойств указан в разделе [Псевдонимы](#aliases).

> [!NOTE]
> `tags.<tagName>`, `tags[tagName]` и `tags[tag.with.dots]` все еще являются приемлемыми способами объявления поля тегов. Однако предпочтительными являются выражения, указанные выше.

> [!NOTE]
> В выражениях **полей** , ссылающихся на **\[ \* \] псевдоним**, каждый элемент массива вычисляется отдельно с помощью логического **и** между элементами. Дополнительные сведения см. в разделе [ссылки на свойства ресурсов массива](../how-to/author-policies-for-arrays.md#referencing-array-resource-properties).

#### <a name="use-tags-with-parameters"></a>Использование тегов с параметрами

Значение параметра передается полю тега. Передача параметра полю тега повышает гибкость определения политики во время ее назначения.

В указанном ниже примере `concat` используется для создания поля подстановки тега для тега со значением параметра **tagName**. Если такой тег не существует, то с помощью действия **modify** добавляется тег, использующий значение тега с таким же именем, заданным для проверенной родительской группы ресурсов с помощью функции поиска `resourcegroup()`.

```json
{
    "if": {
        "field": "[concat('tags[', parameters('tagName'), ']')]",
        "exists": "false"
    },
    "then": {
        "effect": "modify",
        "details": {
            "operations": [{
                "operation": "add",
                "field": "[concat('tags[', parameters('tagName'), ']')]",
                "value": "[resourcegroup().tags[parameters('tagName')]]"
            }],
            "roleDefinitionIds": [
                "/providers/microsoft.authorization/roleDefinitions/4a9ae827-6dc8-4573-8ac7-8239d42aa03f"
            ]
        }
    }
}
```

### <a name="value"></a>Значение

Условия, которые оценивают, соответствует ли значение определенным критериям, могут быть сформированы с помощью выражения **значения** . Значения могут быть литералами, значениями [параметров](#parameters)или возвращаемыми значениями всех [поддерживаемых функций шаблонов](#policy-functions).

> [!WARNING]
> Если результатом _функции шаблона_ является ошибка, оценка политики завершится сбоем. Завершившаяся сбоем оценка — это неявный **запрет**. Дополнительные сведения см. в разделе [Аvoiding template failures](#avoiding-template-failures) (Предотвращение сбоев шаблонов). Используйте [enforcementMode](./assignment-structure.md#enforcement-mode) **DoNotEnforce**, чтобы исключить влияние неудачной оценки на новые или обновленные ресурсы при тестировании и проверке нового определения политики.

#### <a name="value-examples"></a>Примеры значений

В этом примере правила политики используют **value** для сравнения результата функции `resourceGroup()` и возвращенного свойства **name** с условием **like** для `*netrg`. Это правило запрещает любой ресурс, с **типом**, отличающимся от `Microsoft.Network/*`, в любой группе ресурсов, имя которой заканчивается на `*netrg`.

```json
{
    "if": {
        "allOf": [{
                "value": "[resourceGroup().name]",
                "like": "*netrg"
            },
            {
                "field": "type",
                "notLike": "Microsoft.Network/*"
            }
        ]
    },
    "then": {
        "effect": "deny"
    }
}
```

В этом примере правила политики используют **value** (значение) для проверки того, **равен** ли `true` результат нескольких вложенных функций. Это правило запрещает любой ресурс, в котором нет хотя бы трех тегов.

```json
{
    "mode": "indexed",
    "policyRule": {
        "if": {
            "value": "[less(length(field('tags')), 3)]",
            "equals": "true"
        },
        "then": {
            "effect": "deny"
        }
    }
}
```

#### <a name="avoiding-template-failures"></a>Предотвращение сбоев шаблонов

Использование _функций шаблона_ в **value** позволяет выполнять многие сложные вложенные функции. Если результатом _функции шаблона_ является ошибка, оценка политики завершится сбоем. Завершившаяся сбоем оценка — это неявный **запрет**. Пример **value**, которое приводит к сбою в некоторых сценариях.

```json
{
    "policyRule": {
        "if": {
            "value": "[substring(field('name'), 0, 3)]",
            "equals": "abc"
        },
        "then": {
            "effect": "audit"
        }
    }
}
```

В примере правила политики выше используется [substring()](../../../azure-resource-manager/templates/template-functions-string.md#substring) для сравнения первых трех символов **имени** с **abc**. Если **имя** короче трех символов, то функция `substring()` приводит к ошибке. Эта ошибка приводит к тому, что политика становится действием **deny**.

Вместо этого используйте функцию [if()](../../../azure-resource-manager/templates/template-functions-logical.md#if), чтобы проверить, совпадают ли первые три символа **имени** с **abc**, не давая **имени** короче трех символов вызывать ошибку.

```json
{
    "policyRule": {
        "if": {
            "value": "[if(greaterOrEquals(length(field('name')), 3), substring(field('name'), 0, 3), 'not starting with abc')]",
            "equals": "abc"
        },
        "then": {
            "effect": "audit"
        }
    }
}
```

С измененным правилом политики `if()` проверяет длину **имени** перед попыткой получить `substring()` для значения с менее чем тремя символами. Если **имя** слишком коротко, то возвращается значение «не начинается с abc», которое затем сравнивается с **abc**. Ресурс с коротким именем, которое не начинается с **abc**, по-прежнему не выполняет правило политики, но больше не вызывает ошибку во время оценки.

### <a name="count"></a>Count

Условия, которые подсчитывает количество элементов массива, удовлетворяющих определенным критериям, можно формировать с помощью выражения **Count** . Распространенными сценариями является проверка того, что "хотя бы один из", "только один из", "все" или "ни одного из" элементов массива не удовлетворяет условию. Функция **Count** вычисляет каждый элемент массива для выражения условия и суммирует _истинные_ результаты, которые затем сравниваются с оператором выражения.

#### <a name="field-count"></a>Число полей

Подсчитайте, сколько элементов массива в полезных данных запроса удовлетворяет условию выражения. Структура выражений **подсчета полей** :

```json
{
    "count": {
        "field": "<[*] alias>",
        "where": {
            /* condition expression */
        }
    },
    "<condition>": "<compare the count of true condition expression array members to this value>"
}
```

Со **счетчиком полей** используются следующие свойства:

- **count.field** (обязательное): содержит путь к массиву и должно быть псевдонимом массива.
- **Count. Where** (необязательно): выражение условия для индивидуального вычисления для каждого члена массива [ \[ \* \] псевдонимов](#understanding-the--alias) `count.field` . Если это свойство не указано, все элементы массива с путем "Field" оцениваются в _значение true_. В этом свойстве можно использовать любое [condition](../concepts/definition-structure.md#conditions) (условие).
  Внутри этого свойства можно использовать [логические операторы](#logical-operators) для создания сложных требований к оценке.
- **\<condition\>** (обязательно): значение сравнивается с числом элементов, которые соответствуют условному выражению **Count. Where** . Следует использовать числовое [condition](../concepts/definition-structure.md#conditions).

Выражения **счетчика полей** позволяют перечислить один массив полей до трех раз в одном определении **класс policyrule** .

Дополнительные сведения о работе со свойствами массива в политике Azure, включая подробное объяснение того, как вычисляется выражение **счетчика полей** , см. в разделе [свойства ресурса массива ссылок](../how-to/author-policies-for-arrays.md#referencing-array-resource-properties).

#### <a name="value-count"></a>Число значений

Подсчитайте, сколько элементов массива удовлетворяет условию. Массив может быть литеральным массивом или [ссылкой на параметр массива](#using-a-parameter-value). Структура выражений **счетчика значений** имеет следующие значения:

```json
{
    "count": {
        "value": "<literal array | array parameter reference>",
        "name": "<index name>",
        "where": {
            /* condition expression */
        }
    },
    "<condition>": "<compare the count of true condition expression array members to this value>"
}
```

Следующие свойства используются со **счетчиком значений**:

- **Count. Value** (обязательно): вычисляемый массив.
- **Count.Name** (обязательно): имя индекса, состоящее из букв и цифр английского языка. Определяет имя для значения члена массива, вычисленного в текущей итерации. Имя используется для ссылки на текущее значение внутри `count.where` условия. Необязательно, если выражение **Count** не находится в дочернем элементе другого выражения **Count** . Если не указано, имя индекса неявно устанавливается в значение `"default"` .
- **Count. Where** (необязательно): выражение условия для отдельного вычисления для каждого члена массива `count.value` . Если это свойство не указано, все члены массива оцениваются как _true_. В этом свойстве можно использовать любое [condition](../concepts/definition-structure.md#conditions) (условие). Внутри этого свойства можно использовать [логические операторы](#logical-operators) для создания сложных требований к оценке. Значение доступного для перечисления члена массива можно получить, вызвав [текущую](#the-current-function) функцию.
- **\<condition\>** (обязательно): значение сравнивается с числом элементов, удовлетворяющих `count.where` условию выражения. Следует использовать числовое [condition](../concepts/definition-structure.md#conditions).

Применяются следующие ограничения.
- В одном определении **класс policyrule** можно использовать до 10 выражений **количества значений** .
- Каждое выражение **числа значений** может выполнять до 100 итераций. Это число включает число итераций, выполненных любыми родительскими выражениями **счетчика значений** .

#### <a name="the-current-function"></a>Текущая функция

`current()`Функция доступна только внутри `count.where` условия. Он возвращает значение члена массива, перечисленного в данный момент при вычислении выражения **Count** .

**Использование количества значений**

- `current(<index name defined in count.name>)`. Например: `current('arrayMember')`.
- `current()`. Допускается только в том случае, если выражение **счетчика значений** не является дочерним по отношению к другому выражению **Count** . Возвращает то же значение, что и выше.

Если значение, возвращаемое вызовом, является объектом, то поддерживаются методы доступа к свойствам. Например: `current('objectArrayMember').property`.

**Использование счетчика полей**

- `current(<the array alias defined in count.field>)`. Например, `current('Microsoft.Test/resource/enumeratedArray[*]')`.
- `current()`. Допускается только в том случае, если выражение **числа полей** не является дочерним по отношению к другому выражению **Count** . Возвращает то же значение, что и выше.
- `current(<alias of a property of the array member>)`. Например, `current('Microsoft.Test/resource/enumeratedArray[*].property')`.

#### <a name="field-count-examples"></a>Примеры количества полей

Пример 1: Проверить, является ли массив пустым.

```json
{
    "count": {
        "field": "Microsoft.Network/networkSecurityGroups/securityRules[*]"
    },
    "equals": 0
}
```

Пример 2. Проверять только один элемент массива на соответствие выражению условия.

```json
{
    "count": {
        "field": "Microsoft.Network/networkSecurityGroups/securityRules[*]",
        "where": {
            "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].description",
            "equals": "My unique description"
        }
    },
    "equals": 1
}
```

Пример 3. Проверить хотя бы один элемент массива на соответствие выражению условия.

```json
{
    "count": {
        "field": "Microsoft.Network/networkSecurityGroups/securityRules[*]",
        "where": {
            "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].description",
            "equals": "My common description"
        }
    },
    "greaterOrEquals": 1
}
```

Пример 4. Убедиться, что все члены массива объектов соответствуют выражению условия.

```json
{
    "count": {
        "field": "Microsoft.Network/networkSecurityGroups/securityRules[*]",
        "where": {
            "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].description",
            "equals": "description"
        }
    },
    "equals": "[length(field('Microsoft.Network/networkSecurityGroups/securityRules[*]'))]"
}
```

Пример 5. Проверка того, что хотя бы один элемент массива соответствует нескольким свойствам в выражении условия

```json
{
    "count": {
        "field": "Microsoft.Network/networkSecurityGroups/securityRules[*]",
        "where": {
            "allOf": [
                {
                    "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].direction",
                    "equals": "Inbound"
                },
                {
                    "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].access",
                    "equals": "Allow"
                },
                {
                    "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].destinationPortRange",
                    "equals": "3389"
                }
            ]
        }
    },
    "greater": 0
}
```

Пример 6. Использование `current()` функции внутри `where` условий для доступа к значению перечисленного члена массива в функции-шаблоне. Это условие проверяет, содержит ли виртуальная сеть префикс адреса, который не входит в диапазон CIDR/24.

```json
{
    "count": {
        "field": "Microsoft.Network/virtualNetworks/addressSpace.addressPrefixes[*]",
        "where": {
          "value": "[ipRangeContains('10.0.0.0/24', current('Microsoft.Network/virtualNetworks/addressSpace.addressPrefixes[*]'))]",
          "equals": false
        }
    },
    "greater": 0
}
```

Пример 7. Использование `field()` функции внутри `where` условий для доступа к значению члена массива, перечисленного в данный момент. Это условие проверяет, содержит ли виртуальная сеть префикс адреса, который не входит в диапазон CIDR/24.

```json
{
    "count": {
        "field": "Microsoft.Network/virtualNetworks/addressSpace.addressPrefixes[*]",
        "where": {
          "value": "[ipRangeContains('10.0.0.0/24', first(field(('Microsoft.Network/virtualNetworks/addressSpace.addressPrefixes[*]')))]",
          "equals": false
        }
    },
    "greater": 0
}
```

#### <a name="value-count-examples"></a>Примеры количества значений

Пример 1. Проверка совпадения имени ресурса с любым из заданных шаблонов имен.

```json
{
    "count": {
        "value": [ "prefix1_*", "prefix2_*" ],
        "name": "pattern",
        "where": {
            "field": "name",
            "like": "[current('pattern')]"
        }
    },
    "greater": 0
}
```

Пример 2. Проверка совпадения имени ресурса с любым из заданных шаблонов имен. `current()`Функция не задает имя индекса. Результат аналогичен предыдущему примеру.

```json
{
    "count": {
        "value": [ "prefix1_*", "prefix2_*" ],
        "where": {
            "field": "name",
            "like": "[current()]"
        }
    },
    "greater": 0
}
```

Пример 3. Проверка совпадения имени ресурса с любым из заданных шаблонов имен, предоставленных параметром массива.

```json
{
    "count": {
        "value": "[parameters('namePatterns')]",
        "name": "pattern",
        "where": {
            "field": "name",
            "like": "[current('pattern')]"
        }
    },
    "greater": 0
}
```

Пример 4. Проверьте, не находится ли префикс адреса виртуальной сети в списке утвержденных префиксов.

```json
{
    "count": {
        "field": "Microsoft.Network/virtualNetworks/addressSpace.addressPrefixes[*]",
        "where": {
            "count": {
                "value": "[parameters('approvedPrefixes')]",
                "name": "approvedPrefix",
                "where": {
                    "value": "[ipRangeContains(current('approvedPrefix'), current('Microsoft.Network/virtualNetworks/addressSpace.addressPrefixes[*]'))]",
                    "equals": true
                },
            },
            "equals": 0
        }
    },
    "greater": 0
}
```

Пример 5. Убедитесь, что все зарезервированные правила NSG определены в NSG. Свойства зарезервированных правил NSG определяются в параметре массива, содержащем объекты.

Значение параметра:

```json
[
    {
        "priority": 101,
        "access": "deny",
        "direction": "inbound",
        "destinationPortRange": 22
    },
    {
        "priority": 102,
        "access": "deny",
        "direction": "inbound",
        "destinationPortRange": 3389
    }
]
```

Политика:
```json
{
    "count": {
        "value": "[parameters('reservedNsgRules')]",
        "name": "reservedNsgRule",
        "where": {
            "count": {
                "field": "Microsoft.Network/networkSecurityGroups/securityRules[*]",
                "where": {
                    "allOf": [
                        {
                            "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].priority",
                            "equals": "[current('reservedNsgRule').priority]"
                        },
                        {
                            "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].access",
                            "equals": "[current('reservedNsgRule').access]"
                        },
                        {
                            "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].direction",
                            "equals": "[current('reservedNsgRule').direction]"
                        },
                        {
                            "field": "Microsoft.Network/networkSecurityGroups/securityRules[*].destinationPortRange",
                            "equals": "[current('reservedNsgRule').destinationPortRange]"
                        }
                    ]
                }
            },
            "equals": 1
        }
    },
    "equals": "[length(parameters('reservedNsgRules'))]"
}
```

### <a name="effect"></a>Действие

Политика Azure поддерживает следующие типы действий:

- **Append** добавляет в запрос некоторый набор полей;
- **Audit** записывает предупреждение в журнал действий, но не отвергает запрос;
- **AuditIfNotExists**: создает событие предупреждения в журнале действий, если связанный ресурс не существует;
- **Deny** записывает событие в журнал действий и отвергает запрос;
- **DeployIfNotExists**: развертывает связанный ресурс, если он еще не существует;
- **Disabled** не оценивает ресурсы на соответствие правилу политики.
- **Изменить**: добавляет, обновляет или удаляет определенные теги из ресурса или подписки.
- **Енфорцеопаконстраинт** (не рекомендуется): Настройка контроллера рассоединений агента открытой политики с привратником v3 для самостоятельно управляемых кластеров Kubernetes в Azure
- **Енфорцерегополици** (не рекомендуется): Настройка контроллера допусков агента открытой политики с привратником версии 2 в службе Kubernetes Azure.

Подробные сведения о каждом эффекте, порядке оценки и свойствах, а также примеры см. в статье [Действия политик Azure](effects.md).

### <a name="policy-functions"></a>Функции политики

В рамках правила политики можно использовать все [функции шаблона Resource Manager](../../../azure-resource-manager/templates/template-functions.md), кроме функций, определяемых пользователем и следующих.

- copyIndex()
- deployment()
- list*
- newGuid()
- pickZones()
- providers()
- reference()
- resourceId()
- variables()

> [!NOTE]
> Эти функции по-прежнему доступны в части `details.deployment.properties.template` развертывания шаблона, в определении политики **deployIfNotExists**.

Следующая функция доступна для использования в правиле политики, но отличается от использования в шаблоне Azure Resource Manager (шаблон ARM):

- `utcNow()` -В отличие от шаблона ARM, это свойство может использоваться вне _DefaultValue_.
  - Возвращает строку, в которой заданы текущие дата и время в формате UTC 8601 DateTime `yyyy-MM-ddTHH:mm:ss.fffffffZ` .

Следующие функции доступны только в правилах политик.

- `addDays(dateTime, numberOfDaysToAdd)`
  - **DateTime**: [Required] строка строки в формате ISO 8601 DateTime ' гггг-mm-ddTHH: mm: SS. ФФФФФФФЗ "
  - **numberOfDaysToAdd**: [обязательная] целое число — число дней для добавления.
- `field(fieldName)`
  - **fieldName**: [обязательная] строка — имя [поля](#fields), которое следует извлечь.
  - Возвращает значение этого поля из ресурса, оцениваемого условием if.
  - `field` предназначена главным образом для использования с **AuditIfNotExists** и **DeployIfNotExists**, чтобы ссылаться на поля в ресурсе, который оценивается. Это можно увидеть на [примере DeployIfNotExists](effects.md#deployifnotexists-example).
- `requestContext().apiVersion`
  - Возвращает версию API запроса, который активировал оценку политики (пример: `2019-09-01`).
    Это значение представляет собой версию API, которая использовалась в запросе на выстановку или исправление для оценок при создании или обновлении ресурсов. Последняя версия API всегда используется во время оценки соответствия для существующих ресурсов.
- `policy()`
  - Возвращает следующие сведения о политике, для которой выполняется оценка. Доступ к свойствам можно получить из возвращенного объекта (пример: `[policy().assignmentId]` ).
  
  ```json
  {
    "assignmentId": "/subscriptions/ad404ddd-36a5-4ea8-b3e3-681e77487a63/providers/Microsoft.Authorization/policyAssignments/myAssignment",
    "definitionId": "/providers/Microsoft.Authorization/policyDefinitions/34c877ad-507e-4c82-993e-3452a6e0ad3c",
    "setDefinitionId": "/providers/Microsoft.Authorization/policySetDefinitions/42a694ed-f65e-42b2-aa9e-8052e9740a92",
    "definitionReferenceId": "StorageAccountNetworkACLs"
  }
  ```

- `ipRangeContains(range, targetRange)`
  - **Range**: [обязательное значение] строка строки, указывающая диапазон IP-адресов.
  - **таржетранже**: [обязательный] строка строки, указывающая диапазон IP-адресов.

  Возвращает значение, указывающее, содержит ли указанный диапазон IP-адресов целевой диапазон IP-адресов. Пустые диапазоны или смешивание между семействами IP-адресов не разрешено и приводит к сбою оценки.

  Поддерживаемые форматы:
  - Один IP-адрес (примеры: `10.0.0.0` , `2001:0DB8::3:FFFE` )
  - Диапазон CIDR (примеры: `10.0.0.0/24` , `2001:0DB8::/110` )
  - Диапазон, определенный начальным и конечным IP-адресами (примеры: `192.168.0.1-192.168.0.9` , `2001:0DB8::-2001:0DB8::3:FFFF` )

- `current(indexName)`
  - Специальная функция, которая может использоваться только внутри [выражений Count](#count).

#### <a name="policy-function-example"></a>Пример функции политики

В этом примере правила политики функция ресурса `resourceGroup` используется для получения свойства **name** в сочетании с массивом `concat` и функцией объекта для создания условия `like`, требующего, чтобы имя ресурса начиналось с имени группы ресурсов.

```json
{
    "if": {
        "not": {
            "field": "name",
            "like": "[concat(resourceGroup().name,'*')]"
        }
    },
    "then": {
        "effect": "deny"
    }
}
```

## <a name="aliases"></a>Aliases

Псевдонимы свойств позволяют обращаться к определенным свойствам для типа ресурса. Псевдонимы позволяют ограничить значения или условия, разрешенные для свойства ресурса. Каждый псевдоним сопоставляется с путями в разных версиях API для заданного типа ресурса. Во время оценки политики модуль политики получает путь свойства для этой версии API.

Список псевдонимов постоянно пополняется. Чтобы узнать, какие псевдонимы в настоящее время поддерживаются службой "Политика Azure", используйте один из следующих методов:

- Расширение Политики Azure для Visual Studio Code (рекомендуется)

  Используйте [расширение Политики Azure для Visual Studio Code](../how-to/extension-for-vscode.md), чтобы просматривать и находить псевдонимы для свойств ресурсов.

  :::image type="content" source="../media/extension-for-vscode/extension-hover-shows-property-alias.png" alt-text="Снимок экрана расширения политики Azure для Visual Studio Code наведения указателя мыши на свойство для отображения имен псевдонимов." border="false":::

- Azure PowerShell

  ```azurepowershell-interactive
  # Login first with Connect-AzAccount if not using Cloud Shell

  # Use Get-AzPolicyAlias to list available providers
  Get-AzPolicyAlias -ListAvailable

  # Use Get-AzPolicyAlias to list aliases for a Namespace (such as Azure Compute -- Microsoft.Compute)
  (Get-AzPolicyAlias -NamespaceMatch 'compute').Aliases
  ```

  > [!NOTE]
  > Чтобы найти псевдонимы, которые можно использовать с действием [изменения](./effects.md#modify) , используйте следующую команду в Azure PowerShell **4.6.0** или более поздней версии:
  >
  > ```azurepowershell-interactive
  > Get-AzPolicyAlias | Select-Object -ExpandProperty 'Aliases' | Where-Object { $_.DefaultMetadata.Attributes -eq 'Modifiable' }
  > ```

- Azure CLI

  ```azurecli-interactive
  # Login first with az login if not using Cloud Shell

  # List namespaces
  az provider list --query [*].namespace

  # Get Azure Policy aliases for a specific Namespace (such as Azure Compute -- Microsoft.Compute)
  az provider show --namespace Microsoft.Compute --expand "resourceTypes/aliases" --query "resourceTypes[].aliases[].name"
  ```

- REST API или ARMClient

  ```http
  GET https://management.azure.com/providers/?api-version=2019-10-01&$expand=resourceTypes/aliases
  ```

### <a name="understanding-the--alias"></a>Общие сведения о псевдониме [*]

Некоторые доступные псевдонимы имеют версию с отображаемым «обычным» именем, а другие — с присоединенным **\[\*\]** . Пример:

- `Microsoft.Storage/storageAccounts/networkAcls.ipRules`
- `Microsoft.Storage/storageAccounts/networkAcls.ipRules[*]`

«Обычный» псевдоним представляет поле как одно значение. Это поле предназначено для сценариев сравнения точного соответствия, если весь набор значений должен в точности соответствовать определению, не больше и не меньше.

**\[\*\]** Псевдоним представляет коллекцию значений, выбранных из элементов свойства ресурса массива. Пример.

| Псевдоним | Выбранные значения |
|:---|:---|
| `Microsoft.Storage/storageAccounts/networkAcls.ipRules[*]` | Элементы `ipRules` массива. |
| `Microsoft.Storage/storageAccounts/networkAcls.ipRules[*].action` | Значения `action` свойства из каждого элемента `ipRules` массива. |

При использовании в условии [поля](#fields) псевдонимы массивов позволяют сравнивать каждый отдельный элемент массива с целевым значением. При использовании с выражением [Count](#count) можно:

- Проверка размера массива
- Проверить, соответствует ли алл\ани\ноне элементов массива сложному условию
- Проверить, соответствует ли ровно ***n*** элементов массива сложному условию

Дополнительные сведения и примеры см. в разделе [ссылки на свойства ресурсов массива](../how-to/author-policies-for-arrays.md#referencing-array-resource-properties).

## <a name="next-steps"></a>Дальнейшие действия

- См. [структуру определения инициативы](./initiative-definition-structure.md)
- См. другие [примеры шаблонов для службы Политика Azure](../samples/index.md).
- Изучите [сведения о действии политик](effects.md).
- Узнайте о [программном создании политик](../how-to/programmatically-create.md).
- Узнайте, как [получать сведения о соответствии](../how-to/get-compliance-data.md).
- Узнайте, как [исправлять несоответствующие ресурсы](../how-to/remediate-resources.md).
- Дополнительные сведения о группе управления см. в статье [Упорядочивание ресурсов с помощью групп управления Azure](../../management-groups/overview.md).
