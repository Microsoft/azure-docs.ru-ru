---
title: Рекомендации по Функциям Azure
description: Ознакомьтесь с рекомендациями и шаблонами для Функций Azure.
ms.assetid: 9058fb2f-8a93-4036-a921-97a0772f503c
ms.topic: conceptual
ms.date: 12/17/2019
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: 5783f8092a6435b43ab8720df18cc5200e390d46
ms.sourcegitcommit: 867cb1b7a1f3a1f0b427282c648d411d0ca4f81f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "100378253"
---
# <a name="best-practices-for-performance-and-reliability-of-azure-functions"></a>Рекомендации по повышению производительности и надежности функций Azure

В этой статье описано, как повысить производительность и надежность [бессерверных](https://azure.microsoft.com/solutions/serverless/) приложений-функций.  

Ниже приведены рекомендации по созданию и разработке бессерверных решений с помощью службы "Функции Azure".

## <a name="avoid-long-running-functions"></a>Избегайте длительных функций

Крупные длительные функции могут вызывать непредвиденные проблемы времени ожидания. Дополнительные сведения о времени ожидания для заданного плана размещения см. в разделе время [ожидания приложения-функции](functions-scale.md#timeout).

Функция может стать большой, так как многие Node.js зависимости. Импорт зависимостей может также привести к замедлению загрузки, что, в свою очередь, приводит к непредвиденным проблемам времени ожидания. Зависимости можно загрузить явно и неявно. Один модуль, загруженный в коде, может загрузить собственные дополнительные модули.

По возможности выполняйте рефакторинг крупных функций и перерабатывайте их на более мелкие совместимые наборы функций, которые работают сообща и быстро возвращают ответ. Например, для веб-перехватчика или функции триггера HTTP может потребоваться ответ подтверждения в течение определенного предела времени. для веб-перехватчиков обычно требуется немедленный отклик. Полезные данные триггера HTTP можно передать в очередь для обработки с помощью функции триггера очереди. Такой подход позволяет отложить фактическую работу и вернуть немедленный ответ.

## <a name="cross-function-communication"></a>Взаимодействие функций

[Устойчивые функции](durable/durable-functions-overview.md) и [Azure Logic Apps](../logic-apps/logic-apps-overview.md) используются для управления переходами состояний и обмена данными между несколькими функциями.

Если не используется Устойчивые функции или Logic Apps для интеграции с несколькими функциями, лучше использовать очереди хранилища для обмена данными между функциями. Основная причина заключается в том, что очереди хранилища являются более дешевыми и проще в подготовке, чем другие варианты хранения.

Размер отдельных сообщений в очереди хранилища ограничен до 64 КБ. Если между функциями нужно передать сообщения большего размера, можно использовать очередь служебной шины Azure, которая поддерживает сообщения размером до 256 КБ на уровне "Стандартный" и 1 МБ на уровне "Премиум".

Если перед обработкой сообщений их нужно отфильтровать, ознакомьтесь со статьями о служебной шине.

Для поддержки обмена крупными сообщениями используются Центры событий.

## <a name="write-functions-to-be-stateless"></a>Создавайте функции без отслеживания состояния

По возможности функции должны быть без отслеживания состояния и идемпотентными. Свяжите все необходимые сведения о состоянии с вашими данными. Например, с обрабатываемым заказом скорее всего будет связан элемент `state`. Функция может обработать заказ, основываясь на этом состоянии, но в ней самой при этом не отслеживается состояние.

Идемпотентные функции рекомендуется использовать с триггерами таймера. Например, если у вас есть нечто, что должно выполняться раз в день, напишите его, чтобы оно можно было выполнять в любое время в течение дня с теми же результатами. Функция может выйти из программы, если она не работает в определенный день. Кроме того, если предыдущее выполнение завершилось ошибкой, следующее выполнение должно начаться с прерванного момента.

## <a name="write-defensive-functions"></a>Создавайте защищенные функции

Предположим, что в любое время в функции может возникнуть исключение. Реализуйте в функции возможность продолжения с предыдущей точки сбоя во время следующего выполнения. Давайте рассмотрим сценарий, в котором необходимо сделать следующее:

1. Запрос 10 000 строк в базе данных.
2. Создать сообщение очереди для каждой из этих строк для дальнейшей обработки.

В зависимости от того, насколько сложна система, у вас может быть: вовлечение подчиненных служб в неплохое поведение, сбои сети или достигнутые квоты и т. д. Все это может повлиять на вашу функцию в любое время. Функции необходимо подготавливать к таким проблемам.

Как отреагирует ваш код при сбое после вставки 5000 элементов в очередь для обработки? Отслеживайте элементы в наборе, работа с которым завершена. В противном случае их можно вставить позже. Такая двойная Вставка может оказать серьезное воздействие на рабочий процесс, поэтому [функция идемпотентными](functions-idempotent.md). 

Если элемент очереди уже обработан, разрешите холостой цикл выполнения функции.

Воспользуйтесь предоставленными возможностями защиты для компонентов, используемых на платформе Функций Azure. Например, ознакомьтесь с разделом **Обработка подозрительных сообщений очереди** в документации по [триггерам и привязкам очереди службы хранилища Azure](functions-bindings-storage-queue-trigger.md#poison-messages).

## <a name="function-organization-best-practices"></a>Рекомендации по функциям Организации

В рамках вашего решения вы можете разрабатывать и публиковать несколько функций. Эти функции часто объединяются в одно приложение-функцию, но они также могут выполняться в отдельных приложениях-функциях. В планах размещения Premium и Dedicated (служба приложений) несколько приложений-функций также могут совместно использовать одни и те же ресурсы, запуская их в одном плане. Способ группировки функций и приложений функций может повлиять на производительность, масштабирование, настройку, развертывание и безопасность общего решения. Нет правил, которые применяются к каждому сценарию, поэтому при планировании и разработке функций следует учитывать сведения, приведенные в этом разделе.

### <a name="organize-functions-for-performance-and-scaling"></a>Упорядочивание функций для повышения производительности и масштабирования

Каждая создаваемая функция имеет объем памяти. Хотя этот объем обычно небольшой, слишком много функций в приложении-функции может привести к более медленному запуску приложения на новых экземплярах. Это также означает, что общее использование памяти приложением функции может быть выше. Трудно сказать, сколько функций должно быть в одном приложении, которое зависит от конкретной рабочей нагрузки. Однако если функция хранит большой объем данных в памяти, рассмотрите возможность меньшего числа функций в одном приложении.

При запуске нескольких приложений-функций в одном или выделенном плане Premium (служба приложений) все эти приложения масштабируются вместе. Если у вас есть одно приложение-функцию с большим объемом памяти, чем другие, оно использует непропорциональное количество ресурсов памяти на каждом экземпляре, в котором развернуто приложение. Так как это может привести к уменьшению объема доступной памяти для других приложений на каждом экземпляре, может потребоваться запустить приложение-функцию с большим объемом памяти, как это было в отдельном плане размещения.

> [!NOTE]
> При использовании [плана потребления](./functions-scale.md)рекомендуется всегда размещать каждое приложение в собственном плане, так как приложения в любом случае масштабируются независимо друг от друга.

Рассмотрите возможность группирования функций с разными профилями нагрузки. Например, если имеется функция, обрабатывающая множество тысяч сообщений очереди, и другая, которая вызывается только иногда, но имеет высокие требования к памяти, может потребоваться развернуть их в отдельных приложениях-функциях, чтобы они получили собственные наборы ресурсов и масштабировать их независимо друг от друга.

### <a name="organize-functions-for-configuration-and-deployment"></a>Организация функций для настройки и развертывания

Приложения-функции имеют `host.json` файл, который используется для настройки расширенного поведения триггеров функций и среды выполнения функций Azure. Изменения в `host.json` файле применяются ко всем функциям в приложении. Если у вас есть функции, для которых требуются пользовательские конфигурации, рассмотрите возможность перемещения их в собственное приложение функции.

Все функции в локальном проекте развертываются вместе как набор файлов для приложения-функции в Azure. Может потребоваться отдельное развертывание отдельных функций или использование таких функций, как [слоты развертывания](./functions-deployment-slots.md) , для некоторых функций, а не других. В таких случаях следует развернуть эти функции (в разных проектах кода) для различных приложений-функций.

### <a name="organize-functions-by-privilege"></a>Упорядочивание функций по привилегиям

Строки подключения и другие учетные данные, хранящиеся в параметрах приложения, предоставляют всем функциям в приложении-функции одинаковый набор разрешений в связанном ресурсе. Рекомендуется свести к минимуму количество функций с доступом к определенным учетным данным, переместив те из них, которые не используют такие учетные данные, в отдельное приложение-функцию. Для передачи данных между функциями в различных приложениях-функциях всегда можно использовать такие методы, как [связывание функций](/learn/modules/chain-azure-functions-data-using-bindings/).  

## <a name="scalability-best-practices"></a>Рекомендации по масштабируемости

Существует ряд факторов, влияющих на то, как экземпляры приложения-функции масштабируются. Дополнительные сведения см. в документации по [масштабированию функций](functions-scale.md).  Ниже приведены рекомендации по оптимальному масштабированию приложения-функции.

### <a name="share-and-manage-connections"></a>Управление подключениями и общий доступ к ним

При возможности повторно используйте подключения к внешним ресурсам. См. раздел [Способы управления подключениями в службе "Функции Azure"](./manage-connections.md).

### <a name="avoid-sharing-storage-accounts"></a>Избегайте совместного использования учетных записей хранения

При создании приложения-функции необходимо связать его с учетной записью хранения. Подключение к учетной записи хранения сохраняется в параметре приложения [AzureWebJobsStorage](./functions-app-settings.md#azurewebjobsstorage).

[!INCLUDE [functions-shared-storage](../../includes/functions-shared-storage.md)]

### <a name="dont-mix-test-and-production-code-in-the-same-function-app"></a>Не используйте тестовый и рабочий код в одном приложении-функции

Функции в приложении-функции совместно используют ресурсы. Например, память. Если приложение-функция используется в рабочей среде, не добавляйте в нее тестовые функции и ресурсы. Это может вызвать непредвиденные затраты во время выполнения кода в рабочей среде.

Следите за тем, что вы загружаете в рабочие приложения-функции. Память усредняется для каждой функции в приложении.

Если у вас есть общая сборка, на которую имеется ссылка в нескольких функциях .NET, поставьте ее в общую общую папку. В противном случае можно случайно развернуть несколько версий одного и того же двоичного файла, которые ведут себя по-разному в разных функциях.

Не используйте подробный журнал в рабочем коде, что отрицательно сказывается на производительности.

### <a name="use-async-code-but-avoid-blocking-calls"></a>Использование асинхронного кода без блокирующих вызовов

Рекомендуется использовать асинхронное программирование, особенно если вовлечены блокирующие операции ввода-вывода.

В C# всегда Избегайте обращения к `Result` свойству или вызывающему `Wait` методу в `Task` экземпляре. Применение этого подхода может привести к нехватке потоков.

[!INCLUDE [HTTP client best practices](../../includes/functions-http-client-best-practices.md)]

### <a name="use-multiple-worker-processes"></a>Использование нескольких рабочих процессов

По умолчанию любой экземпляр узла для функций использует один рабочий процесс. Чтобы повысить производительность, особенно при использовании однопотоковых сред выполнения, таких как Python, используйте [FUNCTIONS_WORKER_PROCESS_COUNT](functions-app-settings.md#functions_worker_process_count) , чтобы увеличить количество рабочих процессов на узел (до 10). Затем Функции Azure пытаются равномерно распределять одновременные вызовы функций между этими рабочими процессами.

FUNCTIONS_WORKER_PROCESS_COUNT применяется к каждому узлу, создаваемому функциями при масштабировании приложения для удовлетворения потребности.

### <a name="receive-messages-in-batch-whenever-possible"></a>По возможности получайте сообщения в пакетном режиме

Некоторые триггеры, например триггер концентратора событий, позволяют получать сообщения в пакетном режиме в рамках одного вызова.  Пакетная обработка сообщений обеспечивает более высокую производительность.  Вы можете настроить максимальный размер пакета в файле `host.json`, как описано в [справочной документации по host.json](functions-host-json.md).

Для функций C# можно изменить тип на строго типизированный массив.  Например, вместо `EventData sensorEvent` можно использовать сигнатуру метода `EventData[] sensorEvent`.  Для других языков необходимо явно задать свойство кратности в `function.json` , чтобы `many` включить пакетную обработку [, как показано ниже](https://github.com/Azure/azure-webjobs-sdk-templates/blob/df94e19484fea88fc2c68d9f032c9d18d860d5b5/Functions.Templates/Templates/EventHubTrigger-JavaScript/function.json#L10).

### <a name="configure-host-behaviors-to-better-handle-concurrency"></a>Настройте поведение узла для обеспечения оптимального параллелизма

Файл `host.json` в приложении-функции позволяет настраивать среду выполнения узла и поведение триггера.  Кроме настройки поведения пакетной обработки, вы можете управлять параллелизмом определенного числа триггеров. Часто настройка этих параметров помогает масштабировать каждый экземпляр согласно требованиям вызванных функций.

Параметры в host.jsфайле применяются ко всем функциям в приложении в рамках *одного экземпляра* функции. Например, если у вас есть приложение-функция с двумя функциями HTTP и [`maxConcurrentRequests`](functions-bindings-http-webhook-output.md#hostjson-settings) запросами, для которых задано значение 25, запрос к любому триггеру HTTP будет считаться общим 25 одновременных запросов.  Если это приложение-функция масштабируется до 10 экземпляров, то десять функций эффективно допускают 250 параллельных запросов (10 экземпляров * 25 одновременных запросов на экземпляр). 

Другие параметры конфигурации узла находятся в [ разделеhost.json Configuration](functions-host-json.md).

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения см. в следующих ресурсах:

* [Способы управления подключениями в службе "Функции Azure"](manage-connections.md)
* [Рекомендации по использованию службы приложений Azure](../app-service/app-service-best-practices.md)
