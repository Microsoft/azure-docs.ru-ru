---
title: Сохраняемость и сериализация данных в Устойчивые функции — Azure
description: Сведения о том, как расширение Устойчивые функции для функций Azure сохраняет данные
author: ConnorMcMahon
ms.topic: conceptual
ms.date: 02/11/2021
ms.author: azfuncdf
ms.openlocfilehash: 34845afe0efd0131e0c568eac1169ddc10be5d47
ms.sourcegitcommit: e972837797dbad9dbaa01df93abd745cb357cde1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2021
ms.locfileid: "100521165"
---
# <a name="data-persistence-and-serialization-in-durable-functions-azure-functions"></a>Сохранение и сериализация данных в Устойчивые функции (функции Azure)

Устойчивые функции автоматически сохраняет параметры функции, возвращаемые значения и другое состояние для устойчивой серверной части, чтобы обеспечить надежное выполнение. Однако объем и частота данных, сохраняемых в долговременном хранилище, может повлиять на производительность приложений и затраты на транзакции хранилища. В зависимости от типа данных, которые хранятся в вашем приложении, также может потребоваться учитывать политики хранения данных и конфиденциальности.

## <a name="azure-storage"></a>Служба хранилища Azure

По умолчанию Устойчивые функции сохраняет данные в очередях, таблицах и BLOB-объектах в указанной учетной записи [хранения Azure](https://azure.microsoft.com/services/storage/) .

### <a name="queues"></a>Очереди

Устойчивые функции использует очереди службы хранилища Azure для надежного планирования всех выполнений функций. Эти сообщения очереди содержат входные или выходные данные функции, в зависимости от того, используется ли сообщение для планирования выполнения или возврата значения обратно в вызывающую функцию. Эти сообщения очереди также содержат дополнительные метаданные, которые Устойчивые функции использовать для внутренних целей, таких как маршрутизация и сквозная корреляция. После завершения выполнения функции в ответ на полученное сообщение это сообщение удаляется, а результат выполнения также может быть сохранен в таблицах службы хранилища Azure или больших двоичных объектах службы хранилища Azure.

В одном [концентраторе задач](durable-functions-task-hubs.md)устойчивые функции создает и добавляет сообщения в очередь *рабочих элементов* с именем `<taskhub>-workitem` для функций планирования и одну или несколько *очередей управления* с именем `<taskhub>-control-##` для планирования или возобновления работы Orchestrator и функций сущностей. Количество управляющих очередей равно числу секций, настроенных для приложения. Дополнительные сведения об очередях и секциях см. в [документации по производительности и масштабируемости](durable-functions-perf-and-scale.md).

### <a name="tables"></a>Таблицы

После успешного обработки сообщений согласование результирующих действий сохраняется в таблице *журнала* с именем `<taskhub>History` . Входные и выходные данные оркестрации также сохраняются в таблице *экземпляров* с именем `<taskhub>Instances` .

### <a name="blobs"></a>BLOB-объекты

В большинстве случаев Устойчивые функции не использует большие двоичные объекты службы хранилища Azure для сохранения данных. Однако очереди и таблицы имеют [ограничения по размеру](../../azure-resource-manager/management/azure-subscription-service-limits.md#azure-queue-storage-limits) , которые могут препятствовать устойчивые функции сохранению всех необходимых данных в строке хранилища или в сообщении очереди. Например, если фрагмент данных, который необходимо сохранить в очереди, превышает 45 КБ при сериализации, Устойчивые функции будет сжимать данные и хранить их в большом двоичном объекте. При таком сохранении данных в хранилище BLOB-объектов устойчивая функция сохраняет ссылку на этот большой двоичный объект в строке таблицы или в сообщении очереди. Когда Устойчивые функции необходимо получить данные, они будут автоматически извлечены из большого двоичного объекта. Эти большие двоичные объекты хранятся в контейнере больших двоичных объектов `<taskhub>-largemessages` .

> [!NOTE]
> Дополнительные шаги сжатия и больших двоичных объектов для больших сообщений могут быть дорогостоящими с точки зрения производительности ЦП и задержки ввода-вывода. Кроме того, Устойчивые функции необходимо загрузить сохраняемые данные в память и, возможно, сделать это для множества различных выполнений функций одновременно. В результате сохранение полезных данных большого объема может также привести к увеличению объема используемой памяти. Чтобы снизить нагрузку на память, рекомендуется сохранять большие объемы данных вручную (например, в хранилище BLOB-объектов), а не передавать ссылки на эти данные. Таким образом, код может загружать данные только при необходимости, чтобы избежать избыточных нагрузок во время [воспроизведения функции Orchestrator](durable-functions-orchestrations.md#reliability). Однако хранить полезные данные на диске *не* рекомендуется, так как состояние на диске не гарантируется, так как функции могут выполняться на разных виртуальных машинах в течение всего времени существования.

### <a name="types-of-data-that-is-serialized-and-persisted"></a>Типы данных, которые сериализуются и сохраняются
Ниже приведен список различных типов данных, которые будут сериализованы и сохранены при использовании функций Устойчивые функции.

- Все входы и выходы функций Orchestrator, Activity и Entity, включая любые идентификаторы и необработанные исключения.
- Имена функций Orchestrator, Activity и Entity
- Имена внешних событий и полезные данные
- Пользовательские полезные данные состояния оркестрации
- Сообщения о завершении оркестрации
- Устойчивые полезные данные таймера
- Устойчивые URL-адреса запросов и ответов HTTP, заголовки и полезные данные
- Вызов сущности и полезные данные сигнала
- Полезные данные состояния сущности

### <a name="working-with-sensitive-data"></a>Работа с конфиденциальными данными
При использовании службы хранилища Azure все данные автоматически шифруются. Однако любой пользователь, имеющий доступ к учетной записи хранения, может считывать данные в их незашифрованном виде. Если требуется более надежная защита конфиденциальных данных, рекомендуется сначала зашифровать данные с помощью собственных ключей шифрования, чтобы Устойчивые функции сохранял данные в виде предварительно зашифрованной формы.

Кроме того, пользователи .NET имеют возможность реализовать пользовательские поставщики сериализации, обеспечивающие автоматическое шифрование. Пример пользовательской сериализации с шифрованием можно найти в [этом образце GitHub](https://github.com/charleszipp/azure-durable-entities-encryption).

> [!NOTE]
> Если вы решили реализовать шифрование на уровне приложения, имейте в виду, что оркестрации и сущности могут существовать в течение неопределенного количества времени. Это важно, когда приходит время на смену ключей шифрования, так как оркестрации или сущности могут работать дольше, чем политика смены ключей. Если происходит смена ключа, ключ, используемый для шифрования данных, может быть недоступен для расшифровки при следующем выполнении оркестрации или сущности. Шифрование клиентов рекомендуется использовать, только если предполагается, что согласования и сущности выполняются в течение относительно коротких периодов времени.

## <a name="customizing-serialization-and-deserialization"></a>Настройка сериализации и десериализации

# <a name="c"></a>[C#](#tab/csharp)

### <a name="default-serialization-logic"></a>Логика сериализации по умолчанию

Устойчивые функции внутренне использует [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) для сериализации данных оркестрации и EDM в JSON. Параметры по умолчанию Устойчивые функции используются для Json.NET:

**Входы, выходы и состояние:**

```csharp
JsonSerializerSettings
{
    TypeNameHandling = TypeNameHandling.None,
    DateParseHandling = DateParseHandling.None,
}
```

**Отличи**

```csharp
JsonSerializerSettings
{
    ContractResolver = new ExceptionResolver(),
    TypeNameHandling = TypeNameHandling.Objects,
    ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
}
```

Дополнительные сведения см `JsonSerializerSettings` . [здесь](https://www.newtonsoft.com/json/help/html/SerializationSettings.htm).

## <a name="customizing-serialization-with-net-attributes"></a>Настройка сериализации с помощью атрибутов .NET

При сериализации данных Json.NET ищет [различные атрибуты](https://www.newtonsoft.com/json/help/html/SerializationAttributes.htm) в классах и свойствах, которые управляют способом сериализации и десериализации данных из JSON. Если вы владеете исходным кодом для типа данных, переданного Устойчивые функцииным API-интерфейсам, рассмотрите возможность добавления этих атрибутов к типу для настройки сериализации и десериализации.

## <a name="customizing-serialization-with-dependency-injection"></a>Настройка сериализации с внедрением зависимостей

Приложения-функции, предназначенные для .NET и выполняемые в среде выполнения функции v3, могут использовать [внедрение зависимостей (DI)](../functions-dotnet-dependency-injection.md) для настройки сериализации данных и исключений. В примере кода ниже показано, как использовать DI для переопределения параметров сериализации Json.NET по умолчанию с помощью пользовательских реализаций `IMessageSerializerSettingsFactory` `IErrorSerializerSettingsFactory` интерфейсов служб и.

```csharp
using Microsoft.Azure.Functions.Extensions.DependencyInjection;
using Microsoft.Azure.WebJobs.Extensions.DurableTask;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using System.Collections.Generic;

[assembly: FunctionsStartup(typeof(MyApplication.Startup))]
namespace MyApplication
{
    public class Startup : FunctionsStartup
    {
        public override void Configure(IFunctionsHostBuilder builder)
        {
            builder.Services.AddSingleton<IMessageSerializerSettingsFactory, CustomMessageSerializerSettingFactory>();
            builder.Services.AddSingleton<IErrorSerializerSettingsFactory, CustomErrorSerializerSettingsFactory>();
        }

        /// <summary>
        /// A factory that provides the serialization for all inputs and outputs for activities and
        /// orchestrations, as well as entity state.
        /// </summary>
        internal class CustomMessageSerializerSettingsFactory : IMessageSerializerSettingsFactory
        {
            public JsonSerializerSettings CreateJsonSerializerSettings()
            {
                // Return your custom JsonSerializerSettings here
            }
        }

        /// <summary>
        /// A factory that provides the serialization for all exceptions thrown by activities
        /// and orchestrations
        /// </summary>
        internal class CustomErrorSerializerSettingsFactory : IErrorSerializerSettingsFactory
        {
            public JsonSerializerSettings CreateJsonSerializerSettings()
            {
                // Return your custom JsonSerializerSettings here
            }
        }
    }
}
```

# <a name="javascript"></a>[JavaScript](#tab/javascript)

### <a name="serialization-and-deserialization-logic"></a>Логика сериализации и десериализации

Приложения узла "функции Azure" используют [ `JSON.stringify()` для сериализации](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) и [ `JSON.Parse()` десериализации](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse). Большинство типов должны беспрепятственно выполнять сериализацию и десериализацию. В случаях, когда логика по умолчанию недостаточна, определение `toJSON()` метода для объекта будет перехватывать логику сериализации. Однако для десериализации объектов аналогов не существует.

Для полной настройки конвейера сериализации и десериализации рассмотрите возможность обработки сериализации и десериализации с помощью собственного кода и передачи данных в виде строк.


# <a name="python"></a>[Python](#tab/python)

### <a name="serialization-and-deserialization-logic"></a>Логика сериализации и десериализации

Настоятельно рекомендуется использовать аннотации типов, чтобы гарантировать, Устойчивые функции сериализует и десериализует данные правильно. Хотя многие встроенные типы обрабатываются автоматически, некоторые встроенные типы данных нуждаются в заметках типа для сохранения типа во время десериализации.

Для пользовательских типов данных необходимо определить сериализацию и десериализацию JSON типа данных, экспортировав статический `to_json` `from_json` метод и из класса.

---
