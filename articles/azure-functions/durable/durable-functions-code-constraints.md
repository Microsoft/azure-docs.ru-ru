---
title: Устойчивые ограничения кода Orchestrator — функции Azure
description: Функции оркестрации и ограничения кода для Устойчивые функции Azure.
author: cgillum
ms.topic: conceptual
ms.date: 11/02/2019
ms.author: azfuncdf
ms.openlocfilehash: 63db8375379144b2ede78d9e7010a350b3f69b12
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/20/2021
ms.locfileid: "101726416"
---
# <a name="orchestrator-function-code-constraints"></a>Ограничения кода функции Orchestrator

Устойчивые функции — это расширение [функций Azure](../functions-overview.md) , которое позволяет создавать приложения с отслеживанием состояния. [Функцию Orchestrator](durable-functions-orchestrations.md) можно использовать для координации выполнения других устойчивых функций в приложении-функции. Функции Orchestrator поддерживают отслеживание состояния, надежность и потенциально длительное выполнение.

## <a name="orchestrator-code-constraints"></a>Ограничения кода оркестратора

Функции Orchestrator используют [источники событий](/azure/architecture/patterns/event-sourcing) для обеспечения надежного выполнения и поддержания состояния локальной переменной. [Поведение воспроизведения](durable-functions-orchestrations.md#reliability) кода Orchestrator создает ограничения на тип кода, который можно написать в функции Orchestrator. Например, функции Orchestrator должны быть *детерминированными*: функция Orchestrator будет воспроизведена несколько раз, и она должна выдавать один и тот же результат каждый раз.

### <a name="using-deterministic-apis"></a>Использование детерминированных интерфейсов API

В этом разделе приводятся некоторые простые рекомендации по обеспечению детерминированности кода.

Функции Orchestrator могут вызывать любой API на своих целевых языках. Однако важно, чтобы функции Orchestrator вызывали только детерминированные API. *Детерминированный API* — это API, который всегда возвращает одно и то же значение при вводе одних и тех же входных данных независимо от того, когда или как часто он вызывается.

В следующей таблице приведены примеры интерфейсов API, которые следует избегать, поскольку они *не* являются детерминированными. Эти ограничения относятся только к функциям Orchestrator. Другие типы функций не имеют таких ограничений.

| Категория API | Причина | Обходной путь |
| ------------ | ------ | ---------- |
| Даты и время  | API, возвращающие текущую дату или время, являются недетерминированными, поскольку возвращаемое значение отличается для каждого воспроизведения. | Используйте свойство [CurrentUtcDateTime](/dotnet/api/microsoft.azure.webjobs.extensions.durabletask.idurableorchestrationcontext.currentutcdatetime) в .NET, `currentUtcDateTime` API в JavaScript или `current_utc_datetime` API в Python, которые являются надежными для воспроизведения. |
| Идентификаторы GUID и UUID  | API-интерфейсы, возвращающие случайный идентификатор GUID или UUID, являются недетерминированными, поскольку сформированное значение отличается для каждого воспроизведения. | Используйте [NewGuid](/dotnet/api/microsoft.azure.webjobs.extensions.durabletask.idurableorchestrationcontext.newguid) в .NET, `newGuid` в JavaScript и `new_guid` в Python для безопасного создания случайных идентификаторов GUID. |
| Случайные числа | API-интерфейсы, возвращающие случайные числа, являются недетерминированными, поскольку сформированное значение отличается для каждого воспроизведения. | Используйте функцию действия для возврата случайных чисел в согласование. Возвращаемые значения функций действий всегда являются надежными для воспроизведения. |
| Привязки | Входные и выходные привязки обычно выполняют операции ввода-вывода и являются недетерминированными. Функция Orchestrator не должна напрямую использовать даже [клиент оркестрации](durable-functions-bindings.md#orchestration-client) и привязки [клиента сущности](durable-functions-bindings.md#entity-client) . | Используйте входные и выходные привязки внутри функций клиента или действия. |
| Сеть | Сетевые вызовы содержат внешние системы и являются недетерминированными. | Используйте функции действий для выполнения сетевых вызовов. Если необходимо выполнить HTTP-вызов из функции Orchestrator, можно также использовать [устойчивые API HTTP](durable-functions-http-features.md#consuming-http-apis). |
| Блокирующие API | Блокирующие интерфейсы API, такие как `Thread.Sleep` в .NET и аналогичные API, могут вызвать проблемы производительности и масштабирования для функций Orchestrator, и их следует избегать. В плане потребления функций Azure они могут даже привести к ненужной оплате времени выполнения. | Используйте альтернативы для блокирования API, когда они доступны. Например, используйте,  `CreateTimer` чтобы ввести задержки при выполнении согласования. [Устойчивые задержки таймера](durable-functions-timers.md) не учитываются во время выполнения функции Orchestrator. |
| Асинхронные API | Код Orchestrator никогда не должен запускать асинхронную операцию, за исключением использования `IDurableOrchestrationContext` API, `context.df` API в JavaScript или `context` API в Python. Например, нельзя использовать `Task.Run` , `Task.Delay` и `HttpClient.SendAsync` в .NET или `setTimeout` и `setInterval` в JavaScript. Платформа устойчивых задач запускает код Orchestrator в одном потоке. Он не может взаимодействовать с другими потоками, которые могут вызываться другими асинхронными API. | Функция Orchestrator должна делать только устойчивые асинхронные вызовы. Функции действий должны выполнять любые другие асинхронные вызовы API. |
| Асинхронные функции JavaScript | Нельзя объявлять функции JavaScript в языке, `async` так как среда выполнения node.js не гарантирует, что асинхронные функции являются детерминированными. | Объявление функций в JavaScript Orchestrator как функции синхронного генератора |
| Соподпрограммы Python | Нельзя объявлять функции Python в качестве соподпрограмм, т. е. объявите их с помощью `async` ключевого слова, поскольку семантика соподпрограмм не соответствует модели воспроизведения устойчивые функции. | Объявите функции Python в качестве генераторов, что означает, что `context` API следует использовать `yield` вместо `await` .   |
| API-интерфейсы потоков | Платформа устойчивых задач запускает код Orchestrator в одном потоке и не может взаимодействовать с другими потоками. Введение новых потоков в выполнение оркестрации может привести к недетерминированному выполнению или взаимоблокировкам. | Функции Orchestrator практически никогда не используют API-интерфейсы потоков. Например, в .NET Избегайте использования `ConfigureAwait(continueOnCapturedContext: false)` . Это гарантирует, что продолжения задач будет выполняться в исходной функции Orchestrator `SynchronizationContext` . Если такие API необходимы, ограничьте их использование только функциями действий. |
| Статические переменные | Избегайте использования неконстантных статических переменных в функциях Orchestrator, так как их значения могут меняться со временем, что приводит к недетерминированному поведению во время выполнения. | Используйте константы или ограничьте использование статических переменных функциями действий. |
| Переменные среды | Не используйте переменные среды в функциях Orchestrator. Их значения со временем могут меняться, что приводит к недетерминированному поведению во время выполнения. | Ссылки на переменные среды должны осуществляться только в клиентских функциях или функциях действий. |
| Бесконечные циклы | Избегайте бесконечных циклов в функциях оркестраторов. Так как платформа устойчивых задач сохраняет журнал выполнения в ходе выполнения функции оркестрации, бесконечный цикл может привести к нехватке памяти для экземпляра Orchestrator. | Для сценариев бесконечного цикла используйте API-интерфейсы, такие как `ContinueAsNew` в .NET, `continueAsNew` JavaScript или `continue_as_new` Python, чтобы перезапустить выполнение функции и отменить предыдущий журнал выполнения. |

Хотя применение этих ограничений на первый взгляд может показаться затруднительным, на практике их легко отслеживать.

Платформа устойчивых задач пытается обнаружить нарушения предыдущих правил. Если обнаруживается нарушение, платформа создает исключение **нондетерминистикорчестратионексцептион** . Однако это поведение не будет перехватывать все нарушения, и вам не следует зависеть от него.

## <a name="versioning"></a>Управление версиями

Устойчивое оркестрации может выполняться непрерывно в течение дней, месяцев, лет или даже [етерналли](durable-functions-eternal-orchestrations.md). Любые обновления кода, внесенные в Устойчивые функции приложения, влияющие на незавершенные оркестрации, могут нарушить поведение воспроизведения оркестрации. Именно поэтому важно тщательно спланировать при внесении обновлений в код. Более подробное описание способов версии кода см. в [статье Управление версиями](durable-functions-versioning.md).

## <a name="durable-tasks"></a>Устойчивые задачи

> [!NOTE]
> Этот раздел содержит сведения о внутренней реализации платформы устойчивых задач. Вы можете использовать устойчивые функции, не зная этих сведений. Она предназначена только для того, чтобы помочь вам понять поведение воспроизведения.

Задачи, которые могут безопасно ожидать в функциях Orchestrator, иногда называют *устойчивыми задачами*. Платформа устойчивых задач создает и управляет этими задачами. Примерами являются задачи, возвращаемые **каллактивитясинк**, **ваитфорекстерналевент** и **CreateTimer** в функциях .NET Orchestrator.

Эти устойчивые задачи внутренне управляются списком `TaskCompletionSource` объектов в .NET. Во время воспроизведения эти задачи создаются в ходе выполнения кода Orchestrator. Они завершаются, так как диспетчер перечисляет соответствующие события журнала.

Задачи выполняются синхронно с помощью одного потока, пока не будут воспроизведены все журналы. Для устойчивых задач, которые не завершены в конце воспроизведения журнала, выполняются соответствующие действия. Например, сообщение может быть поставлено в очередь для вызова функции действия.

Описание поведения во время выполнения этого раздела должно помочь понять, почему функция Orchestrator не может использовать `await` или `yield` в неустойчивой задаче. Существует две причины: поток Dispatcher не может дождаться завершения задачи, а любой обратный вызов этой задачи может повредить состояние отслеживания функции Orchestrator. Для обнаружения этих нарушений используются некоторые проверки среды выполнения.

Чтобы узнать больше о том, как платформа устойчивых задач выполняет функции Orchestrator, просмотрите [Исходный код устойчивой задачи на сайте GitHub](https://github.com/Azure/durabletask). В частности, см. [таскорчестратионексекутор. CS](https://github.com/Azure/durabletask/blob/master/src/DurableTask.Core/TaskOrchestrationExecutor.cs) и [таскорчестратионконтекст. CS](https://github.com/Azure/durabletask/blob/master/src/DurableTask.Core/TaskOrchestrationContext.cs).

## <a name="next-steps"></a>Дальнейшие действия

> [!div class="nextstepaction"]
> [Узнайте, как вызывать подсистемы взаимодействия](durable-functions-sub-orchestrations.md)

> [!div class="nextstepaction"]
> [Сведения об обработке управления версиями](durable-functions-versioning.md)
