---
title: Работа с учетными записями-посредниками в функциях Azure
description: Общие сведения об использовании прокси Функций Azure
ms.topic: conceptual
ms.date: 01/22/2018
ms.openlocfilehash: fb263239f99bcb4ec4c893b700d5c1cce078659f
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "96601379"
---
# <a name="work-with-azure-functions-proxies"></a>Работа с функцией "Прокси-серверы Функций Azure"

В этой статье описано, как настроить прокси Функций Azure и работать с ними. Эта функция позволяет указать конечные точки в приложении-функции, реализуемые другим ресурсом. Эти прокси можно использовать для разбиения большого API-интерфейса на несколько приложений-функций (как в архитектуре микрослужб), сохраняя при этом единую область API для клиентов.

[!INCLUDE [intro](../../includes/functions-bindings-intro.md)]

> [!NOTE] 
> На выполнение прокси-сервера распространяется стандартная тарификация службы "Функции". Дополнительные сведения см. на странице [цен на Функции Azure](https://azure.microsoft.com/pricing/details/functions/).

## <a name="create-a-proxy"></a><a name="create"></a>Создание учетной записи-посредника

В этом разделе показано, как создать прокси-сервер на портале Функций.

1. Откройте [портал Azure] и перейдите к своему приложению-функции.
2. В левой области выберите **Создать прокси-сервер**.
3. Задайте имя прокси.
4. Настройте конечную точку в этом приложении-функции, указав **шаблон маршрута** и **методы HTTP**. Поведение этих параметров соответствует правилам для [триггеров HTTP].
5. Задайте **URL-адрес внутреннего сервера** для другой конечной точки. Ею может быть функция в другом приложении-функции или другой API. Значение не обязательно должно быть статическим и может ссылаться на [параметры приложения] и [параметры исходного запроса клиента].
6. Нажмите кнопку **Создать**.

Прокси теперь существует в виде новой конечной точки в приложении-функции. С точки зрения клиента это аналогично HttpTrigger в Функциях Azure. Можно испытать новый прокси, скопировав URL-адрес прокси и протестировав его с помощью избранного клиента HTTP.

## <a name="modify-requests-and-responses"></a><a name="modify-requests-responses"></a>Изменение запросов и ответов

Прокси-серверы Функций Azure позволяют изменять запросы и ответы из внутреннего сервера. При таком преобразовании используются переменные, указанные в разделе [Использование переменных].

### <a name="modify-the-back-end-request"></a><a name="modify-backend-request"></a>Изменение запроса внутреннего сервера

По умолчанию запрос внутреннего сервера инициализируется в качестве копии исходного запроса. Кроме настройки URL-адреса внутреннего сервера вы также можете изменить метод, заголовки и параметры строки запроса HTTP. Измененные значения могут ссылаться на [параметры приложения] и [параметры исходного запроса клиента].

Запросы на серверной стороне можно изменить на портале, развернув раздел *Переопределение запроса* на странице со сведениями о прокси-сервере. 

### <a name="modify-the-response"></a><a name="modify-response"></a>Изменить ответ

По умолчанию ответ клиента инициализируется в качестве копии ответа внутреннего сервера. Вы можете изменить код состояния, описание, заголовки и текст ответа. Измененные значения могут ссылаться на [Параметры приложения], [параметры из исходного запроса клиента]и [параметры из ответа серверной части].

Запросы на серверной стороне можно изменить на портале, развернув раздел *Переопределение ответа* на странице со сведениями о прокси-сервере. 

## <a name="use-variables"></a><a name="using-variables"></a>Использование переменных

Использовать статическую конфигурацию для прокси-сервера необязательно. Вы можете настроить для него использование переменных из исходного клиентского запроса, ответа внутреннего сервера или параметров приложения.

### <a name="reference-local-functions"></a><a name="reference-localhost"></a>Ссылки на локальные функции
Вы можете использовать `localhost` для прямой ссылки на функцию в одном и том же приложении-функции, не применяя запрос прокси-сервера для обмена данными.

`"backendUri": "https://localhost/api/httptriggerC#1"` будет ссылаться на локальную функцию, активируемую HTTP, на маршруте `/api/httptriggerC#1`.

 
>[!Note]  
>Если функция использует уровень авторизации *функции, администратора или системы*, вам нужно указать код и идентификатор клиента в соответствии с исходным URL-адресом функции. В этом случае ссылка будет выглядеть следующим образом: `"backendUri": "https://localhost/api/httptriggerC#1?code=<keyvalue>&clientId=<keyname>"` мы рекомендуем хранить эти ключи в [параметрах приложения] и ссылаться на них в прокси-серверах. Это позволяет избежать сохранения секретов в исходном коде. 

### <a name="reference-request-parameters"></a><a name="request-parameters"></a>Ссылки на параметры запроса

Параметры запроса можно использовать в качестве входных данных для свойства URL-адреса внутреннего сервера или в рамках изменения запросов и ответов. Некоторые параметры могут быть связаны с шаблоном маршрута, указанным в основной конфигурации прокси-сервера, тогда как другие задаются в соответствии со свойствами входящих запросов.

#### <a name="route-template-parameters"></a>Параметры шаблона маршрута
Параметры, используемые в шаблоне маршрута, указываются по именам, которые заключаются в фигурные скобки — {}.

Например, если прокси-сервер использует шаблон маршрута, подобный `/pets/{petId}`, URL-адрес внутреннего сервера может содержать значение `{petId}`, как в `https://<AnotherApp>.azurewebsites.net/api/pets/{petId}`. Если шаблон маршрута заканчивается подстановочным знаком, например `/api/{*restOfPath}`, значение `{restOfPath}` будет строковым представлением остальных сегментов пути входящего запроса.

#### <a name="additional-request-parameters"></a>Дополнительные параметры запроса
В дополнение к параметрам шаблона маршрута вы можете использовать следующие значения конфигурации:

* **{request.method}.** Метод HTTP, используемый в исходном запросе.
* **{request. Headers. \<HeaderName\> }**: заголовок, который можно считать из исходного запроса. Замените на *\<HeaderName\>* имя заголовка, который требуется считать. Если заголовок не включен в запрос, в качестве значения будет отображаться пустая строка.
* **{request. QueryString. \<ParameterName\> }**: параметр строки запроса, который может быть считан из исходного запроса. Замените на *\<ParameterName\>* имя параметра, который требуется считать. Если параметр не включен в запрос, в качестве значения будет отображаться пустая строка.

### <a name="reference-back-end-response-parameters"></a><a name="response-parameters"></a>Ссылки на параметры ответа внутреннего сервера

Параметры ответа можно использовать при изменении ответов для клиента. Следующие значения можно использовать в качестве значений конфигурации:

* **{backend.response.statusCode}.** Код состояния HTTP, возвращаемый для ответа внутреннего сервера.
* **{backend.response.statusReason}.** Код состояния HTTP, возвращаемый для ответа внутреннего сервера.
* **{Серверная часть. Response. Headers. \<HeaderName\> }**: заголовок, который можно считать из ответа серверной части. Замените на *\<HeaderName\>* имя заголовка, который требуется считать. Если заголовок не включен в ответ, в качестве значения будет отображаться пустая строка.

### <a name="reference-application-settings"></a><a name="use-appsettings"></a>Ссылки на параметры приложения

Вы также можете ссылаться на [Параметры приложения, определенные для приложения-функции](./functions-how-to-use-azure-function-app-settings.md) , заключив имя параметра в знаки процента (%).

Например, URL-адрес серверной части *https://%ORDER_PROCESSING_HOST%/api/orders* будет иметь значение "% ORDER_PROCESSING_HOST%", заменяя значением параметра ORDER_PROCESSING_HOST.

> [!TIP] 
> Используйте параметры приложения для внутренних узлов при наличии нескольких развертываний или тестовых сред. Таким образом, вы будете всегда обращаться к правильному внутреннему серверу в этой среде.

## <a name="troubleshoot-proxies"></a><a name="debugProxies"></a>Устранение неполадок функции "Прокси-серверы"

Добавьте флаг `"debug":true` к любому прокси-серверу в `proxies.json`, чтобы включить ведение журнала отладки. Журналы хранятся в папке `D:\home\LogFiles\Application\Proxies\DetailedTrace`. К ним можно получить доступ с помощью дополнительных инструментов (Kudu). Каждый HTTP-ответ также будет содержать заголовок `Proxy-Trace-Location` с URL-адресом для доступа к файлу журнала.

Чтобы отладить прокси-сервер на стороне клиента, добавьте заголовок `Proxy-Trace-Enabled` с заданным значением `true`. При этом также будут записываться журналы трассировки в файловую систему и URL-адрес трассировки будет возвращаться в качестве заголовка в ответе.

### <a name="block-proxy-traces"></a>Блокирование трассировок прокси-сервера

В целях безопасности вы можете запретить всем пользователям вызывать службу для создания файлов трассировки. Пользователи не смогут получить доступ к содержимому трассировки без ваших учетных данных для входа. Но создание файлов трассировки связано с потреблением ресурсов и свидетельствует о том, что вы используете прокси-серверы Функций Azure.

Чтобы полностью отключить трассировку, добавьте `"debug":false` для конкретного прокси-сервера в `proxies.json`.

## <a name="advanced-configuration"></a>Расширенная конфигурация

Настроенные прокси-серверы хранятся в файле *proxies.json*, расположенном в корневом каталоге приложения-функции. Вы можете вручную изменить этот файл и развернуть его как часть приложения, используя любой из [методов развертывания](./functions-continuous-deployment.md), поддерживаемых Функциями. 

> [!TIP] 
> Если вы не настроили ни один из методов развертывания, вы можете сделать это в файле *proxies.json*. Перейдите к приложению-функции и выберите **Функции платформы**, а затем — **Редактор службы приложений**. Так вы сможете просмотреть всю структуру файла приложения-функции и внести изменения.

Файл *proxies.json* определяется объектом proxies, который состоит из именованных прокси-серверов и их определений. При необходимости для автозавершения кода можно ссылаться на [схему JSON](http://json.schemastore.org/proxies), если ваш редактор поддерживает такую возможность. Например, файл может выглядеть следующим образом:

```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "proxy1": {
            "matchCondition": {
                "methods": [ "GET" ],
                "route": "/api/{test}"
            },
            "backendUri": "https://<AnotherApp>.azurewebsites.net/api/<FunctionName>"
        }
    }
}
```

Каждый прокси имеет понятное имя, как например *proxy1* в предыдущем примере. Соответствующий объект определения прокси определяется следующими свойствами:

* **matchCondition** (обязательное) — объект, который определяет запросы, активирующие выполнение этого прокси-сервера. Он содержит два свойства, используемые совместно с [триггерами HTTP]:
    * _methods_ — массив методов HTTP, на которые отвечает прокси-сервер. Если свойство не указано, прокси-сервер будет отвечать на все методы HTTP в маршруте.
    * _route_ (обязательное) — шаблон маршрута, определяющий URL-адреса запросов, на которые будет отвечать прокси-сервер. В отличие от триггеров HTTP значение по умолчанию отсутствует.
* **backendUri** — URL-адрес внутреннего ресурса, к которому должен быть отправлен запрос. Это значение может ссылаться на параметры приложения и параметры исходного запроса клиента. Если это свойство не включено, Функции Azure вернут ответ HTTP 200 OK.
* **requestOverrides.** Объект, определяющий преобразование запросов внутреннего сервера. Ознакомьтесь с разделом [Определение объекта requestOverrides].
* **responseOverrides.** Объект, определяющий преобразование ответа клиента. Ознакомьтесь с разделом [Определение объекта responseOverrides].

> [!NOTE] 
> Свойство *route* в функции "Прокси-серверы Функций Azure" не учитывает свойство *routePrefix* конфигурации узла приложения-функции. Если вы хотите включить префикс, например `/api`, он должен быть включен в свойство *route*.

### <a name="disable-individual-proxies"></a><a name="disableProxies"></a> Отключение отдельных прокси-серверов

Вы можете отключить отдельные прокси-серверы, добавив `"disabled": true` для прокси-сервера в файле `proxies.json`. В результате для всех запросов, соответствующих значению matchCondition, будет возвращаться ошибка 404.
```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "Root": {
            "disabled":true,
            "matchCondition": {
                "route": "/example"
            },
            "backendUri": "https://<AnotherApp>.azurewebsites.net/api/<FunctionName>"
        }
    }
}
```

### <a name="application-settings"></a><a name="applicationSettings"></a> Параметры приложения

Поведением прокси-сервера можно управлять с помощью нескольких параметров приложения. Сведения о них можно узнать из статьи [Справочник по параметрам приложений для Функций Azure](./functions-app-settings.md).

* [AZURE_FUNCTION_PROXY_DISABLE_LOCAL_CALL](./functions-app-settings.md#azure_function_proxy_disable_local_call)
* [AZURE_FUNCTION_PROXY_BACKEND_URL_DECODE_SLASHES](./functions-app-settings.md#azure_function_proxy_backend_url_decode_slashes)

### <a name="reserved-characters-string-formatting"></a><a name="reservedChars"></a> Зарезервированные символы (форматирование строк)

Прокси-серверы считывают все строки из JSON-файла, используя \ как escape-символ. Кроме того, прокси-серверы интерпретируют фигурные скобки. См. полный список примеров ниже.

|Символ|Экранируемый символ|Пример|
|-|-|-|
|{ или }|{{ или }}|`{{ example }}` --> `{ example }`
| \ | \\\\ | `example.com\\text.html` --> `example.com\text.html`
|"|\\\"| `\"example\"` --> `"example"`

### <a name="define-a-requestoverrides-object"></a><a name="requestOverrides"></a>Определение объекта requestOverrides

Объект requestOverrides определяет изменения, внесенные в запрос во время вызова внутреннего ресурса. Объект определяется следующими свойствами:

* **backend.request.method** — метод HTTP, используемый для вызова внутреннего сервера.
* **Серверная часть. Request. \<ParameterName\> Querystring.**: параметр строки запроса, который может быть установлен для вызова серверной части. Замените на *\<ParameterName\>* имя параметра, который необходимо задать. Обратите внимание, что если указана пустая строка, параметр по-прежнему включается в запрос серверной части.
* **Серверная часть. Request. \<HeaderName\> Headers.**: заголовок, который можно задать для вызова серверной части. Замените на *\<HeaderName\>* имя заголовка, который необходимо задать. Обратите внимание, что если указана пустая строка, параметр по-прежнему включается в запрос серверной части.

Значения могут ссылаться на параметры приложения и параметры исходного запроса клиента.

Пример конфигурации может выглядеть следующим образом:

```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "proxy1": {
            "matchCondition": {
                "methods": [ "GET" ],
                "route": "/api/{test}"
            },
            "backendUri": "https://<AnotherApp>.azurewebsites.net/api/<FunctionName>",
            "requestOverrides": {
                "backend.request.headers.Accept": "application/xml",
                "backend.request.headers.x-functions-key": "%ANOTHERAPP_API_KEY%"
            }
        }
    }
}
```

### <a name="define-a-responseoverrides-object"></a><a name="responseOverrides"></a>Определение объекта responseOverrides

Объект requestOverrides определяет изменения, внесенные в ответ, который передается обратно к клиенту. Объект определяется следующими свойствами:

* **response.statusCode.** Код состояния HTTP, который будет возвращен клиенту.
* **response.statusReason.** Описание HTTP, которое будет возвращено клиенту.
* **response.body.** Строковое представление текста, который будет возвращен клиенту.
* **Response. Headers \<HeaderName\> .**: заголовок, который может быть установлен для ответа клиенту. Замените на *\<HeaderName\>* имя заголовка, который необходимо задать. Если указана пустая строка, заголовок не включается в ответ.

Значения могут ссылаться на параметры приложения, параметры исходного запроса клиента и параметры ответа внутреннего сервера.

Пример конфигурации может выглядеть следующим образом:

```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "proxy1": {
            "matchCondition": {
                "methods": [ "GET" ],
                "route": "/api/{test}"
            },
            "responseOverrides": {
                "response.body": "Hello, {test}",
                "response.headers.Content-Type": "text/plain"
            }
        }
    }
}
```
> [!NOTE] 
> В этом примере текст ответа задается напрямую, поэтому задавать свойство `backendUri` не требуется. В примере показано, как можно использовать прокси-серверы Функций Azure для имитации API.

[Портал Azure]: https://portal.azure.com
[Триггеры HTTP]: ./functions-bindings-http-webhook.md
[Modify the back-end request]: #modify-backend-request
[Modify the response]: #modify-response
[Определение объекта requestOverrides]: #requestOverrides
[Определение объекта responseOverrides]: #responseOverrides
[Параметры приложения]: #use-appsettings
[Использование переменных]: #using-variables
[Параметры, установленные для исходного запроса клиента]: #request-parameters
[параметры из ответа серверной части]: #response-parameters
