---
title: Справочник разработчика PowerShell для функций Azure
description: Узнайте, как разрабатывать функции с помощью PowerShell.
author: eamonoreilly
ms.topic: conceptual
ms.custom: devx-track-dotnet, devx-track-azurepowershell
ms.date: 04/22/2019
ms.openlocfilehash: 61ed3ed274505101c65e251260bd759fe78f7b31
ms.sourcegitcommit: 2aa52d30e7b733616d6d92633436e499fbe8b069
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "97936793"
---
# <a name="azure-functions-powershell-developer-guide"></a>Руководство разработчика PowerShell для Функций Azure.

Эта статья содержит сведения о том, как вы пишете функции Azure с помощью PowerShell.

Функция Azure PowerShell (функция) представляется в виде скрипта PowerShell, который выполняется при срабатывании. Каждый сценарий функции имеет связанный `function.json` файл, который определяет, как работает функция, например, как она запускается, а также ее входные и выходные параметры. Дополнительные сведения см. в [статье о триггерах и привязке](functions-triggers-bindings.md). 

Как и другие типы функций, функции скриптов PowerShell принимают параметры, соответствующие именам всех входных привязок, определенных в `function.json` файле. `TriggerMetadata`Также передается параметр, содержащий дополнительные сведения о триггере, который запустил функцию.

В этой статье предполагается, что вы уже прочли [руководство для разработчиков по Функциям Azure](functions-reference.md). Кроме того, для создания первой функции PowerShell необходимо завершить работу с [кратким руководством по функциям PowerShell](./create-first-function-vs-code-powershell.md) .

## <a name="folder-structure"></a>Структура папок

Необходимая структура папок для проекта PowerShell выглядит следующим образом. Это значение по умолчанию можно изменить. Дополнительные сведения см. в разделе о [scriptFile](#configure-function-scriptfile) ниже.

```
PSFunctionApp
 | - MyFirstFunction
 | | - run.ps1
 | | - function.json
 | - MySecondFunction
 | | - run.ps1
 | | - function.json
 | - Modules
 | | - myFirstHelperModule
 | | | - myFirstHelperModule.psd1
 | | | - myFirstHelperModule.psm1
 | | - mySecondHelperModule
 | | | - mySecondHelperModule.psd1
 | | | - mySecondHelperModule.psm1
 | - local.settings.json
 | - host.json
 | - requirements.psd1
 | - profile.ps1
 | - extensions.csproj
 | - bin
```

В корне проекта есть общий [`host.json`](functions-host-json.md) файл, который можно использовать для настройки приложения-функции. У каждой функции есть папка с собственным файлом кода (PS1) и файл конфигурации привязки ( `function.json` ). Имя function.jsродительского каталога файла всегда является именем функции.

Для определенных привязок требуется наличие `extensions.csproj` файла. Расширения привязки, необходимые в [версии 2. x и более поздних версиях](functions-versions.md) среды выполнения функций, определяются в `extensions.csproj` файле с фактическими файлами библиотеки в `bin` папке. При локальной разработке необходимо [зарегистрировать расширения привязки](functions-bindings-register.md#extension-bundles). При разработке функций на портале Azure эта регистрация выполняется автоматически.

В приложениях-функциях PowerShell при необходимости можно использовать, `profile.ps1` который запускается при запуске приложения-функции (в противном случае — как *[холодный запуск](#cold-start)*). Дополнительные сведения см. в разделе [профиль PowerShell](#powershell-profile).

## <a name="defining-a-powershell-script-as-a-function"></a>Определение скрипта PowerShell как функции

По умолчанию среда выполнения Функций ищет функцию в файле `run.ps1`, где `run.ps1` использует тот же родительский каталог, что и соответствующий файл `function.json`.

При выполнении скрипту передается ряд аргументов. Чтобы обрабатывал эти параметры, добавьте `param` блок в начало скрипта, как показано в следующем примере:

```powershell
# $TriggerMetadata is optional here. If you don't need it, you can safely remove it from the param block
param($MyFirstInputBinding, $MySecondInputBinding, $TriggerMetadata)
```

### <a name="triggermetadata-parameter"></a>Тригжерметадата, параметр

`TriggerMetadata`Параметр используется для предоставления дополнительных сведений о триггере. Дополнительные метаданные отличаются от привязки к привязке, но все они содержат `sys` свойство, которое содержит следующие данные:

```powershell
$TriggerMetadata.sys
```

| Свойство   | Описание                                     | Тип     |
|------------|-------------------------------------------------|----------|
| UtcNow     | Когда, в формате UTC, была активирована функция        | Дата и время |
| MethodName | Имя функции, которая была активирована     | строка   |
| рандгуид   | уникальный идентификатор GUID для этого выполнения функции | строка   |

Каждый тип триггера имеет другой набор метаданных. Например, `$TriggerMetadata` для `QueueTrigger` содержит `InsertionTime` ,, и, помимо прочего, `Id` `DequeueCount` . Дополнительные сведения о метаданных триггера очереди см. в [официальной документации по триггерам очереди](functions-bindings-storage-queue-trigger.md#message-metadata). Ознакомьтесь с документацией по [триггерам](functions-triggers-bindings.md) , с которыми вы работаете, чтобы узнать, что входит в метаданные триггера.

## <a name="bindings"></a>Привязки

В PowerShell [привязки](functions-triggers-bindings.md) настраиваются и определяются в function.jsфункции. Функции взаимодействуют с привязками несколькими способами.

### <a name="reading-trigger-and-input-data"></a>Чтение триггера и входных данных

Привязки триггера и ввода считываются как параметры, передаваемые в функцию. Для входных привязок `direction` задано значение `in` в function.json. `name`Свойство, определенное в `function.json` , является именем параметра в `param` блоке. Так как PowerShell использует именованные параметры для привязки, порядок параметров не имеет значения. Однако рекомендуется следовать порядку привязок, определенных в `function.json` .

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)
```

### <a name="writing-output-data"></a>запись выходных данных;

В функциях выходная привязка имеет значение, заданное `direction` `out` в function.json. Запись в выходную привязку можно выполнить с помощью `Push-OutputBinding` командлета, который доступен для среды выполнения функций. Во всех случаях `name` свойство привязки, определенное в, `function.json` соответствует `Name` параметру `Push-OutputBinding` командлета.

Ниже показано, как вызвать `Push-OutputBinding` в скрипте функции:

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)

Push-OutputBinding -Name myQueue -Value $myValue
```

Можно также передать значение для конкретной привязки через конвейер.

```powershell
param($MyFirstInputBinding, $MySecondInputBinding)

Produce-MyOutputValue | Push-OutputBinding -Name myQueue
```

`Push-OutputBinding` ведет себя по-разному в зависимости от значения, указанного для `-Name` :

* Если указанное имя не может быть разрешено в допустимую выходную привязку, возникает ошибка.

* Если выходная привязка принимает коллекцию значений, `Push-OutputBinding` для отправки нескольких значений можно многократно вызывать несколько раз.

* Если выходная привязка принимает только одноэлементное значение, вызов `Push-OutputBinding` второго раза вызывает ошибку.

#### <a name="push-outputbinding-syntax"></a>Синтаксис `Push-OutputBinding`

Ниже приведены допустимые параметры для вызова `Push-OutputBinding` .

| Имя | Тип | Положение | Описание |
| ---- | ---- |  -------- | ----------- |
| **`-Name`** | Строка | 1 | Имя выходной привязки, которую необходимо задать. |
| **`-Value`** | Объект | 2 | Значение выходной привязки, которое необходимо задать, которое принимается из Бивалуе конвейера. |
| **`-Clobber`** | Параметр-переключатель | именованная | Используемых При указании параметра устанавливает значение для заданной выходной привязки. | 

Также поддерживаются следующие общие параметры: 
* `Verbose`
* `Debug`
* `ErrorAction`
* `ErrorVariable`
* `WarningAction`
* `WarningVariable`
* `OutBuffer`
* `PipelineVariable`
* `OutVariable` 

Дополнительные сведения см. в разделе [About общиепараметры](/powershell/module/microsoft.powershell.core/about/about_commonparameters).

#### <a name="push-outputbinding-example-http-responses"></a>Push-OutputBinding пример: HTTP-ответы

Триггер HTTP возвращает ответ, используя выходную привязку с именем `response` . В следующем примере выходная привязка `response` имеет значение "output #1":

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #1"
})
```

Поскольку выходным данным является HTTP, которая принимает только одноэлементное значение, возникает ошибка, когда `Push-OutputBinding` вызывается второй раз.

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #2"
})
```

Для выходов, которые принимают только одноэлементные значения, можно использовать `-Clobber` параметр для переопределения старого значения вместо того, чтобы пытаться добавить его в коллекцию. В следующем примере предполагается, что вы уже добавили значение. Используя `-Clobber` , ответ из следующего примера переопределяет существующее значение для возврата значения "output #3":

```powershell
PS >Push-OutputBinding -Name response -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "output #3"
}) -Clobber
```

#### <a name="push-outputbinding-example-queue-output-binding"></a>Push-OutputBinding пример: Выходная привязка очереди

`Push-OutputBinding` используется для отправки данных в выходные привязки, такие как [выходная привязка хранилища очередей Azure](functions-bindings-storage-queue-output.md). В следующем примере сообщение, записанное в очередь, имеет значение "Output #1":

```powershell
PS >Push-OutputBinding -Name outQueue -Value "output #1"
```

Выходная привязка для очереди хранилища принимает несколько выходных значений. В этом случае вызов следующего примера после первой записи в очередь списка с двумя элементами: "Output #1" и "Output #2".

```powershell
PS >Push-OutputBinding -Name outQueue -Value "output #2"
```

В следующем примере, когда вызывается после двух предыдущих, в выходную коллекцию добавляется еще два значения:

```powershell
PS >Push-OutputBinding -Name outQueue -Value @("output #3", "output #4")
```

При запись в очередь сообщение содержит следующие четыре значения: "Output #1", "Output #2", "Output #3" и "Output #4".

#### <a name="get-outputbinding-cmdlet"></a>Командлет `Get-OutputBinding`

`Get-OutputBinding`С помощью командлета можно получить значения, заданные в данный момент для выходных привязок. Этот командлет извлекает хэш-таблицу, содержащую имена выходных привязок с соответствующими значениями. 

Ниже приведен пример использования `Get-OutputBinding` для возврата текущих значений привязки.

```powershell
Get-OutputBinding
```

```Output
Name                           Value
----                           -----
MyQueue                        myData
MyOtherQueue                   myData
```

`Get-OutputBinding` также содержит параметр с именем `-Name` , который можно использовать для фильтрации возвращаемой привязки, как показано в следующем примере:

```powershell
Get-OutputBinding -Name MyQ*
```

```Output
Name                           Value
----                           -----
MyQueue                        myData
```

Подстановочные знаки (*) поддерживаются в `Get-OutputBinding` .

## <a name="logging"></a>Ведение журнала

Ведение журнала в функциях PowerShell работает как обычное ведение журнала PowerShell. Командлеты ведения журнала можно использовать для записи в каждый выходной поток. Каждый командлет сопоставляется с уровнем ведения журнала, который используется функциями.

| Уровень ведения журнала функций | Командлет ведения журнала |
| ------------- | -------------- |
| Ошибка | **`Write-Error`** |
| Предупреждение | **`Write-Warning`**  | 
| Информация | **`Write-Information`** <br/> **`Write-Host`** <br /> **`Write-Output`**      | Информация | Выполняет запись в журнал на уровне _информации_ . |
| Отладка | **`Write-Debug`** |
| Трассировка | **`Write-Progress`** <br /> **`Write-Verbose`** |

Помимо этих командлетов, все данные, записанные в конвейер, перенаправляются на `Information` уровень ведения журнала и отображаются с форматированием PowerShell по умолчанию.

> [!IMPORTANT]
> Использование `Write-Verbose` `Write-Debug` командлетов или не является достаточным для просмотра подробных сведений и ведения журнала на уровне отладки. Кроме того, необходимо настроить пороговое значение уровня ведения журнала, которое объявляет, какой уровень журналов вы в действительности интересуют. Дополнительные сведения см. в статье [Настройка уровня ведения журнала приложения функции](#configure-the-function-app-log-level).

### <a name="configure-the-function-app-log-level"></a>Настройка уровня ведения журнала приложения функции

Функции Azure позволяют определить пороговый уровень, чтобы упростить управление способом записи функций в журналы. Чтобы задать пороговое значение для всех трассировок, записываемых на консоль, используйте `logging.logLevel.default` свойство в [ `host.json` файле] [host.jsпо ссылке]. Этот параметр применяется ко всем функциям в приложении-функции.

В следующем примере устанавливается пороговое значение для включения подробного ведения журнала для всех функций, но устанавливается пороговое значение включения ведения журнала отладки для функции с именем `MyFunction` :

```json
{
    "logging": {
        "logLevel": {
            "Function.MyFunction": "Debug",
            "default": "Trace"
        }
    }
}  
```

Дополнительные сведения см. в [справочной статье о host.json].

### <a name="viewing-the-logs"></a>Просмотр журналов

Если приложение-функция выполняется в Azure, можно использовать Application Insights для мониторинга. Дополнительные сведения о просмотре журналов функций и обращении к ним см. в статье [мониторинг Функций Azure](functions-monitoring.md).

Если вы используете приложение-функция локально для разработки, ведет журнал по умолчанию в файловой системе. Чтобы просмотреть журналы в консоли, задайте `AZURE_FUNCTIONS_ENVIRONMENT` для переменной среды значение `Development` перед запуском приложение-функция.

## <a name="triggers-and-bindings-types"></a>Типы триггеров и привязок

Существует ряд триггеров и привязок, которые можно использовать с приложением-функцией. Полный список триггеров и привязок [можно найти здесь](functions-triggers-bindings.md#supported-bindings).

Все триггеры и привязки представлены в коде как несколько реальных типов данных:

* Хэш-таблицы
* строка
* byte[]
* INT
* double
* хттпрекуестконтекст
* хттпреспонсеконтекст

Первые пять типов в этом списке являются стандартными типами .NET. Последние два используются только [триггером HttpTrigger](#http-triggers-and-bindings).

Каждый параметр привязки в функциях должен иметь один из этих типов.

### <a name="http-triggers-and-bindings"></a>Триггеры и привязки HTTP

Триггеры HTTP и webhook, а также привязки вывода HTTP используют объекты запроса и ответа для обмена сообщениями HTTP.

#### <a name="request-object"></a>Объект запроса

Объект запроса, переданный в скрипт, имеет тип `HttpRequestContext` , который имеет следующие свойства:

| Свойство  | Описание                                                    | Тип                      |
|-----------|----------------------------------------------------------------|---------------------------|
| **`Body`**    | Объект, содержащий текст запроса. `Body` сериализуется в лучший тип на основе данных. Например, если данные являются JSON, они передаются в виде хэш-таблицы. Если данные являются строкой, они передаются в виде строки. | object |
| **`Headers`** | Словарь, содержащий заголовки запроса.                | Строка<словаря, строка><sup>*</sup> |
| **`Method`** | Метод HTTP, используемый для запроса.                                | строка                    |
| **`Params`**  | Объект, содержащий параметры маршрутизации запроса. | Строка<словаря, строка><sup>*</sup> |
| **`Query`** | Объект, содержащий параметры запроса.                  | Строка<словаря, строка><sup>*</sup> |
| **`Url`** | URL-адрес запроса.                                        | строка                    |

<sup>*</sup> Во всех `Dictionary<string,string>` ключах регистр не учитывается.

#### <a name="response-object"></a>Объект ответа

Объект ответа, который необходимо отправить обратно, имеет тип `HttpResponseContext` , который имеет следующие свойства:

| Свойство      | Описание                                                 | Тип                      |
|---------------|-------------------------------------------------------------|---------------------------|
| **`Body`**  | Объект, содержащий текст ответа.           | object                    |
| **`ContentType`** | Короткий рукой для установки типа содержимого для ответа. | строка                    |
| **`Headers`** | Объект, содержащий заголовок ответа.               | Словарь или хэш-таблица   |
| **`StatusCode`**  | Код состояния HTTP ответа.                       | строка или целое число             |

#### <a name="accessing-the-request-and-response"></a>Доступ к запросу и ответу

При работе с триггерами HTTP доступ к HTTP-запросу можно получить так же, как и с любой другой входной привязкой. Он находится в `param` блоке.

Используйте `HttpResponseContext` объект для возврата ответа, как показано ниже:

`function.json`

```json
{
  "bindings": [
    {
      "type": "httpTrigger",
      "direction": "in",
      "authLevel": "anonymous"
    },
    {
      "type": "http",
      "direction": "out"
    }
  ]
}
```

`run.ps1`

```powershell
param($req, $TriggerMetadata)

$name = $req.Query.Name

Push-OutputBinding -Name res -Value ([HttpResponseContext]@{
    StatusCode = [System.Net.HttpStatusCode]::OK
    Body = "Hello $name!"
})
```

Результат вызова этой функции будет следующим:

```
PS > irm http://localhost:5001?Name=Functions
Hello Functions!
```

### <a name="type-casting-for-triggers-and-bindings"></a>Приведение типов для триггеров и привязок

Для некоторых привязок, таких как привязка больших двоичных объектов, можно указать тип параметра.

Например, чтобы данные из хранилища BLOB-объектов передавались в виде строки, добавьте следующий тип к моему `param` блоку:

```powershell
param([string] $myBlob)
```

## <a name="powershell-profile"></a>Профиль PowerShell

В PowerShell есть понятие профиля PowerShell. Если вы не знакомы с профилями PowerShell, см. раздел [About Profiles](/powershell/module/microsoft.powershell.core/about/about_profiles).

В функциях PowerShell скрипт профиля выполняется один раз для каждого экземпляра рабочего процесса PowerShell в приложении при первом развертывании и после его бездействия ([холодный запуск](#cold-start). Если параметр Concurrency включен с помощью значения [псворкеринпрокконкурренциуппербаунд](#concurrency) , скрипт профиля выполняется для каждого создаваемого пространства выполнения.

При создании приложения-функции с помощью средств, таких как Visual Studio Code и Azure Functions Core Tools, создается значение по умолчанию `profile.ps1` . Профиль по умолчанию хранится [в репозитории основных средств](https://github.com/Azure/azure-functions-core-tools/blob/dev/src/Azure.Functions.Cli/StaticResources/profile.ps1) , который содержит:

* Автоматическая проверка подлинности MSI в Azure.
* Возможность включения Azure PowerShell `AzureRM` псевдонимов PowerShell при желании.

## <a name="powershell-versions"></a>Версии PowerShell

В следующей таблице приведены версии PowerShell, доступные для каждой основной версии среды выполнения функций, и требуемая версия .NET.

| Версия службы "Функции" | Версия PowerShell                               | Версия .NET  | 
|-------------------|--------------------------------------------------|---------------|
| 3. x (рекомендуется) | PowerShell 7 (рекомендуется)<br/>PowerShell Core 6 | .NET Core 3.1<br/>.NET Core 2.1 |
| 2.x               | PowerShell Core 6                                | .NET Core 2.2 |

Текущую версию можно просмотреть, выполнив печать `$PSVersionTable` из любой функции.

### <a name="running-local-on-a-specific-version"></a>Локальный запуск в определенной версии

При локальном запуске среда выполнения функций Azure по умолчанию использует PowerShell Core 6. Чтобы вместо этого использовать PowerShell 7 при локальном запуске, необходимо добавить параметр `"FUNCTIONS_WORKER_RUNTIME_VERSION" : "~7"` в `Values` массив в файле local.setting.jsв корневом каталоге проекта. При локальном запуске в PowerShell 7 local.settings.jsв файле выглядит, как в следующем примере: 

```json
{
  "IsEncrypted": false,
  "Values": {
    "AzureWebJobsStorage": "",
    "FUNCTIONS_WORKER_RUNTIME": "powershell",
    "FUNCTIONS_WORKER_RUNTIME_VERSION" : "~7"
  }
}
```

### <a name="changing-the-powershell-version"></a>Изменение версии PowerShell

Приложение функции должно работать на версии 3. x, чтобы иметь возможность выполнить обновление с PowerShell Core 6 до PowerShell 7. Чтобы узнать, как это сделать, см. статью [Просмотр и обновление текущей версии среды выполнения](set-runtime-version.md#view-and-update-the-current-runtime-version).

Чтобы изменить версию PowerShell, используемую приложением функции, выполните следующие действия. Это можно сделать либо в портал Azure, либо с помощью PowerShell.

# <a name="portal"></a>[Портал](#tab/portal)

1. На [портале Azure](https://portal.azure.com) перейдите к приложению-функции.

1. В разделе **Параметры** выберите **Конфигурация**. На вкладке **Общие параметры** выберите **версию PowerShell**. 

    :::image type="content" source="media/functions-reference-powershell/change-powershell-version-portal.png" alt-text="Выберите версию PowerShell, используемую приложением функции"::: 

1. Выберите нужную **версию PowerShell Core** и нажмите кнопку **сохранить**. При предупреждении о ожидающем перезапуске выберите **Continue (продолжить**). Приложение функции перезапускается в выбранной версии PowerShell. 

# <a name="powershell"></a>[PowerShell](#tab/powershell)

Выполните следующий скрипт, чтобы изменить версию PowerShell: 

```powershell
Set-AzResource -ResourceId "/subscriptions/<SUBSCRIPTION_ID>/resourceGroups/<RESOURCE_GROUP>/providers/Microsoft.Web/sites/<FUNCTION_APP>/config/web" -Properties @{  powerShellVersion  = '<VERSION>' } -Force -UsePatchSemantics

```

Замените `<SUBSCRIPTION_ID>` , `<RESOURCE_GROUP>` и `<FUNCTION_APP>` идентификатором своей подписки Azure, именем группы ресурсов и приложением функции соответственно.  Кроме того, замените `<VERSION>` на `~6` либо `~7` . Вы можете проверить обновленное значение `powerShellVersion` параметра в `Properties` возвращаемой хэш-таблице. 

---

После внесения изменений в конфигурацию приложение-функция перезапускается.

## <a name="dependency-management"></a>Управление зависимостями

Функции позволяют использовать [коллекцию PowerShell](https://www.powershellgallery.com) для управления зависимостями. При включенном управлении зависимостями файл requirements.psd1 используется для автоматической загрузки необходимых модулей. Это поведение можно включить, задав `managedDependency` для свойства значение `true` в корневом каталоге [host.jsдля файла](functions-host-json.md), как показано в следующем примере:

```json
{
  "managedDependency": {
          "enabled": true
       }
}
```

При создании нового проекта функций PowerShell управление зависимостями включается по умолчанию с включенным [ `Az` модулем](/powershell/azure/new-azureps-module-az) Azure. Максимальное число модулей, поддерживаемое в настоящее время, равно 10. Поддерживаемый синтаксис — _`MajorNumber`_ `.*` или точная версия модуля, как показано в следующем requirements.psd1 примере:

```powershell
@{
    Az = '1.*'
    SqlServer = '21.1.18147'
}
```

При обновлении файла requirements.psd1 обновленные модули устанавливаются после перезагрузки.

> [!NOTE]
> Управляемым зависимостям требуется доступ к www.powershellgallery.com для скачивания модулей. При локальном запуске убедитесь, что среда выполнения может получить доступ к этому URL-адресу, добавив необходимые правила брандмауэра.

> [!NOTE]
> В настоящее время управляемые зависимости не поддерживают модули, требующие от пользователя принятия лицензии, либо путем принятия лицензии в интерактивном режиме, либо путем предоставления `-AcceptLicense` коммутатора при вызове `Install-Module` .

Следующие параметры приложения можно использовать для изменения способа загрузки и установки управляемых зависимостей. Обновление приложения начинается в пределах `MDMaxBackgroundUpgradePeriod` , а процесс обновления завершается примерно в `MDNewSnapshotCheckPeriod` .

| Параметр приложение-функция              | Значение по умолчанию             | Описание                                         |
|   -----------------------------   |   -------------------     |  -----------------------------------------------    |
| **`MDMaxBackgroundUpgradePeriod`**      | `7.00:00:00` (7 дней)     | Каждый рабочий процесс PowerShell инициирует проверку наличия обновлений модулей на коллекция PowerShell при запуске процесса и каждый `MDMaxBackgroundUpgradePeriod` после этого. Если в коллекция PowerShell доступна новая версия модуля, она устанавливается в файловую систему и становится доступной для рабочих ролей PowerShell. Уменьшение этого значения позволяет приложению-функции получать более новые версии модулей быстрее, но также увеличивает использование ресурсов приложения (сетевой ввод-вывод, ЦП, хранилище). Увеличение этого значения приводит к уменьшению использования ресурсов приложением, но может также задержать доставку новых версий модуля в приложение. | 
| **`MDNewSnapshotCheckPeriod`**         | `01:00:00` (1 час)       | После установки новых версий модулей в файловой системе необходимо перезапустить каждый рабочий процесс PowerShell. Перезапуск рабочих ролей PowerShell влияет на доступность приложения, так как он может прерывать текущее выполнение функции. До тех пор пока все рабочие процессы PowerShell не будут перезапущены, вызовы функций могут использовать либо старые, либо новые версии модулей. Перезапуск всех рабочих ролей PowerShell завершен в `MDNewSnapshotCheckPeriod` . Увеличение этого значения снижает частоту прерываний, но также может увеличить период времени, в течение которого вызовы функций используют старую или новую версию модуля недетерминированно. |
| **`MDMinBackgroundUpgradePeriod`**      | `1.00:00:00` (1 день)     | Чтобы избежать чрезмерного обновления модулей при частых перезапусках рабочих ролей, проверка обновления модулей не выполняется, когда любой рабочий процесс уже инициировал эту проверку в последней `MDMinBackgroundUpgradePeriod` . |

Использование собственных пользовательских модулей немного отличается от того, как это можно сделать обычным образом.

На локальном компьютере модуль устанавливается в одну из глобально доступных папок в `$env:PSModulePath` . При работе в Azure у вас нет доступа к модулям, установленным на вашем компьютере. Это означает, что объект `$env:PSModulePath` для приложения-функции PowerShell отличается от `$env:PSModulePath` в регулярном скрипте PowerShell.

В функциях `PSModulePath` содержит два пути:

* `Modules`Папка, которая находится в корне приложения-функции.
* Путь к `Modules` папке, управляемой рабочим работником языка PowerShell.


### <a name="function-app-level-modules-folder"></a>Папка уровня приложения-функции `Modules`

Чтобы использовать пользовательские модули, можно разместить модули, от которых зависят функции, в `Modules` папке. Из этой папки модули автоматически становятся доступными для среды выполнения функций. Все функции в приложении функции могут использовать эти модули. 

> [!NOTE]
> Модули, указанные в файле requirements.psd1, автоматически загружаются и включаются в путь, поэтому их не нужно включать в папку Modules. Они хранятся локально в `$env:LOCALAPPDATA/AzureFunctions` папке и в `/data/ManagedDependencies` папке при запуске в облаке.

Чтобы воспользоваться функцией пользовательского модуля, создайте `Modules` папку в корне приложения-функции. Скопируйте модули, которые вы хотите использовать в функциях, в это расположение.

```powershell
mkdir ./Modules
Copy-Item -Path /mymodules/mycustommodule -Destination ./Modules -Recurse
```

В `Modules` папке приложение-функция должно иметь следующую структуру папок:

```
PSFunctionApp
 | - MyFunction
 | | - run.ps1
 | | - function.json
 | - Modules
 | | - MyCustomModule
 | | - MyOtherCustomModule
 | | - MySpecialModule.psm1
 | - local.settings.json
 | - host.json
 | - requirements.psd1
```

При запуске приложения-функции языковой рабочий процесс PowerShell добавляет эту папку в, `Modules` `$env:PSModulePath` чтобы вы могли полагаться на автозагрузку модуля точно так же, как в обычном сценарии PowerShell.

### <a name="language-worker-level-modules-folder"></a>Папка уровня рабочей роли языка `Modules`

Рабочие роли языка PowerShell обычно используют несколько модулей. Эти модули определяются в последней должности `PSModulePath` . 

Текущий список модулей выглядит следующим образом:

* [Microsoft. PowerShell. Archive](https://www.powershellgallery.com/packages/Microsoft.PowerShell.Archive): модуль, используемый для работы с архивами, например `.zip` , `.nupkg` и другими.
* **Среаджоб**: реализация API-интерфейсов задания PowerShell на основе потока.

По умолчанию функции используют самые последние версии этих модулей. Чтобы использовать конкретную версию модуля, вставьте эту конкретную версию в `Modules` папку приложения-функции.

## <a name="environment-variables"></a>Переменные среды

В Функциях [параметры приложения](functions-app-settings.md), такие как строки подключения службы, доступны в виде переменных среды во время выполнения. Доступ к этим параметрам можно получить с помощью `$env:NAME_OF_ENV_VAR` , как показано в следующем примере:

```powershell
param($myTimer)

Write-Host "PowerShell timer trigger function ran! $(Get-Date)"
Write-Host $env:AzureWebJobsStorage
Write-Host $env:WEBSITE_SITE_NAME
```

[!INCLUDE [Function app settings](../../includes/functions-app-settings.md)]

При локальном запуске приложения параметры считываются из файла проекта [local.settings.json](functions-run-local.md#local-settings-file).

## <a name="concurrency"></a>Параллелизм

По умолчанию среда выполнения PowerShell для функций может обрабатывать только один вызов функции за раз. Однако этот уровень параллелизма может быть недостаточно в следующих ситуациях:

* При одновременной обработке большого количества вызовов одновременно.
* При наличии функций, которые вызывают другие функции в одном и том же приложении функции.

Существует несколько моделей параллелизма, которые можно исследовать в зависимости от типа рабочей нагрузки.

* Увеличить ```FUNCTIONS_WORKER_PROCESS_COUNT``` . Это позволяет обрабатывать вызовы функций в нескольких процессах в одном экземпляре, что приводит к определенным издержкам ЦП и памяти. Как правило, функции, связанные с вводом-выводом, не повлияют на эту нагрузку. Для функций, зависящих от процессора, влияние может быть значительным.

* Увеличьте ```PSWorkerInProcConcurrencyUpperBound``` значение параметра приложения. Это позволяет создавать несколько пространств выполнения в рамках одного процесса, что значительно сокращает нагрузку на ЦП и память.

Эти переменные среды задаются в [параметрах приложения](functions-app-settings.md) для приложения функции.

В зависимости от варианта использования Устойчивые функции может значительно повысить масштабируемость. Дополнительные сведения см. в разделе [шаблоны приложений устойчивые функции](./durable/durable-functions-overview.md?tabs=powershell#application-patterns).

>[!NOTE]
> Вы можете получить сообщение "запросы помещаются в очередь из-за отсутствия доступных пространств выполнения". Обратите внимание, что это не ошибка. Сообщение говорит о том, что запросы помещаются в очередь и будут обработаны после завершения предыдущих запросов.

### <a name="considerations-for-using-concurrency"></a>Рекомендации по использованию параллелизма

По умолчанию PowerShell является _отдельным потоковым_ языком сценариев. Однако параллелизм можно добавить с помощью нескольких пространств выполнения PowerShell в одном процессе. Объем созданных пространств выполнения будет соответствовать ```PSWorkerInProcConcurrencyUpperBound``` параметру приложения. На пропускную способность влияет объем ресурсов ЦП и памяти, доступный в выбранном плане.

Azure PowerShell использует некоторые контексты и состояния _уровня процесса_ , чтобы помочь сэкономить от чрезмерного ввода. Однако при включении параллелизма в приложении функции и вызове действий, изменяющих состояние, могут возникнуть состояния гонки. Эти состояния гонки трудно отлаживать, поскольку один вызов зависит от определенного состояния, а другой вызов изменил состояние.

Во время параллелизма Azure PowerShell, так как некоторые операции могут занимать значительное количество времени. Однако следует соблюдать осторожность. Если вы считаете, что столкнулись с состоянием гонки, задайте для параметра приложения Псворкеринпрокконкурренциуппербаунд значение `1` и вместо этого используйте [изоляцию уровня языкового рабочего процесса](functions-app-settings.md#functions_worker_process_count) для параллелизма.

## <a name="configure-function-scriptfile"></a>Настройка функции `scriptFile`

По умолчанию функция PowerShell выполняется из `run.ps1` файла, который использует тот же родительский каталог, что и соответствующий `function.json` .

`scriptFile`Свойство в `function.json` можно использовать для получения структуры папок, которая выглядит, как в следующем примере:

```
FunctionApp
 | - host.json
 | - myFunction
 | | - function.json
 | - lib
 | | - PSFunction.ps1
```

В этом случае `function.json` для `myFunction` включает `scriptFile` свойство, ссылающееся на файл с экспортированной функцией для выполнения.

```json
{
  "scriptFile": "../lib/PSFunction.ps1",
  "bindings": [
    // ...
  ]
}
```

## <a name="use-powershell-modules-by-configuring-an-entrypoint"></a>Использование модулей PowerShell с помощью настройки точки входа

В этой статье показаны функции PowerShell в файле сценария по умолчанию, `run.ps1` созданном шаблонами.
Однако можно также включить функции в модули PowerShell. Вы можете ссылаться на код конкретной функции в модуле, используя `scriptFile` `entryPoint` поля и в function.jsв файле конфигурации.

В этом случае `entryPoint` — это имя функции или командлета в модуле PowerShell, на который ссылается `scriptFile` .

Рассмотрим следующую структуру папок:

```
FunctionApp
 | - host.json
 | - myFunction
 | | - function.json
 | - lib
 | | - PSFunction.psm1
```

Где `PSFunction.psm1` содержит:

```powershell
function Invoke-PSTestFunc {
    param($InputBinding, $TriggerMetadata)

    Push-OutputBinding -Name OutputBinding -Value "output"
}

Export-ModuleMember -Function "Invoke-PSTestFunc"
```

В этом примере конфигурация `myFunction` включает `scriptFile` свойство, которое ссылается на `PSFunction.psm1` модуль PowerShell в другой папке.  `entryPoint`Свойство ссылается на `Invoke-PSTestFunc` функцию, которая является точкой входа в модуле.

```json
{
  "scriptFile": "../lib/PSFunction.psm1",
  "entryPoint": "Invoke-PSTestFunc",
  "bindings": [
    // ...
  ]
}
```

В этой конфигурации объект `Invoke-PSTestFunc` выполняется точно так же, как и `run.ps1` .

## <a name="considerations-for-powershell-functions"></a>Рекомендации по функциям PowerShell

При работе с функциями PowerShell учитывайте рекомендации в следующих разделах.

### <a name="cold-start"></a>Холодный запуск

При разработке функций Azure в [модели размещения, не поддерживающей сервер](consumption-plan.md), холодный запуск — это реальность. *Холодный запуск* — это период времени, который требуется для запуска приложения-функции для обработки запроса. Холодный запуск чаще всего происходит в плане потребления, так как приложение-функция завершает работу в периоды бездействия.

### <a name="bundle-modules-instead-of-using-install-module"></a>Используйте модули пакета вместо `Install-Module`

Сценарий выполняется при каждом вызове. Избегайте использования `Install-Module` в скрипте. Вместо этого используйте `Save-Module` перед публикацией, чтобы функция не могла тратить время на загрузку модуля. Если холодный запуск влияет на ваши функции, рассмотрите возможность развертывания приложения-функции в [плане службы приложений](dedicated-plan.md) со значением *Always on* или в [плане Premium](functions-premium-plan.md).

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения см. в следующих ресурсах:

* [Рекомендации по функциям Azure](functions-best-practices.md)
* [Справочник разработчика по функциям Azure](functions-reference.md)
* [Azure Functions triggers and bindings (Триггеры и привязки в Функциях Azure)](functions-triggers-bindings.md)

[Справочник по host.json]: functions-host-json.md