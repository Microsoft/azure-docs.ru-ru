---
title: Повышение производительности приложений Python в функциях Azure
description: Узнайте, как разрабатывать приложения функций Azure с помощью Python, которые хорошо работают и масштабируются под нагрузкой.
ms.topic: article
ms.date: 10/13/2020
ms.custom: devx-track-python
ms.openlocfilehash: e3bbdb8819062d45d071633e0208fb58a003da54
ms.sourcegitcommit: a055089dd6195fde2555b27a84ae052b668a18c7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/26/2021
ms.locfileid: "98786112"
---
# <a name="improve-throughput-performance-of-python-apps-in-azure-functions"></a>Повышение производительности приложений Python в функциях Azure

При разработке для функций Azure с помощью Python необходимо понимать, как работают функции и как эта производительность влияет на масштабирование приложения функции. Потребность в большей степени важна при проектировании высокопроизводительных приложений. Основные факторы, которые следует учитывать при проектировании, написании и настройке приложений функций, — это горизонтальные и масштабируемые конфигурации производительности.

## <a name="horizontal-scaling"></a>Горизонтальное масштабирование
По умолчанию Функции Azure автоматически отслеживают нагрузку на приложение и при необходимости создают дополнительные экземпляры узлов для Python. Функции Azure используют встроенные пороговые значения для различных типов триггеров, чтобы решить, когда следует добавлять экземпляры, например возраст сообщений и размер очереди для QueueTrigger. Эти пороговые значения не настраиваются пользователем. Дополнительные сведения см. [в статье масштабирование на основе событий в функциях Azure](event-driven-scaling.md).

## <a name="improving-throughput-performance"></a>Повышение производительности пропускной способности

Конфигурации по умолчанию подходят для большинства приложений функций Azure. Однако производительность приложений можно повысить путем применения конфигураций на основе профиля рабочей нагрузки. Первым шагом является понимание типа выполняемой рабочей нагрузки.

| Тип рабочей нагрузки | Характеристики приложения функции       | Примеры                                          |
| ------------- | ---------------------------------- | ------------------------------------------------- |
| **Привязка ввода-вывода**     | • Приложение должно выполнять много одновременных вызовов.<br>• Приложение обрабатывает большое количество событий ввода-вывода, таких как сетевые вызовы и дисковые операции чтения и записи. | • Веб-API                                          |
| **С привязкой к ЦП**     | • Приложение выполняет длительные вычисления, такие как изменение размера изображения.<br>• Приложение выполняет преобразование данных.                                                | • Обработка данных<br>• Определение машинного обучения<br> |

 
Так как рабочие нагрузки реальных мировых функций обычно являются сочетанием операций ввода-вывода и ЦП, необходимо профилировать приложение в условиях реалистичных рабочих нагрузок.


### <a name="performance-specific-configurations"></a>Конфигурации, зависящие от производительности

После знакомства с профилем рабочей нагрузки приложения функции ниже приведены конфигурации, которые можно использовать для повышения производительности функций.

* [Асинхронный режим](#async)
* [Рабочий процесс с несколькими языками](#use-multiple-language-worker-processes)
* [Максимальное число рабочих процессов в рамках рабочего процесса языка](#set-up-max-workers-within-a-language-worker-process)
* [Цикл событий](#managing-event-loop)
* [Вертикальное масштабирование](#vertical-scaling)



#### <a name="async"></a>Async

Поскольку [Python является однопотоковым временем выполнения](https://wiki.python.org/moin/GlobalInterpreterLock), экземпляр узла для Python может по умолчанию обрабатывать только один вызов функции. Для приложений, обрабатывающих большое количество событий ввода-вывода и/или связанных с вводом-выводом, производительность можно значительно повысить, запустив функции асинхронно.

Чтобы выполнить функцию в асинхронном режиме, используйте инструкцию `async def`, которая запускает функцию с [asyncio](https://docs.python.org/3/library/asyncio.html) напрямую:

```python
async def main():
    await some_nonblocking_socket_io_op()
```
Ниже приведен пример функции с триггером HTTP, который использует HTTP-клиент [аиохттп](https://pypi.org/project/aiohttp/) :

```python
import aiohttp

import azure.functions as func

async def main(req: func.HttpRequest) -> func.HttpResponse:
    async with aiohttp.ClientSession() as client:
        async with client.get("PUT_YOUR_URL_HERE") as response:
            return func.HttpResponse(await response.text())

    return func.HttpResponse(body='NotFound', status_code=404)
```


Функция без `async` ключевого слова выполняется автоматически в пуле потоков среадпулексекутор:

```python
# Runs in an ThreadPoolExecutor threadpool. Number of threads is defined by PYTHON_THREADPOOL_THREAD_COUNT. 
# The example is intended to show how default synchronous function are handled.

def main():
    some_blocking_socket_io()
```

Чтобы добиться полной выгоды от асинхронного выполнения функций, в коде для операции ввода-вывода или библиотеки, используемой кодом, должна также быть реализована асинхронная реализация. Использование синхронных операций ввода-вывода в функциях, определенных как асинхронные, может отрицательно **понизить** общую производительность. Если используемые библиотеки не имеют асинхронной версии, вы можете по-прежнему использовать асинхронный запуск кода, [управляя циклом событий](#managing-event-loop) в приложении. 

Вот несколько примеров клиентских библиотек, в которых реализована асинхронная модель:
- [аиохттп](https://pypi.org/project/aiohttp/) -HTTP клиент/сервер для асинЦио 
- [API потоков](https://docs.python.org/3/library/asyncio-stream.html) — основные примитивы для работы с сетевым подключением высокого уровня с поддержкой асинхронных и ожидающих выполнения
- [Очередь Янус](https://pypi.org/project/janus/) — потокобезопасная очередь с поддержкой АсинЦио для Python
- привязки [пизмк](https://pypi.org/project/pyzmq/) -Python для ZeroMQ
 
##### <a name="understanding-async-in-python-worker"></a>Основные сведения о Async в рабочей роли Python

При определении `async` перед сигнатурой функции Python помечает функцию как соподпрограмму. При вызове соподпрограмма его можно запланировать как задачу в цикле событий. При вызове `await` в асинхронной функции он регистрирует продолжение в цикле событий и разрешает циклу событий обрабатывать следующую задачу в течение времени ожидания.

В рабочей роли Python рабочий процесс совместно использует цикл событий с `async` функцией клиента, и он способен обрабатывать несколько запросов одновременно. Мы настоятельно рекомендуем нашим клиентам использовать библиотеки, совместимые с асинЦио (например, [аиохттп](https://pypi.org/project/aiohttp/), [пизмк](https://pypi.org/project/pyzmq/)). Применение этих рекомендаций значительно повысит пропускную способность функции по сравнению с библиотеками, реализованными в синхронном режиме.

> [!NOTE]
>  Если функция объявлена как `async` без каких-либо функций `await` внутри своей реализации, производительность функции будет серьезно затронута, так как цикл событий будет заблокирован, что запрещает рабочему процессу Python обрабатывать параллельные запросы.

#### <a name="use-multiple-language-worker-processes"></a>Использование многоязыковых рабочих процессов

По умолчанию каждый экземпляр узла функций имеет рабочий процесс с одним языком. Вы можете увеличить количество рабочих процессов на узел (до 10) с помощью параметра приложения [FUNCTIONS_WORKER_PROCESS_COUNT](functions-app-settings.md#functions_worker_process_count). Затем Функции Azure пытаются равномерно распределять одновременные вызовы функций между этими рабочими процессами.

Для приложений, привязанных к ЦП, необходимо задать количество языковых рабочих ролей, равное или большему количеству ядер, доступных для каждого приложения функции. Дополнительные сведения см. в разделе [номера SKU доступных экземпляров](functions-premium-plan.md#available-instance-skus). 

Приложения, привязанные к вводу-выводу, также могут увеличить количество рабочих процессов за пределами числа доступных ядер. Помните, что установка слишком большого количества рабочих процессов может повлиять на общую производительность из-за большего количества требуемых переключений контекста. 

FUNCTIONS_WORKER_PROCESS_COUNT применяется к каждому узлу, создаваемому функциями при масштабировании приложения для удовлетворения потребности.

#### <a name="set-up-max-workers-within-a-language-worker-process"></a>Настройка максимального числа рабочих ролей в рамках рабочего процесса языка

Как упоминалось в [разделе](#understanding-async-in-python-worker)async, Рабочая роль языка Python обрабатывает функции и [соподпрограммы](https://docs.python.org/3/library/asyncio-task.html#coroutines) по-разному. Соподпрограмма выполняется в том же цикле событий, в котором выполняется Языковая рабочая роль. С другой стороны, вызов функции выполняется в [среадпулексекутор](https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor), который поддерживается рабочим работником в качестве потока.

Максимальное число рабочих ролей, разрешенных для выполнения функций синхронизации, можно задать с помощью параметра приложения [PYTHON_THREADPOOL_THREAD_COUNT](functions-app-settings.md#python_threadpool_thread_count) . Это значение задает `max_worker` аргумент объекта среадпулексекутор, который позволяет Python использовать пул в большинстве `max_worker` потоков для асинхронного выполнения вызовов. Компонент `PYTHON_THREADPOOL_THREAD_COUNT` применяется к каждому рабочему процессу, создаваемому узлом функций, и Python принимает решение о создании нового потока или повторном использовании существующего потока. Для старых версий Python (т. е `3.8` `3.7` ., и `3.6` ) `max_worker` значение равно 1. Для версии Python `3.9` параметр `max_worker` имеет значение `None` .

Для приложений, привязанных к ЦП, следует присвоить параметру небольшое значение, начиная с 1 и увеличивая его по мере эксперимента с рабочей нагрузкой. Это позволяет сократить время, затраченное на переключение контекста, и разрешить завершение задач, привязанных к ЦП.

Для приложений, привязанных к вводу-выводу, вы должны получить значительный выигрыш, увеличив число потоков, работающих при каждом вызове. рекомендуется начать с версии Python по умолчанию — количество ядер + 4, а затем настроить на основе наблюдаемых значений пропускной способности.

Для развертывания приложений рабочих нагрузок необходимо сбалансировать `FUNCTIONS_WORKER_PROCESS_COUNT` и `PYTHON_THREADPOOL_THREAD_COUNT` конфигурацию, чтобы максимально увеличить пропускную способность. Чтобы понять, какие приложения функции используют большую часть времени, рекомендуется профилировать их и задать значения в соответствии с поведением, которое они представляют. Также ознакомьтесь с этим [разделом](#use-multiple-language-worker-processes) , чтобы узнать о параметрах FUNCTIONS_WORKER_PROCESS_COUNT приложения.

> [!NOTE]
>  Хотя эти рекомендации применяются как к функциям HTTP, так и к триггерам, не поддерживающим HTTP, может потребоваться настроить другие конфигурации триггера для функций, не являющихся триггерами HTTP, чтобы получить ожидаемую производительность приложений-функций. Дополнительные сведения об этом см. в этой [статье](functions-best-practices.md).


#### <a name="managing-event-loop"></a>Управление циклом событий

Следует использовать асинЦио, совместимые с сторонними библиотеками. Если ни одна из сторонних библиотек не соответствует вашим потребностям, вы также можете управлять циклами событий в функциях Azure. Управление циклами событий обеспечивает большую гибкость при управлении ресурсами вычислений, а также делает возможным переносить синхронные библиотеки ввода-вывода в соподпрограммы.

Существует множество полезных официальных документов Python, обсуждающих [соподпрограммы, задачи](https://docs.python.org/3/library/asyncio-task.html) и [цикл обработки событий](https://docs.python.org/3.8/library/asyncio-eventloop.html) с помощью встроенной библиотеки **асинЦио** .

Возьмем в качестве примера библиотеку [запросов](https://github.com/psf/requests) . в этом фрагменте кода используется библиотека **асинЦио** для `requests.get()` создания оболочки метода в соподпрограмме, выполняющем несколько веб-запросов для SAMPLE_URL параллельно.


```python
import asyncio
import json
import logging

import azure.functions as func
from time import time
from requests import get, Response


async def invoke_get_request(eventloop: asyncio.AbstractEventLoop) -> Response:
    # Wrap requests.get function into a coroutine
    single_result = await eventloop.run_in_executor(
        None,  # using the default executor
        get,  # each task call invoke_get_request
        'SAMPLE_URL'  # the url to be passed into the requests.get function
    )
    return single_result

async def main(req: func.HttpRequest) -> func.HttpResponse:
    logging.info('Python HTTP trigger function processed a request.')

    eventloop = asyncio.get_event_loop()

    # Create 10 tasks for requests.get synchronous call
    tasks = [
        asyncio.create_task(
            invoke_get_request(eventloop)
        ) for _ in range(10)
    ]

    done_tasks, _ = await asyncio.wait(tasks)
    status_codes = [d.result().status_code for d in done_tasks]

    return func.HttpResponse(body=json.dumps(status_codes),
                             mimetype='application/json')
```
#### <a name="vertical-scaling"></a>Вертикальное масштабирование
Для большего количества единиц обработки, особенно в операциях, связанных с ЦП, вы можете получить это путем обновления до плана Premium с более высокими спецификациями. С более высокими единицами обработки можно настроить число рабочих процессов в соответствии с количеством доступных ядер и достичь более высокой степени параллелизма. 

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о разработке функций Python в Azure см. в следующих ресурсах:

* [Azure Functions Python Developer Guide](functions-reference-python.md) (Справочник по Функциям Azure для разработчика Python)
* [Рекомендации по функциям Azure](functions-best-practices.md)
* [Справочник разработчика по функциям Azure](functions-reference.md)

