---
title: Пользовательские обработчики функций Azure
description: Узнайте, как использовать функции Azure с любым языком или версией среды выполнения.
author: anthonychu
ms.author: antchu
ms.date: 12/1/2020
ms.topic: article
ms.openlocfilehash: f527b387afc01eb60bd582adc13a4ad3d516055b
ms.sourcegitcommit: 2aa52d30e7b733616d6d92633436e499fbe8b069
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "97936997"
---
# <a name="azure-functions-custom-handlers"></a>Пользовательские обработчики функций Azure

Каждое приложение функций выполняется обработчиком конкретного языка. Хотя функции Azure поддерживают много [языковых обработчиков](./supported-languages.md) по умолчанию, в некоторых случаях может потребоваться использовать другие языки или среды выполнения.

Пользовательские обработчики — это упрощенные веб-серверы, которые получают события от узла функций. Любой язык, поддерживающий примитивы HTTP, может реализовать пользовательский обработчик.

Пользовательские обработчики лучше всего подходят для ситуаций, в которых вы хотите:

- Реализуйте приложение-функцию на языке, который сейчас не поддерживается, например Go или Руст.
- Реализуйте приложение-функцию в среде выполнения, которая в настоящее время не поддерживается, например дено.

С помощью пользовательских обработчиков можно использовать [триггеры и входные и выходные привязки](./functions-triggers-bindings.md) через [пакеты расширений](./functions-bindings-register.md).

Приступая к работе с пользовательскими обработчиками функций Azure с [краткими руководствами в Go и Руст](create-first-function-vs-code-other.md).

## <a name="overview"></a>Общие сведения

На следующей схеме показана связь между узлом функций и веб-сервером, реализованным как пользовательский обработчик.

![Общие сведения о пользовательском обработчике функций Azure](./media/functions-custom-handlers/azure-functions-custom-handlers-overview.png)

1. Каждое событие инициирует запрос, отправленный узлу функций. Событие — это любой триггер, поддерживаемый функциями Azure.
1. Затем узел функций выдает [полезные данные запроса](#request-payload) на веб-сервер. Полезная нагрузка содержит данные триггера и входных данных привязки, а также другие метаданные для функции.
1. Веб-сервер выполняет отдельную функцию и возвращает [полезные данные ответа](#response-payload) в узел функций.
1. Узел функций передает данные из ответа в выходные привязки функции для обработки.

Приложение "функции Azure", реализованное как пользовательский обработчик, должно настраивать *host.jsна*, *local.settings.js* и *function.jsв* файлах в соответствии с определенными соглашениями.

## <a name="application-structure"></a>Структура приложений

Для реализации пользовательского обработчика вам потребуются следующие аспекты приложения:

- *host.js* файла в корне приложения
- *local.settings.js* файла в корне приложения
- *function.jsв* файле для каждой функции (в папке, соответствующей имени функции)
- Команда, сценарий или исполняемый файл, который запускает веб-сервер.

На следующей схеме показано, как эти файлы ищут файловую систему для функции с именем "Микуеуефунктион" и исполняемого файла настраиваемого обработчика с именем *handler.exe*.

```bash
| /MyQueueFunction
|   function.json
|
| host.json
| local.settings.json
| handler.exe
```

### <a name="configuration"></a>Конфигурация

Приложение настраивается с помощью *host.jsв* файлах и *local.settings.js* .

#### <a name="hostjson"></a>host.json

*host.json* указывает узлу функций, куда отправляются запросы, указывая на веб-сервер, способный ОБРАБАТЫВАТЬ события HTTP.

Пользовательский обработчик определяется путем настройки *host.jsв* файле с подробными сведениями о том, как запускать веб-сервер с помощью `customHandler` раздела.

```json
{
  "version": "2.0",
  "customHandler": {
    "description": {
      "defaultExecutablePath": "handler.exe"
    }
  }
}
```

`customHandler`Раздел указывает на целевой объект, как определено в `defaultExecutablePath` . Целью выполнения может быть команда, исполняемый объект или файл, в котором реализован веб-сервер.

Используйте `arguments` массив для передачи аргументов в исполняемый файл. Аргументы поддерживают расширение переменных среды (параметров приложения) с помощью `%%` нотации.

Также можно изменить рабочий каталог, используемый исполняемым объектом, с помощью `workingDirectory` .

```json
{
  "version": "2.0",
  "customHandler": {
    "description": {
      "defaultExecutablePath": "app/handler.exe",
      "arguments": [
        "--database-connection-string",
        "%DATABASE_CONNECTION_STRING%"
      ],
      "workingDirectory": "app"
    }
  }
}
```

##### <a name="bindings-support"></a>Поддержка привязок

Стандартные триггеры, а также входные и выходные привязки доступны для ссылок на [пакеты расширений](./functions-bindings-register.md) в *host.js* в файле.

#### <a name="localsettingsjson"></a>local.settings.json

*local.settings.json* определяет параметры приложения, используемые при локальном запуске приложения функции. Так как он может содержать секреты, *local.settings.js* должны быть исключены из системы управления версиями. В Azure вместо этого используйте параметры приложения.

Для пользовательских обработчиков установите `FUNCTIONS_WORKER_RUNTIME` `Custom` в значение в *local.settings.json*.

```json
{
  "IsEncrypted": false,
  "Values": {
    "FUNCTIONS_WORKER_RUNTIME": "Custom"
  }
}
```

> [!NOTE]
> `Custom` не распознается как допустимая среда выполнения в планах службы приложений для Linux Premium или. Если это ваш целевой объект развертывания, задайте `FUNCTIONS_WORKER_RUNTIME` в качестве значения пустую строку.

### <a name="function-metadata"></a>Метаданные функции

При использовании с пользовательским обработчиком *function.js* в содержимом не отличается от того, как вы определите функцию в любом другом контексте. Единственное требование заключается в том, что *function.jsдля* файлов должны находиться в папке с именем, соответствующей имени функции.

Следующая *function.jsо* настройке функции, которая имеет триггер очереди и выходную привязку очереди. Так как он находится в папке с именем *микуеуефунктион*, он определяет функцию с именем *микуеуефунктион*.

**Микуеуефунктион/function.jsна**

```json
{
  "bindings": [
    {
      "name": "myQueueItem",
      "type": "queueTrigger",
      "direction": "in",
      "queueName": "messages-incoming",
      "connection": "AzureWebJobsStorage"
    },
    {
      "name": "$return",
      "type": "queue",
      "direction": "out",
      "queueName": "messages-outgoing",
      "connection": "AzureWebJobsStorage"
    }
  ]
}
```

### <a name="request-payload"></a>Полезные данные запроса

При получении сообщения очереди узел функций отправляет запрос HTTP POST в пользовательский обработчик с полезной нагрузкой в тексте.

Следующий код представляет пример полезных данных запроса. Полезные данные включают структуру JSON с двумя членами: `Data` и `Metadata` .

`Data`Член включает ключи, соответствующие входным и активируемым именам, как определено в массиве привязок в *function.js* в файле.

`Metadata`Элемент включает [метаданные, созданные из источника событий](./functions-bindings-expressions-patterns.md#trigger-metadata).

```json
{
  "Data": {
    "myQueueItem": "{ message: \"Message sent\" }"
  },
  "Metadata": {
    "DequeueCount": 1,
    "ExpirationTime": "2019-10-16T17:58:31+00:00",
    "Id": "800ae4b3-bdd2-4c08-badd-f08e5a34b865",
    "InsertionTime": "2019-10-09T17:58:31+00:00",
    "NextVisibleTime": "2019-10-09T18:08:32+00:00",
    "PopReceipt": "AgAAAAMAAAAAAAAAAgtnj8x+1QE=",
    "sys": {
      "MethodName": "QueueTrigger",
      "UtcNow": "2019-10-09T17:58:32.2205399Z",
      "RandGuid": "24ad4c06-24ad-4e5b-8294-3da9714877e9"
    }
  }
}
```

### <a name="response-payload"></a>Полезные данные ответа

По соглашению ответы функций форматируются как пары "ключ-значение". Поддерживаются следующие ключи:

| <nobr>Ключ полезных данных</nobr>   | Тип данных | Комментарии                                                      |
| ------------- | --------- | ------------------------------------------------------------ |
| `Outputs`     | object    | Содержит значения ответа, определенные `bindings` массивом в *function.json*.<br /><br />Например, если для функции настроена выходная привязка очереди с именем "Микуеуеаутпут", то `Outputs` содержит ключ с именем `myQueueOutput` , который задается настраиваемым обработчиком для сообщений, отправляемых в очередь. |
| `Logs`        | array     | Сообщения отображаются в журналах вызова функций.<br /><br />При работе в Azure сообщения отображаются в Application Insights. |
| `ReturnValue` | строка    | Используется для предоставления ответа, когда выходные данные настраиваются как `$return` в *function.js* в файле. |

Это пример полезных данных ответа.

```json
{
  "Outputs": {
    "res": {
      "body": "Message enqueued"
    },
    "myQueueOutput": [
      "queue message 1",
      "queue message 2"
    ]
  },
  "Logs": [
    "Log message 1",
    "Log message 2"
  ],
  "ReturnValue": "{\"hello\":\"world\"}"
}
```

## <a name="examples"></a>Примеры

Пользовательские обработчики могут быть реализованы на любом языке, поддерживающем получение HTTP-событий. В следующих примерах показано, как реализовать пользовательский обработчик с помощью языка программирования Go.

### <a name="function-with-bindings"></a>Функция с привязками

Сценарий, реализованный в этом примере, использует функцию с именем `order` , которая принимает объект с полезной нагрузкой, `POST` представляющей заказ продукта. Когда в функцию отправляется заказ, создается сообщение хранилища очереди и возвращается ответ HTTP.

<a id="bindings-implementation" name="bindings-implementation"></a>

#### <a name="implementation"></a>Реализация

В папке с именем *order* *function.js* File настраивает функцию, активируемую HTTP.

**Order/function.jsвкл.**

```json
{
  "bindings": [
    {
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["post"]
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    },
    {
      "type": "queue",
      "name": "message",
      "direction": "out",
      "queueName": "orders",
      "connection": "AzureWebJobsStorage"
    }
  ]
}
```

Эта функция определена как [функция, активируемая HTTP](./functions-bindings-http-webhook-trigger.md) и возвращающая [ответ HTTP](./functions-bindings-http-webhook-output.md) и выводит сообщение [хранилища очереди](./functions-bindings-storage-queue-output.md) .

В корне приложения *host.jsв* файле настроен для запуска исполняемого файла с именем `handler.exe` ( `handler` в Linux или macOS).

```json
{
  "version": "2.0",
  "customHandler": {
    "description": {
      "defaultExecutablePath": "handler.exe"
    }
  },
  "extensionBundle": {
    "id": "Microsoft.Azure.Functions.ExtensionBundle",
    "version": "[1.*, 2.0.0)"
  }
}
```

Это HTTP-запрос, отправленный в среду выполнения функций.

```http
POST http://127.0.0.1:7071/api/order HTTP/1.1
Content-Type: application/json

{
  "id": 1005,
  "quantity": 2,
  "color": "black"
}
```

Затем среда выполнения функций отправляет следующий HTTP-запрос в пользовательский обработчик:

```http
POST http://127.0.0.1:<FUNCTIONS_CUSTOMHANDLER_PORT>/order HTTP/1.1
Content-Type: application/json

{
  "Data": {
    "req": {
      "Url": "http://localhost:7071/api/order",
      "Method": "POST",
      "Query": "{}",
      "Headers": {
        "Content-Type": [
          "application/json"
        ]
      },
      "Params": {},
      "Body": "{\"id\":1005,\"quantity\":2,\"color\":\"black\"}"
    }
  },
  "Metadata": {
  }
}
```

> [!NOTE]
> Некоторые части полезных данных были удалены для краткости.

*handler.exe* — это скомпилированная программа пользовательского обработчика Go, которая запускает веб-сервер и реагирует на запросы вызова функций от узла функций.

```go
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "os"
)

type InvokeRequest struct {
    Data     map[string]json.RawMessage
    Metadata map[string]interface{}
}

type InvokeResponse struct {
    Outputs     map[string]interface{}
    Logs        []string
    ReturnValue interface{}
}

func orderHandler(w http.ResponseWriter, r *http.Request) {
    var invokeRequest InvokeRequest

    d := json.NewDecoder(r.Body)
    d.Decode(&invokeRequest)

    var reqData map[string]interface{}
    json.Unmarshal(invokeRequest.Data["req"], &reqData)

    outputs := make(map[string]interface{})
    outputs["message"] = reqData["Body"]

    resData := make(map[string]interface{})
    resData["body"] = "Order enqueued"
    outputs["res"] = resData
    invokeResponse := InvokeResponse{outputs, nil, nil}

    responseJson, _ := json.Marshal(invokeResponse)

    w.Header().Set("Content-Type", "application/json")
    w.Write(responseJson)
}

func main() {
    customHandlerPort, exists := os.LookupEnv("FUNCTIONS_CUSTOMHANDLER_PORT")
    if !exists {
        customHandlerPort = "8080"
    }
    mux := http.NewServeMux()
    mux.HandleFunc("/order", orderHandler)
    fmt.Println("Go server Listening on: ", customHandlerPort)
    log.Fatal(http.ListenAndServe(":"+customHandlerPort, mux))
}
```

В этом примере пользовательский обработчик запускает веб-сервер для обработки событий HTTP и задается для прослушивания запросов через `FUNCTIONS_CUSTOMHANDLER_PORT` .

Несмотря на то, что узел функций получил исходный HTTP-запрос по адресу `/api/order` , он вызывает пользовательский обработчик, используя имя функции (имя папки). В этом примере функция определена по пути `/order` . Узел отправляет настраиваемый обработчик HTTP-запрос по пути `/order` .

По мере `POST` отправки запросов этой функции данные триггера и метаданные функции доступны через текст HTTP-запроса. Доступ к исходному тексту HTTP-запроса можно получить в полезных данных `Data.req.Body` .

Ответ функции форматируется в пары "ключ-значение", где `Outputs` элемент содержит значение JSON, в котором ключи соответствуют выходам, определенным в *function.jsв* файле.

Это пример полезных данных, который этот обработчик возвращает узлу функций.

```json
{
  "Outputs": {
    "message": "{\"id\":1005,\"quantity\":2,\"color\":\"black\"}",
    "res": {
      "body": "Order enqueued"
    }
  },
  "Logs": null,
  "ReturnValue": null
}
```

Если задать выходные данные, `message` равные данным заказа, которые были получены из запроса, функция выводит данные, которые упорядочиваются в настроенную очередь. Узел функций также возвращает ответ HTTP, настроенный в `res` вызывающей стороне.

### <a name="http-only-function"></a>Функция "только HTTP"

Для функций, активируемых HTTP без дополнительных привязок или выходов, может потребоваться, чтобы обработчик работал непосредственно с HTTP-запросом и ответом вместо полезных данных [запроса](#request-payload) и [ответа](#response-payload) пользовательского обработчика. Это поведение можно настроить в *host.js* с помощью `enableForwardingHttpRequest` параметра.

> [!IMPORTANT]
> Основным назначением функции пользовательских обработчиков является включение языков и сред выполнения, которые в настоящее время не имеют поддержки первого класса в функциях Azure. Хотя можно запускать веб-приложения с помощью пользовательских обработчиков, функции Azure не являются стандартным обратным прокси-сервером. Некоторые функции, такие как потоковая передача ответов, HTTP/2 и WebSockets, недоступны. Некоторые компоненты HTTP-запроса, такие как определенные заголовки и маршруты, могут быть ограничены. Приложение может также столкнуться с чрезмерным [запуском холодного запуска](event-driven-scaling.md#cold-start).
>
> Чтобы устранить эти ситуации, рассмотрите возможность запуска веб-приложений в [службе приложений Azure](../app-service/overview.md).

В следующем примере показано, как настроить функцию, активируемую HTTP, без дополнительных привязок или выходов. Сценарий, реализованный в этом примере, поддерживает функцию с именем `hello` , которая принимает `GET` или `POST` .

<a id="hello-implementation" name="hello-implementation"></a>

#### <a name="implementation"></a>Реализация

В папке с именем *hello* *function.js* файл настраивает функцию, активируемую HTTP.

**Привет и function.jsна**

```json
{
  "bindings": [
    {
      "type": "httpTrigger",
      "authLevel": "anonymous",
      "direction": "in",
      "name": "req",
      "methods": ["get", "post"]
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    }
  ]
}
```

Функция настроена на прием `GET` запросов и, `POST` а результирующее значение предоставляется через аргумент с именем `res` .

В корне приложения *host.js* для файла настроен для запуска `handler.exe` и `enableForwardingHttpRequest` имеет значение `true` .

```json
{
  "version": "2.0",
  "customHandler": {
    "description": {
      "defaultExecutablePath": "handler.exe"
    },
    "enableForwardingHttpRequest": true
  }
}
```

Если `enableForwardingHttpRequest` имеет значение `true` , поведение функций только по протоколу HTTP отличается от поведения пользовательских обработчиков по умолчанию следующим образом:

* HTTP-запрос не содержит полезных данных [запроса](#request-payload) пользовательских обработчиков. Вместо этого узел функций вызывает обработчик с копией исходного HTTP-запроса.
* Узел функций вызывает обработчик с тем же путем, что и исходный запрос, включая любые параметры строки запроса.
* Узел функций возвращает копию HTTP-ответа обработчика в качестве ответа на исходный запрос.

Ниже приведен запрос POST к узлу функций. Затем узел функций отправляет копию запроса пользовательскому обработчику по тому же пути.

```http
POST http://127.0.0.1:7071/api/hello HTTP/1.1
Content-Type: application/json

{
  "message": "Hello World!"
}
```

Файл *обработчика файла. Go* реализует веб-сервер и функцию HTTP.

```go
package main

import (
    "fmt"
    "io/ioutil"
    "log"
    "net/http"
    "os"
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    if r.Method == "GET" {
        w.Write([]byte("hello world"))
    } else {
        body, _ := ioutil.ReadAll(r.Body)
        w.Write(body)
    }
}

func main() {
    customHandlerPort, exists := os.LookupEnv("FUNCTIONS_CUSTOMHANDLER_PORT")
    if !exists {
        customHandlerPort = "8080"
    }
    mux := http.NewServeMux()
    mux.HandleFunc("/api/hello", helloHandler)
    fmt.Println("Go server Listening on: ", customHandlerPort)
    log.Fatal(http.ListenAndServe(":"+customHandlerPort, mux))
}
```

В этом примере пользовательский обработчик создает веб-сервер для обработки событий HTTP и задается для прослушивания запросов через `FUNCTIONS_CUSTOMHANDLER_PORT` .

`GET` запросы обрабатываются путем возвращения строки, а `POST` запросы имеют доступ к тексту запроса.

Маршрут для функции заказа имеет то же значение `/api/hello` , что и исходный запрос.

>[!NOTE]
>`FUNCTIONS_CUSTOMHANDLER_PORT`Не является общедоступным портом, используемым для вызова функции. Этот порт используется узлом функций для вызова пользовательского обработчика.

## <a name="deploying"></a>Развертывание

Пользовательский обработчик может быть развернут на каждом параметре размещения функций Azure. Если обработчику требуются зависимости операционной системы или платформы (например, языковая среда выполнения), может потребоваться использовать [пользовательский контейнер](./functions-create-function-linux-custom-image.md).

При создании приложения-функции в Azure для пользовательских обработчиков мы рекомендуем выбрать .NET Core в качестве стека. В будущем будет добавлен пользовательский стек для пользовательских обработчиков.

Чтобы развернуть приложение пользовательского обработчика с помощью Azure Functions Core Tools, выполните следующую команду.

```bash
func azure functionapp publish $functionAppName
```

> [!NOTE]
> Убедитесь, что все файлы, необходимые для выполнения пользовательского обработчика, находятся в папке и включены в развертывание. Если пользовательский обработчик является двоичным исполняемым файлом или имеет зависящие от платформы зависимости, убедитесь, что эти файлы соответствуют целевой платформе развертывания.

## <a name="restrictions"></a>Ограничения

- Веб-сервер настраиваемого обработчика должен запускаться в течение 60 секунд.

## <a name="samples"></a>Примеры

Примеры реализации функций на различных языках см. в [репозитории примеров пользовательского обработчика GitHub](https://github.com/Azure-Samples/functions-custom-handlers) .

## <a name="troubleshooting-and-support"></a>Устранение неполадок и поддержка

### <a name="trace-logging"></a>Ведение журнала трассировки

Если не удается запустить процесс настраиваемого обработчика или возникли проблемы при взаимодействии с узлом функций, можно увеличить уровень ведения журнала приложения функции до, чтобы `Trace` Просмотреть дополнительные диагностические сообщения от узла.

Чтобы изменить уровень ведения журнала приложения функции по умолчанию, настройте `logLevel` параметр в `logging` разделе *host.json*.

```json
{
  "version": "2.0",
  "customHandler": {
    "description": {
      "defaultExecutablePath": "handler.exe"
    }
  },
  "logging": {
    "logLevel": {
      "default": "Trace"
    }
  }
}
```

Узел функции выводит дополнительные сообщения журнала, включая сведения, связанные с процессом пользовательского обработчика. Используйте журналы для изучения проблем, возникающих при запуске процесса настраиваемого обработчика или вызова функций в пользовательском обработчике.

В локальной среде журналы выводятся на консоль.

В Azure [запросите Application Insights трассировки](analyze-telemetry-data.md#query-telemetry-data) , чтобы просмотреть сообщения журнала. Если приложение создает большой объем журналов, в Application Insights отправляется только подмножество сообщений журнала. [Отключите выборку](configure-monitoring.md#configure-sampling) , чтобы убедиться в записи всех сообщений.

### <a name="test-custom-handler-in-isolation"></a>Тестирование пользовательского обработчика в изоляции

Приложения пользовательского обработчика — это процесс веб-сервера, поэтому может оказаться полезным запустить его на своих собственных и тестовых вызовах функций, отправив макет [http-запросов](#request-payload) с помощью такого средства, как « [прилистывание](https://curl.haxx.se/) » или « [POST](https://www.postman.com/)».

Эту стратегию можно также использовать в конвейерах CI/CD для выполнения автоматических тестов в пользовательском обработчике.

### <a name="execution-environment"></a>Среда выполнения

Пользовательские обработчики запускаются в той же среде, что и типичное приложение функций Azure. Протестируйте обработчик, чтобы убедиться, что среда содержит все зависимости, необходимые для выполнения. Для приложений, требующих дополнительных зависимостей, может потребоваться выполнить их с помощью [пользовательского образа контейнера](functions-create-function-linux-custom-image.md) , размещенного в плане "функции Azure" [Premium](functions-premium-plan.md).

### <a name="get-support"></a>Получение поддержки

Если вам нужна помощь в приложении-функции с пользовательскими обработчиками, вы можете отправить запрос через регулярные каналы поддержки. Однако из-за широкого спектра возможных языков, используемых для создания пользовательских приложений обработчиков, поддержка не ограничена.

Поддержка доступна, если в узле функций имеются проблемы при запуске или взаимодействии с процессом настраиваемого обработчика. Для проблем, связанных с внутренней обработкой процесса настраиваемого обработчика, например проблем с выбранным языком или платформой, наша группа поддержки не может предоставить помощь в этом контексте.

## <a name="next-steps"></a>Дальнейшие действия

Приступая к созданию приложения "функции Azure" в Go или Руст с помощью [краткого руководства по настраиваемым обработчикам](create-first-function-vs-code-other.md).
