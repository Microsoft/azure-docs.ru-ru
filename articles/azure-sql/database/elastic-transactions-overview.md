---
title: Распределенные транзакции по облачным базам данных (предварительная версия)
description: Общие сведения о транзакциях эластичной базы данных с помощью базы данных SQL Azure и Управляемый экземпляр Azure SQL.
services: sql-database
ms.service: sql-database
ms.subservice: scale-out
ms.custom: sqldbrb=1
ms.devlang: ''
ms.topic: conceptual
author: stevestein
ms.author: sstein
ms.reviewer: ''
ms.date: 03/12/2019
ms.openlocfilehash: 5504b9bc87f78682ff584006255d4e75e5e69fa7
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "92793353"
---
# <a name="distributed-transactions-across-cloud-databases-preview"></a>Распределенные транзакции по облачным базам данных (предварительная версия)
[!INCLUDE[appliesto-sqldb-sqlmi](../includes/appliesto-sqldb-sqlmi.md)]

Транзакции эластичных баз данных для базы данных SQL Azure и Управляемый экземпляр Azure SQL позволяют выполнять транзакции, охватывающие несколько баз данных. Транзакции эластичной базы данных доступны для приложений .NET с помощью ADO.NET и интегрируются с привычным интерфейсом программирования с помощью классов [System. Transaction](/dotnet/api/system.transactions) . Инструкции по подключению библиотеки см. в статье [Microsoft .NET Framework 4.6.1 (веб-установщик) для Windows 7 SP1, Windows 8, Windows 8.1, Windows 10, Windows Server 2008 R2 SP1, Windows Server 2012 и Windows Server 2012 R2](https://www.microsoft.com/download/details.aspx?id=49981).
Кроме того, для Управляемый экземпляр распределенных транзакций доступны в [Transact-SQL](/sql/t-sql/language-elements/begin-distributed-transaction-transact-sql).

В локальной среде такой сценарий обычно требует запуска Microsoft координатор распределенных транзакций (MSDTC). Так как MSDTC недоступен для приложения типа "платформа как услуга" в Azure, возможность координировать распределенные транзакции теперь напрямую интегрирована в базу данных SQL или Управляемый экземпляр. Приложения могут подключаться к любой базе данных для запуска распределенных транзакций, а одна из баз данных или серверов будет прозрачно координировать распределенную транзакцию, как показано на следующем рисунке.

В этом документе термины «распределенные транзакции» и «транзакции эластичных баз данных» считаются синонимами и будут использоваться взаимозаменяемыми.

  ![Осуществление распределенных транзакций в Базе данных SQL Azure с использованием транзакций эластичной базы данных ][1]

## <a name="common-scenarios"></a>Распространенные сценарии

Транзакции эластичных баз данных позволяют приложениям вносить атомарные изменения в данные, хранящиеся в нескольких разных базах данных. Эта предварительная версия ориентирована на клиентскую разработку на языке C# с использованием платформы .NET. Взаимодействие на стороне сервера (код, написанный в хранимых процедурах или серверных скриптах) с помощью [Transact-SQL](/sql/t-sql/language-elements/begin-distributed-transaction-transact-sql) доступен только для управляемый экземпляр.
> [!IMPORTANT]
> В настоящее время в режиме предварительной версии выполнение транзакций эластичной базы данных между базой данных SQL Azure и Azure SQL Управляемый экземпляр не поддерживается. Транзакция эластичной базы данных может охватывать только несколько баз данных SQL или набор управляемых экземпляров.

Транзакции эластичной базы данных предназначены для следующих сценариев:

* Приложения с несколькими базами данных в Azure. в этом сценарии данные вертикально секционированы по нескольким базам данных SQL или Управляемый экземпляр так, что различные типы данных находятся в разных базах данных. Некоторые операции нуждаются в изменениях данных, которые хранятся в двух или более базах данных. Приложение использует транзакции эластичной базы данных для скоординированного внесения изменений в базах данных и обеспечения атомарности.
* Сегментированные приложения баз данных в Azure. в этом сценарии уровень данных использует [клиентскую библиотеку эластичной базы данных](elastic-database-client-library.md) или самосегментирование для горизонтального секционирования данных по нескольким базам данных в базе или управляемый экземпляр. Первый пример использования заключается в необходимости внести атомарные изменения в сегментированное мультитенантное приложение, если изменения распространяются на клиенты. Например, рассмотрим передачу данных из одного клиента в другой, при этом оба клиента находятся в разных базах данных. Второй вариант — детальное сегментирование для удовлетворения потребностей больших клиентов, которые, в свою очередь, обычно подразумевают, что некоторые атомарные операции должны быть перенесены в несколько баз данных, используемых для одного и того же клиента. Третий пример предусматривает атомарное обновление, обеспечивающее возможность ссылаться на данные, реплицируемые в базах данных. Теперь благодаря предварительной версии стала возможна координация атомарных транзакционных операций со всеми этими строками в нескольких базах данных.
  Транзакции эластичной базы данных используют две фазы фиксации, чтобы обеспечить атомарность транзакций между базами данных. Это хорошо подходит для транзакций, в которых в одной транзакции задействовано менее 100 баз данных. Эти ограничения не применяются, но при превышении этих ограничений для транзакций эластичной базы данных следует рассчитывать на производительность и успешную скорость.

## <a name="installation-and-migration"></a>Установка и миграция

Возможности транзакций эластичной базы данных предоставляются через обновления библиотек .NET System.Data.dll и System.Transactions.dll. Библиотеки DLL обеспечивают использование двухфазной фиксации для соблюдения атомарности. Чтобы начать разработку приложений, использующих транзакции эластичной базы данных, установите платформу [.NET 4.6.1](https://www.microsoft.com/download/details.aspx?id=49981) или более поздней версии. При использовании платформы .NET предыдущей версии происходит ошибка повышения уровня транзакций до распределенных, после чего возникает исключение.

После установки можно использовать интерфейсы API распределенных транзакций в System. Transactions с подключениями к базе данных SQL и Управляемый экземпляр. Если у вас есть приложения MSDTC, использующие эти API, перестройте существующие приложения для .NET 4,6 после установки платформы 4.6.1. Если проекты ориентированы на .NET 4,6, они будут автоматически использовать обновленные библиотеки DLL из новой версии платформы и вызовы API распределенных транзакций в сочетании с подключениями к базе данных SQL или Управляемый экземпляр теперь будут выполнены.

Помните, что для транзакций эластичной базы данных не требуется установка MSDTC. Вместо этого транзакции эластичной базы данных напрямую управляются и в службе. Это значительно упрощает облачные сценарии, так как развертывание MSDTC не требуется для использования распределенных транзакций с базой данных SQL или Управляемый экземпляр. В разделе 4 более подробно описано развертывание транзакций эластичной базы данных и требуемой платформы .NET вместе с облачными приложениями в Azure.

## <a name="net-installation-for-azure-cloud-services"></a>Установка .NET для облачных служб Azure

Azure включает несколько предложений для размещения приложений .NET. Сравнение различных предложений приведено в статье [Сравнение службы приложений, облачных служб и виртуальных машин Azure](/azure/architecture/guide/technology-choices/compute-decision-tree). Если версия гостевой операционной системы предложения меньше .NET 4.6.1 (версия, необходимая для эластичных транзакций), необходимо обновить гостевую ОС до версии 4.6.1.

Для службы приложений Azure обновления до гостевой ОС в настоящее время не поддерживаются. В виртуальных машинах Azure необходимо просто выполнить вход и запустить установщик для последней версии .NET Framework. Для облачных служб Azure необходимо включить установку более новой версии .NET в задачи запуска данного развертывания. Основные понятия и рекомендованные шаги см. в статье [Установка .NET для роли облачной службы](../../cloud-services/cloud-services-dotnet-install-dotnet.md).  

Обратите внимание на то, что в процессе начальной загрузки в облачных службах Azure для установки .NET 4.6.1 может потребоваться больше объема временного хранилища, чем для установки .NET 4.6. Для успешной установки необходимо увеличить временное хранилище для облачной службы Azure в разделе LocalResources файла ServiceDefinition.csdef и в параметрах среды для задачи запуска, как показано в следующем примере:

```xml
    <LocalResources>
    ...
        <LocalStorage name="TEMP" sizeInMB="5000" cleanOnRoleRecycle="false" />
        <LocalStorage name="TMP" sizeInMB="5000" cleanOnRoleRecycle="false" />
    </LocalResources>
    <Startup>
        <Task commandLine="install.cmd" executionContext="elevated" taskType="simple">
            <Environment>
        ...
                <Variable name="TEMP">
                    <RoleInstanceValue xpath="/RoleEnvironment/CurrentInstance/LocalResources/LocalResource[@name='TEMP']/@path" />
                </Variable>
                <Variable name="TMP">
                    <RoleInstanceValue xpath="/RoleEnvironment/CurrentInstance/LocalResources/LocalResource[@name='TMP']/@path" />
                </Variable>
            </Environment>
        </Task>
    </Startup>
```

## <a name="net-development-experience"></a>Возможности разработки .NET

### <a name="multi-database-applications"></a>Приложения, использующие несколько баз данных

В следующем примере кода знакомые приемы программирования используются в сочетании с System.Transactions .NET. Класс TransactionScope позволяет выполнить внешнюю транзакцию в .NET. («Внешняя транзакция» — это то, что находится в текущем потоке.) Все соединения, открытые в TransactionScope, участвуют в транзакции. Если в транзакции задействовано несколько разных баз данных, ее уровень автоматически повышается и она стает распределенной. Для этого необходимо задать в настройках области ее завершение, что позволяет обозначить выполнение фиксации.

```csharp
    using (var scope = new TransactionScope())
    {
        using (var conn1 = new SqlConnection(connStrDb1))
        {
            conn1.Open();
            SqlCommand cmd1 = conn1.CreateCommand();
            cmd1.CommandText = string.Format("insert into T1 values(1)");
            cmd1.ExecuteNonQuery();
        }

        using (var conn2 = new SqlConnection(connStrDb2))
        {
            conn2.Open();
            var cmd2 = conn2.CreateCommand();
            cmd2.CommandText = string.Format("insert into T2 values(2)");
            cmd2.ExecuteNonQuery();
        }

        scope.Complete();
    }
```

### <a name="sharded-database-applications"></a>Приложения, использующие сегментированные базы данных

Транзакции эластичных баз данных для базы данных SQL и Управляемый экземпляр также поддерживают координацию распределенных транзакций, в которых используется метод OpenConnectionForKey клиентской библиотеки эластичной базы данных для открытия соединений для масштабируемого уровня данных. Рассмотрим случаи, когда необходимо обеспечить согласованность изменений транзакций для нескольких разных значений ключей сегментирования. Подключения к сегментам с разными значениями ключей сегментирования устанавливаются через посредника с использованием OpenConnectionForKey. В большинстве случаев устанавливаются подключения к разным сегментам. Поэтому для осуществления транзакций требуется выполнение распределенной транзакции.
Этот подход показан в следующем примере кода. В нем предполагается использование переменной shardmap для представления карты сегментов в клиентской библиотеке эластичной базы данных:

```csharp
    using (var scope = new TransactionScope())
    {
        using (var conn1 = shardmap.OpenConnectionForKey(tenantId1, credentialsStr))
        {
            SqlCommand cmd1 = conn1.CreateCommand();
            cmd1.CommandText = string.Format("insert into T1 values(1)");
            cmd1.ExecuteNonQuery();
        }

        using (var conn2 = shardmap.OpenConnectionForKey(tenantId2, credentialsStr))
        {
            var cmd2 = conn2.CreateCommand();
            cmd2.CommandText = string.Format("insert into T1 values(2)");
            cmd2.ExecuteNonQuery();
        }

        scope.Complete();
    }
```

## <a name="transact-sql-development-experience"></a>Опыт разработки Transact-SQL

Распределенные транзакции на стороне сервера с использованием Transact-SQL доступны только для Управляемый экземпляр Azure SQL. Распределенная транзакция может выполняться только между управляемыми экземплярами, принадлежащими одной и той же [группе доверия сервера](../managed-instance/server-trust-group-overview.md). В этом случае управляемым экземплярам необходимо использовать [связанный сервер](/sql/relational-databases/linked-servers/create-linked-servers-sql-server-database-engine#TsqlProcedure) для ссылки друг на друга.

Следующий пример кода Transact-SQL использует инструкцию [Begin распределенной транзакции](/sql/t-sql/language-elements/begin-distributed-transaction-transact-sql) для запуска распределенной транзакции.

```Transact-SQL

    -- Configure the Linked Server
    -- Add one Azure SQL Managed Instance as Linked Server
    EXEC sp_addlinkedserver
        @server='RemoteServer', -- Linked server name
        @srvproduct='',
        @provider='sqlncli', -- SQL Server Native Client
        @datasrc='managed-instance-server.46e7afd5bc81.database.windows.net' -- Managed Instance endpoint

    -- Add credentials and options to this Linked Server
    EXEC sp_addlinkedsrvlogin
        @rmtsrvname = 'RemoteServer', -- Linked server name
        @useself = 'false',
        @rmtuser = '<login_name>',         -- login
        @rmtpassword = '<secure_password>' -- password

    USE AdventureWorks2012;
    GO
    SET XACT_ABORT ON;
    GO
    BEGIN DISTRIBUTED TRANSACTION;
    -- Delete candidate from local instance.
    DELETE AdventureWorks2012.HumanResources.JobCandidate
        WHERE JobCandidateID = 13;
    -- Delete candidate from remote instance.
    DELETE RemoteServer.AdventureWorks2012.HumanResources.JobCandidate
        WHERE JobCandidateID = 13;
    COMMIT TRANSACTION;
    GO
```

## <a name="combining-net-and-transact-sql-development-experience"></a>Объединение возможностей разработки .NET и Transact-SQL

Приложения .NET, использующие классы System. Transaction, могут сочетать класс TransactionScope с инструкцией Transact-SQL BEGIN РАСПРЕДЕЛЕНной транзакции. Внутри класса TransactionScope внутренняя транзакция, выполняющая инструкцию BEGIN РАСПРЕДЕЛЕНной транзакции, будет явно преобразована в распределенную транзакцию. Кроме того, при открытии второго Склконнектон в TransactionScope он будет неявно выдвинут на распределенную транзакцию. После запуска распределенной транзакции все последующие запросы, поступающие от .NET или Transact-SQL, будут присоединяться к родительской распределенной транзакции. Как следствие, все вложенные области транзакций, инициированные инструкцией BEGIN, будут находиться в одной транзакции, а инструкции COMMIT и ROLLBACK будут влиять на общий результат:
 * Инструкция COMMIT не будет оказывать никакого воздействия на область транзакции, инициированную инструкцией BEGIN, то есть никакие результаты не будут зафиксированы перед вызовом метода Complete () для объекта TransactionScope. Если объект TransactionScope уничтожается до завершения, то выполняется откат всех изменений, выполненных в области.
 * Инструкция ROLLBACK приведет к откату всей TransactionScope. Любые попытки прикрепить новые транзакции в TransactionScope будут завершаться с ошибкой, а также попытаться вызвать метод Complete () для объекта TransactionScope.

Ниже приведен пример, в котором транзакция явно повышается до распределенной транзакции с помощью Transact-SQL.

```csharp
    using (TransactionScope s = new TransactionScope())
    {
        using (SqlConnection conn = new SqlConnection(DB0_ConnectionString)
        {
            conn.Open();
        
            // Transaction is here promoted to distributed by BEGIN statement
            //
            Helper.ExecuteNonQueryOnOpenConnection(conn, "BEGIN DISTRIBUTED TRAN");
            // ...
        }
     
        using (SqlConnection conn2 = new SqlConnection(DB1_ConnectionString)
        {
            conn2.Open();
            // ...
        }
        
        s.Complete();
    }
```

В следующем примере показана транзакция, которая неявно повышается до распределенной транзакции после запуска второй Склконнектон в TransactionScope.

```csharp
    using (TransactionScope s = new TransactionScope())
    {
        using (SqlConnection conn = new SqlConnection(DB0_ConnectionString)
        {
            conn.Open();
            // ...
        }
        
        using (SqlConnection conn = new SqlConnection(DB1_ConnectionString)
        {
            // Because this is second SqlConnection within TransactionScope transaction is here implicitly promoted distributed.
            //
            conn.Open(); 
            Helper.ExecuteNonQueryOnOpenConnection(conn, "BEGIN DISTRIBUTED TRAN");
            Helper.ExecuteNonQueryOnOpenConnection(conn, lsQuery);
            // ...
        }
        
        s.Complete();
    }
```

## <a name="transactions-across-multiple-servers-for-azure-sql-database"></a>Транзакции между несколькими серверами для базы данных SQL Azure

[!INCLUDE [updated-for-az](../../../includes/updated-for-az.md)]
> [!IMPORTANT]
> Модуль PowerShell Azure Resource Manager по-прежнему поддерживается базой данных SQL Azure, но вся будущая разработка сосредоточена на модуле Az.Sql. Сведения об этих командлетах см. в разделе [AzureRM.Sql](/powershell/module/AzureRM.Sql/). Аргументы команд в модулях Az и AzureRm практически идентичны.

Транзакции эластичной базы данных поддерживаются на разных серверах в базе данных SQL Azure. Если транзакции пересекают границы сервера, участвующие серверы сначала должны быть указаны в связи взаимной связи. После установления отношения взаимодействия любая база данных на любом из двух серверов может участвовать в эластичных транзакциях с базами данных другого сервера. При наличии транзакций, охватывающих более двух серверов, для любой пары серверов необходимо установить связь связи.

Используйте следующие командлеты PowerShell для управления отношениями взаимодействия между серверами для транзакций эластичной базы данных:

* **New-азсклсерверкоммуникатионлинк**: Используйте этот командлет для создания нового отношения взаимодействия между двумя серверами в базе данных SQL Azure. Связь является симметричной. Это означает, что оба сервера могут инициировать транзакции с другим сервером.
* **Get-азсклсерверкоммуникатионлинк**: Используйте этот командлет для получения существующих отношений связи и их свойств.
* **Remove-азсклсерверкоммуникатионлинк**: Используйте этот командлет для удаления существующего отношения связи.

## <a name="transactions-across-multiple-servers-for-azure-sql-managed-instance"></a>Транзакции на нескольких серверах для Управляемый экземпляр Azure SQL

Распределенные транзакции поддерживаются на разных серверах в Управляемый экземпляр SQL Azure. Когда транзакции пересекают границы Управляемый экземпляр, экземпляры, участвующие в ней, сначала должны быть указаны в взаимной взаимосвязи безопасности и связи. Это можно сделать, создав [группу доверия серверов](../managed-instance/server-trust-group-overview.md), которая может быть выполнена на портал Azure. Если управляемые экземпляры находятся не в одной виртуальной сети, необходимо настроить [пиринг виртуальных сетей](../../virtual-network/virtual-network-peering-overview.md) , а правила входящего и исходящего трафика группы безопасности сети должны разрешить порты 5024 и 11000-12000 для всех участвующих виртуальных сетей.

  ![Группы доверия сервера на портале Azure][3]

На следующей схеме показана группа доверия серверов с управляемыми экземплярами, которые могут выполнять распределенные транзакции с помощью .NET или Transact-SQL.

  ![Распределенные транзакции с помощью Управляемый экземпляр Azure SQL с использованием эластичных транзакций][2]

## <a name="monitoring-transaction-status"></a>Мониторинг состояния транзакций

Используйте динамические административные представления (DMV) для отслеживания состояния и хода выполнения текущих транзакций эластичной базы данных. Все динамические представления, связанные с транзакциями, относятся к распределенным транзакциям в базе данных SQL и Управляемый экземпляр. Соответствующий список динамических административных представлений можно найти здесь: [Динамические административные представления и функции, связанные с транзакциями (Transact-SQL)](/sql/relational-databases/system-dynamic-management-views/transaction-related-dynamic-management-views-and-functions-transact-sql).

Особенно полезны следующие динамические административные представления.

* **sys.dm\_tran\_active\_transactions** — позволяет просматривать список активных транзакций и их состояние. В столбце UOW (единица работы) можно просмотреть различные дочерние транзакции, которые относятся к одной распределенной транзакции. У всех транзакций в рамках одной распределенной транзакции одинаковое значение UOW. Дополнительные сведения см. в [документации по DMV](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-active-transactions-transact-sql).
* **sys.dm\_tran\_database\_transactions** — здесь можно просматривать дополнительные сведения о транзакциях, включая расположение транзакции в журнале. Дополнительные сведения см. в [документации по DMV](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-database-transactions-transact-sql).
* **sys.dm\_tran\_locks** — в этом представлении указываются сведения о текущих блокировках транзакций. Дополнительные сведения см. в [документации по DMV](/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql).

## <a name="limitations"></a>Ограничения

В настоящее время к транзакциям эластичных баз данных в базе данных SQL применяются следующие ограничения:

* Поддерживаются только транзакции в базах данных SQL. Другие поставщики ресурсов и базы данных [XA](https://en.wikipedia.org/wiki/X/Open_XA) , расположенные за пределами базы данных SQL, не могут участвовать в транзакциях эластичной базы данных. Это означает, что транзакции эластичной базы данных не могут быть перенесены в локальные SQL Server и базу данных SQL Azure. Чтобы осуществлять распределенные транзакции локально, нужно использовать MSDTC.
* Поддерживаются только транзакции, которые осуществляются с помощью приложения .NET и которые координирует клиент. Сейчас выполнение запросов T-SQL на серверах (например, BEGIN DISTRIBUTED TRANSACTION) не поддерживается, но в будущем мы планируем добавить эту возможность.
* Транзакции в службах WCF не поддерживаются. Например, если у вас есть метод службы WCF, выполняющий транзакцию, включение вызова в область транзакции завершится ошибкой с исключением [System.ServiceModel.ProtocolException](/dotnet/api/system.servicemodel.protocolexception).

Следующие ограничения в настоящее время применяются к распределенным транзакциям в Управляемый экземпляр.

* Поддерживаются только транзакции для баз данных в Управляемый экземпляр. Другие поставщики ресурсов и базы данных [XA](https://en.wikipedia.org/wiki/X/Open_XA) , расположенные за пределами Azure SQL управляемый экземпляр, не могут участвовать в распределенных транзакциях. Это означает, что распределенные транзакции не могут быть перенесены в локальные SQL Server и Управляемый экземпляр SQL Azure. Чтобы осуществлять распределенные транзакции локально, нужно использовать MSDTC.
* Транзакции в службах WCF не поддерживаются. Например, если у вас есть метод службы WCF, выполняющий транзакцию, включение вызова в область транзакции завершится ошибкой с исключением [System.ServiceModel.ProtocolException](/dotnet/api/system.servicemodel.protocolexception).
* Для участия в распределенной транзакции Управляемый экземпляр Azure SQL необходимо входить в [группу доверия серверов](../managed-instance/server-trust-group-overview.md) .
* Ограничения [групп доверия серверов](../managed-instance/server-trust-group-overview.md) влияют на распределенные транзакции.
* Управляемые экземпляры, участвующие в распределенных транзакциях, должны иметь возможность подключения через частные конечные точки (с использованием частного IP-адреса из виртуальной сети, где они развернуты) и должны быть взаимосвязаны с использованием частных полных доменных имен. Клиентские приложения могут использовать распределенные транзакции в частных конечных точках. Кроме того, в случаях, когда Transact-SQL использует связанные серверы, ссылающиеся на частные конечные точки, клиентские приложения могут также использовать распределенные транзакции на общедоступных конечных точках. Это ограничение объясняется на следующей схеме.
  ![Ограничение подключения к частной конечной точке][4]
## <a name="next-steps"></a>Дальнейшие действия

* Для получения вопросов свяжитесь с нами на [странице Microsoft Q&A вопрос для базы данных SQL](/answers/topics/azure-sql-database.html).
* Для запросов функций добавьте их на [Форум обратной связи с базой данных SQL](https://feedback.azure.com/forums/217321-sql-database/) или на [форум управляемый экземпляр](https://feedback.azure.com/forums/915676-sql-managed-instance).



<!--Image references-->
[1]: ./media/elastic-transactions-overview/distributed-transactions.png
[2]: ./media/elastic-transactions-overview/sql-mi-distributed-transactions.png
[3]: ./media/elastic-transactions-overview/server-trust-groups-azure-portal.png
[4]: ./media/elastic-transactions-overview/managed-instance-distributed-transactions-private-endpoint-limitations.png
