---
title: Рекомендации по настройке производительности для приложений и баз данных
titleSuffix: Azure SQL Database & Azure SQL Managed Instance
description: Сведения о настройке приложений и баз данных для повышения производительности в базе данных SQL Azure и Управляемый экземпляр Azure SQL.
services: sql-database
ms.service: sql-db-mi
ms.subservice: performance
ms.custom: sqldbrb=2
ms.devlang: ''
ms.topic: conceptual
author: WilliamDAssafMSFT
ms.author: wiassaf
ms.reviewer: sstein
ms.date: 03/10/2020
ms.openlocfilehash: 40657ad2f3b69d62e0e0d9c7d9e0f0be7343547b
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "96490607"
---
# <a name="tune-applications-and-databases-for-performance-in-azure-sql-database-and-azure-sql-managed-instance"></a>Настройка приложений и баз данных для повышения производительности в базе данных SQL Azure и Управляемый экземпляр Azure SQL
[!INCLUDE[appliesto-sqldb-sqlmi](../includes/appliesto-sqldb-sqlmi.md)]

После определения проблемы с производительностью, с которой вы столкнулись с базой данных SQL Azure и Управляемый экземпляр Azure SQL, эта статья призвана помочь:

- Настройте приложение и примените некоторые рекомендации, которые могут увеличить производительность.
- Настройте базу данных, изменив индексы и запросы, чтобы повысить эффективность работы с данными.

В этой статье предполагается, что вы уже работали с [рекомендациями помощника по базам данных](database-advisor-implement-performance-recommendations.md) SQL Azure и [рекомендациями по автоматической настройке](automatic-tuning-overview.md)базы данных SQL Azure, если это применимо. В ней также предполагается, что вы ознакомились с [общими сведениями о мониторинге и настройке](monitor-tune-overview.md) и другими статьями, описывающими устранение проблем с производительностью. Кроме того, в этой статье предполагается, что у вас нет ресурсов ЦП, а также проблемы производительности, которую можно устранить, увеличив объем вычислений или уровень служб, чтобы предоставить дополнительные ресурсы для базы данных.

## <a name="tune-your-application"></a>Настройка приложения

В традиционной локальной среде SQL Server процесс изначального планирования загрузки часто отделен от процесса запуска приложения в рабочей среде. Сначала приобретаются лицензии на оборудование и продукт, а затем настраивается производительность. При использовании Azure SQL лучше всего выполнять процесс запуска приложения и его настройки с помощью. Оплата только за используемые ресурсы позволяет настраивать приложение на использование минимального объема ресурсов, которые нужны в данный момент, а не выполнять избыточную подготовку согласно прогнозам будущего роста нагрузки на приложение, так как такие прогнозы часто ошибочны. Некоторые пользователи предпочитают не настраивать приложение и вместо этого используют избыточную подготовку ресурсов оборудования. Этот подход может подойти, если вы не желаете изменять ключевое приложение в период высокой нагрузки. Однако настройка приложения может снизить требования к ресурсам и более низкие ежемесячные счета при использовании уровней служб в базе данных SQL Azure и Управляемый экземпляр Azure SQL.

### <a name="application-characteristics"></a>Характеристики приложения

Несмотря на то что база данных SQL Azure и уровни служб Azure SQL Управляемый экземпляр предназначены для повышения стабильности и предсказуемости работы приложения, некоторые рекомендации могут помочь в настройке приложения для лучшего использования ресурсов в масштабе вычислений. Многие приложения получают значительный прирост производительности после простого перехода на более высокий объем вычислительных ресурсов или уровень служб, в то время как для лучшей работы других приложений на новом уровне требуется дополнительная настройка. Для повышения производительности приложений со следующими характеристиками необходима дополнительная настройка:

- **Приложения с низкой производительностью из-за "нестабильной" работы**.

  Возможно, в такие приложения понадобится внести изменения, сократив число операций доступа к данным в Базе данных SQL. Может потребоваться изменить эти типы приложений, чтобы уменьшить количество операций доступа к данным в базе данных. Например, вы можете повысить производительность приложения с помощью таких методов, как пакетирование нерегламентированных запросов или перемещение запросов в хранимые процедуры. в разделе [Пакетные запросы](#batch-queries).

- **Базы данных с интенсивной рабочей нагрузкой, которая не может поддерживаться целой машиной**

   Базам данных, которые превышают использование ресурсов при использовании наивысшего объема вычислительных ресурсов уровня служб "Премиум", может быть полезно масштабировать рабочие нагрузки. Дополнительные сведения см. в разделах [Сегментирование баз данных](#cross-database-sharding) и [Функциональное секционирование](#functional-partitioning).

- **Приложения с неоптимальными запросами**.

  Приложения, особенно те, которые на уровне доступа к данным, используют плохо настроенные запросы, могут не получить выгоды за счет использования высокого объема вычислительных ресурсов. Больше пользы таким приложениям приносят стандартные методы оптимизации производительности запросов. Дополнительные сведения см. Дополнительные сведения см. в разделах [Отсутствующие индексы](#identifying-and-adding-missing-indexes) и [Настройка запросов и указания на них](#query-tuning-and-hinting).

- **Приложения с неоптимальной схемой доступа к данным**.

   Приложениям, в которых есть проблемы параллельного доступа к данным, например взаимоблокировка, нецелесообразно увеличивать объем вычислительных ресурсов. Рассмотрите возможность уменьшения круговых путей к базе данных путем кэширования данных на стороне клиента с помощью службы кэширования Azure или другой технологии кэширования. раздел [Кэширование на уровне приложения](#application-tier-caching).

## <a name="tune-your-database"></a>Настройка базы данных

В этом разделе мы рассмотрим некоторые методы, которые можно использовать для настройки базы данных, чтобы добиться лучшей производительности приложения и запустить его с наименьшим возможным размером вычислений. Некоторые из этих методов соответствуют традиционным рекомендациям по настройке SQL Server, но другие относятся к базе данных SQL Azure и Azure SQL Управляемый экземпляр. В некоторых случаях можно изучить потребляемые ресурсы для базы данных, чтобы найти области для дальнейшей настройки и расширения традиционных методов SQL Server для работы в базе данных SQL Azure и Azure SQL Управляемый экземпляр.

### <a name="identifying-and-adding-missing-indexes"></a>Определение и добавление недостающих индексов

Одна из распространенных проблем производительности баз данных OLTP связана с физической схемой базы данных. Часто схемы базы данных создаются и поставляются без проверки масштабируемости по нагрузке или объему данных. К сожалению, производительность плана запроса, приемлемая при небольшом масштабе, может существенно снижаться при использовании объема данных уровня большой компании. Самый распространенный источник проблем связан с отсутствием индексов, которые позволили бы сортировать и ограничивать данные в запросе. Часто при этом сканируется вся таблица, в то время как поиска по индексу было бы достаточно.

В этом примере в выбранном плане запроса используется сканирование, хотя здесь было бы достаточно поиска.

```sql
DROP TABLE dbo.missingindex;
CREATE TABLE dbo.missingindex (col1 INT IDENTITY PRIMARY KEY, col2 INT);
DECLARE @a int = 0;
SET NOCOUNT ON;
BEGIN TRANSACTION
    WHILE @a < 20000
    BEGIN
        INSERT INTO dbo.missingindex(col2) VALUES (@a);
        SET @a += 1;
    END
    COMMIT TRANSACTION;
    GO
SELECT m1.col1
    FROM dbo.missingindex m1 INNER JOIN dbo.missingindex m2 ON(m1.col1=m2.col1)
    WHERE m1.col2 = 4;
```

![План запроса c отсутствующими индексами](./media/performance-guidance/query_plan_missing_indexes.png)

База данных SQL Azure и Управляемый экземпляр Azure SQL позволяют находить и исправлять основные условия отсутствующих индексов. Динамические административные представления, встроенные в базу данных SQL Azure, и SQL Azure Управляемый экземпляр просматривать компиляции запросов, в которых индекс значительно сокращает оценочные затраты на выполнение запроса. Во время выполнения запроса ядро СУБД отслеживает, как часто выполняется каждый план запроса, и отслеживает предполагаемый зазор между выполняемым планом запроса и представьтем, где существовал этот индекс. Эти представления можно использовать, чтобы быстро выяснить, какие изменения схемы базы данных могли бы существенно уменьшить рабочую нагрузку для базы данных.

Этот запрос можно использовать для оценки потенциально отсутствующих индексов:

```sql
SELECT
   CONVERT (varchar, getdate(), 126) AS runtime
   , mig.index_group_handle
   , mid.index_handle
   , CONVERT (decimal (28,1), migs.avg_total_user_cost * migs.avg_user_impact *
        (migs.user_seeks + migs.user_scans)) AS improvement_measure
   , 'CREATE INDEX missing_index_' + CONVERT (varchar, mig.index_group_handle) + '_' +
        CONVERT (varchar, mid.index_handle) + ' ON ' + mid.statement + '
        (' + ISNULL (mid.equality_columns,'')
        + CASE WHEN mid.equality_columns IS NOT NULL
        AND mid.inequality_columns IS NOT NULL
        THEN ',' ELSE '' END + ISNULL (mid.inequality_columns, '') + ')'
        + ISNULL (' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement
   , migs.*
   , mid.database_id
   , mid.[object_id]
FROM sys.dm_db_missing_index_groups AS mig
   INNER JOIN sys.dm_db_missing_index_group_stats AS migs
      ON migs.group_handle = mig.index_group_handle
   INNER JOIN sys.dm_db_missing_index_details AS mid
      ON mig.index_handle = mid.index_handle
 ORDER BY migs.avg_total_user_cost * migs.avg_user_impact * (migs.user_seeks + migs.user_scans) DESC
```

В этом примере при выполнении запроса возникло такое предложение:

```sql
CREATE INDEX missing_index_5006_5005 ON [dbo].[missingindex] ([col2])  
```

После его создания инструкция SELECT выбирает другой план, в котором используется поиск вместо сканирования, а затем выполняет план более эффективно.

![План запроса c исправленными индексами](./media/performance-guidance/query_plan_corrected_indexes.png)

Важно понимать, что пропускная способность общей среды более ограничена, чем пропускная способность выделенного сервера. Для минимизации ненужных операций ввода-вывода можно свести к минимуму, чтобы воспользоваться максимальным преимуществом системы в ресурсах каждого размера вычислений уровней служб. Улучшение физической схемы базы данных может значительно уменьшить задержку для определенных запросов, улучшить пропускную способность при параллельных запросах, обрабатываемых на единицу масштабирования, и минимизировать затраты, необходимые на выполнение одного запроса. Дополнительные сведения о динамических административных представлениях для отсутствующих индексов см. в разделе [sys.dm_db_missing_index_details](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-missing-index-details-transact-sql).

### <a name="query-tuning-and-hinting"></a>Настройка запросов и указания на них

Оптимизатор запросов в базе данных SQL Azure и Управляемый экземпляр SQL Azure аналогичен традиционному оптимизатору запросов SQL Server. Большинство рекомендаций по настройке запросов и пониманию ограничений модели причин для оптимизатора запросов также применяются к базе данных SQL Azure и Управляемый экземпляр Azure SQL. Если вы настраиваете запросы в базе данных SQL Azure и Управляемый экземпляр Azure SQL, вы можете получить дополнительное преимущество снижения совокупных требований к ресурсам. С помощью настройки можно снизить затраты на приложение, так как в результате можно будет использовать более низкий объем вычислительных ресурсов.

Пример, типичный в SQL Server и применяемый к базе данных SQL Azure и Управляемый экземпляр SQL Azure, — это то, как параметры "перехвата" оптимизатора запросов. Во время компиляции оптимизатор запросов вычисляет текущее значение параметра с целью создания более оптимального плана запроса. Хотя эта стратегия часто может привести к тому, что план запроса значительно быстрее, чем план, скомпилированный без известных значений параметров, в настоящее время он работает незаметно как в SQL Server, в базе данных SQL Azure, так и в Управляемый экземпляр SQL Azure. Иногда параметр сканируется, а иногда нет, но при этом созданный план неэффективен для полного набора значений параметров в рабочей нагрузке. Майкрософт предусматривает использование указаний запросов (директив), которые позволяют указать, следует ли изменить поведение по умолчанию. Часто при использовании указаний вы можете исправить случаи, в которых неидеальны SQL Server по умолчанию, базу данных SQL Azure и поведение Управляемый экземпляр SQL Azure для конкретной рабочей нагрузки клиента.

В следующем примере показано, как обработчик запросов может создать план, который не соответствует требованиям к производительности и ресурсам. В этом примере также показано, что при использовании указания запроса можно сократить время выполнения запроса и требования к ресурсам для базы данных.

```sql
DROP TABLE psptest1;
CREATE TABLE psptest1(col1 int primary key identity, col2 int, col3 binary(200));
DECLARE @a int = 0;
SET NOCOUNT ON;
BEGIN TRANSACTION
   WHILE @a < 20000
   BEGIN
     INSERT INTO psptest1(col2) values (1);
     INSERT INTO psptest1(col2) values (@a);
     SET @a += 1;
   END
   COMMIT TRANSACTION
   CREATE INDEX i1 on psptest1(col2);
GO

CREATE PROCEDURE psp1 (@param1 int)
   AS
   BEGIN
      INSERT INTO t1 SELECT * FROM psptest1
      WHERE col2 = @param1
      ORDER BY col2;
    END
    GO

CREATE PROCEDURE psp2 (@param2 int)
   AS
   BEGIN
      INSERT INTO t1 SELECT * FROM psptest1 WHERE col2 = @param2
      ORDER BY col2
      OPTION (OPTIMIZE FOR (@param2 UNKNOWN))
   END
   GO

CREATE TABLE t1 (col1 int primary key, col2 int, col3 binary(200));
GO
```

Код установки создает таблицу с неравномерным распределением данных. Оптимальный план запроса зависит от выбранного параметра. К сожалению, при кэшировании плана запрос не всегда повторно компилируется в зависимости от наиболее подходящего значения параметра. Таким образом, может получиться так, что будет кэширован неоптимальный план, который будет использоваться во многих случаях, когда можно было бы использовать более эффективный план. После этого план запроса создает две хранимые процедуры, которые идентичны друг другу, за исключением того, что одна из них содержит специальное указание запроса.

```sql
-- Prime Procedure Cache with scan plan
EXEC psp1 @param1=1;
TRUNCATE TABLE t1;

-- Iterate multiple times to show the performance difference
DECLARE @i int = 0;
WHILE @i < 1000
   BEGIN
      EXEC psp1 @param1=2;
      TRUNCATE TABLE t1;
      SET @i += 1;
    END
```

Прежде чем приступать ко второй части примера, мы советуем подождать около 10 минут, чтобы в итоговых данных телеметрии результаты были очевидными.

```sql
EXEC psp2 @param2=1;
TRUNCATE TABLE t1;

DECLARE @i int = 0;
    WHILE @i < 1000
    BEGIN
        EXEC psp2 @param2=2;
        TRUNCATE TABLE t1;
        SET @i += 1;
    END
```

Каждая часть примера пытается выполнить параметризованную вставку 1000 раз (это необходимо для создания достаточной нагрузки). При выполнении хранимых процедур обработчик запросов проверяет значение параметра, переданное в процедуру во время первой компиляции ("вставка на лету"). Обработчик кэширует результирующий план и использует его в дальнейшем, даже если значение параметра будет другим. Оптимальный план может подойти не для всех случаев. Иногда нужно указывать оптимизатору, какой план выбрать, чтобы этот план был относительно универсальным, а не просто подходящим для определенного случая, когда впервые происходит компиляция запроса. В этом примере изначальный план создает сканирование, при котором считываются все строки, чтобы найти значение, которое отвечает параметру.

![Настройка запроса с использованием плана сканирования](./media/performance-guidance/query_tuning_1.png)

Так как процедура выполнена с использованием значения 1, результирующий план был оптимальным для значения 1, но неоптимальным для всех остальных значений в таблице. Если вы будете выбирать каждый план случайным образом, скорее всего, результат не будет оптимальным, так как план будет выполняться медленнее и задействовать больше ресурсов.

При выполнении теста с параметром `SET STATISTICS IO` со значением `ON` логическое сканирование в этом примере будет проходить в фоновом режиме. Вы можете увидеть, что план выполнил 1148 операций чтения (что является неэффективным, если обычно нужно вернуть только одну строку).

![Настройка запроса с использованием логического сканирования](./media/performance-guidance/query_tuning_2.png)

Во второй части примера используется указание запроса, которое позволяет дать оптимизатору инструкцию использовать конкретное значение во время компиляции. В этом случае обработчик запросов принудительно игнорирует значение, которое передается в качестве параметра, и вместо этого использует значение `UNKNOWN`. Это значение со средней частотой в таблице (независимо от искажения распределения). В результате мы получим план на основе поиска, который работает быстрее и использует меньше ресурсов, чем план из части 1 этого примера.

![Настройка запроса с помощью указания запроса](./media/performance-guidance/query_tuning_3.png)

Просмотреть результат можно в таблице **sys.resource_stats** (между временем выполнения теста и появлением данных в таблице есть задержка). В этом примере первая часть выполнялась в рамках временного окна 22:25:00, а вторая часть — в 22:35:00. В первой части использовано больше ресурсов, чем во второй (в силу повышения эффективности).

```sql
SELECT TOP 1000 *
FROM sys.resource_stats
WHERE database_name = 'resource1'
ORDER BY start_time DESC
```

![Пример результатов настройки запроса](./media/performance-guidance/query_tuning_4.png)

> [!NOTE]
> В этом примере преднамеренно использовались небольшие значения, однако последствия неоптимальных параметров могут быть существенными, особенно для больших баз данных. Разница для быстрых и медленных запросов в некоторых случаях может достигать от нескольких секунд до нескольких часов.

Вы можете просмотреть таблицу **sys.resource_stats**, чтобы определить, использует ли один тест больше ресурсов, чем другой. При сравнении данных между тестами необходимо установить интервалы, чтобы они не группировались в одном 5-минутном окне в представлении **sys.resource_stats**. Цель расчетов — минимизировать общее использование ресурсов, а не пиковую нагрузку. Обычно оптимизация части кода с целью уменьшения задержки выполнения также приводит к сокращению использования ресурсов. Убедитесь, что изменения, внесенные в приложение, необходимы и что они не оказывают негативное влияние на работу приложения при использовании указаний запроса.

Если рабочая нагрузка содержит ряд повторяющихся запросов, то часто бывает целесообразно отследить и проверить оптимальность планов, так как это позволит уменьшить минимальный размер ресурсов, необходимых базе данных. После проверки иногда пересматривайте планы, чтобы убедиться, что их производительность не ухудшилась. Дополнительные сведения об указаниях запроса (Transact-SQL) см. [в этой статье](/sql/t-sql/queries/hints-transact-sql-query).

### <a name="very-large-database-architectures"></a>Очень крупные архитектуры баз данных

Перед выпуском уровня службы " [Горизонтальный](service-tier-hyperscale.md) " в базе данных SQL Azure клиенты использовали для ограничения емкости отдельных баз данных. Эти ограничения емкости по-прежнему существуют для баз данных пула в пулах эластичных баз данных SQL Azure и базах данных экземпляров в управляемых экземплярах SQL Azure. В следующих двух разделах обсуждаются два варианта решения проблем с очень большими базами данных в Azure SQL Server и Управляемый экземпляр SQL Azure, если вы не можете использовать уровень службы "масштабирование".

### <a name="cross-database-sharding"></a>Сегментирование баз данных

Поскольку база данных SQL Azure и Управляемый экземпляр Azure SQL выполняются на оборудовании товара, ограничения емкости для отдельной базы данных ниже, чем для традиционной локальной установки SQL Server. Некоторые клиенты используют методы сегментирования для распределения операций базы данных по нескольким базам данных, если операции не помещаются в пределах отдельной базы данных в базе данных SQL Azure и Управляемый экземпляр Azure SQL. Большинство клиентов, использующих методы сегментирования в базе данных SQL Azure и Azure SQL Управляемый экземпляр разбивают свои данные в одном измерении по нескольким базам данных. При использовании этого подхода необходимо понимать, что часто приложения OLTP выполняют транзакции, которые применимы только к одной строке или небольшой группе строк внутри одной схемы.

> [!NOTE]
> Теперь база данных SQL Azure предоставляет библиотеку для помощи с сегментированием. Дополнительные сведения см. в статье [Обзор клиентской библиотеки для эластичных баз данных](elastic-database-client-library.md).

Например, если база данных содержит сведения об имени клиента, заказе и цене (как можно увидеть в стандартном примере базы данных Northwind, который используется для SQL Server), эти данные можно разбить на несколько баз данных, группируя вместе сведения о клиенте и заказе. Это гарантирует, что данные клиента останутся в пределах отдельной базы данных. Приложение должно разбивать заказчиков по разным базам данных и эффективно распределять нагрузку. С помощью сегментирования клиенты могут не только ограничивать максимальный размер базы данных, но и базу данных SQL Azure и Azure SQL Управляемый экземпляр также могут обрабатывать рабочие нагрузки, которые значительно превосходят ограничения различных размеров вычислений, при условии, что каждая отдельная база данных соответствует ограничениям уровня службы.

Несмотря на то что сегментирование баз данных не снижает общую нагрузку для решения, такой подход очень эффективен для поддержки очень больших решений, распределенных по нескольким базам данных. Каждую базу данных можно запускать с разным объемом вычислительных ресурсов для поддержки очень больших "эффективных" баз данных с высокими требованиями к ресурсам.

#### <a name="functional-partitioning"></a>Функциональное секционирование

Пользователи часто объединяют многие функции в отдельной базе данных. Например, если приложение содержит логику управления запасами склада, то база данных может содержать логику, связанную с запасами, отслеживанием заказов на покупку, хранимыми процедурами, индексированными или материализованными представлениями для управления ежемесячными отчетами. Такой подход позволяет легко администрировать базы данных и выполнять такие операции, как резервное копирование. Однако в этом случае нужно также изменить размер оборудования, чтобы распределять пиковую нагрузку функций одного приложения.

Если вы используете архитектуру масштабирования в базе данных SQL Azure и Управляемый экземпляр SQL Azure, рекомендуется разделить различные функции приложения на разные базы данных. При использовании этого метода приложения масштабируются независимо друг от друга. По мере повышения нагрузки на приложение (и нагрузки на базу данных) администратор сможет определить объемы вычислительных ресурсов отдельно для каждой функции одного приложения. Такая архитектура позволит приложению расширяться за пределы одного сервера за счет распределения нагрузки по разным серверам.

### <a name="batch-queries"></a>Пакетные запросы

Для приложений, обращающихся к данным с помощью больших объемов, частых, нерегламентированных запросов, для сетевого взаимодействия между уровнем приложения и уровнем базы данных тратится значительное время ответа. Даже если приложение и база данных находятся в одном центре обработки данных, задержка в сети между ними может быть увеличена при большом количестве операций доступа к данным. Чтобы уменьшить количество циклических операций доступа к данным, попробуйте выполнить пакетную обработку нерегламентированных запросов или скомпилировать их в качестве хранимых процедур. При пакетной обработке нерегламентированных запросов можно отправить несколько запросов в одну крупную пакетную службу в одну поездку в базу данных. Выполнив компилирование нерегламентированных запросов в одну хранимую процедуру, можно достигнуть того же результата, что и при пакетной обработке. Использование хранимой процедуры также позволяет повысить вероятность кэширования планов запросов в базе данных, чтобы можно было снова использовать хранимую процедуру.

Некоторые приложения требуют большого количества операций записи.  Иногда можно уменьшить общую нагрузку операций ввода-вывода на базы данных путем правильной пакетной обработки операций записи. Часто для этого нужно просто использовать явные транзакции вместо автоматических в хранимых процедурах и пакетах нерегламентированных запросов. Для ознакомления с различными методиками, которые можно использовать, см. раздел [приемы пакетной обработки для приложений баз данных в Azure](../performance-improve-use-batching.md). Поэкспериментируйте со своей рабочей нагрузкой, чтобы найти оптимальную модель пакетной обработки. Необходимо учитывать, что гарантии согласованности транзакций разных моделей могут немного отличаться. Чтобы определить наиболее оптимальную рабочую нагрузку, которая минимизирует использование ресурсов, необходимо добиться правильного сочетания компромиссов согласованности и производительности.

### <a name="application-tier-caching"></a>Кэширование на уровне приложения

Некоторые приложения базы данных содержат рабочие нагрузки, выполняющие много операций чтения. Уровни кэширования могут снизить нагрузку на базу данных и потенциально снизить размер вычислений, необходимый для поддержки базы данных, с помощью базы данных SQL Azure и Управляемый экземпляр Azure SQL. При использовании [кэша Azure для Redis](https://azure.microsoft.com/services/cache/)при наличии рабочей нагрузки с интенсивным чтением данных можно считывать данные один раз (или, возможно, один раз на компьютер уровня приложения в зависимости от того, как он настроен), а затем сохранять эти данные за пределами базы данных. Это помогает снизить нагрузку на базу данных (загрузка ЦП и число операций ввода-вывода), однако это может повлиять на согласованность транзакций, так как данные в кэше могут быть не синхронизированы с данными в базе данных. Для многих приложений определенный уровень несогласованности приемлем, однако это подходит не для всех рабочих нагрузок. Мы советуем внимательно изучить требования к приложению, прежде чем использовать стратегию кэширования на уровне приложения.

## <a name="next-steps"></a>Дальнейшие действия

- Дополнительные сведения об уровнях служб на основе единиц DTU см. в статье о [модели приобретения на основе единиц DTU](service-tiers-dtu.md).
- Дополнительные сведения об уровнях служб на основе виртуальных ядер см. в разделе [Модель приобретения на основе виртуальных ядер](service-tiers-vcore.md).
- Дополнительные сведения о пулах эластичных баз данных Azure см. в статье [Что такое пул эластичных БД Azure?](elastic-pool-overview.md)
- Сведения о производительности и пулах эластичных баз данных см. в статье [Когда следует использовать эластичный пул?](elastic-pool-overview.md)