---
title: In-Memory OLTP улучшает производительность SQL транзакция
description: Внедрение In-Memory OLTP для повышения производительности транзакций в существующей базе данных в базе данных SQL Azure и Управляемый экземпляр SQL Azure.
services: sql-database
ms.service: sql-database
ms.custom: sqldbrb=2
ms.subservice: development
ms.topic: how-to
author: stevestein
ms.author: sstein
ms.reviewer: MightyPen
ms.date: 11/07/2018
ms.openlocfilehash: e17e98e784b7453c87814c5cce5c03568f66b1cb
ms.sourcegitcommit: 772eb9c6684dd4864e0ba507945a83e48b8c16f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "91619752"
---
# <a name="use-in-memory-oltp-to-improve-your-application-performance-in-azure-sql-database-and-azure-sql-managed-instance"></a>Использование In-Memory OLTP для повышения производительности приложения в базе данных SQL Azure и Azure SQL Управляемый экземпляр
[!INCLUDE[appliesto-sqldb-sqlmi](includes/appliesto-sqldb-sqlmi.md)]

[Выполняющуюся в памяти OLTP](in-memory-oltp-overview.md) можно использовать для повышения производительности обработки транзакций, приема данных и сценариев, связанных с временными данными, в базах данных уровней ["Премиум" и "Критически важный для бизнеса"](database/service-tiers-vcore.md), не повышая ценовую категорию.

> [!NOTE]
> Узнайте [, как кворум удваивает рабочую нагрузку ключевой базы данных при снижении количества DTU на 70% в базе данных SQL Azure](https://customers.microsoft.com/story/quorum-doubles-key-databases-workload-while-lowering-dtu-with-sql-database) .

Выполните следующие действия, чтобы внедрить выполняющуюся в памяти OLTP в существующую базу данных.

## <a name="step-1-ensure-you-are-using-a-premium-and-business-critical-tier-database"></a>Шаг 1. Проверка того, используется ли база данных нужного уровня ("Премиум"или "Критически важный для бизнеса")

Выполняющаяся в памяти OLTP поддерживается только в базах данных уровней "Премиум"и "Критически важный для бизнеса". In-Memory поддерживается, если полученное значение равно 1 (не 0):

```sql
SELECT DatabasePropertyEx(Db_Name(), 'IsXTPSupported');
```

Сокращение *XTP* обозначает технологию *экстремальной обработки транзакций (Extreme Transaction Processing)*.

## <a name="step-2-identify-objects-to-migrate-to-in-memory-oltp"></a>Этап 2. Определение объектов для переноса в In-Memory OLTP

Среда SSMS позволяет создать отчет **Обзор анализа производительности транзакций** , который затем можно запустить для базы данных с активной рабочей нагрузкой. В отчете определены таблицы и хранимые процедуры, которые подходят для миграции в компонент In-Memory OLTP.

Для создания отчета в среде SSMS выполните следующие действия:

* В **обозревателе объектов** щелкните узел своей базы данных правой кнопкой мыши.
* Щелкните **отчеты**  >  **Стандартные отчеты**  >  **Обзор анализа производительности транзакций**.

Дополнительные сведения см. в статье [Определение, должна ли таблица или хранимая процедура быть перенесена в выполняющуюся в памяти OLTP](/sql/relational-databases/in-memory-oltp/determining-if-a-table-or-stored-procedure-should-be-ported-to-in-memory-oltp).

## <a name="step-3-create-a-comparable-test-database"></a>Шаг 3. Создание сопоставимой тестовой базы данных

Предположим, что согласно отчету ваша база данных содержит таблицу, которую лучше преобразовать в оптимизированную для памяти таблицу. Мы рекомендуем сначала проверить это утверждение.

Вам понадобится тестовая копия рабочей базы данных. У тестовой и рабочей баз данных должен быть один уровень служб.

Чтобы упростить тестирование, настройте тестовую базу данных следующим образом.

1. Подключитесь к новой тестовой базе данных с помощью SSMS.
2. Чтобы не использовать параметр WITH (SNAPSHOT) в запросах, настройте параметр базы данных, как показано в следующей инструкции T-SQL:

   ```sql
   ALTER DATABASE CURRENT
    SET
        MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = ON;
   ```

## <a name="step-4-migrate-tables"></a>Шаг 4. Миграция таблиц

Вам нужно создать и заполнить копию оптимизированной для памяти таблицы, которую вы тестируете. Ее можно создать с помощью:

* удобного мастера оптимизации памяти в SSMS;
* вручную с помощью инструкций T-SQL.

### <a name="memory-optimization-wizard-in-ssms"></a>Создание таблицы с помощью мастера оптимизации памяти в SSMS

Чтобы использовать этот параметр миграции, сделайте следующее.

1. Подключитесь к тестовой базе данных с помощью SSMS.
2. В **обозревателе объектов** щелкните правой кнопкой мыши таблицу, а затем выберите пункт **Memory Optimization Advisor** (Помощник по оптимизации памяти).

   Отобразится мастер **Помощник по оптимизации памяти таблицы** .
3. В окне мастера щелкните **Проверка переноса** (или нажмите кнопку **Далее**). Так вы узнаете, содержит ли таблица функции, которые не поддерживаются в оптимизированных для памяти таблицах. Дополнительные сведения см. в разделе:

   * *Контрольный список оптимизации памяти* в [помощнике по оптимизации памяти](/sql/relational-databases/in-memory-oltp/memory-optimization-advisor).
   * [Конструкции Transact-SQL, не поддерживаемые In-Memory OLTP](/sql/relational-databases/in-memory-oltp/transact-sql-constructs-not-supported-by-in-memory-oltp).
   * [Миграция в In-Memory OLTP](/sql/relational-databases/in-memory-oltp/plan-your-adoption-of-in-memory-oltp-features-in-sql-server).
4. Если в таблице нет неподдерживаемых функций, помощник выполнит фактический перенос схемы и данных автоматически.

### <a name="manual-t-sql"></a>Создание таблицы вручную с помощью инструкций T-SQL

Чтобы использовать этот параметр миграции, сделайте следующее.

1. Подключитесь к тестовой базе данных с помощью SSMS (или аналогичной служебной программы).
2. Получите полный сценарий T-SQL для таблицы и ее индексов.

   * В среде SSMS щелкните правой кнопкой мыши узел таблицы.
   * Нажмите кнопку создать **Скрипт**  >  **для таблицы создание**  >  **нового окна запроса**.
3. В окне сценария добавьте в инструкцию CREATE TABLE параметр WITH (MEMORY_OPTIMIZED = ON).
4. При необходимости измените для индекса параметр CLUSTERED (Кластеризовано) на NONCLUSTERED (Некластеризовано).
5. Переименуйте существующую таблицу с помощью инструкции SP_RENAME.
6. Создайте копию оптимизированной для памяти таблицы, выполнив отредактированный сценарий CREATE TABLE.
7. Скопируйте данные в оптимизированную для памяти таблицу с помощью инструкции INSERT...SELECT * INTO:

```sql
INSERT INTO <new_memory_optimized_table>
        SELECT * FROM <old_disk_based_table>;
```

## <a name="step-5-optional-migrate-stored-procedures"></a>Шаг 5 (необязательный). Миграция хранимых процедур

Компонент In-Memory также может изменять хранимую процедуру для повышения производительности.

### <a name="considerations-with-natively-compiled-stored-procedures"></a>Общие сведения о скомпилированных в собственном коде хранимых процедурах

Скомпилированная в собственном коде хранимая процедура должна иметь следующие параметры в условии T-SQL:

* NATIVE_COMPILATION
* SCHEMABINDING — в таблицах хранимых процедур определения столбцов нельзя изменять, если это может повлиять на хранимую процедуру (исключением является удаление хранимой процедуры).

Собственный модуль должен использовать один большой [блок ATOMIC](/sql/relational-databases/in-memory-oltp/atomic-blocks-in-native-procedures) для управления транзакциями. Роли для явной транзакции BEGIN TRANSACTION или ROLLBACK TRANSACTION не существует. Если код обнаруживает нарушение бизнес-правила, он может завершить атомарный блок с помощью инструкции [THROW](/sql/t-sql/language-elements/throw-transact-sql) .

### <a name="typical-create-procedure-for-natively-compiled"></a>Стандартная инструкция CREATE PROCEDURE для создания скомпилированных в собственном коде процедур

Как правило, инструкция T-SQL для создания скомпилированной хранимой процедуры имеет следующий вид:

```sql
CREATE PROCEDURE schemaname.procedurename
    @param1 type1, …
    WITH NATIVE_COMPILATION, SCHEMABINDING
    AS
        BEGIN ATOMIC WITH
            (TRANSACTION ISOLATION LEVEL = SNAPSHOT,
            LANGUAGE = N'your_language__see_sys.languages'
            )
        …
        END;
```

* Для TRANSACTION_ISOLATION_LEVEL значение SNAPSHOT является наиболее распространенным при создании скомпилированной хранимой процедуры. Однако также поддерживается подмножество других значений:
  
  * REPEATABLE READ
  * SERIALIZABLE
* Значение LANGUAGE должно присутствовать в представлении sys.languages.

### <a name="how-to-migrate-a-stored-procedure"></a>Миграция хранимой процедуры

Этапы миграции

1. Получите скрипт CREATE PROCEDURE, чтобы создать интерпретируемую хранимую процедуру.
2. Перезапишите ее заголовок в соответствии с предыдущим шаблоном.
3. Убедитесь, используются ли в коде T-SQL хранимой процедуры функции, которые не поддерживаются для скомпилированных хранимых процедур. При необходимости устраните эту проблему.

   Дополнительные сведения см. в статье [Проблемы миграции, связанные с хранимыми процедурами, скомпилированными в собственном коде](/sql/relational-databases/in-memory-oltp/a-guide-to-query-processing-for-memory-optimized-tables).
4. С помощью SP_RENAME переименуйте старую хранимую процедуру. Или просто удалите ее с помощью DROP.
5. Запустите измененный сценарий T-SQL CREATE PROCEDURE.

## <a name="step-6-run-your-workload-in-test"></a>Шаг 6. Запуск рабочей нагрузки в тестовой среде

Запустите рабочую нагрузку в тестовой базе данных, как если бы это была рабочая нагрузка, запущенная в рабочей базе данных. Вы увидите, насколько выросла производительность таблиц и хранимых процедур при использовании компонента In-Memory.

Основные атрибуты рабочей нагрузки:

* количество одновременных подключений;
* отношение количества операций чтения и записи.

Чтобы адаптировать и запустить тестовую рабочую нагрузку, рассмотрите возможность использования удобного `ostress.exe` средства, которое проиллюстрировано в этой статье [в памяти](in-memory-oltp-overview.md) .

Чтобы свести к минимуму задержки в сети, выполняйте проверку в географическом регионе Azure, в котором расположена ваша база данных.

## <a name="step-7-post-implementation-monitoring"></a>Шаг 7. Мониторинг после реализации

Рассмотрите возможность отслеживания влияния, оказываемого компонентом In-Memory в рабочей среде.

* [Мониторинг In-Memoryного хранилища](in-memory-oltp-monitor-space.md).
* [Мониторинг с помощью динамических административных представлений](database/monitoring-with-dmvs.md)

## <a name="related-links"></a>Связанные ссылки

* [In-Memory OLTP (оптимизация в памяти)](/sql/relational-databases/in-memory-oltp/in-memory-oltp-in-memory-optimization)
* [Общие сведения о скомпилированных в собственном коде хранимых процедурах](/sql/relational-databases/in-memory-oltp/a-guide-to-query-processing-for-memory-optimized-tables)
* [Помощник по оптимизации памяти](/sql/relational-databases/in-memory-oltp/memory-optimization-advisor)
