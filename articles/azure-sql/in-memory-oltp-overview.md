---
title: Технологии, выполняющиеся в памяти
description: Технологии в памяти значительно улучшают производительность транзакционных и аналитических рабочих нагрузок в базе данных SQL Azure и Управляемый экземпляр Azure SQL.
services: sql-database
ms.service: sql-db-mi
ms.subservice: ''
ms.custom: sqldbrb=2
ms.devlang: ''
ms.topic: conceptual
author: stevestein
ms.author: sstein
ms.reviewer: ''
ms.date: 03/19/2019
ms.openlocfilehash: 48b74a5507eb4a1d48b7bf70133e476a30fe8169
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "92779957"
---
# <a name="optimize-performance-by-using-in-memory-technologies-in-azure-sql-database-and-azure-sql-managed-instance"></a>Оптимизация производительности с помощью технологий в памяти в базе данных SQL Azure и Azure SQL Управляемый экземпляр
[!INCLUDE[appliesto-sqldb-sqlmi](includes/appliesto-sqldb-sqlmi.md)]

Технологии в памяти позволяют повысить производительность приложения и, возможно, снизить затраты на базу данных.

## <a name="when-to-use-in-memory-technologies"></a>Когда следует использовать технологии в памяти

Используя технологии в памяти, можно повысить производительность с помощью различных рабочих нагрузок:

- **Транзакционные** (оперативная обработка транзакций, OLTP), где большая часть запросов касается чтения или обновления малых набор данных (например, операции CRUD).
- **Аналитические** (интерактивная аналитическая обработка, OLAP), где большинство запросов использует сложные вычисления для создания отчетов с определенным количеством запросов, которые загружают и добавляют данные в существующих таблицах (так называемая массовая загрузка) или удаляют данные из таблиц.
- **Смешанные** (гибридная транзакционная и аналитическая обработка, HTAP), где запросы OLTP и OLAP выполняются в одном наборе данных.

Технологии обработки в памяти могут повысить производительность этих рабочих нагрузок благодаря хранению обрабатываемых данных в памяти, с помощью собственной компиляции запросов или расширенной обработки, например пакетной обработки и инструкций SIMD, доступных на базовом оборудовании.

## <a name="overview"></a>Обзор

База данных SQL Azure и Azure SQL Управляемый экземпляр имеют следующие технологии в памяти:

- *[Выполняющаяся в памяти OLTP](/sql/relational-databases/in-memory-oltp/in-memory-oltp-in-memory-optimization)* повышает скорость выполнения транзакций и сокращает задержки при их обработке. Выполняющуюся в памяти OLTP полезно использовать в следующих сценариях: обработка транзакций с высокой пропускной способностью, например для торговли и игр, прием данных о событиях или устройствах Интернета вещей, кэширование, загрузка данных, использование временных таблиц и табличных переменных.
- *Кластеризованные индексы columnstore* снижают требования к вместимости хранилища (иногда до 10 раз) и повышают производительность запросов для отчетов и аналитики. Используйте их с таблицами фактов в киосках данных, чтобы разместить в базе больше данных и повысить ее производительность. Вы также можете использовать их с данными журналов в рабочей базе данных, чтобы архивировать и запрашивать в 10 раз больше данных.
- *Некластеризованные индексы columnstore* для гибридных сценариев транзакционной и аналитической обработки помогут вам получить информацию о параметрах бизнеса в режиме реального времени, напрямую запрашивая рабочую базу данных без необходимости выполнения ресурсоемких операций извлечения, преобразования и загрузки, а также без задержек при заполнении хранилища данных. Некластеризованные индексы columnstore позволяют быстро выполнять аналитические запросы к базе данных OLTP, практически не оказывая влияния на рабочую нагрузку.
- Использование *оптимизированных для памяти индексов columnstore* для HTAP позволит ускорить для одного набора данных *одновременно* и обработку транзакций, и выполнение аналитических запросов.

Индексы columnstore и выполняющаяся в памяти OLTP включены в выпуски SQL Server, начиная с версий 2012 и 2014 соответственно. База данных SQL Azure, Azure SQL Управляемый экземпляр и SQL Server используют одну и ту же реализацию технологий в памяти.

## <a name="benefits-of-in-memory-technology"></a>Преимущества технологии в памяти

Благодаря более эффективной обработке запросов и транзакций технологии в памяти также помогают снизить затраты. Вам не нужно переходить на более высокую ценовую категорию баз данных, чтобы добиться повышения производительности. В некоторых случаях вы даже можете уменьшить ценовую категорию, а также повысить производительность технологий, реализованных в памяти.

Вот несколько примеров того, как выполняющаяся в памяти OLTP помогла значительно улучшить показатели производительности:

- Используя выполняющуюся в памяти OLTP, [компания Quorum Business Solutions смогла вдвое увеличить свои рабочие нагрузки, при этом улучшив показатели DTU на 70 %](https://resources.quorumsoftware.com/case-studies/quorum-doubles-key-database-s-workload-while-lowering-dtu).
- В следующем видео демонстрируется значительное улучшение потребления ресурсов с помощью примера рабочей нагрузки: [видео в памяти OLTP](https://channel9.msdn.com/Shows/Data-Exposed/In-Memory-OTLP-in-Azure-SQL-DB). Дополнительные сведения см. в записи блога: [OLTP в памяти](https://azure.microsoft.com/blog/in-memory-oltp-in-azure-sql-database/)

> [!NOTE]  
> Технологии в памяти доступны на уровнях "Премиум" и "критически важный для бизнеса".

В следующем видео объясняется возможное увеличение производительности с помощью технологий в памяти. Помните, что фактическое увеличение производительности всегда зависит от многих факторов, включая характер рабочей нагрузки и свойства данных, схему доступа к базе данных и т. д.

> [!VIDEO https://channel9.msdn.com/Blogs/Azure/Azure-SQL-Database-In-Memory-Technologies/player]
>

В этой статье описываются аспекты In-Memory и индексов OLTP и columnstore, относящихся к базе данных SQL Azure и Управляемый экземпляр SQL Azure, а также включает примеры:

- Сначала мы рассмотрим, как эти технологии влияют на использование хранилища и ограничения размера данных.
- Вы узнаете, как правильно изменять ценовую категорию для баз данных, в которых используются эти технологии.
- Вы увидите два образца, иллюстрирующих использование In-Memory OLTP, а также индексов columnstore.

Дополнительные сведения о в памяти в SQL Server см. в следующих статьях:

- Статья [Общие сведения и сценарии использования](/sql/relational-databases/in-memory-oltp/overview-and-usage-scenarios) содержит ссылки на примеры реальных клиентов и сведения, необходимые для начала работы.
- [In-Memory OLTP (оптимизация в памяти)](/sql/relational-databases/in-memory-oltp/in-memory-oltp-in-memory-optimization)
- [Руководство по индексам columnstore](/sql/relational-databases/indexes/columnstore-indexes-overview)
- Гибридные сценарии транзакционной и аналитической обработки, которые также называются [операционной аналитикой в реальном времени](/sql/relational-databases/indexes/get-started-with-columnstore-for-real-time-operational-analytics).

## <a name="in-memory-oltp"></a>Выполняющаяся в памяти OLTP

Технология In-Memory OLTP обеспечивает чрезвычайно быстрые операции доступа к данным за счет хранения всех данных в памяти. Она также использует специализированные индексы, собственную компиляцию запросов и доступ к данным без защелок доступа для повышения производительности рабочей нагрузки OLTP. Существует два способа организации данных OLTP в памяти:

- Формат **оптимизированных для памяти rowstore**, где каждая строка представляет собой отдельный объект в памяти. Это классический формат OLTP в памяти, оптимизированный для высокой производительности рабочих нагрузок OLTP. Существует два типа таблиц, оптимизированных для памяти, которые могут использоваться в формате rowstore, оптимизированных для памяти.

  - *Устойчивые таблицы* (SCHEMA_AND_DATA), где строки, помещенные в память, сохраняются после перезапуска сервера. Этот тип таблицы ведет себя как стандартная таблица rowstore, но дает дополнительные преимущества оптимизации в памяти.
  - *Неустойчивые таблицы* (SCHEMA_ONLY), где строки не сохраняются после перезапуска. Этот тип таблицы предназначен для временных данных (например, замены временных таблиц) или таблиц, когда необходимо быстро загрузить данные, прежде чем переместить их в сохраненную таблицу (так называемые промежуточные таблицы).

- Формат **columnstore с оптимизацией памяти**, где данные организованы в виде столбцов. Эта структура предназначена для сценариев HTAP, где необходимо выполнять аналитические запросы над той же структурой данных, где выполняется рабочая нагрузка OLTP.

> [!Note]
> Технология OLTP в памяти предназначена для структур данных, которые могут полностью находиться в памяти. Так как данные в памяти невозможно выгрузить на диск, убедитесь, что вы используете базы данных с достаточным объемом памяти. См. раздел [Ограничения на объем данных и емкость хранилища для OLTP в памяти](#data-size-and-storage-cap-for-in-memory-oltp).

Краткое руководство по In-Memory OLTP: быстрый запуск [1. In-Memory технологии OLTP для повышения производительности T-SQL](/sql/relational-databases/in-memory-oltp/survey-of-initial-areas-in-in-memory-oltp) (другая статья поможет вам приступить к работе).

Подробные видеоролики об этих технологиях:

- Выполняющаяся [в памяти OLTP](https://channel9.msdn.com/Shows/Data-Exposed/In-Memory-OTLP-in-Azure-SQL-DB) (которая содержит демонстрацию преимуществ производительности и действий по самостоятельному воспроизведению этих результатов)
- [In-Memory OLTP Videos: What it is and When/How to use it](/archive/blogs/sqlserverstorageengine/in-memory-oltp-video-what-it-is-and-whenhow-to-use-it) (Видео про технологию In-Memory OLTP: что это такое, когда и как ее использовать).

Вы можете программным методом узнать, поддерживает ли база данных In-Memory OLTP. Для этого выполните следующий запрос Transact-SQL:

```sql
SELECT DatabasePropertyEx(DB_NAME(), 'IsXTPSupported');
```

Если запрос возвращает **1**, база данных поддерживает In-Memory OLTP. Следующие запросы указывают все объекты, которые необходимо удалить до перехода базы данных в общего назначения, Standard или Basic.

```sql
SELECT * FROM sys.tables WHERE is_memory_optimized=1
SELECT * FROM sys.table_types WHERE is_memory_optimized=1
SELECT * FROM sys.sql_modules WHERE uses_native_compilation=1
```

### <a name="data-size-and-storage-cap-for-in-memory-oltp"></a>Ограничения на объем данных и емкость хранилища для In-Memory OLTP

In-Memory OLTP включает оптимизированные для памяти таблицы, которые используются для хранения пользовательских данных. Эти таблицы должны умещаться в памяти. Так как вы управляете памятью непосредственно в базе данных SQL, у нас есть понятие квоты для пользовательских данных. или *хранилище выполняющейся в памяти OLTP*.

Каждая поддерживаемая ценовая категория отдельных баз данных и эластичных пулов включает некоторый объем хранилища выполняющейся в памяти OLTP.

- [Ограничения ресурсов на основе DTU — отдельная база данных](database/resource-limits-dtu-single-databases.md)
- [Ограничения ресурсов на основе DTU — эластичные пулы](database/resource-limits-dtu-elastic-pools.md)
- [Ограничения ресурсов для отдельной базы данных при использовании модели на основе виртуальных ядер](database/resource-limits-vcore-single-databases.md)
- [ограничения ресурсов на основе виртуальное ядро — эластичные пулы](database/resource-limits-vcore-elastic-pools.md)
- [ограничения ресурсов на основе виртуальное ядро — управляемый экземпляр](managed-instance/resource-limits.md)

При расчете емкости хранилища для выполняющейся в памяти OLTP используются следующие параметры.

- Активные строки пользовательских данных в оптимизированных для памяти таблицах и переменных таблиц. Обратите внимание, что старые версии строк не учитываются в объеме.
- Индексы оптимизированных для памяти таблиц.
- Операционные затраты на операции ALTER TABLE.

Когда ограничение будет достигнуто, вы получите ошибку с сообщением о том, что квота израсходована, и не сможете выполнять операции вставки и обновления данных. Чтобы устранить такую проблему, удалите часть данных или перейдите на более высокую ценовую категорию базы данных или пула.

Дополнительные сведения о мониторинге In-Memory использования хранилища OLTP и настройке оповещений при почти достижении ограничения см. [в разделе мониторинг хранилища в памяти](in-memory-oltp-monitor-space.md).

#### <a name="about-elastic-pools"></a>О пулах эластичных баз данных

При использовании пулов эластичных баз данных хранилище выполняющейся в памяти OLTP используется совместно всеми базами данных в пуле. Следовательно, используемый объем одной базы данных может повлиять на другие базы данных. Есть два пути устранения таких проблем.

- Установите для баз данных значение `Max-eDTU` или `MaxvCore` ниже, чем значение eDTU или число виртуальных ядер для пула в целом. Это новое ограничение eDTU на емкость хранилища выполняющейся в памяти OLTP будет действовать в отношении любой базы данных в пуле.
- Установите для баз данных значение `Min-eDTU` или `MinvCore` больше нуля. Это минимальное значение гарантирует, что каждая база данных в пуле получит определенный объем хранилища для выполняющейся в памяти OLTP в соответствии с указанным значением `Min-eDTU` или `vCore`.

### <a name="changing-service-tiers-of-databases-that-use-in-memory-oltp-technologies"></a>Изменение уровней служб баз данных, которые используют технологии OLTP в памяти

Вы всегда можете повысить базы данных или экземпляр до более высокого уровня, например от уровня общего назначения до критически важного для бизнеса (или с класса "Стандартный" до класса "Премиум"). Все доступные функции и ресурсы будут только расширяться.

Учтите, что понижение уровня может отрицательно повлиять на базу данных. Такое влияние при переходе от критически важного для бизнеса уровня до уровня общего назначения (или с класса "Премиум" на "Стандартный" или "Базовый") будет особенно заметно, если база данных содержит объекты выполняющейся в памяти OLTP. После понижения ценовой категории или уровня оптимизированные для памяти таблицы станут недоступными (даже если останутся видимыми). Те же рекомендации применяются при снижении ценовой категории эластичного пула или при перемещении базы данных с технологиями в памяти в пул эластичных БД общего назначения, Standard или Basic.

> [!Important]
> OLTP в памяти не поддерживается базами данных класса "Стандартный" или "Базовый". Таким образом, невозможно переместить базу данных, в которой есть In-Memory объекты OLTP на один из этих уровней.

Перед переходом на более раннюю версию базы данных до общего назначения, Standard или Basic удалите все оптимизированные для памяти таблицы и табличные типы, а также все модули, скомпилированные в собственном формате T-SQL.

*Масштабирование ресурсов на критически важный для бизнеса уровне*. данные в оптимизированных для памяти таблицах должны помещаться в хранилище OLTP In-Memory, связанном с уровнем базы данных или управляемого экземпляра, или в пуле эластичных БД. Если вы попытаетесь понизить уровень базы данных или переместить базу данных в пул, в котором нет достаточного объема хранилища выполняющейся в памяти OLTP, операция завершится ошибкой.

## <a name="in-memory-columnstore"></a>Технология columnstore в памяти

Технология columnstore в памяти позволяет хранить и запрашивать большой объем данных в таблицах. Она использует формат хранения по столбцам данных и пакетную обработку запросов, позволяя до 10 раз увеличить производительность запросов в рабочих нагрузках OLAP относительно традиционного хранилища, основанного на строках. Также, можно добиться 10-кратного сжатия данных относительно несжатых данных.
Существует два типа моделей columnstore, которые можно использовать для организации данных.

- **Кластеризованный индекс columnstore**, где все данные в таблице организованы в виде столбцов. В этой модели все строки в таблице помещаются в табличном формате, который существенно сжимает данные и допускает выполнение аналитических запросов и отчетов в таблице. В зависимости от характера данных снижение объема может составлять от 10x до 100x. Кластеризованный индекс columnstore также позволяет быстро принимать большие объемы данных (массовая загрузка), поскольку большие пакеты данных (больше 100 тысяч строк) сжимаются перед сохранением на диске. Эта модель хорошо подходит для сценариев данных классического хранилища.
- **Хранилище columnstore без кластеризации**, где данные хранятся в стандартной таблице rowstore, а также есть индекс в формате columnstore, который используется для аналитических запросов. Эта модель допускает гибридную транзакционную аналитическую обработку (HTAP): возможность запускать аналитику в реальном времени с высокой производительностью на транзакционной рабочей нагрузке. Запросы OLTP выполняются в таблице rowstore, которая оптимизирована для доступа к небольшому числу строк, тогда как запросы OLAP выполняются в индексе columnstore, который лучше подходит для сканирования и анализа. Оптимизатор запросов динамически выбирает формат rowstore или columnstore на основе запроса. Индексы columnstore, отличные от кластерных, не позволяют уменьшить объем данных, так как исходный набор данных хранится в исходной таблице rowstore без изменений. Тем не менее размер дополнительного индекса columnstore будет на порядок меньше, чем эквивалентный индекс сбалансированного дерева.

> [!Note]
> Технология columnstore в памяти сохраняет в памяти только данные, необходимые для обработки, храня данные, которые не помещаются в памяти, на диске. Таким образом, объем данных в структурах columnstore в памяти может превышать объем доступной памяти.

Подробные видеоролики об этих технологиях

- [Индекс columnstore: видео аналитики в памяти от Ignite 2016](/archive/blogs/sqlserverstorageengine/columnstore-index-in-memory-analytics-i-e-columnstore-index-videos-from-ignite-2016)

### <a name="data-size-and-storage-for-columnstore-indexes"></a>Размер данных и хранилище для индексов сolumnstore

Индексы сolumnstore не обязательно должны помещаться в памяти. Поэтому для размера индексов применяется только одно ограничение — на максимальный общий размер базы данных. См. подробнее о моделях приобретения на основе [единиц DTU](database/service-tiers-dtu.md) и [виртуальных ядер](database/service-tiers-vcore.md).

При использовании кластеризованных индексов сolumnstore для хранения базовых таблиц применяется сжатие по столбцам. Сжатие может значительно снизить объем хранимых пользовательских данных, позволяя разместить в базе данных больше информации. Этот эффект можно усилить, используя [архивное сжатие по столбцам](/sql/relational-databases/data-compression/data-compression#using-columnstore-and-columnstore-archive-compression). Степень сжатия, которой можно добиться, зависит от характера данных. Вполне можно достигнуть 10-кратного сжатия.

Например, если для базы данных установлен максимальный размер 1 терабайт (ТБ), а с помощью технологии columnstore удастся добиться 10-кратного сжатия, вы сможете хранить в этой базе данных 10 ТБ пользовательских данных.

При использовании некластеризованных индексов columnstore базовая таблица по-прежнему хранится в традиционном формате rowstore, Таким образом, экономия хранилища не так важна, как кластеризованные индексы columnstore. Но если вы при этом замените некоторое число традиционных некластеризованных индексов одним индексом columnstore, даже так вы заметите некоторое сокращение общего объема хранилища для этой таблицы.

### <a name="changing-service-tiers-of-databases-containing-columnstore-indexes"></a>Изменение уровней служб базы данных, содержащей индексы columnstore

*Понижение уровня отдельной базы данных до* уровня "базовый" или "Стандартный" может оказаться невозможным, если целевой уровень ниже S3. Индексы columnstore поддерживаются только в ценовой категории "Премиум" и "Критически важный для бизнеса" или "Стандартный" (S3 и выше), но не в ценовой категории "Базовый". При переходе базы данных на неподдерживаемую ценовую категорию или уровень, индексы columnstore становятся недоступными. Система сохранит ваш индекс columnstore, но не будет его использовать. Если вы позднее перейдете на поддерживаемую ценовую категорию или уровень, индекс columnstore будет немедленно готов к использованию.

Если у вас есть **кластеризованный** индекс columnstore, после понижения вся таблица станет недоступной. Поэтому корпорация Майкрософт рекомендует удалить все *кластеризованные* индексы columnstore перед переходом базы данных на неподдерживаемую ценовую категорию или уровень.

> [!Note]
> SQL Управляемый экземпляр поддерживает индексы columnstore на всех уровнях.

<a id="install_oltp_manuallink" name="install_oltp_manuallink"></a>

## <a name="next-steps"></a>Дальнейшие действия

- [Краткое руководство 1. Технологии выполнения OLTP в памяти для повышения производительности службы Transact-SQL](/sql/relational-databases/in-memory-oltp/survey-of-initial-areas-in-in-memory-oltp)
- [Повышение производительности приложений в базе данных SQL с помощью выполняющейся в памяти OLTP](in-memory-oltp-configure.md)
- [Мониторинг хранилища OLTP в памяти](in-memory-oltp-monitor-space.md)
- [Изучение компонентов, выполняющихся в памяти](in-memory-sample.md)

## <a name="additional-resources"></a>Дополнительные ресурсы

### <a name="deeper-information"></a>Подробные сведения

- Узнайте, как [Quorum удваивает ключевую рабочую нагрузку на базу данных при одновременном сокращении DTU на 70 % благодаря использованию In-Memory OLTP для базы данных SQL](https://customers.microsoft.com/story/quorum-doubles-key-databases-workload-while-lowering-dtu-with-sql-database)
- [Запись блога в памяти OLTP](https://azure.microsoft.com/blog/in-memory-oltp-in-azure-sql-database/)
- [Learn about In-Memory OLTP](/sql/relational-databases/in-memory-oltp/in-memory-oltp-in-memory-optimization) (Знакомство с In-Memory OLTP)
- [Руководство по индексам columnstore](/sql/relational-databases/indexes/columnstore-indexes-overview)
- [Начало работы с Columnstore для получения операционной аналитики в реальном времени](/sql/relational-databases/indexes/get-started-with-columnstore-for-real-time-operational-analytics)
- Технический документ с [рекомендациями по распространенным шаблонам рабочих нагрузок и миграции](/previous-versions/dn673538(v=msdn.10)) включает описание шаблонов рабочих нагрузок, для которых выполняющаяся OLTP обычно обеспечивает значительное повышение производительности.

### <a name="application-design"></a>Проектирование приложений

- [Выполняющаяся в памяти OLTP (оптимизация в памяти)](/sql/relational-databases/in-memory-oltp/in-memory-oltp-in-memory-optimization)
- [Повышение производительности приложений в базе данных SQL с помощью выполняющейся в памяти OLTP](in-memory-oltp-configure.md)

### <a name="tools"></a>Инструменты

- [Портал Azure](https://portal.azure.com/)
- [SQL Server Management Studio (SSMS)](/sql/ssms/download-sql-server-management-studio-ssms)
- [SQL Server Data Tools (SSDT)](/sql/ssdt/download-sql-server-data-tools-ssdt)