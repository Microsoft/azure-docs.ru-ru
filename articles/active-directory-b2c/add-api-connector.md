---
title: Добавление соединителей API в потоки пользователей (Предварительная версия)
description: Настройте соединитель API для использования в потоке пользователя.
services: active-directory-b2c
ms.service: active-directory
ms.subservice: B2C
ms.topic: how-to
ms.date: 10/15/2020
ms.author: mimart
author: msmimart
manager: celestedg
ms.custom: it-pro
ms.openlocfilehash: 59246c3739ad4de27e65641cc9d2154b33a6ee5e
ms.sourcegitcommit: 225e4b45844e845bc41d5c043587a61e6b6ce5ae
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/11/2021
ms.locfileid: "103008439"
---
# <a name="add-an-api-connector-to-a-sign-up-user-flow-preview"></a>Добавление соединителя API в пользовательский поток регистрации (Предварительная версия)

> [!IMPORTANT]
> Соединители API для регистрации — это общедоступная Предварительная версия функции Azure AD B2C. См. подробные сведения о [дополнительных условиях использования предварительных выпусков Microsoft Azure](https://azure.microsoft.com/support/legal/preview-supplemental-terms/).

Чтобы использовать [соединитель API](api-connectors-overview.md), сначала создайте соединитель API, а затем включите его в потоке пользователя.

## <a name="create-an-api-connector"></a>Создание соединителя API

1. Войдите на [портал Azure](https://portal.azure.com/).
2. В разделе **Службы Azure** выберите **Azure AD B2C**.
4. Выберите **соединители API (Предварительная версия)**, а затем выберите **новый соединитель API**.

   ![Добавить новый соединитель API](./media/add-api-connector/api-connector-new.png)

5. Укажите отображаемое имя для вызова. Например, **Проверьте сведения о пользователе**.
6. Укажите **URL-адрес конечной точки** для вызова API.
7. Выберите **тип проверки подлинности** и настройте сведения для проверки подлинности при вызове API. Сведения о защите API см. в разделе ниже.

    ![Настройка соединителя API](./media/add-api-connector/api-connector-config.png)

8. Щелкните **Сохранить**.

## <a name="securing-the-api-endpoint"></a>Защита конечной точки API
Вы можете защитить конечную точку API, используя обычную проверку подлинности HTTP или проверку подлинности сертификата клиента HTTPS (Предварительная версия). В любом случае вы предоставляете учетные данные, которые Azure AD B2C будут использоваться при вызове конечной точки API. Затем конечная точка API проверяет учетные данные и выполняет принятие решений об авторизации.

### <a name="http-basic-authentication"></a>Обычная аутентификация через HTTP
Обычная аутентификация через HTTP определяется стандартом [RFC 2617](https://tools.ietf.org/html/rfc2617). Azure AD B2C отправляет HTTP-запрос с учетными данными клиента ( `username` и `password` ) в `Authorization` заголовке. Учетные данные форматируются в виде строки в кодировке Base64 `username:password` . Затем API проверяет эти значения, чтобы определить, следует ли отклонять вызов API.

### <a name="https-client-certificate-authentication-preview"></a>Проверка подлинности сертификата клиента HTTPS (Предварительная версия)

> [!IMPORTANT]
> Эта функция доступна в режиме предварительной версии и предоставляется без соглашения об уровне обслуживания. Дополнительные сведения см. в статье [Дополнительные условия использования предварительных выпусков Microsoft Azure](https://azure.microsoft.com/support/legal/preview-supplemental-terms/).

Проверка подлинности с помощью сертификата клиента — это взаимная проверка подлинности на основе сертификата, при которой клиент предоставляет серверу сертификат клиента для подтверждения его личности. В этом случае Azure AD B2C будет использовать сертификат, который вы отправляете как часть конфигурации соединителя API. Это происходит в процессе приветствия SSL. Только службы, имеющие правильные сертификаты, могут получить доступ к службе REST API. Сертификат клиента — это цифровой сертификат X.509. В рабочих средах она должна быть подписана центром сертификации. 


Чтобы создать сертификат, можно использовать [Azure Key Vault](../key-vault/certificates/create-certificate.md), который содержит параметры для самозаверяющих сертификатов и интеграции с поставщиками сертификатов для подписанных сертификатов. Затем можно [экспортировать сертификат](../key-vault/certificates/how-to-export-certificate.md) и передать его для использования в конфигурации соединителей API. Обратите внимание, что пароль требуется только для файлов сертификатов, защищенных паролем. Для создания самозаверяющего сертификата можно также использовать [командлет New-SelfSignedCertificate](./secure-rest-api.md#prepare-a-self-signed-certificate-optional) PowerShell.

Сведения о том, как включить и проверить сертификат из конечной точки API, см. в статье [Настройка взаимной проверки подлинности TLS](../app-service/app-service-web-configure-tls-mutual-auth.md) для службы приложений Azure и функций Azure.

Рекомендуется установить напоминания о том, когда истечет срок действия сертификата. Чтобы отправить новый сертификат в существующий соединитель API, выберите соединитель API в разделе **соединители API (Предварительная версия)** и щелкните **отправить новый сертификат**. Последний отправленный сертификат, срок действия которого не истек, и Дата последнего запуска будут автоматически использоваться Azure AD B2C.

### <a name="api-key"></a>Ключ API
Некоторые службы используют механизм "ключ API" для маскировки доступа к конечным точкам HTTP во время разработки. Для [функций Azure](../azure-functions/functions-bindings-http-webhook-trigger.md#authorization-keys)это можно сделать, включив `code` параметр AS в качестве параметра запроса в **URL-адрес конечной точки**. Например, `https://contoso.azurewebsites.net/api/endpoint` <b>`?code=0123456789`</b> ). 

Это не механизм, который следует использовать в рабочей среде отдельно. Таким образом, всегда требуется настройка для проверки подлинности Basic или Certificate. Если вы не хотите реализовывать какой-либо метод проверки подлинности (не рекомендуется) для целей разработки, можно выбрать обычную проверку подлинности и использовать временные значения для `username` и `password` что ваш API может игнорироваться во время реализации авторизации в API.

## <a name="the-request-sent-to-your-api"></a>Запрос, отправленный в API
Соединитель API материализации как запрос **HTTP POST** , отправляющий атрибуты пользователя ("Claims") в качестве пар "ключ-значение" в теле JSON. Атрибуты сериализуются аналогично [Microsoft Graph](/graph/api/resources/user#properties) свойства пользователя. 

**Пример запроса**
```http
POST <API-endpoint>
Content-type: application/json

{
 "email": "johnsmith@fabrikam.onmicrosoft.com",
 "identities": [
     {
     "signInType":"federated",
     "issuer":"facebook.com",
     "issuerAssignedId":"0123456789"
     }
 ],
 "displayName": "John Smith",
 "givenName":"John",
 "surname":"Smith",
 "jobTitle":"Supplier",
 "streetAddress":"1000 Microsoft Way",
 "city":"Seattle",
 "postalCode": "12345",
 "state":"Washington",
 "country":"United States",
 "extension_<extensions-app-id>_CustomAttribute1": "custom attribute value",
 "extension_<extensions-app-id>_CustomAttribute2": "custom attribute value",
 "ui_locales":"en-US"
}
```

В запросе могут быть отправлены только свойства пользователя и настраиваемые атрибуты, перечисленные в  >  **пользовательском** интерфейсе Azure AD B2C атрибуты.

Пользовательские атрибуты существуют в **extension_ формате \<extensions-app-id> _CustomAttribute**  в каталоге. API должен рассчитывать на получение утверждений в том же сериализованном формате. Дополнительные сведения о настраиваемых атрибутах см. [в разделе Определение настраиваемых атрибутов в Azure AD B2C](user-flow-custom-attributes.md).

Кроме того, утверждение **национальных настроек пользовательского интерфейса ("ui_locales")** отправляется по умолчанию во все запросы. Он предоставляет языковые стандарты пользователя, настроенные на устройстве, которые могут использоваться API для возврата международных ответов.

> [!IMPORTANT]
> Если у утверждения нет значения во время вызова конечной точки API, утверждение не будет отправлено в API. Ваш API должен быть спроектирован таким образом, чтобы явно проверять и обрабатывать случай, когда утверждение не находится в запросе.

> [!TIP] 
> [**идентификаторы ("удостоверения")**](/graph/api/resources/objectidentity) и **адреса электронной почты ("Электронная почта")** могут использоваться API для идентификации пользователя, прежде чем они будут иметь учетную запись в клиенте. 

## <a name="enable-the-api-connector-in-a-user-flow"></a>Включение соединителя API в потоке пользователя

Выполните следующие действия, чтобы добавить соединитель API в поток пользователя регистрации.

1. Войдите на [портал Azure](https://portal.azure.com/).
2. В разделе **Службы Azure** выберите **Azure AD B2C**.
4. Выберите последовательности **пользователей**, а затем выберите пользовательский поток, к которому нужно добавить соединитель API.
5. Выберите **соединители API**, а затем выберите конечные точки API, которые нужно вызвать, на следующих шагах в потоке пользователя:

   - **После входа с помощью поставщика удостоверений**
   - **Перед созданием пользователя**

   ![Добавление API в поток пользователя](./media/add-api-connector/api-connectors-user-flow-select.png)

6. Щелкните **Сохранить**.

## <a name="after-signing-in-with-an-identity-provider"></a>После входа с помощью поставщика удостоверений

Соединитель API на этом этапе в процессе регистрации вызывается сразу после проверки подлинности пользователя с помощью поставщика удостоверений (например, Google, Facebook, & Azure AD). Этот шаг предшествует ***странице Коллекция атрибутов***, которая является формой, представленной пользователю для сбора атрибутов пользователя. Этот шаг не вызывается, если пользователь регистрируется с помощью локальной учетной записи.

### <a name="example-request-sent-to-the-api-at-this-step"></a>Пример запроса, отправленного в API на этом шаге
```http
POST <API-endpoint>
Content-type: application/json

{
 "email": "johnsmith@fabrikam.onmicrosoft.com",
 "identities": [ 
     {
     "signInType":"federated",
     "issuer":"facebook.com",
     "issuerAssignedId":"0123456789"
     }
 ],
 "displayName": "John Smith",
 "givenName":"John",
 "lastName":"Smith",
 "ui_locales":"en-US"
}
```

Точные утверждения, отправляемые в API, зависят от того, какие сведения предоставляются поставщиком удостоверений. "Электронная почта" всегда отправляется.

### <a name="expected-response-types-from-the-web-api-at-this-step"></a>Ожидаемые типы ответов из веб-API на этом шаге

Когда веб-API получает запрос HTTP от Azure AD во время потока пользователя, он может вернуть следующие ответы:

- Ответ продолжения
- Блокирующий ответ

#### <a name="continuation-response"></a>Ответ продолжения

Ответ на продолжение указывает на то, что поток пользователя переходит к следующему шагу: странице Коллекция атрибутов.

В ответе на продолжение API может возвращать утверждения. Если в API возвращается утверждение, утверждение выполняет следующие действия:

- Предварительно заполняет поле ввода на странице Коллекция атрибутов.

См. Пример ответа на [продолжение](#example-of-a-continuation-response).

#### <a name="blocking-response"></a>Блокирующий ответ

Блокирующий ответ завершает поток пользователя. Он может быть специально выдан API-интерфейсом для прекращения продолжения работы потока пользователя путем отображения страницы блокировки для пользователя. На странице Block отображается `userMessage` предоставленный API-интерфейс.

См. пример [блокирующего ответа](#example-of-a-blocking-response).

## <a name="before-creating-the-user"></a>Перед созданием пользователя

Соединитель API на этом этапе в процессе регистрации вызывается после страницы коллекции атрибутов, если она включена. Этот шаг всегда вызывается перед созданием учетной записи пользователя.

### <a name="example-request-sent-to-the-api-at-this-step"></a>Пример запроса, отправленного в API на этом шаге

```http
POST <API-endpoint>
Content-type: application/json

{
 "email": "johnsmith@fabrikam.onmicrosoft.com",
 "identities": [
     {
     "signInType":"federated",
     "issuer":"facebook.com",
     "issuerAssignedId":"0123456789"
     }
 ],
 "displayName": "John Smith",
 "givenName":"John",
 "surname":"Smith",
 "jobTitle":"Supplier",
 "streetAddress":"1000 Microsoft Way",
 "city":"Seattle",
 "postalCode": "12345",
 "state":"Washington",
 "country":"United States",
 "extension_<extensions-app-id>_CustomAttribute1": "custom attribute value",
 "extension_<extensions-app-id>_CustomAttribute2": "custom attribute value",
 "ui_locales":"en-US"
}
```
Точные утверждения, отправляемые в API, зависят от того, какие сведения собираются от пользователя или предоставлены поставщиком удостоверений.

### <a name="expected-response-types-from-the-web-api-at-this-step"></a>Ожидаемые типы ответов из веб-API на этом шаге

Когда веб-API получает запрос HTTP от Azure AD во время потока пользователя, он может вернуть следующие ответы:

- Ответ продолжения
- Блокирующий ответ
- Ответ на проверку

#### <a name="continuation-response"></a>Ответ продолжения

Ответ на продолжение указывает, что поток пользователя должен перейти к следующему шагу: Создайте пользователя в каталоге.

В ответе на продолжение API может возвращать утверждения. Если в API возвращается утверждение, утверждение выполняет следующие действия:

- Переопределяет любое значение, которое уже было присвоено утверждению на странице Коллекция атрибутов.

См. Пример ответа на [продолжение](#example-of-a-continuation-response).

#### <a name="blocking-response"></a>Блокирующий ответ
Блокирующий ответ завершает поток пользователя. Он может быть специально выдан API-интерфейсом для прекращения продолжения работы потока пользователя путем отображения страницы блокировки для пользователя. На странице Block отображается `userMessage` предоставленный API-интерфейс.

См. пример [блокирующего ответа](#example-of-a-blocking-response).

### <a name="validation-error-response"></a>Проверка-ошибка при отклике
 Когда API отвечает на ответ проверки на ошибку, поток пользователя остается на странице Коллекция атрибутов, а `userMessage` пользователь отображается пользователю. Пользователь может изменить и повторно отправить форму. Этот тип ответа можно использовать для проверки входных данных.

См. Пример ответа на [ошибку проверки](#example-of-a-validation-error-response).

## <a name="example-responses"></a>Примеры ответов

### <a name="example-of-a-continuation-response"></a>Пример ответа продолжения

```http
HTTP/1.1 200 OK
Content-type: application/json

{
    "version": "1.0.0",
    "action": "Continue",
    "postalCode": "12349", // return claim
    "extension_<extensions-app-id>_CustomAttribute": "value" // return claim
}
```

| Параметр                                          | Тип              | Обязательно | Описание                                                                                                                                                                                                                                                                            |
| -------------------------------------------------- | ----------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| action                                             | Строка            | Да      | Необходимое значение: `Continue`.                                                                                                                                                                                                                                                              |
| \<builtInUserAttribute>                            | \<attribute-type> | Нет       | Возвращаемые значения могут перезаписывать значения, собранные от пользователя. Они также могут возвращаться в токене, если выбрано в качестве **утверждения приложения**.                                              |
| \<extension\_{extensions-app-id}\_CustomAttribute> | \<attribute-type> | Нет       | Утверждение не обязательно должно содержать `_<extensions-app-id>_` . Возвращаемые значения могут перезаписывать значения, собранные от пользователя. Они также могут возвращаться в токене, если выбрано в качестве **утверждения приложения**.  |

### <a name="example-of-a-blocking-response"></a>Пример блокирующего ответа

```http
HTTP/1.1 200 OK
Content-type: application/json

{
    "version": "1.0.0",
    "action": "ShowBlockPage",
    "userMessage": "There was a problem with your request. You are not able to sign up at this time.",
}

```

| Параметр   | Тип   | Обязательно | Описание                                                                |
| ----------- | ------ | -------- | -------------------------------------------------------------------------- |
| version     | Строка | Да      | Версия API.                                                    |
| action      | Строка | Да      | Значение должно быть `ShowBlockPage`                                              |
| userMessage | Строка | Да      | Сообщение, отображаемое для пользователя.                                            |

**Взаимодействие с конечным пользователем с блокирующим ответом**

![Пример блокировки страницы](./media/add-api-connector/blocking-page-response.png)

### <a name="example-of-a-validation-error-response"></a>Пример ответа на ошибку проверки

```http
HTTP/1.1 400 Bad Request
Content-type: application/json

{
    "version": "1.0.0",
    "status": 400,
    "action": "ValidationError",
    "userMessage": "Please enter a valid Postal Code."
}
```

| Параметр   | Тип    | Обязательно | Описание                                                                |
| ----------- | ------- | -------- | -------------------------------------------------------------------------- |
| version     | Строка  | Да      | Версия API.                                                    |
| action      | Строка  | Да      | Необходимое значение: `ValidationError`.                                           |
| status      | Целое число | Да      | `400`Для ответа ValidationError должно быть значение.                        |
| userMessage | Строка  | Да      | Сообщение, отображаемое для пользователя.                                            |

> [!NOTE]
> Код состояния HTTP должен быть "400" в дополнение к значению "Status" в тексте ответа.

**Взаимодействие с пользователем при проверке — ошибка проверки**

![Страница "пример проверки"](./media/add-api-connector/validation-error-postal-code.png)


## <a name="best-practices-and-how-to-troubleshoot"></a>Рекомендации и устранение неполадок

### <a name="using-serverless-cloud-functions"></a>Использование безсерверных облачных функций
Бессерверные функции, такие как триггеры HTTP в функциях Azure, предоставляют простой способ создания конечных точек API для использования с соединителем API. Вы можете использовать бессерверную облачную функцию, [например](code-samples.md#api-connectors), выполнить логику проверки и ограничить число входов конкретными доменами электронной почты. Бессерверная облачная функция также может вызывать и вызывать другие веб-API, хранилища пользователей и другие облачные службы для более сложных сценариев.

### <a name="best-practices"></a>Рекомендации
Убедитесь в следующем:
* API-интерфейс следует за контрактами запросов и ответов API, как описано выше. 
* **URL-адрес конечной точки** соединителя API указывает на правильную конечную точку API.
* API явным образом проверяет значения NULL полученных утверждений.
* API реагирует как можно быстрее, чтобы обеспечить работу пользователей в гибком виде.
    * Если используется бессерверная функция или Масштабируемая веб-служба, используйте план размещения, который поддерживает API "спящий" или "тепло". в рабочей среде. Для функций Azure рекомендуется использовать [план Premium](../azure-functions/functions-scale.md) .
 

### <a name="use-logging"></a>Использовать ведение журнала
Как правило, полезно использовать средства ведения журнала, включенные службой веб-API, например [Application Insights](../azure-functions/functions-monitoring.md), для мониторинга API с непредвиденными кодами ошибок, исключениями и низкой производительностью.
* Отслеживать коды состояния HTTP, которые не являются HTTP 200 или 400.
* Код состояния HTTP 401 или 403, как правило, указывает на наличие проблемы с проверкой подлинности. Дважды проверьте уровень проверки подлинности API и соответствующую конфигурацию в соединителе API.
* При необходимости используйте более агрессивные уровни ведения журнала (например, "Трассировка" или "Отладка") в разработке.
* Отслеживайте долгое время ответа API.

## <a name="next-steps"></a>Дальнейшие действия
- Начните работу с нашими [примерами](code-samples.md#api-connectors).
