---
title: Преобразование "Уточняющий запрос" в потоке данных для сопоставления
description: Ссылайтесь на данные из другого источника с помощью преобразования "Уточняющий запрос" в потоке данных сопоставления.
author: kromerm
ms.reviewer: daperlov
ms.author: makromer
ms.service: data-factory
ms.topic: conceptual
ms.custom: seo-lt-2019
ms.date: 02/19/2021
ms.openlocfilehash: b8754742c572a8dbc1f55c64e47bec640d757d65
ms.sourcegitcommit: c27a20b278f2ac758447418ea4c8c61e27927d6a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/03/2021
ms.locfileid: "101739374"
---
# <a name="lookup-transformation-in-mapping-data-flow"></a>Преобразование "Уточняющий запрос" в потоке данных для сопоставления

[!INCLUDE[appliesto-adf-asa-md](includes/appliesto-adf-asa-md.md)]

Преобразование "Уточняющий запрос" используется для ссылки на данные из другого источника в потоке данных. Преобразование "Уточняющий запрос" добавляет столбцы из сопоставленных данных в исходные данные.

Преобразование "Уточняющий запрос" похоже на левое внешнее соединение. Все строки из основного потока будут существовать в выходном потоке с дополнительными столбцами из потока уточняющего запроса.

> [!VIDEO https://www.microsoft.com/en-us/videoplayer/embed/RE4xsVT]

## <a name="configuration"></a>Конфигурация

![На снимке экрана показана вкладка параметры подстановки с метками, описанными в следующем тексте.](media/data-flow/lookup1.png "Поиск")

**Основной поток:** входящий поток данных. Этот поток эквивалентен левой стороне соединения.

**Поток уточняющего запроса:** данные, добавляемые в основной поток. Добавляемые данные определяются условиями уточняющего запроса. Этот поток эквивалентен правой стороне соединения.

**Сопоставление нескольких строк:** если этот параметр включен, строка с несколькими совпадениями в первичном потоке вернет несколько строк. В противном случае будет возвращена только одна строка, основанная на условии "Сопоставлять на".

**Сопоставлять на:** отображается, только если не выбрано "Сопоставлять несколько строк". Выберите, следует ли выполнять поиск по любой строке, по первому совпадению или по последнему совпадению. Рекомендуется поиск по любой строке, так как он выполняется быстрее всего. Если выбрана первая строка или последняя строка, потребуется указать условия сортировки.

**Условия уточняющего запроса:** выберите столбцы, по которым следует выполнять поиск. Если условие равенства выполнено, строки будут считаться совпадениями. Наведите указатель мыши на пункт "Вычисляемый столбец", чтобы извлечь значение с помощью [языка выражений потока данных](data-flow-expression-functions.md).

В выходные данные включаются все столбцы из обоих потоков. Чтобы удалить дублирующиеся или ненужные столбцы, добавьте [преобразование "Выбор"](data-flow-select.md) после преобразования "Уточняющий запрос". Столбцы также могут быть удалены или переименованы в преобразовании приемника.

### <a name="non-equi-joins"></a>Неэквивалентные соединения

Чтобы использовать условный оператор, например not equals (не равно, !=) или greater than (больше чем, >) в условиях уточняющего запроса, измените раскрывающийся список операторов между двумя столбцами. Для неэквивалентных соединений требуется широковещательная рассылка по крайней мере одного из двух потоков с помощью **Фиксированного** вещания на вкладке **Оптимизация**.

![Неэквивалентный уточняющий запрос](media/data-flow/non-equi-lookup.png "Неэквивалентный уточняющий запрос")

## <a name="analyzing-matched-rows"></a>Анализ сопоставленных строк

После преобразования "Уточняющий запрос" функция `isMatch()` может использоваться для проверки соответствия уточняющего запроса отдельным строкам.

![Шаблон уточняющего запроса](media/data-flow/lookup111.png "Шаблон уточняющего запроса")

Примером такого шаблона является использование преобразования "Условное разбиение" для разбиения по функции `isMatch()`. В приведенном выше примере совпадающие строки проходят через верхний поток, а несовпадающие строки — через поток ```NoMatch```.

## <a name="testing-lookup-conditions"></a>Проверка условий уточняющего запроса

При тестировании преобразования "Уточняющий запрос" с предварительным просмотром данных в режиме отладки используйте небольшой набор известных данных. При выборке строк из большого набора данных нельзя предсказать, какие строки и ключи будут считываться для тестирования. Результат является недетерминированным, то есть условия соединения могут и не возвратить совпадений.

## <a name="broadcast-optimization"></a>Оптимизация вещания

![Широковещательное соединение](media/data-flow/broadcast.png "Широковещательное соединение")

При преобразованиях "Соединения", "Уточняющие запросы" и "Существование", если один или оба потока данных помещаются в память рабочего узла, можно оптимизировать производительность, включив **Трансляцию**. По умолчанию механизм Spark автоматически решает, следует ли транслировать одну сторону. Чтобы вручную выбрать сторону для трансляции, выберите **Фиксированные**.

Не рекомендуется отключать широковещательную трансляцию с помощью параметра **Выкл.** , пока соединения не столкнутся с ошибками времени ожидания.

## <a name="cached-lookup"></a>Кэшированный поиск

Если вы выполняете несколько небольших уточняющих запросов в одном источнике, кэшированный приемник и поиск, возможно, лучше использовать, чем преобразование «Уточняющий запрос». Распространенными примерами, в которых приемник кэша может быть лучше, является поиск максимального значения в хранилище данных и сопоставление кодов ошибок с базой данных сообщений об ошибках. Дополнительные сведения см. в статье о [приемниках кэша](data-flow-sink.md#cache-sink) и [кэшированных уточняющих запросах](concepts-data-flow-expression-builder.md#cached-lookup).

## <a name="data-flow-script"></a>Скрипт потока данных

### <a name="syntax"></a>Синтаксис

```
<leftStream>, <rightStream>
    lookup(
        <lookupConditionExpression>,
        multiple: { true | false },
        pickup: { 'first' | 'last' | 'any' },  ## Only required if false is selected for multiple
        { desc | asc }( <sortColumn>, { true | false }), ## Only required if 'first' or 'last' is selected. true/false determines whether to put nulls first
        broadcast: { 'auto' | 'left' | 'right' | 'both' | 'off' }
    ) ~> <lookupTransformationName>
```
### <a name="example"></a>Пример

![На снимке экрана показана вкладка параметры подстановки для следующего кода.](media/data-flow/lookup-dsl-example.png "Поиск")

Сценарий потока данных для приведенной выше конфигурации уточняющего запроса находится в следующем фрагменте кода.

```
SQLProducts, DimProd lookup(ProductID == ProductKey,
    multiple: false,
    pickup: 'first',
    asc(ProductKey, true),
    broadcast: 'auto')~> LookupKeys
```
## 
Дальнейшие действия

* Преобразования [Соединение](data-flow-join.md) и [Существует](data-flow-exists.md) принимают несколько входных потоков.
* Используйте [преобразование "Условное разбиение"](data-flow-conditional-split.md) с ```isMatch()```, чтобы разбить строки на совпадающие и несовпадающие значения.
