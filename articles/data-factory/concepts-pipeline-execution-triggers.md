---
title: Выполнение конвейера и триггеры в фабрике данных Azure
description: В этой статье объясняется, как выполнить конвейер в фабрике данных Azure по запросу или путем создания триггера.
author: dcstwh
ms.author: weetok
ms.reviewer: jburchel
ms.service: data-factory
ms.topic: conceptual
ms.date: 07/05/2018
ms.openlocfilehash: 271dbd87950018cebbd23841d32324afa42511e7
ms.sourcegitcommit: f611b3f57027a21f7b229edf8a5b4f4c75f76331
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2021
ms.locfileid: "104785807"
---
# <a name="pipeline-execution-and-triggers-in-azure-data-factory"></a>Выполнение конвейера и триггеры в фабрике данных Azure

> [!div class="op_single_selector" title1="Выберите версию службы "Фабрика данных", которую вы используете:"]
> * [Версия 1](v1/data-factory-scheduling-and-execution.md)
> * [Текущая версия](concepts-pipeline-execution-triggers.md)
[!INCLUDE[appliesto-adf-asa-md](includes/appliesto-adf-asa-md.md)]

_Запуск конвейера_ в службе "Фабрика данных Azure" определяет экземпляр выполнения конвейера. Например, у вас есть конвейер, который выполняется в 8:00, 09:00 и 10:00. В этом случае выполняются три отдельных запуска конвейера или конвейера. Для каждого запуска конвейера предусмотрен уникальный идентификатор. Идентификатор запуска представляет собой уникальный идентификатор GUID, который определяет запуск определенного конвейера.

Запуск конвейера обычно создается путем передачи аргументов в параметры, определенные в конвейерах. Конвейер можно выполнить двумя способами: вручную или с помощью _триггера_. Эта статья подробно описывает оба способа.

## <a name="manual-execution-on-demand"></a>Выполнение вручную (по запросу)

Выполнение конвейера вручную также называется выполнением _по требованию_.

Предположим, у вас есть базовый конвейер с именем **copyPipeline**, который вы хотите выполнить. Это конвейер с одним действием, которое копирует данные из папки источника, расположенной в хранилище BLOB-объектов Azure, в папку приемника в том же хранилище. В следующем определении JSON показан этот пример конвейера:

```json
{
    "name": "copyPipeline",
    "properties": {
        "activities": [
            {
                "type": "Copy",
                "typeProperties": {
                    "source": {
                        "type": "BlobSource"
                    },
                    "sink": {
                        "type": "BlobSink"
                    }
                },
                "name": "CopyBlobtoBlob",
                "inputs": [
                    {
                        "referenceName": "sourceBlobDataset",
                        "type": "DatasetReference"
                    }
                ],
                "outputs": [
                    {
                        "referenceName": "sinkBlobDataset",
                        "type": "DatasetReference"
                    }
                ]
            }
        ],
        "parameters": {
            "sourceBlobContainer": {
                "type": "String"
            },
            "sinkBlobContainer": {
                "type": "String"
            }
        }
    }
}
```

В определении JSON этот конвейер принимает два параметра: **sourceBlobContainer** и **sinkBlobContainer**. Значения этих параметров передаются во время выполнения.

Вы можете вручную запустить свой конвейер, используя один из методов ниже:
- Пакет SDK для .NET
- модуль Azure PowerShell;
- REST API
- Пакет SDK для Python

### <a name="rest-api"></a>REST API

В приведенном ниже примере команды показано, как запустить конвейер с помощью REST API вручную.

```
POST
https://management.azure.com/subscriptions/mySubId/resourceGroups/myResourceGroup/providers/Microsoft.DataFactory/factories/myDataFactory/pipelines/copyPipeline/createRun?api-version=2017-03-01-preview
```

Полный пример см. в статье [Создание фабрики данных Azure и конвейера с помощью REST API](quickstart-create-data-factory-rest-api.md).

### <a name="azure-powershell"></a>Azure PowerShell

[!INCLUDE [updated-for-az](../../includes/updated-for-az.md)]

В следующем примере команды показано, как запустить конвейер вручную с помощью Azure PowerShell:

```powershell
Invoke-AzDataFactoryV2Pipeline -DataFactory $df -PipelineName "Adfv2QuickStartPipeline" -ParameterFile .\PipelineParameters.json
```

Параметры передаются в тексте полезных данных запроса. В пакетах SDK для .NET, Azure PowerShell и Python можно передавать значения в словарь, который передается в качестве аргумента вызова:

```json
{
  "sourceBlobContainer": "MySourceFolder",
  "sinkBlobContainer": "MySinkFolder"
}
```

Полезные данные ответа содержат уникальный идентификатор запуска конвейера.

```json
{
  "runId": "0448d45a-a0bd-23f3-90a5-bfeea9264aed"
}
```

Полный пример см. в статье [Создание фабрики данных Azure с помощью PowerShell](quickstart-create-data-factory-powershell.md).

### <a name="net-sdk"></a>Пакет SDK для .NET

В следующем примере вызова показано, как запустить конвейер с помощью пакета SDK для .NET вручную.

```csharp
client.Pipelines.CreateRunWithHttpMessagesAsync(resourceGroup, dataFactoryName, pipelineName, parameters)
```

Полный пример см. в статье [Создание фабрики данных и конвейера с помощью пакета SDK .NET](quickstart-create-data-factory-dot-net.md).

> [!NOTE]
> Пакет SDK для .NET можно использовать для вызова конвейеров фабрики данных из функций Azure, из веб-служб и т. д.

## <a name="trigger-execution"></a>Выполнение триггера

Триггеры — это еще один способ выполнить запуск конвейера. Триггеры обозначает единицу обработки, которая определяет время запуска для выполнения конвейера. Сейчас службы "Фабрика данных" поддерживает три типа триггеров:

- Триггер планировщика. Триггер, который запускает конвейер в определенное время по расписанию.

- Триггер "переворачивающегося" окна. Триггер, который работает на основе периодических интервалов, сохраняя состояние.

- Триггер на основе событий: триггер, который реагирует на событие.

Конвейеры и триггеры имеют связь «многие ко многим» (за исключением триггера окна "переворачивающегося"). Несколько триггеров могут запускать один конвейер, или один триггер может запускать несколько конвейеров. В следующем определении триггера свойство **конвейеры** ссылается на список конвейеров, запускаемых определенным триггером. Определение свойства содержит значения для параметров конвейера.
### <a name="basic-trigger-definition"></a>Базовое определение триггера

```json
{
    "properties": {
        "name": "MyTrigger",
        "type": "<type of trigger>",
        "typeProperties": {...},
        "pipelines": [
            {
                "pipelineReference": {
                    "type": "PipelineReference",
                    "referenceName": "<Name of your pipeline>"
                },
                "parameters": {
                    "<parameter 1 Name>": {
                        "type": "Expression",
                        "value": "<parameter 1 Value>"
                    },
                    "<parameter 2 Name>": "<parameter 2 Value>"
                }
            }
        ]
    }
}
```

## <a name="schedule-trigger"></a>Триггер планировщика
Триггер планировщика запускает конвейер в определенное время по расписанию. Этот триггер поддерживает периодичность и расширенные возможности календаря. Например, триггер поддерживает такие интервалы, как "еженедельно" или "каждую неделю, в 17:00 по понедельникам и в 21:00 по четвергам". Триггер планировщика гибкий, так как шаблон набора данных не важен, а триггер не различает данные временных рядов и данные, не относящиеся к временным рядам.

Дополнительные сведения о триггерах расписания и, например, см. в разделе [Создание триггера, который запускает конвейер по расписанию](how-to-create-schedule-trigger.md).

## <a name="schedule-trigger-definition"></a>Определение триггера планировщика
При создании триггера планировщика нужно указать расписание и повторения с помощью определения JSON.

Чтобы триггер планировщика выполнял конвейер, включите в определении триггера ссылку на нужный конвейер. Конвейеры и триггеры имеют связь "многие ко многим". Несколько триггеров могут запускать один конвейер. Один триггер может запускать несколько конвейеров.

```json
{
  "properties": {
    "type": "ScheduleTrigger",
    "typeProperties": {
      "recurrence": {
        "frequency": <<Minute, Hour, Day, Week, Year>>,
        "interval": <<int>>, // How often to fire
        "startTime": <<datetime>>,
        "endTime": <<datetime>>,
        "timeZone": "UTC",
        "schedule": { // Optional (advanced scheduling specifics)
          "hours": [<<0-24>>],
          "weekDays": [<<Monday-Sunday>>],
          "minutes": [<<0-60>>],
          "monthDays": [<<1-31>>],
          "monthlyOccurrences": [
            {
              "day": <<Monday-Sunday>>,
              "occurrence": <<1-5>>
            }
          ]
        }
      }
    },
  "pipelines": [
    {
      "pipelineReference": {
        "type": "PipelineReference",
        "referenceName": "<Name of your pipeline>"
      },
      "parameters": {
        "<parameter 1 Name>": {
          "type": "Expression",
          "value": "<parameter 1 Value>"
        },
        "<parameter 2 Name>": "<parameter 2 Value>"
      }
    }
  ]}
}
```

> [!IMPORTANT]
> Свойство **parameters** является обязательным свойством для элемента **pipelines**. Если конвейер не принимает никаких параметров, необходимо включить пустое определение JSON для свойства **parameters**.

### <a name="schema-overview"></a>Общие сведения о схеме
Таблица ниже содержит обзор основных элементов схемы, связанных с периодичностью выполнения и расписанием триггера:

| Свойство JSON | Описание |
| --- | --- |
| **startTime** | Значение даты и времени. Для базовых расписаний значение свойства **startTime** применяется к первому выполнению. В сложных расписаниях триггер не запускается раньше, чем определяется значением **startTime**. |
| **Завершения** | Дата и время завершения триггера. После указанной даты и времени триггер перестает выполняться. Значение свойства не может быть в прошлом. <!-- This property is optional. --> |
| **Стандарт** | Часовой пояс. Список поддерживаемых часовых поясов см. в разделе [Создание триггера, который запускает конвейер по расписанию](how-to-create-schedule-trigger.md#time-zone-option). |
| **шаблон** | Объект recurrence указывает правила повторения для триггера. Этот объект поддерживает следующие элементы: **frequency**, **interval**, **endTime**, **count** и **schedule**. Если определен объект recurrence, элемент **frequency** является обязательным. Другие элементы объекта recurrence являются необязательными. |
| **импульс** | Единица частоты, с которой выполняется триггер. Поддерживаются следующие значения: "минута", "час", "день", "неделя" и "месяц". |
| **пределах** | Положительное целое число, указывающее интервал для значения **frequency**, **которое** определяет, как часто выполняется триггер. Например, если **interval** имеет значение 3, а для элемента **frequency** выбран вариант week (неделя), триггер выполняется один раз каждые три недели. |
| **Расписание** | Расписание повторения для триггера. Триггер с указанным значением **частоты** выполняется по расписанию. Свойство **schedule** содержит изменения для повторения, основанного на минутах, часах, неделях, днях месяца и номере недели. |

### <a name="schedule-trigger-example"></a>Пример триггера расписания

```json
{
  "properties": {
    "name": "MyTrigger",
    "type": "ScheduleTrigger",
    "typeProperties": {
      "recurrence": {
        "frequency": "Hour",
        "interval": 1,
        "startTime": "2017-11-01T09:00:00-08:00",
        "endTime": "2017-11-02T22:00:00-08:00"
      }
    },
    "pipelines": [{
        "pipelineReference": {
          "type": "PipelineReference",
          "referenceName": "SQLServerToBlobPipeline"
        },
        "parameters": {}
      },
      {
        "pipelineReference": {
          "type": "PipelineReference",
          "referenceName": "SQLServerToAzureSQLPipeline"
        },
        "parameters": {}
      }
    ]
  }
}
```

### <a name="schema-defaults-limits-and-examples"></a>Параметры схемы по умолчанию, ограничения и примеры

| Свойство JSON | Тип | Обязательно | Значение по умолчанию | Допустимые значения | Пример |
| --- | --- | --- | --- | --- | --- |
| **startTime** | строка | Да | Нет | Дата и время по спецификации ISO 8601 | `"startTime" : "2013-01-09T09:30:00-08:00"` |
| **шаблон** | object | Да | Нет | Объект recurrence | `"recurrence" : { "frequency" : "monthly", "interval" : 1 }` |
| **пределах** | number | Нет | 1 | От 1 до 1000 | `"interval":10` |
| **Завершения** | строка | Да | Нет | Значение даты и времени, представляющее время в будущем. | `"endTime" : "2013-02-09T09:30:00-08:00"` |
| **Расписание** | object | Нет | None | Объект schedule | `"schedule" : { "minute" : [30], "hour" : [8,17] }` |

### <a name="starttime-property"></a>Свойство startTime
В следующей таблице показано, как свойство **startTime** управляет запуском триггера:

| Значение startTime | Повторение без расписания | Повторение с расписанием |
| --- | --- | --- |
| **Время начала в прошлом** | Вычисляется время первого выполнения, относящееся к будущему времени, после указанного времени начала.<br /><br />Последующие выполнения производятся с учетом времени предыдущего выполнения.<br /><br />Пример представлен после этой таблицы. | Триггер начинается _не раньше_ указанного времени начала. Первое выполнение производится по расписанию, которое отсчитывается от времени начала.<br /><br />Последующие выполнения производятся по расписанию повторов. |
| **Время начала в будущем или в настоящем** | Выполняется первый раз в указанное время начала.<br /><br />Последующие выполнения производятся с учетом времени предыдущего выполнения. | Триггер выполняется _не раньше_ указанного времени начала. Первое выполнение производится по расписанию, которое отсчитывается от времени начала.<br /><br />Последующие выполнения производятся по расписанию повторов. |

Рассмотрим, как работает триггер, для которого время начала установлено в прошлом, указан параметр recurrence и отсутствует параметр schedule. Предположим, что текущее время — 08.04.2017 13:00, время начала — 07.04.2017 14:00, а повторение — каждые два дня. (Значение **периодичности** определяется значением свойства **Frequency** , равным «Day», а свойству **Interval** — 2.) Обратите внимание, что значение **StartTime** находится в прошлом и происходит до текущего времени.

В этих условиях первое выполнение происходит 09.04.2017 в 14:00. От времени начала ядро планировщика отсчитывает время повторных выполнений. Выполнения, которые приходятся на прошлое, игнорируются. Ядро берет очередной случай выполнения, который приходится на будущее. В этом случае время начала — 07.04.2017 в 14:00. Следующее выполнение состоится через 2 дня от этого времени начала, то есть 09.04.2017 в 14:00.

Время первого выполнения останется тем же даже при таких значениях **startTime**: 05.04.2017 в 14:00 или 01.04.2017 в 14:00. Все последующие выполнения после первого вычисляются по расписанию (свойство schedule). Таким образом, последующие выполнения проходят 11.04.2017 в 14:00, затем 13.04.2017 в 14:00, затем 15.04.2017 в 14:00 и т. д.

Наконец, если в расписании триггера не заданы часы или минуты, то в качестве значений по умолчанию используются часы или минуты первого выполнения.

### <a name="schedule-property"></a>Свойство schedule
С помощью параметра **schedule** можно *ограничить* число выполнений триггера. Например, если триггеру назначена ежемесячная частота и параметр schedule, который запускает триггер только на 31-й день месяца, он будет выполняться только в те месяцы, в которых есть 31 день.

Кроме того, с помощью параметра **schedule** можно *увеличить* число выполнений триггера. Например, триггер с ежемесячной частотой и параметром schedule, который запускает триггер в 1 и 2 день месяца, будет выполняться в первый и второй дни месяца, а не раз в месяц.

Если указано несколько элементов **расписания** , порядок вычисления определяется от самого большого до наименьшего значения расписания: номер недели, месяц, день недели, час, минута.

В следующей таблице элементы свойства **schedule** описаны подробно.

| Элемент JSON | Описание | Допустимые значения |
| --- | --- | --- |
| **minutes** | Минуты часа, в которые будет выполняться триггер. |Целое число<br />Массив целых чисел |
| **суток** | Часы дня, в которые будет выполняться триггер. |Целое число<br />Массив целых чисел |
| **Рабочие дни** | Дни недели, в которые будет выполняться триггер. Значение можно указать только с еженедельной частотой.|<br />monday<br />tuesday<br />wednesday<br />thursday<br />friday<br />saturday<br />sunday<br />Массив значений дня (максимальный размер массива — 7)<br /><br />Значения дня не учитывают регистр |
| **monthlyOccurrences** | Дни месяца, по которым выполняется триггер. Значение можно указать только с ежемесячной частотой. |Массив объектов **monthlyOccurrence**: `{ "day": day, "occurrence": occurrence }`<br />Атрибут **day** является днем недели, в который выполняется триггер. Например, свойство **monthlyOccurrences** со значением **day** равным `{Sunday}` означает каждое воскресенье месяца. Атрибут **day** является обязательным.<br />Атрибут **occurrence** является частотой появления определенного **дня** на протяжении месяца. Например, свойство **monthlyOccurrences** со значением **day** и **occurrence** со значением `{Sunday, -1}` означает последнее воскресенье месяца. Атрибут **occurrence** не является обязательным. |
| **monthDays** | Дни месяца, по которым выполняется триггер. Значение можно указать только с ежемесячной частотой. |— любое значение <= -1 и >= -31;<br />— любое значение >= 1 и <= 31.<br />Массив значений |

## <a name="tumbling-window-trigger"></a>Триггер "переворачивающегося" окна
Триггер "переворачивающегося" окна — это тип триггера, который активируется с определенным интервалом начиная с указанного времени запуска, сохраняя состояние. "Переворачивающиеся" окна — это ряд неперекрывающихся и несоприкасающихся интервалов времени фиксированного размера.

Дополнительные сведения о триггерах окна "переворачивающегося" и, например, см. [в разделе Создание триггера окна "переворачивающегося"](how-to-create-tumbling-window-trigger.md).

## <a name="examples-of-trigger-recurrence-schedules"></a>Примеры расписаний повторения триггеров

Этот раздел содержит примеры расписания повторений с применением объекта **schedule** и его элементов.

В примерах предполагается, что значение **интервала** равно 1, а значение **частоты** является правильным в соответствии с определением расписания. Например, у вас не может быть значения **частоты** "Day", а также изменения **monthDays** в объекте **Schedule** . Такие ограничения описаны в таблице в предыдущем разделе.

| Пример | Описание |
| --- | --- |
| `{"hours":[5]}` | Выполняется каждый день в 05:00. |
| `{"minutes":[15], "hours":[5]}` | Выполняется каждый день в 05:15. |
| `{"minutes":[15], "hours":[5,17]}` | Выполняется каждый день в 05:15 и 16:15. |
| `{"minutes":[15,45], "hours":[5,17]}` | Выполняется каждый день в 05:15, 05:45, 16:15 и 16:45. |
| `{"minutes":[0,15,30,45]}` | Выполнение каждые 15 минут. |
| `{hours":[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}` | Выполнение каждый час.<br /><br />Этот триггер запускается каждый час. Минуты зависят от значения **startTime**, если оно указано. Если значение не указано, управление минутами осуществляется в соответствии с временем создания. Например, если триггер запущен или создан (в зависимости от ситуации) в 12:25, он будет запускаться в 00:25, 01:25, 02:25 и т. д. и 23:25.<br /><br />Это расписание аналогично триггеру со значением **Frequency** , равным "Hour", значением **интервала** , равным 1, и без **расписания**. Это расписание можно использовать с различными значениями **частоты** и **интервала** для создания других триггеров. Например, если значение **частоты** равно «month», Расписание выполняется только один раз в месяц, а не каждый день, когда значение **Frequency** равно «Day». |
| `{"minutes":[0]}` | Задание выполняется с наступлением каждого часа.<br /><br />Этот триггер выполняется с наступлением каждого часа, начиная с 12:00, 13:00, 14:00 и т. д.<br /><br />Это расписание является эквивалентом триггера со значением **frequency** равным "hour" и значением **startTime** без минут или без объекта **schedule**, но со значением **frequency** "day". Если значение **частоты** — week или month, Расписание выполняется один раз в неделю или один день в месяц соответственно. |
| `{"minutes":[15]}` | Задание выполняется через 15 минут после наступления каждого часа.<br /><br />Этот триггер выполняется через 15 минут после наступления каждого часа, начиная с 00:15, 01:15, 02:15 и т. д. и заканчивая в 23:15. |
| `{"hours":[17], "weekDays":["saturday"]}` | Задание выполняется в 17:00 каждую субботу. |
| `{"hours":[17], "weekDays":["monday", "wednesday", "friday"]}` | Задание выполняется в 17:00 в каждые понедельник, среду и пятницу. |
| `{"minutes":[15,45], "hours":[17], "weekDays":["monday", "wednesday", "friday"]}` | Задание выполняется в 17:15 и 17:45 в каждые понедельник, среду и пятницу. |
| `{"minutes":[0,15,30,45], "weekDays":["monday", "tuesday", "wednesday", "thursday", "friday"]}` | Задание выполняется каждые 15 минут в каждый рабочий день. |
| `{"minutes":[0,15,30,45], "hours": [9, 10, 11, 12, 13, 14, 15, 16] "weekDays":["monday", "tuesday", "wednesday", "thursday", "friday"]}` | Задание выполняется каждые 15 минут в период с 09:00 до 16:45 в каждый рабочий день. |
| `{"weekDays":["tuesday", "thursday"]}` | Задание выполняется по вторникам и четвергам в указанное время начала. |
| `{"minutes":[0], "hours":[6], "monthDays":[28]}` | Задание выполняется в 6:00 28-го числа каждого месяца (при условии, что значение **frequency** — "month"). |
| `{"minutes":[0], "hours":[6], "monthDays":[-1]}` | Задание выполняется в 06:00 в последний день месяца.<br /><br />Чтобы триггер запускался в последний день месяца, используйте "-1" вместо значения 28, 29, 30 или 31. |
| `{"minutes":[0], "hours":[6], "monthDays":[1,-1]}` | Задание выполняется в 06:00 в первый и последний день каждого месяца. |
| `{monthDays":[1,14]}` | Выполняется в первый и 14-й день каждого месяца в указанное время начала. |
| `{"minutes":[0], "hours":[5], "monthlyOccurrences":[{"day":"friday", "occurrence":1}]}` | Задание выполняется в первую пятницу каждого месяца в 05:00. |
| `{"monthlyOccurrences":[{"day":"friday", "occurrence":1}]}` | Задание выполняется в первую пятницу каждого месяца в указанное время начала. |
| `{"monthlyOccurrences":[{"day":"friday", "occurrence":-3}]}` | Задание выполняется в третью пятницу с конца каждого месяца в указанное время начала. |
| `{"minutes":[15], "hours":[5], "monthlyOccurrences":[{"day":"friday", "occurrence":1},{"day":"friday", "occurrence":-1}]}` | Задание выполняется в первую и последнюю пятницу каждого месяца в 05:15. |
| `{"monthlyOccurrences":[{"day":"friday", "occurrence":1},{"day":"friday", "occurrence":-1}]}` | Задание выполняется в первую и последнюю пятницу каждого месяца в указанное время начала. |
| `{"monthlyOccurrences":[{"day":"friday", "occurrence":5}]}` | Задание выполняется в пятую пятницу каждого месяца в указанное время начала.<br /><br />Оно не выполняется, если пятой пятницы в месяце нет. Чтобы триггер выполнялся в последнюю пятницу месяца, используйте вместо значения **повторения** 5 значение –1. |
| `{"minutes":[0,15,30,45], "monthlyOccurrences":[{"day":"friday", "occurrence":-1}]}` | Задание выполняется каждые 15 минут в последнюю пятницу месяца. |
| `{"minutes":[15,45], "hours":[5,17], "monthlyOccurrences":[{"day":"wednesday", "occurrence":3}]}` | Задание выполняется в 05:15, 05:45, 17:15, 17:45 в третью среду каждого месяца. |

## <a name="trigger-type-comparison"></a>Сравнение типов триггеров

Триггер "переворачивающегося" окна и триггер расписания работают с одинаковыми интервалами времени. Чем они отличаются?

> [!NOTE]
> Запуск триггера окна "переворачивающегося" *ожидает завершения запущенного конвейера* . Его состояние выполнения отражает состояние запущенного конвейера. Например, если запущенный запуск конвейера отменен, соответствующий запуск триггера окна "переворачивающегося" помечается как отмененный. Это отличается от поведения «пожара и забыть» триггера Schedule, который отмечается как успешный до начала выполнения конвейера.

В следующей таблице представлено сравнение триггера "переворачивающегося" окна и триггера расписания:

| Элемент | Триггер "переворачивающегося" окна | Триггер планировщика |
| --- | --- | --- |
| **Сценарии с задним числом** | Поддерживается. Выполнения конвейера можно запланировать для окон в прошлом. | Не поддерживается. Конвейер можно выполнить только в периоды времени в настоящем и будущем. |
| **Надежность** | 100 % надежность. Запуск конвейеров можно запланировать для всех окон с заданной датой начала без пробелов. | Меньшая надежность. |
| **Повторные попытки** | Поддерживается. При сбое запуска конвейера по умолчанию политика повторного запуска настроена на 0 повторных попыток. Или пользователь может указать количество повторных попыток в определении триггера. Автоматически повторяет попытки при сбое конвейера из-за ограничений параллелизма/сервера/регулирования (т. е. коды состояния 400: ошибка пользователя, 429: слишком много запросов и 500: Внутренняя ошибка сервера). | Не поддерживается. |
| **Параллелизм** | Поддерживается. Пользователи могут явно задавать ограничения параллелизма для триггера. Триггер может параллельно запустить от 1 до 50 конвейеров. | Не поддерживается. |
| **Системные переменные** | Вместе с @trigger (). счедуледтиме и @trigger (). StartTime также поддерживает использование системных переменных **WindowStart** и **WindowEnd** . Пользователи могут получить доступ к `trigger().outputs.windowStartTime` и `trigger().outputs.windowEndTime` как к системным переменным триггера в определении триггера. Значения используются как время начала и окончания окна соответственно. Например, для триггера "переворачивающегося" окна, выполняющегося каждый час, в окне от 1:00 до 2:00 определением является `trigger().outputs.windowStartTime = 2017-09-01T01:00:00Z` и `trigger().outputs.windowEndTime = 2017-09-01T02:00:00Z`. | Поддерживаются только @trigger переменные Default (). счедуледтиме и @trigger (). StartTime. |
| **Связь конвейера и триггера** | Поддерживает связь "один к одному". Вы можете активировать только один конвейер. | Поддерживает связи "многие ко многим" Несколько триггеров могут запускать один конвейер. Один триггер может запускать несколько конвейеров. |

## <a name="event-based-trigger"></a>Триггер на основе событий

Триггер на основе события запускает конвейеры в ответ на событие. Существует две разновидности триггеров на основе событий.

* _Триггер событий хранилища_ запускает конвейер для событий, происходящих в учетной записи хранения, таких как получение файла, или удаление файла в учетной записи хранилища BLOB-объектов Azure.
* _Триггеры пользовательских событий_ и обработка [пользовательских разделов](../event-grid/custom-topics.md) в сетке событий

Дополнительные сведения о триггерах на основе событий см. в разделе [триггер событий хранилища](how-to-create-event-trigger.md) и [триггер пользовательских событий](how-to-create-custom-event-trigger.md).

## <a name="next-steps"></a>Следующие шаги

Ознакомьтесь со следующими руководствами:

- [Создание фабрики данных и конвейера с помощью пакета SDK .NET](quickstart-create-data-factory-dot-net.md)
- [Создание триггера расписания](how-to-create-schedule-trigger.md)
- [Создание триггера "переворачивающегося" окна](how-to-create-tumbling-window-trigger.md)
