---
title: Перенос таблиц базы данных SQL Azure в Azure CosmosDB с помощью фабрики данных Azure
description: Возьмите существующую нормализованную схему базы данных из базы данных SQL Azure и перенесите ее в Денормализованный контейнер Azure CosmosDB с помощью фабрики данных Azure.
author: kromerm
ms.author: makromer
ms.service: data-factory
ms.topic: conceptual
ms.date: 04/29/2020
ms.openlocfilehash: 3d67ac9474704fac39dbe7eb91aead5c4babc4ce
ms.sourcegitcommit: d4734bc680ea221ea80fdea67859d6d32241aefc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2021
ms.locfileid: "100383948"
---
# <a name="migrate-normalized-database-schema-from-azure-sql-database-to-azure-cosmosdb-denormalized-container"></a>Перенос нормализованной схемы базы данных из базы данных SQL Azure в денормализованный контейнер Azure CosmosDB

В этом руководство объясняется, как взять существующую нормализованную схему базы данных в базе данных SQL Azure и преобразовать ее в денормализованную схему Azure CosmosDB для загрузки в Azure CosmosDB.

Схемы SQL обычно моделируются с помощью третьей нормальной формы, что приводит к нормализованным схемам, обеспечивающим высокий уровень целостности данных и меньшего количества повторяющихся значений данных. Запросы могут соединять сущности вместе между таблицами для чтения. CosmosDB оптимизирован для очень быстрых транзакций и запросов в коллекции или контейнере через денормализованные схемы с самодостаточными данными внутри документа.

С помощью фабрики данных Azure мы создадим конвейер, использующий единый поток данных сопоставления для чтения из двух нормализованных таблиц базы данных SQL Azure, содержащих первичные и внешние ключи в связи сущностей. ADF присоединяет эти таблицы к одному потоку с помощью подсистемы Spark потока данных, собирайте объединенные строки в массивы и создает отдельные очищенные документы для вставки в новый контейнер Azure CosmosDB.

В этом руководством будет создан новый контейнер с именем "заказы", который будет использовать ```SalesOrderHeader``` ```SalesOrderDetail``` таблицы и из образца базы данных SQL Server AdventureWorks. Эти таблицы представляют собой транзакции, Соединенные по продажам ```SalesOrderID``` . Каждая уникальная запись сведений имеет собственный первичный ключ ```SalesOrderDetailID``` . Отношение между заголовком и данными имеет значение ```1:M``` . Мы будем присоединяться к ```SalesOrderID``` ADF, а затем перейдем каждую связанную детальную запись в массив с именем «Detail».

Репрезентативный SQL-запрос для этого руководство:

```
  SELECT
  o.SalesOrderID,
  o.OrderDate,
  o.Status,
  o.ShipDate,
  o.SalesOrderNumber,
  o.ShipMethod,
  o.SubTotal,
  (select SalesOrderDetailID, UnitPrice, OrderQty from SalesLT.SalesOrderDetail od where od.SalesOrderID = o.SalesOrderID for json auto) as OrderDetails
FROM SalesLT.SalesOrderHeader o;
```

Результирующий контейнер CosmosDB внедряет внутренний запрос в один документ и будет выглядеть следующим образом:

![Коллекция](media/data-flow/cosmosb3.png)

## <a name="create-a-pipeline"></a>Создание конвейера

1. Выберите **+ создать конвейер** , чтобы создать новый конвейер.

2. Добавление действия потока данных

3. В действии поток данных выберите **создать сопоставление поток данных**.

4. Эта диаграмма потока данных будет построена ниже

![Диаграмма потока данных](media/data-flow/cosmosb1.png)

5. Определите источник "Саурцеордердетаилс". Для набора данных создайте новый набор данных базы данных SQL Azure, указывающий на ```SalesOrderDetail``` таблицу.

6. Определите источник "Саурцеордерхеадер". Для набора данных создайте новый набор данных базы данных SQL Azure, указывающий на ```SalesOrderHeader``` таблицу.

7. В верхнем источнике добавьте преобразование «Производный столбец» после «Саурцеордердетаилс». Вызовите новое преобразование «приведение типа». Необходимо округлить ```UnitPrice``` столбец и привести его к типу данных Double для CosmosDB. Задайте формулу: ```toDouble(round(UnitPrice,2))``` .

8. Добавьте еще один производный столбец и вызовите его «Макеструкт». Здесь мы создадим иерархическую структуру для хранения значений из таблицы Details. Помните, что сведения являются ```M:1``` отношением к заголовку. Назовите новую структуру ```orderdetailsstruct``` и создайте иерархию таким образом, задав каждому подстолбцу имя входящего столбца:

![Создание структуры](media/data-flow/cosmosb9.png)

9. Теперь давайте перейдем к источнику заголовка продаж. Добавьте преобразование «соединение». Для правой части выберите "Макеструкт". Оставьте значение внутреннее соединение и выберите ```SalesOrderID``` для обеих сторон условия объединения.

10. Щелкните вкладку Предварительный просмотр данных в новом добавленном соединении, чтобы просмотреть результаты до этой точки. Вы должны увидеть все строки заголовка, Соединенные со строками детализации. Это результат объединения, сформированного из ```SalesOrderID``` . Далее мы будем объединять сведения из общих строк в структуру Details и объединять общие строки.

![Join](media/data-flow/cosmosb4.png)

11. Прежде чем создавать массивы для денормализации этих строк, необходимо удалить ненужные столбцы и убедиться, что значения данных будут соответствовать типам данных CosmosDB.

12. Добавьте преобразование «выбор» и задайте сопоставление поля следующим образом:

![Очистка столбца](media/data-flow/cosmosb5.png)

13. Теперь давайте снова приведите столбец валюты, на этот раз ```TotalDue``` . Как мы делали на шаге 7, задайте формулу: ```toDouble(round(TotalDue,2))``` .

14. Здесь мы будем денормализовать строки, группируя их по общему ключу ```SalesOrderID``` . Добавьте преобразование «Статистическая обработка» и задайте для параметра Group By значение ```SalesOrderID``` .

15. В статистической формуле добавьте новый столбец с именем "Details" (сведения) и используйте эту формулу для сбора значений в структуре, созданной ранее с названием ```orderdetailsstruct``` : ```collect(orderdetailsstruct)``` .

16. Преобразование «Статистическая обработка» будет выводить только столбцы, которые являются частью статистических выражений или группирования по формулам. Поэтому необходимо также включить столбцы из заголовка Sales. Для этого добавьте шаблон столбца в то же преобразование «Статистическая обработка». Этот шаблон будет включать все остальные столбцы в выходных данных:

```instr(name,'OrderQty')==0&&instr(name,'UnitPrice')==0&&instr(name,'SalesOrderID')==0```

17. Используйте синтаксис "this" в других свойствах, чтобы сохранить одни и те же имена столбцов и использовать ```first()``` функцию в качестве статистического выражения:

![Статистическое](media/data-flow/cosmosb6.png)

18. Мы готовы завершить процесс миграции, добавив преобразование приемника. Щелкните "создать" рядом с набором данных и добавьте набор данных CosmosDB, указывающий на базу данных CosmosDB. Для коллекции мы назовем «Orders», и она не будет иметь схемы и документов, так как она будет создана на лету.

19. В разделе параметры приемника, ключ секции ```\SalesOrderID``` и действие сбора — "повторное создание". Убедитесь, что вкладка Сопоставление выглядит следующим образом:

![На снимке экрана показана вкладка Сопоставление.](media/data-flow/cosmosb7.png)

20. Щелкните Предварительный просмотр данных, чтобы убедиться, что следующие 32 строк отображаются в качестве новых документов в новом контейнере.

![На снимке экрана показана вкладка Предварительный просмотр данных.](media/data-flow/cosmosb8.png)

Если все выглядит хорошо, теперь все готово для создания нового конвейера, добавления этого действия потока данных в этот конвейер и его выполнения. Можно выполнить из отладки или запуска триггера. Через несколько минут в базе данных CosmosDB должен быть новый Денормализованный контейнер заказов, именуемый "заказы".

## <a name="next-steps"></a>Следующие шаги

* Создайте оставшуюся часть логики потока данных с помощью [преобразования потоков данных](concepts-data-flow-overview.md)сопоставления.
* [Скачайте шаблон завершенного конвейера](https://github.com/kromerm/adfdataflowdocs/blob/master/sampledata/SQL%20Orders%20to%20CosmosDB.zip) для этого руководства и импортируйте шаблон в фабрику.
