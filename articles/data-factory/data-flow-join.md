---
title: Преобразование "Соединение" в потоке данных для сопоставления
description: Объединение данных из двух источников данных с помощью преобразования "Соединение" в потоке данных для сопоставления Фабрики данных Azure
author: kromerm
ms.author: makromer
ms.reviewer: daperlov
ms.service: data-factory
ms.topic: conceptual
ms.custom: seo-lt-2019
ms.date: 05/15/2020
ms.openlocfilehash: ac84ce17f53145ffd85ffa31b6633d8b4b184962
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "93042656"
---
# <a name="join-transformation-in-mapping-data-flow"></a>Преобразование "Соединение" в потоке данных для сопоставления

[!INCLUDE[appliesto-adf-asa-md](includes/appliesto-adf-asa-md.md)]

Используйте преобразование "Соединение" для объединения данных из двух источников или потоков в поток данных для сопоставления. Поток вывода будет включать все столбцы из обоих источников, сопоставленные на основе условия соединения. 

## <a name="join-types"></a>Типы соединений

Потоки данных для сопоставления в настоящее время поддерживают пять различных типов соединений.

### <a name="inner-join"></a>Внутреннее соединение

Внутреннее соединение выводит только строки, которые имеют совпадающие значения в обеих таблицах.

### <a name="left-outer"></a>Левое внешнее соединение

Левое внешнее соединение возвращает все строки из левого потока и сопоставленные записи из правого потока. Если строка из левого потока не имеет соответствия, выходным столбцам из правого потока задается значение NULL. Выходными данными будут строки, возвращаемые внутренним соединением, а также несовпадающие строки из левого потока.

> [!NOTE]
> Модуль Spark, используемый потоками данных, иногда выходит из строя из-за возможных декартовых произведений в условиях соединения. В этом случае вы можете переключиться на пользовательское перекрестное соединение и вручную ввести условие соединения. Это может привести к снижению производительности в потоках данных, так как подсистеме выполнения может потребоваться вычислить все строки с обеих сторон связи, а затем отфильтровать их.

### <a name="right-outer"></a>Правое внешнее соединение

Правое внешнее соединение возвращает все строки из правого потока и сопоставленные записи из левого потока. Если строка из правого потока не имеет соответствия, выходным столбцам из левого потока задается значение NULL. Выходными данными будут строки, возвращаемые внутренним соединением, а также несовпадающие строки из правого потока.

### <a name="full-outer"></a>Полное внешнее соединение

Полное внешнее соединение выводит все столбцы и строки с обеих сторон со значениями NULL для столбцов, которые не совпадают.

### <a name="custom-cross-join"></a>Пользовательское перекрестное соединение

Перекрестное соединение выводит перекрестное произведение двух потоков на основе условия. Если вы используете условие, которое не является равенством, необходимо указать пользовательское выражение в качестве условия перекрестного соединения. Потоком вывода будут все строки, которые соответствуют условию соединения.

Вы можете использовать этот тип соединения для неэквивалентных соединений и условий ```OR```.

Если вы хотите явно создать полный декартов продукт, в каждом из двух независимых потоков перед соединением используйте преобразование "Производный столбец", чтобы создать искусственный ключ для сопоставления. Например, создайте в производном столбце в каждом вызываемом потоке ```SyntheticKey``` столбец и присвойте ему значение ```1```. Затем используйте ```a.SyntheticKey == b.SyntheticKey``` в качестве пользовательского выражения соединения.

> [!NOTE]
> Обязательно включите хотя бы один столбец с каждой стороны левой и правой связей в пользовательском перекрестном соединении. Выполнение перекрестных соединений со статическими значениями вместо столбцов с каждой стороны приводит к полному сканированию всего набора данных, в результате чего поток данных работает плохо.

## <a name="configuration"></a>Конфигурация

1. Из правого раскрывающегося **списка потока** выберите, к какому потоку данных вы присоединяетесь.
1. Выберите **тип соединения**.
1. Выберите, какие ключевые столбцы будут сопоставляться с условием соединения. По умолчанию поток данных ищет равенство между одним столбцом в каждом потоке. Чтобы выполнить сравнение с помощью вычисленного значения, наведите указатель мыши на раскрывающийся список столбцов и выберите **Вычисляемый столбец**.

![Преобразование "Соединение"](media/data-flow/join.png "Join")

### <a name="non-equi-joins"></a>Неэквивалентные соединения

Чтобы использовать условный оператор, например not equals (не равно, !=) или greater than (больше чем, >) в условиях соединения, измените раскрывающийся список операторов между двумя столбцами. Для неэквивалентных соединений требуется широковещательная рассылка по крайней мере одного из двух потоков с помощью **Фиксированного** вещания на вкладке **Оптимизация**.

![Неэквивалентное соединение](media/data-flow/non-equi-join.png "Неэквивалентное соединение")

## <a name="optimizing-join-performance"></a>Оптимизация производительности соединения

В отличие от таких инструментов, как SQL Server Integration Services, преобразование "Соединение" необязательно является операцией соединения слиянием. Для ключей соединения не требуется сортировка. Операция соединения происходит на основе оптимальной операции соединения в Spark. Это либо широковещательное соединение, либо соединение на стороне сопоставления.

![Оптимизация преобразования "Соединение"](media/data-flow/joinoptimize.png "Оптимизация объединения")

При преобразованиях "Соединения", "Уточняющие запросы" и "Существование", если один или оба потока данных помещаются в память рабочего узла, можно оптимизировать производительность, включив **Трансляцию**. По умолчанию механизм Spark автоматически решает, следует ли транслировать одну сторону. Чтобы вручную выбрать сторону для трансляции, выберите **Фиксированные**.

Не рекомендуется отключать широковещательную трансляцию с помощью параметра **Выкл.** , пока соединения не столкнутся с ошибками времени ожидания.

## <a name="self-join"></a>Самосоединение

Чтобы самостоятельно соединить поток данных с самим собой, создайте псевдоним имеющегося потока с преобразованием "Выбор". Создайте ветвь, щелкнув значок плюса рядом с преобразованием и выбрав **Новая ветвь**. Добавьте преобразование "Выбор" для создания псевдонима исходного потока. Добавьте преобразование "Соединение" и выберите исходный поток в качестве **левого потока**, а преобразование "Выбор" — в качестве **правого потока**.

![Самосоединение](media/data-flow/selfjoin.png "Самосоединение")

## <a name="testing-join-conditions"></a>Тестирование условий соединения

При тестировании преобразования "Соединение" с предварительным просмотром данных в режиме отладки используйте небольшой набор известных данных. При выборке строк из большого набора данных нельзя предсказать, какие строки и ключи будут считываться для тестирования. Результат является недетерминированным, то есть условия соединения могут и не возвратить совпадений.

## <a name="data-flow-script"></a>Скрипт потока данных

### <a name="syntax"></a>Синтаксис

```
<leftStream>, <rightStream>
    join(
        <conditionalExpression>,
        joinType: { 'inner'> | 'outer' | 'left_outer' | 'right_outer' | 'cross' }
        broadcast: { 'auto' | 'left' | 'right' | 'both' | 'off' }
    ) ~> <joinTransformationName>
```

### <a name="inner-join-example"></a>Пример внутреннего соединения

Приведенный ниже пример представляет собой преобразование "Соединение" с именем `JoinMatchedData`, которое принимает левый поток `TripData` и правый поток `TripFare`.  Условие соединения является выражением `hack_license == { hack_license} && TripData@medallion == TripFare@medallion && vendor_id == { vendor_id} && pickup_datetime == { pickup_datetime}`, которое возвращает значение TRUE, если столбцы `hack_license`, `medallion`, `vendor_id` и `pickup_datetime` в каждом потоке совпадают. `joinType` является `'inner'`. Мы включаем широковещательную трансляцию только в левом потоке, поэтому `broadcast` имеет значение `'left'`.

В интерфейсе Фабрики данных это преобразование выглядит следующим образом:

![На снимке экрана показано преобразование с выбранной вкладкой Параметры объединения и типом объединения Inner.](media/data-flow/join-script1.png "Пример соединения")

Скрипт потока данных для этого преобразования представлен в следующем фрагменте кода:

```
TripData, TripFare
    join(
        hack_license == { hack_license}
        && TripData@medallion == TripFare@medallion
        && vendor_id == { vendor_id}
        && pickup_datetime == { pickup_datetime},
        joinType:'inner',
        broadcast: 'left'
    )~> JoinMatchedData
```

### <a name="custom-cross-join-example"></a>Пример пользовательского перекрестного соединения

Приведенный ниже пример представляет собой преобразование "Соединение" с именем `JoiningColumns`, которое принимает левый поток `LeftStream` и правый поток `RightStream`. Это преобразование принимает два потока и объединяет все строки, где столбец `leftstreamcolumn` больше столбца `rightstreamcolumn`. `joinType` является `cross`. Широковещательная трансляция не включена, `broadcast` имеет значение `'none'`.

В интерфейсе Фабрики данных это преобразование выглядит следующим образом:

![На снимке экрана показано преобразование с выбранной вкладкой Параметры объединения и типом объединения Custom (перекрестная).](media/data-flow/join-script2.png "Пример соединения")

Скрипт потока данных для этого преобразования представлен в следующем фрагменте кода:

```
LeftStream, RightStream
    join(
        leftstreamcolumn > rightstreamcolumn,
        joinType:'cross',
        broadcast: 'none'
    )~> JoiningColumns
```

## <a name="next-steps"></a>Дальнейшие действия

После объединения данных создайте [производный столбец](data-flow-derived-column.md) и [передайте](data-flow-sink.md) данные в целевое хранилище данных.
