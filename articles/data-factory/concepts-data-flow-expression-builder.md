---
title: Построитель выражений в потоке данных сопоставления
description: Построение выражений с помощью построителя выражений при сопоставлении потоков данных в фабрике данных Azure
author: kromerm
ms.author: makromer
ms.reviewer: daperlov
ms.service: data-factory
ms.topic: conceptual
ms.date: 02/04/2021
ms.openlocfilehash: 753f201fbde5d9e7100b6e257f8dc79e4462d7b6
ms.sourcegitcommit: 867cb1b7a1f3a1f0b427282c648d411d0ca4f81f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "99584929"
---
# <a name="build-expressions-in-mapping-data-flow"></a>Выражения сборки в потоке данных сопоставления

[!INCLUDE[appliesto-adf-asa-md](includes/appliesto-adf-asa-md.md)]

В потоке данных сопоставления многие свойства преобразования задаются как выражения. Эти выражения состоят из значений столбцов, параметров, функций, операторов и литералов, результатом вычисления которых является тип данных Spark во время выполнения. Сопоставление потоков данных имеет выделенный интерфейс, предназначенный для помощи в построении этих выражений, называемых **построителем выражений**. При использовании  [функции](/visualstudio/ide/using-intellisense) завершения кода IntelliSense для выделения, проверки синтаксиса и автозаполнения построитель выражений предназначен для облегчения создания потоков данных. В этой статье объясняется, как использовать построитель выражений для эффективной сборки бизнес-логики.

![Построитель выражений](media/data-flow/expresion-builder.png "Построитель выражений")

## <a name="open-expression-builder"></a>Открыть построитель выражений

Существует несколько точек входа для открытия построителя выражений. Все они зависят от конкретного контекста преобразования потока данных. Наиболее распространенным вариантом использования являются преобразования, такие как [производный столбец](data-flow-derived-column.md) , и [Статистическая обработка](data-flow-aggregate.md) , где пользователи создают или обновляют столбцы с помощью языка выражений потока данных. Построитель выражений можно открыть, выбрав **открыть построитель выражений** над списком столбцов. Можно также щелкнуть контекст столбца и открыть построитель выражений непосредственно в этом выражении.

![Открыть производный построитель выражений](media/data-flow/open-expression-builder-derive.png "Открыть производный построитель выражений")

В некоторых преобразованиях, таких как [Фильтр](data-flow-filter.md), при щелчке в текстовом поле синего выражения откроется построитель выражений. 

![Синее поле выражения](media/data-flow/expressionbox.png "Синее поле выражения")

При ссылке на столбцы в условии сопоставления или группирования выражение может извлекать значения из столбцов. Чтобы создать выражение, выберите **вычисляемый столбец**.

![Параметр вычисляемого столбца](media/data-flow/computedcolumn.png "Параметр вычисляемого столбца")

В случаях, когда выражение или литеральное значение являются допустимыми входными данными, выберите **добавить динамическое содержимое** , чтобы построить выражение, результатом вычисления которого является литеральное значение.

![Параметр "добавить динамическое содержимое"](media/data-flow/add-dynamic-content.png "Параметр "добавить динамическое содержимое"")

## <a name="expression-elements"></a>Элементы выражения

В сопоставлении потоков данных выражения могут состоять из значений столбцов, параметров, функций, локальных переменных, операторов и литералов. Эти выражения должны иметь тип данных Spark, например String, Boolean или Integer.

![Элементы выражения](media/data-flow/expression-elements.png "Элементы выражения")

### <a name="functions"></a>Функции

Сопоставление потоков данных имеет встроенные функции и операторы, которые можно использовать в выражениях. Список доступных функций см. в [справочнике по языку потока данных сопоставления](data-flow-expression-functions.md).

#### <a name="address-array-indexes"></a>Индексы массива адресов

При работе со столбцами или функциями, которые возвращают типы массивов, используйте квадратные скобки ([]) для доступа к определенному элементу. Если индекс не существует, выражение принимает значение NULL.

![Массив построителя выражений](media/data-flow/expression-array.png "Предварительный просмотр данных выражения")

> [!IMPORTANT]
> В сопоставлении потоков данных массивы — это значение, основанное на первом элементе, на который ссылается индекс 1. Например, myArray [1] будет обращаться к первому элементу массива с именем "myArray".

### <a name="input-schema"></a>Схема ввода

Если поток данных использует определенную схему в любом из ее источников, можно ссылаться на столбец по имени во многих выражениях. При использовании смещения схемы можно ссылаться на столбцы явным образом с помощью `byName()` функций или, `byNames()` используя шаблоны столбцов.

#### <a name="column-names-with-special-characters"></a>Имена столбцов с специальными символами

Если имена столбцов содержат специальные символы или пробелы, заключите имя в фигурные скобки, чтобы ссылаться на них в выражении.

```{[dbo].this_is my complex name$$$}```

### <a name="parameters"></a>Параметры

Параметры — это значения, которые передаются в поток данных во время выполнения из конвейера. Чтобы создать ссылку на параметр, либо щелкните параметр в представлении **элементов выражения** , либо сослаться на него с помощью знака доллара перед его именем. Например, на параметре, именуемом параметр1, будет ссылаться `$parameter1` . Дополнительные сведения см. в разделе [параметризация сопоставления потоков данных](parameters-data-flow.md).

### <a name="cached-lookup"></a>Кэшированный поиск

Кэшированный поиск позволяет выполнить встроенный поиск выходных данных кэшированного приемника. Для каждого приемника можно использовать две функции: `lookup()` и `outputs()` . Для ссылки на эти функции используется синтаксис `cacheSinkName#functionName()` . Дополнительные сведения см. в разделе [приемники кэша](data-flow-sink.md#cache-sink).

`lookup()` принимает совпадающие столбцы в текущем преобразовании как параметры и возвращает сложный столбец, равный строке, соответствующей ключевым столбцам в приемнике кэша. Возвращаемый сложный столбец содержит подстолбец для каждого столбца, сопоставленного в приемнике кэша. Например, если у вас есть приемник кэша кода ошибки `errorCodeCache` , которому соответствует ключевой столбец в коде, и столбец с именем `Message` . Вызов `errorCodeCache#lookup(errorCode).Message` возвращает сообщение, соответствующее переданному коду. 

`outputs()` не принимает параметры и возвращает весь приемник кэша в виде массива сложных столбцов. Этот метод не может быть вызван, если ключевые столбцы указаны в приемнике и должны использоваться только при наличии небольшого числа строк в приемнике кэша. Распространенным вариантом использования является добавление максимального значения для инкрементного ключа. Если кэшированная одна статистическая строка `CacheMaxKey` содержит столбец `MaxKey` , то можно сослаться на первое значение, вызвав метод `CacheMaxKey#outputs()[1].MaxKey` .

![Кэшированный поиск](media/data-flow/cached-lookup-example.png "Кэшированный поиск")

### <a name="locals"></a>Локальные

Если вы используете логику совместно с несколькими столбцами или хотите компартментализе логику, можно создать локальную в производном колумн\. Чтобы сослаться на локальную версию, щелкните локальную часть в представлении **элементов выражения** или укажите в ней двоеточие перед его именем. Например, на локальный объект с именем local1 будет ссылаться `:local1` . Дополнительные сведения о локальных переменных см. в [документации по производному столбцу](data-flow-derived-column.md#locals).

## <a name="preview-expression-results"></a>Просмотр результатов выражения

Если включен [режим отладки](concepts-data-flow-debug-mode.md) , можно в интерактивном режиме использовать отладочный кластер для предварительного просмотра результатов вычисления выражения. Нажмите кнопку **Обновить** рядом с пунктом предварительный просмотр данных, чтобы обновить результаты предварительного просмотра данных. Выходные данные каждой строки можно увидеть при наличии входных столбцов.

![Выполняющаяся Предварительная версия](media/data-flow/preview-expression.png "Предварительный просмотр данных выражения")

## <a name="string-interpolation"></a>Интерполяция строк

При создании длинных строк, использующих элементы выражений, используйте интерполяцию строк для простого создания сложной строковой логики. Интерполяция строк позволяет избежать широкого использования объединения строк, если параметры включены в строки запроса. Используйте двойные кавычки для заключения текста литеральной строки вместе с выражениями. Можно включать функции выражений, столбцы и параметры. Чтобы использовать синтаксис выражений, заключите его в фигурные скобки,

Некоторые примеры интерполяции строк:

* ```"My favorite movie is {iif(instr(title,', The')>0,"The {split(title,', The')[1]}",title)}"```

* ```"select * from {$tablename} where orderyear > {$year}"```

* ```"Total cost with sales tax is {round(totalcost * 1.08,2)}"```

* ```"{:playerName} is a {:playerRating} player"```

> [!NOTE]
> При использовании синтаксиса интерполяции строк в SQL исходных запросах строка запроса должна находиться в одной строке, без "/n".

## <a name="commenting-expressions"></a>Выражения комментариев

Добавление комментариев к выражениям с помощью однострочного и многострочного синтаксиса комментариев.

Ниже приведены допустимые комментарии.

* ```/* This is my comment */```

* ```/* This is a```
* ```multi-line comment */```

Если вы поместили комментарий в верхней части выражения, он появится в текстовом поле преобразование, чтобы документировать выражения преобразования.

![Комментарий в текстовом поле преобразования](media/data-flow/comment-expression.png "Комментарии")

## <a name="regular-expressions"></a>Регулярные выражения

Многие функции языка выражений используют синтаксис регулярных выражений. При использовании функций регулярных выражений построитель выражений пытается интерпретировать обратную косую черту ( \\ ) в качестве последовательности escape-символов. При использовании обратных косых черт в регулярном выражении либо заключите все регулярное выражение в обратные ( \` ), либо используйте двойную обратную косую черту.

Пример, использующий обратные кавычки:

```
regex_replace('100 and 200', `(\d+)`, 'digits')
```

Пример, в котором используются двойные косые черты:

```
regex_replace('100 and 200', '(\\d+)', 'digits')
```

## <a name="keyboard-shortcuts"></a>сочетания клавиш

Ниже приведен список сочетаний клавиш, доступных в построителе выражений. При создании выражений доступны большинство сочетаний клавиш IntelliSense.

* CTRL + K CTRL + C: Комментирование всей строки.
* CTRL + K Ctrl + U: раскомментировать.
* F1: предоставление команд справки по редактору.
* Alt + клавиша со стрелкой вниз: перемещение вниз текущей строки.
* Alt + клавиша со стрелкой вверх: перемещение вверх текущей строки.
* Ctrl + пробел: отображение контекстной справки.

## <a name="commonly-used-expressions"></a>Часто используемые выражения

### <a name="convert-to-dates-or-timestamps"></a>Преобразовать в даты или метки времени

Чтобы включить строковые литералы в выходные данные отметок времени, заключите преобразование в ```toString()``` .

```toString(toTimestamp('12/31/2016T00:12:00', 'MM/dd/yyyy\'T\'HH:mm:ss'), 'MM/dd /yyyy\'T\'HH:mm:ss')```

Чтобы преобразовать миллисекунды из эпохи в дату или отметку времени, используйте `toTimestamp(<number of milliseconds>)` . Если время исходят в секундах, умножьте его на 1 000.

```toTimestamp(1574127407*1000l)```

Замыкающий символ "l" в конце предыдущего выражения означает преобразование в тип long в качестве встроенного синтаксиса.

### <a name="find-time-from-epoch-or-unix-time"></a>Поиск времени из эпохи или времени Unix

Толонг (currentTimestamp ()-Тотиместамп (' 1970-01-01 00:00:00.000 ', ' гггг-мм-дд чч: мм: СС. SSS ")) * 1000

## <a name="next-steps"></a>Дальнейшие действия

[Начало создания выражений преобразования данных](data-flow-expression-functions.md)
