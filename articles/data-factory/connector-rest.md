---
title: Копирование данных из конечной точки RESTFUL и обратно в конечную точку с помощью фабрики данных Azure
description: Узнайте, как копировать данные из облачного или локального источника в поддерживаемые хранилища данных-приемники или из поддерживаемого исходного хранилища данных в приемник RESTFUL с помощью действия копирования в конвейере фабрики данных Azure.
author: linda33wj
ms.service: data-factory
ms.topic: conceptual
ms.date: 03/16/2021
ms.author: jingwang
ms.openlocfilehash: 6d9bb17e0e68c563c6d8cc18669d8c298d4f267b
ms.sourcegitcommit: ac035293291c3d2962cee270b33fca3628432fac
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2021
ms.locfileid: "104951850"
---
# <a name="copy-data-from-and-to-a-rest-endpoint-by-using-azure-data-factory"></a>Копирование данных из конечной точки RESTFUL и обратно в конечную точку с помощью фабрики данных Azure
[!INCLUDE[appliesto-adf-asa-md](includes/appliesto-adf-asa-md.md)]

В этой статье описано, как с помощью действия копирования в фабрике данных Azure копировать данные в конечную точку и обратно. Это продолжение статьи о [действии копирования в Фабрике данных Azure](copy-activity-overview.md), в которой представлены общие сведения о действии копирования.

Разница между этим соединителем, [соединителем HTTP](connector-http.md)и [соединителем веб-таблиц](connector-web-table.md) :

- **Соединитель RESTful** специально поддерживает копирование данных из интерфейсов API RESTful. 
- **Соединитель HTTP** является универсальным для получения данных из любой КОНЕЧНОЙ точки HTTP, например для загрузки файла. Перед этим соединителем RESTFUL можно использовать соединитель HTTP для копирования данных из API RESTFUL, который поддерживается, но менее функциональным сравнением с соединителем RESTFUL.
- **Соединитель веб-таблиц** извлекает содержимое таблицы со страницы HTML.

## <a name="supported-capabilities"></a>Поддерживаемые возможности

Данные из источника REST можно скопировать в любое хранилище данных, поддерживаемое в качестве приемника. Вы также можете скопировать данные из любого поддерживаемого исходного хранилища данных в приемник остальных. Список хранилищ данных, поддерживаемых действием копирования в качестве источников и приемников, приведен в разделе [Поддерживаемые хранилища данных и форматы](copy-activity-overview.md#supported-data-stores-and-formats).

Этот универсальный соединитель REST, в частности, поддерживает следующее.

- Копирование данных из конечной точки RESTFUL с помощью методов **Get** или **POST** и копирование данных в конечную точку RESTful с помощью методов **POST**, **WHERE** или **Patch** .
- Копирование данных с помощью одной из следующих проверок подлинности: **Анонимный**, **базовый**, **субъект-служба AAD** и **управляемые удостоверения для ресурсов Azure**.
- **[Разбиение на страницы](#pagination-support)** в интерфейсах REST API.
- Для класса "ОСТАВШАЯся" в качестве источника скопируйте ответ "ОСТАВШИЙся код JSON" [как есть](#export-json-response-as-is) или проанализируйте его с помощью [сопоставления схемы](copy-activity-schema-and-type-mapping.md#schema-mapping). Поддерживаются только полезные данные ответа в **JSON**.

> [!TIP]
> Чтобы проверить запрос для извлечения данных, прежде чем настраивать соединитель REST в Фабрике данных, ознакомьтесь с требованиями спецификации API в отношении заголовка и текста. Для проверки можно использовать такие средства, как Postman или веб-браузер.

## <a name="prerequisites"></a>Предварительные требования

[!INCLUDE [data-factory-v2-integration-runtime-requirements](../../includes/data-factory-v2-integration-runtime-requirements.md)]

## <a name="get-started"></a>Начало работы

[!INCLUDE [data-factory-v2-connector-get-started](../../includes/data-factory-v2-connector-get-started.md)]

В разделах ниже приведены сведения о свойствах, которые используются для определения сущностей Фабрики данных, относящихся к соединителю REST.

## <a name="linked-service-properties"></a>Свойства связанной службы

Для связанной службы REST поддерживаются следующие свойства.

| Свойство | Описание | Обязательно |
|:--- |:--- |:--- |
| type | Для свойства **Type** необходимо задать значение **рестсервице**. | Да |
| url | Базовый URL-адрес службы REST. | Да |
| enableServerCertificateValidation | Следует ли проверять сертификат TLS/SSL на стороне сервера при подключении к конечной точке. | Нет<br /> (значение по умолчанию — **true**) |
| authenticationType | Тип проверки подлинности, используемый для подключения к службе REST. Допустимые значения: **anonymous**, **Basic**, **аадсервицепринЦипал** и **манажедсервицеидентити**. OAuth на основе пользователя не поддерживается. Кроме того, можно настроить заголовки проверки подлинности в `authHeader` свойстве. Обратитесь к соответствующим разделам ниже, в которых описываются дополнительные свойства и примеры.| Да |
| аусхеадерс | Дополнительные заголовки HTTP-запросов для проверки подлинности.<br/> Например, чтобы использовать проверку подлинности с помощью ключа API, можно выбрать тип проверки подлинности "Анонимный" и указать ключ API в заголовке. | Нет |
| connectVia | [Среда выполнения интеграции](concepts-integration-runtime.md), используемая для подключения к хранилищу данных. Дополнительные сведения см. в разделе [Предварительные условия](#prerequisites). Если не указано другое, это свойство по умолчанию использует интегрированную среду выполнения Azure. |Нет |

### <a name="use-basic-authentication"></a>Использование обычной проверки подлинности

Задайте для свойства **authenticationType** значение **Basic**. В дополнение к общим свойствам, описанных в предыдущих разделах, укажите следующие свойства:

| Свойство | Описание | Обязательно |
|:--- |:--- |:--- |
| userName | Имя пользователя для доступа к конечной точке REST. | Да |
| password | Пароль для пользователя (значение **userName**). Пометьте это поле как **SecureString**, чтобы безопасно хранить его в фабрике данных. Вы можете также [указать секрет, хранящийся в Azure Key Vault](store-credentials-in-key-vault.md). | Да |

**Пример**

```json
{
    "name": "RESTLinkedService",
    "properties": {
        "type": "RestService",
        "typeProperties": {
            "authenticationType": "Basic",
            "url" : "<REST endpoint>",
            "userName": "<user name>",
            "password": {
                "type": "SecureString",
                "value": "<password>"
            }
        },
        "connectVia": {
            "referenceName": "<name of Integration Runtime>",
            "type": "IntegrationRuntimeReference"
        }
    }
}
```

### <a name="use-aad-service-principal-authentication"></a>Использование проверки подлинности субъекта-службы AAD

Задайте для свойства **authenticationType** значение **AadServicePrincipal**. В дополнение к общим свойствам, описанных в предыдущих разделах, укажите следующие свойства:

| Свойство | Описание | Обязательно |
|:--- |:--- |:--- |
| servicePrincipalId | Укажите идентификатор клиента приложения Azure Active Directory. | Да |
| servicePrincipalKey | Укажите ключ приложения Azure Active Directory. Пометьте это поле как **SecureString**, чтобы безопасно хранить его в фабрике данных, или [добавьте ссылку на секрет, хранящийся в Azure Key Vault](store-credentials-in-key-vault.md). | Да |
| tenant | Укажите сведения о клиенте (доменное имя или идентификатор клиента), в котором находится приложение. Его можно получить, наведя указатель мыши на правый верхний угол страницы портала Azure. | Да |
| aadResourceId | Укажите ресурс AAD, для которого запрашивается авторизация, например `https://management.core.windows.net` .| Да |
| азуреклаудтипе | Для проверки подлинности субъекта-службы укажите тип облачной среды Azure, в которой зарегистрировано приложение AAD. <br/> Допустимые значения: **азурепублик**, **AzureChina**, **AzureUsGovernment** и **азурежермани**. По умолчанию используется облачная среда фабрики данных. | Нет |

**Пример**

```json
{
    "name": "RESTLinkedService",
    "properties": {
        "type": "RestService",
        "typeProperties": {
            "url": "<REST endpoint e.g. https://www.example.com/>",
            "authenticationType": "AadServicePrincipal",
            "servicePrincipalId": "<service principal id>",
            "servicePrincipalKey": {
                "value": "<service principal key>",
                "type": "SecureString"
            },
            "tenant": "<tenant info, e.g. microsoft.onmicrosoft.com>",
            "aadResourceId": "<AAD resource URL e.g. https://management.core.windows.net>"
        },
        "connectVia": {
            "referenceName": "<name of Integration Runtime>",
            "type": "IntegrationRuntimeReference"
        }
    }
}
```

### <a name="use-managed-identities-for-azure-resources-authentication"></a><a name="managed-identity"></a> Использование аутентификации управляемых удостоверений для ресурсов Azure

Задайте для свойства **authenticationType** значение **ManagedServiceIdentity**. В дополнение к общим свойствам, описанных в предыдущих разделах, укажите следующие свойства:

| Свойство | Описание | Обязательно |
|:--- |:--- |:--- |
| aadResourceId | Укажите ресурс AAD, для которого запрашивается авторизация, например `https://management.core.windows.net` .| Да |

**Пример**

```json
{
    "name": "RESTLinkedService",
    "properties": {
        "type": "RestService",
        "typeProperties": {
            "url": "<REST endpoint e.g. https://www.example.com/>",
            "authenticationType": "ManagedServiceIdentity",
            "aadResourceId": "<AAD resource URL e.g. https://management.core.windows.net>"
        },
        "connectVia": {
            "referenceName": "<name of Integration Runtime>",
            "type": "IntegrationRuntimeReference"
        }
    }
}
```

### <a name="using-authentication-headers"></a>Использование заголовков проверки подлинности

Кроме того, можно настроить заголовки запроса для проверки подлинности вместе со встроенными типами проверки подлинности.

**Пример. Использование проверки подлинности ключа API**

```json
{
    "name": "RESTLinkedService",
    "properties": {
        "type": "RestService",
        "typeProperties": {
            "url": "<REST endpoint>",
            "authenticationType": "Anonymous",
            "authHeader": {
                "x-api-key": {
                    "type": "SecureString",
                    "value": "<API key>"
                }
            }
        },
        "connectVia": {
            "referenceName": "<name of Integration Runtime>",
            "type": "IntegrationRuntimeReference"
        }
    }
}
```

## <a name="dataset-properties"></a>Свойства набора данных

Этот раздел содержит список свойств, поддерживаемых набором данных REST. 

Полный список разделов и свойств, используемых для определения наборов данных, приведен в статье [Наборы данных и связанные службы в фабрике данных Azure](concepts-datasets-linked-services.md). 

Для копирования данных из REST поддерживаются следующие свойства.

| Свойство | Описание | Обязательно |
|:--- |:--- |:--- |
| type | Для свойства **type** набора данных необходимо задать значение **RestResource**. | Да |
| relativeUrl | Относительный URL-адрес ресурса, который содержит данные. Если свойство не задано, используется только URL-адрес, указанный в определении связанной службы. Соединитель HTTP копирует данные из комбинированного URL-адреса: `[URL specified in linked service]/[relative URL specified in dataset]` . | Нет |

Если вы настраиваете `requestMethod` , `additionalHeaders` `requestBody` и `paginationRules` в наборе данных, он по-прежнему поддерживается "как есть", хотя вы предлагаете использовать новую модель в действии вперед.

**Пример**.

```json
{
    "name": "RESTDataset",
    "properties": {
        "type": "RestResource",
        "typeProperties": {
            "relativeUrl": "<relative url>"
        },
        "schema": [],
        "linkedServiceName": {
            "referenceName": "<REST linked service name>",
            "type": "LinkedServiceReference"
        }
    }
}
```

## <a name="copy-activity-properties"></a>Свойства действия копирования

В этом разделе содержится список свойств, поддерживаемых источником и приемником оставшейся части.

Полный список разделов и свойств, доступных для определения действий, см. в статье, посвященной [конвейерам и действиям в Фабрике данных Azure](concepts-pipelines-activities.md). 

### <a name="rest-as-source"></a>REST в качестве источника

В разделе **source** действия копирования поддерживаются следующие свойства:

| Свойство | Описание | Обязательно |
|:--- |:--- |:--- |
| type | Свойство **type** источника действия копирования должно иметь значение **RestSource**. | Да |
| requestMethod | Метод HTTP. Допустимые значения: **Get** (по умолчанию) и **POST**. | Нет |
| additionalHeaders | Дополнительные заголовки HTTP-запроса. | Нет |
| requestBody | Текст HTTP-запроса. | Нет |
| paginationRules | Правила разбиения на страницы для составления следующих запросов страниц. Дополнительные сведения см. в разделе, посвященном [поддержке разбиения на страницы](#pagination-support). | нет |
| httpRequestTimeout | Время ожидания (значение **Временной диапазон**) ответа для HTTP-запроса. Это значение является интервалом времени для получения ответа, а не считывания данных ответа. По умолчанию используется значение **00:01:40**.  | Нет |
| requestInterval | Время ожидания перед отправкой запроса следующей страницы. Значение по умолчанию — **00:00:01** |  Нет |

>[!NOTE]
>Соединитель RESTFUL игнорирует любой заголовок Accept, указанный в `additionalHeaders` . Так как соединитель RESTFUL поддерживает только ответ в JSON, он автоматически создает заголовок `Accept: application/json` .

**Пример 1. использование метода Get с разбивкой на страницы**

```json
"activities":[
    {
        "name": "CopyFromREST",
        "type": "Copy",
        "inputs": [
            {
                "referenceName": "<REST input dataset name>",
                "type": "DatasetReference"
            }
        ],
        "outputs": [
            {
                "referenceName": "<output dataset name>",
                "type": "DatasetReference"
            }
        ],
        "typeProperties": {
            "source": {
                "type": "RestSource",
                "additionalHeaders": {
                    "x-user-defined": "helloworld"
                },
                "paginationRules": {
                    "AbsoluteUrl": "$.paging.next"
                },
                "httpRequestTimeout": "00:01:00"
            },
            "sink": {
                "type": "<sink type>"
            }
        }
    }
]
```

**Пример 2. Использование метода POST**

```json
"activities":[
    {
        "name": "CopyFromREST",
        "type": "Copy",
        "inputs": [
            {
                "referenceName": "<REST input dataset name>",
                "type": "DatasetReference"
            }
        ],
        "outputs": [
            {
                "referenceName": "<output dataset name>",
                "type": "DatasetReference"
            }
        ],
        "typeProperties": {
            "source": {
                "type": "RestSource",
                "requestMethod": "Post",
                "requestBody": "<body for POST REST request>",
                "httpRequestTimeout": "00:01:00"
            },
            "sink": {
                "type": "<sink type>"
            }
        }
    }
]
```

### <a name="rest-as-sink"></a>ОСТАВШАЯся как приемник

В разделе **sink** действия копирования поддерживаются следующие свойства:

| Свойство | Описание | Обязательно |
|:--- |:--- |:--- |
| type | Свойство **Type** приемника действия копирования должно иметь значение **рестсинк**. | Да |
| requestMethod | Метод HTTP. Допустимые значения: **POST** (по умолчанию), « **Вставить**» и « **Patch**». | Нет |
| additionalHeaders | Дополнительные заголовки HTTP-запроса. | нет |
| httpRequestTimeout | Время ожидания (значение **Временной диапазон**) ответа для HTTP-запроса. Это значение представляет собой время ожидания для получения ответа, а не время ожидания записи данных. По умолчанию используется значение **00:01:40**.  | Нет |
| requestInterval | Интервал времени между различными запросами в миллисекундах. Значение интервала запроса должно быть числом в диапазоне от [10 до 60000]. |  Нет |
| хттпкомпрессионтипе | Тип сжатия HTTP для использования при отправке данных с оптимальным уровнем сжатия. Допустимые значения: **None** и **gzip**. | Нет |
| writeBatchSize | Число записей, записываемых в приемник оставшейся части на пакет. Значение по умолчанию — 10 000. | Нет |

Соединитель RESTFUL в качестве приемника работает с интерфейсами API, принимающими JSON. Данные будут отправлены в JSON со следующим шаблоном. При необходимости можно использовать [сопоставление схемы](copy-activity-schema-and-type-mapping.md#schema-mapping) действия копирования, чтобы изменить форму исходных данных, чтобы они соответствовали ожидаемым полезным данным REST API.

```json
[
    { <data object> },
    { <data object> },
    ...
]
```

**Пример**.

```json
"activities":[
    {
        "name": "CopyToREST",
        "type": "Copy",
        "inputs": [
            {
                "referenceName": "<input dataset name>",
                "type": "DatasetReference"
            }
        ],
        "outputs": [
            {
                "referenceName": "<REST output dataset name>",
                "type": "DatasetReference"
            }
        ],
        "typeProperties": {
            "source": {
                "type": "<source type>"
            },
            "sink": {
                "type": "RestSink",
                "requestMethod": "POST",
                "httpRequestTimeout": "00:01:40",
                "requestInterval": 10,
                "writeBatchSize": 10000,
                "httpCompressionType": "none",
            },
        }
    }
]
```

## <a name="pagination-support"></a>Поддержка разбиения на страницы

При копировании данных из API-интерфейсов RESTFUL обычно REST API ограничивает размер полезных данных ответа одного запроса по разумному числу; Хотя для получения большого объема данных он разделяет результат на несколько страниц и требует от вызывающих объектов отправку последовательных запросов для получения следующей страницы результата. Обычно запрос одной страницы является динамическим и состоит из сведений, возвращенных из ответа предыдущей страницы.

Этот универсальный соединитель REST поддерживает следующие шаблоны разбиения на страницы: 

* Абсолютный или относительный URL-адрес следующего запроса = значение свойства в текущем тексте ответа
* Абсолютный или относительный URL-адрес следующего запроса = значение заголовка в текущем заголовке ответа
* параметр запроса следующего запроса = значение свойства в текущем тексте ответа;
* параметр запроса следующего запроса = значение заголовка в текущих заголовках ответа;
* заголовок следующего запроса = значение свойства в текущем тексте ответа;
* заголовок следующего запроса = значение заголовка в текущих заголовках ответа.

**Правила разбиения на страницы** определяются в виде словаря в наборе данных, который содержит одну или несколько пар "ключ-значение", учитывающих регистр. Эта конфигурация будет использоваться для создания запроса, начиная со второй страницы. Соединитель перестанет проходить итерацию, когда он получает код состояния HTTP 204 (без содержимого), или любое из выражений JSONPath в "Пагинатионрулес" возвращает значение null.

**Поддерживаемые ключи** в правилах разбиения на страницы

| Клавиши | Описание |
|:--- |:--- |
| AbsoluteUrl | Указывает URL-адрес для выполнения следующего запроса. Это может быть **абсолютный URL-адрес или относительный URL-адрес**. |
| QueryParameters.*параметр_запроса_запроса* ИЛИ QueryParameters['параметр_запроса_запроса'] | "request_query_parameter" является определяемым пользователем, который ссылается на одно имя параметра запроса в следующем URL-адресе запроса HTTP. |
| Headers.*заголовок_запроса* ИЛИ Headers['заголовок_запроса'] | "request_header" является определяемым пользователем, который ссылается на одно имя заголовка в следующем HTTP-запросе. |

**Поддерживаемые значения** в правилах разбиения на страницы

| Значение | Описание |
|:--- |:--- |
| Headers.*заголовок_ответа* ИЛИ Headers['заголовок_ответа'] | "response_header" является определяемым пользователем, который ссылается на одно имя заголовка в текущем HTTP-ответе, значение которого будет использоваться для выдаче следующего запроса. |
| Выражение JSONPath, начинающееся с $ (представляет корневую часть текста ответа) | Текст ответа должен содержать только один объект JSON. Выражение JSONPath должно возвращать одно значение-примитив, которое будет использоваться для выдачи следующего запроса. |

**Пример**.

Facebook Graph API возвращает ответ со следующей структурой. В этом случае URL-адрес следующей странице представлен в ***paging.next***.

```json
{
    "data": [
        {
            "created_time": "2017-12-12T14:12:20+0000",
            "name": "album1",
            "id": "1809938745705498_1809939942372045"
        },
        {
            "created_time": "2017-12-12T14:14:03+0000",
            "name": "album2",
            "id": "1809938745705498_1809941802371859"
        },
        {
            "created_time": "2017-12-12T14:14:11+0000",
            "name": "album3",
            "id": "1809938745705498_1809941879038518"
        }
    ],
    "paging": {
        "cursors": {
            "after": "MTAxNTExOTQ1MjAwNzI5NDE=",
            "before": "NDMyNzQyODI3OTQw"
        },
        "previous": "https://graph.facebook.com/me/albums?limit=25&before=NDMyNzQyODI3OTQw",
        "next": "https://graph.facebook.com/me/albums?limit=25&after=MTAxNTExOTQ1MjAwNzI5NDE="
    }
}
```

Соответствующая конфигурация источника действия копирования для остальных компонентов, в особенности, выглядит `paginationRules` следующим образом:

```json
"typeProperties": {
    "source": {
        "type": "RestSource",
        "paginationRules": {
            "AbsoluteUrl": "$.paging.next"
        },
        ...
    },
    "sink": {
        "type": "<sink type>"
    }
}
```

## <a name="use-oauth"></a>Использование OAuth
В этом разделе описывается использование шаблона решения для копирования данных из соединителя RESTFUL в Azure Data Lake Storage в формате JSON с помощью OAuth. 

### <a name="about-the-solution-template"></a>О шаблоне решения

Шаблон содержит два действия:
- **Веб-** действие получает маркер носителя и передает его в действие копирования в качестве авторизации.
- Действие **копирования** копирует данные из неактивных данных в Azure Data Lake Storage.

Шаблон определяет два параметра.
- **Синкконтаинер** — путь к корневой папке, куда копируются данные в Azure Data Lake Storage. 
- **Синкдиректори** — это путь к каталогу в корне, куда копируются данные в Azure Data Lake Storage. 

### <a name="how-to-use-this-solution-template"></a>Использование шаблона решения

1. Перейдите к **копии из RESTful или HTTP с помощью шаблона OAuth** . Создать новое соединение для соединения с источником. 
    ![Создание новых подключений](media/solution-template-copy-from-rest-or-http-using-oauth/source-connection.png)

    Ниже приведены основные шаги для новых параметров связанной службы (RESTFUL).
    
     1. В разделе **базовый URL-адрес** укажите параметр URL-адреса для собственной ИСХОДНОЙ службы RESTful. 
     2. В качестве **типа проверки подлинности** выберите *Анонимный*.
        ![Новое подключение к ОСТАВШИМся](media/solution-template-copy-from-rest-or-http-using-oauth/new-rest-connection.png)

2. Создайте новое соединение для соединения с назначением.  
    ![Новое подключение Gen2](media/solution-template-copy-from-rest-or-http-using-oauth/destination-connection.png)

3. Щелкните **Использовать этот шаблон**.
    ![Использовать этот шаблон](media/solution-template-copy-from-rest-or-http-using-oauth/use-this-template.png)

4. Вы увидите созданный конвейер, как показано в следующем примере:  ![ на снимке экрана показан конвейер, созданный на основе шаблона.](media/solution-template-copy-from-rest-or-http-using-oauth/pipeline.png)

5. Выберите **веб-** действие. В окне **Параметры** укажите соответствующий **URL-адрес**, **метод**, **заголовки** и **текст** для получения токена носителя OAuth из API входа службы, из которой нужно скопировать данные. Заполнитель в шаблоне демонстрирует пример Azure Active Directory (AAD) OAuth. Примечание. Проверка подлинности AAD изначально поддерживается соединителем RESTFUL. Вот пример для потока OAuth. 

    | Свойство | Описание |
    |:--- |:--- |
    | URL-адрес |Укажите URL-адрес для получения токена носителя OAuth. Например, в примере здесь https://login.microsoftonline.com/microsoft.onmicrosoft.com/oauth2/token |. 
    | Метод | Метод HTTP. Допустимые значения: **POST** и **Get**. | 
    | Заголовки | Заголовок определяется пользователем, который ссылается на одно имя заголовка в HTTP-запросе. | 
    | Текст | Текст HTTP-запроса. | 

    ![Конвейер](media/solution-template-copy-from-rest-or-http-using-oauth/web-settings.png)

6. На вкладке «действие **копирования данных** » выберите « *источник* », можно увидеть, что токен носителя (ACCESS_TOKEN), полученный из предыдущего шага, будет передан в действие копирование данных как **авторизация** в дополнительных заголовках. Перед запуском конвейера подтвердите параметры следующих свойств.

    | Свойство | Описание |
    |:--- |:--- |
    | Метод запроса | Метод HTTP. Допустимые значения: **GET** (по умолчанию) и **POST**. | 
    | Дополнительные заголовки | Дополнительные заголовки HTTP-запроса.| 

   ![Копировать исходную проверку подлинности](media/solution-template-copy-from-rest-or-http-using-oauth/copy-data-settings.png)

7. Выберите **Отладка**, введите **Параметры**, а затем нажмите **Готово**.
   ![Запуск конвейера](media/solution-template-copy-from-rest-or-http-using-oauth/pipeline-run.png) 

8. После успешного выполнения конвейера вы увидите результат, аналогичный приведенному в следующем примере: ![ результат выполнения конвейера.](media/solution-template-copy-from-rest-or-http-using-oauth/run-result.png) 

9. Щелкните значок "выходные данные" в столбце " **действия** ", чтобы увидеть ACCESS_TOKEN, возвращенные службой.

   ![Выходные данные токена](media/solution-template-copy-from-rest-or-http-using-oauth/token-output.png) 

10. Щелкните значок input (вход) в столбце CopyActivity in **Actions (действия** ). Вы увидите, что ACCESS_TOKEN, извлекаемые службой CopyActivity для проверки подлинности. 

    ![Входные данные токена](media/solution-template-copy-from-rest-or-http-using-oauth/token-input.png)
        
    >[!CAUTION] 
    >Чтобы предотвратить запись маркера в обычный текст, включите параметр "безопасный вывод" в веб-действии и "безопасный ввод" в действии копирования.


## <a name="export-json-response-as-is"></a>Экспорт ответа JSON "как есть"

Вы можете использовать этот соединитель REST для экспорта ответа JSON REST API "как есть" в различные файловые хранилища. Для такого независимого от схемы копирования пропустите раздел "структура" (также называемый *схема*) в наборе данных и сопоставление схемы в действии копирования.

## <a name="schema-mapping"></a>Сопоставление схем

Инструкции по копированию данных из конечной точки REST в табличный приемник см. в разделе о [сопоставлении схем](copy-activity-schema-and-type-mapping.md#schema-mapping).

## <a name="next-steps"></a>Дальнейшие действия

В разделе [Поддерживаемые хранилища данных и форматы](copy-activity-overview.md#supported-data-stores-and-formats) приведен список хранилищ данных, которые поддерживаются в качестве источников и приемников для действия копирования в Фабрике данных Azure.
