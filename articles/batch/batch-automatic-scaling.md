---
title: Автоматическое масштабирование вычислительных узлов в пуле пакетной службы Azure
description: Включение автоматического масштабирования в облачном пуле для динамического изменения количества вычислительных узлов в пуле.
ms.topic: how-to
ms.date: 11/23/2020
ms.custom: H1Hack27Feb2017, fasttrack-edit, devx-track-csharp
ms.openlocfilehash: 06f717e7c3ab8285b494f89c39838af6b0d96c8f
ms.sourcegitcommit: d4734bc680ea221ea80fdea67859d6d32241aefc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2021
ms.locfileid: "100381432"
---
# <a name="create-an-automatic-formula-for-scaling-compute-nodes-in-a-batch-pool"></a>Создание формулы для автоматизации масштабирования вычислительных узлов в пуле пакетной службы

Пакетная служба Azure может автоматически масштабировать пулы на основе определяемых вами параметров, экономя время и деньги. При автоматическом масштабировании Пакетная служба динамически добавляет узлы в пул при увеличении требований задачи и удаляет узлы вычислений по мере уменьшения требований задач.

Чтобы включить автоматическое масштабирование в пуле для кластеров вычислений, необходимо связать пул с заданной *формулой автомасштабирования* . Пакетная служба использует формулу автомасштабирования для определения количества узлов, необходимых для выполнения рабочей нагрузки. Это могут быть выделенные узлы или [узлы с низким приоритетом](batch-low-pri-vms.md). Затем Пакетная служба периодически проверяет данные метрик службы и использует ее для корректировки количества узлов в пуле в зависимости от формулы и с определенным интервалом.

Вы можете включить автоматическое масштабирование при создании пула или применить его к существующему пулу. С помощью пакетной службы можно контролировать работу формул перед их применением к пулам, а также отслеживать состояние автоматического масштабирования. После настройки автоматического масштабирования пула можно внести изменения в формулу позже.

> [!IMPORTANT]
> При создании учетной записи пакетной службы можно указать [режим распределения пула](accounts.md), который определяет, будут ли распределяться пулы в подписке на пакетную службу (по умолчанию) или в пользовательской подписке. Если вы создали учетную запись пакетной службы с конфигурацией пакетных служб по умолчанию, то ваша учетная запись ограничена максимальным числом ядер, которые можно использовать для обработки. Пакетная служба будет создавать вычислительные узлы только до достижения этого предельного количества ядер. По этой причине пакетная служба может не достигать требуемого количества вычислительных узлов, определенного формулой автомасштабирования. Сведения о просмотре и увеличении квот для учетной записи приведены в статье [Квоты и ограничения пакетной службы Azure](batch-quota-limit.md) .
>
>Если вы создали учетную запись с пользовательским режимом подписки, то ваша учетная запись использует общую квоту для подписки. Дополнительные сведения см. в разделе [Ограничения виртуальных машин](../azure-resource-manager/management/azure-subscription-service-limits.md#virtual-machines-limits) в статье [Подписка Azure, границы, квоты и ограничения службы](../azure-resource-manager/management/azure-subscription-service-limits.md).

## <a name="autoscale-formulas"></a>Автомасштабирование формул

Формула автомасштабирования — это строковое значение, которое вы определяете, содержащее одну или несколько инструкций. Формула автоматического масштабирования назначается элементу [autoScaleFormula](/rest/api/batchservice/enable-automatic-scaling-on-a-pool) пула (REST для пакетной службы) или свойству [CloudPool.AutoScaleFormula](/dotnet/api/microsoft.azure.batch.cloudpool.autoscaleformula) (.NET для пакетной службы). С помощью этой формулы пакетная служба определяет целевое количество вычислительных узлов в пуле для следующего интервала обработки. Строка формулы не может превышать 8 КБ, может включать до 100 инструкций, разделенных точкой с запятой, и может включать разрывы строк и комментарии.

Вы можете представить, что формулы автоматического масштабирования — это язык автомасштабирования пакетной службы. Операторы формулы — это выражения с произвольным форматом, которые могут включать как определяемые службой переменные (определяемые пакетной службой), так и пользовательские переменные. Формулы могут выполнять различные операции с этими значениями с помощью встроенных типов, операторов и функций. Например, инструкция может принимать следующую форму:

```
$myNewVariable = function($ServiceDefinedVariable, $myCustomVariable);
```

Обычно формулы содержат несколько инструкций, выполняющих операции со значениями, полученными в предыдущих инструкциях. Например, сначала получим значение для `variable1`, а затем передадим его функции для заполнения `variable2`:

```
$variable1 = function1($ServiceDefinedVariable);
$variable2 = function2($OtherServiceDefinedVariable, $variable1);
```

Добавьте эти операторы в формулу автомасштабирования, чтобы получить целевое количество вычислительных узлов. Выделенные узлы и узлы с низким приоритетом имеют собственные целевые параметры. Формула автомасштабирования может включать в себя целевое значение для выделенных узлов, целевое значение для узлов с низким приоритетом или и то, и другое.

Целевое количество узлов может быть меньше или больше текущего количества узлов данного типа в пуле либо быть равным ему. Пакетная служба оценивает формулу автомасштабирования пула с определенными [интервалами автоматического масштабирования](#automatic-scaling-interval). Затем она изменяет целевое количество узлов каждого типа в пуле на новое значение, полученное по формуле автомасштабирования на момент оценки.

### <a name="sample-autoscale-formulas"></a>Примеры формул автомасштабирования

Ниже представлены два примера формул автомасштабирования, которые можно адаптировать для большинства сценариев. Переменные `startingNumberOfVMs` и `maxNumberofVMs` в этих формулах можно изменять произвольным образом.

#### <a name="pending-tasks"></a>Ожидающие выполнения задачи

Если используется эта формула автоматического масштабирования, пул создается с одной виртуальной машиной. Метрика `$PendingTasks` обозначает количество задач, находящихся в очереди или в состоянии выполнения. Формула находит среднее число ожидающих выполнения задач за последние 180 секунд и соответствующим образом задает значение переменной `$TargetDedicatedNodes`. Формула гарантирует, что целевое число выделенных узлов никогда не превысит значение 25. По мере добавления новых задач пул автоматически расширяется. По мере завершения задач виртуальные машины становятся свободными, а формула автомасштабирования сжимает пул.

Эта формула масштабирует выделенные узлы, но ее можно изменить для масштабирования узлов с низким приоритетом.

```
startingNumberOfVMs = 1;
maxNumberofVMs = 25;
pendingTaskSamplePercent = $PendingTasks.GetSamplePercent(180 * TimeInterval_Second);
pendingTaskSamples = pendingTaskSamplePercent < 70 ? startingNumberOfVMs : avg($PendingTasks.GetSample(180 * TimeInterval_Second));
$TargetDedicatedNodes=min(maxNumberofVMs, pendingTaskSamples);
$NodeDeallocationOption = taskcompletion;
```

#### <a name="preempted-nodes"></a>Замещенные узлы

В этом примере используется пул, который создается с 25 узлами с низким приоритетом. При каждом замещении узла с низким приоритетом такой узел заменяется выделенным узлом. Как и в первом примере, переменная `maxNumberofVMs` не позволяет увеличивать пул, добавляя больше 25 виртуальных машин. Этот пример показывает преимущества использования виртуальных машин с низким приоритетом. При этом в течение всего времени существования пула будет выполнено только фиксированное количество замещений.

```
maxNumberofVMs = 25;
$TargetDedicatedNodes = min(maxNumberofVMs, $PreemptedNodeCount.GetSample(180 * TimeInterval_Second));
$TargetLowPriorityNodes = min(maxNumberofVMs , maxNumberofVMs - $TargetDedicatedNodes);
$NodeDeallocationOption = taskcompletion;
```

Дополнительные сведения о [создании формул автомасштабирования](#write-an-autoscale-formula) и дополнительные [примеры формул автомасштабирования](#example-autoscale-formulas) см. Далее в этом разделе.

## <a name="variables"></a>Переменные

В формуле автоматического масштабирования можно использовать как **служебные**, так и **пользовательские** переменные.

Служебные переменные встроены в пакетную службу. Некоторые из них доступны для чтения и записи, а некоторые — только для чтения.

Пользовательские переменные — это переменные, которые определяете вы. В примере формулы, приведенной выше, `$TargetDedicatedNodes` и `$PendingTasks` являются переменными, определяемыми службой, тогда как `startingNumberOfVMs` и `maxNumberofVMs` являются определяемыми пользователем переменными.

> [!NOTE]
> Служебные переменные всегда начинаются с символа доллара ($). Для определяемых пользователем переменных знак доллара является необязательным.

В следующих таблицах показаны переменные, доступные только для чтения и записи и определенные пакетной службой.

### <a name="read-write-service-defined-variables"></a>Определяемые службой переменные для чтения и записи

Вы можете получить и задать значения этих переменных, определяемых службой, чтобы управлять количеством расчетных узлов в пуле.

| Переменная | Описание |
| --- | --- |
| $TargetDedicatedNodes |Целевое количество выделенных вычислительных узлов для пула. Это значение указывается в качестве целевого объекта, так как пул не всегда достигает требуемого количества узлов. Например, если целевое количество выделенных узлов изменяется при оценке автомасштабирования до того, как пул достиг первоначального целевого объекта, пул может не достичь целевого объекта. <br /><br /> Пул в учетной записи, созданной в режиме пакетной службы, может не достичь цели, если целевой объект превышает квоту узла или ядра учетной записи пакета. Пул в учетной записи, созданной в режиме пользовательской подписки, может не достичь целевого объекта, если целевой объект превышает квоту общего ядра для подписки.|
| $TargetLowPriorityNodes |Целевое количество вычислительных узлов с низким приоритетом для пула. Он указан как целевой, так как пул не всегда достигает требуемого количества узлов. Например, если целевое количество узлов с низким приоритетом изменяется при оценке автомасштабирования до того, как пул достигнет первоначального целевого объекта, пул может не достичь целевого объекта. Это также может произойти, если целевое количество превышает квоту узлов или ядер в учетной записи пакетной службы. <br /><br /> Дополнительные сведения о вычислительных узлах с низким приоритетом см. в статье [Использование низкоприоритетных виртуальных машин в пакетной службе](batch-low-pri-vms.md). |
| $NodeDeallocationOption |Действие, выполняемое после удаления вычислительных узлов из пула. Возможны следующие значения:<ul><li>**Queue**: значение по умолчанию. Завершает задачи немедленно и помещает их обратно в очередь заданий, чтобы они были перепланированы. Это действие гарантирует, что целевое количество узлов будет достигнуто максимально быстро. Однако это может быть менее эффективным, так как все выполняющиеся задачи будут прерваны, а затем будут полностью перезапущены. <li>**Завершение**: немедленно завершает задачи и удаляет их из очереди заданий.<li>**taskcompletion**: ожидает завершения выполняемых в данный момент задач, а затем удаляет узел из пула. Используйте этот параметр, чтобы избежать прерывания и повторного постановки в очередь задач, тратя на работу, выполненную задачей.<li>**retaineddata**: Ожидание очистки всех локальных данных, хранящихся на узле, перед удалением узла из пула.</ul> |

> [!NOTE]
> Вместо переменной `$TargetDedicatedNodes` также можно использовать ее псевдоним `$TargetDedicated`, а вместо `$TargetLowPriorityNodes` — псевдоним `$TargetLowPriority`. Если формула присваивает значения переменной как по полному имени, так и по псевдониму, приоритетным будет значение, присвоенное по полному имени.

### <a name="read-only-service-defined-variables"></a>Определяемые службой переменные только для чтения

Вы можете получить значения этих переменных, определяемых службой, чтобы внести изменения, основанные на метриках из пакетной службы.

> [!IMPORTANT]
> Задачи выпуска заданий в настоящее время не включены в переменные, которые предоставляют счетчики задач, такие как $ActiveTasks и $PendingTasks. В зависимости от формулы автомасштабирования это может привести к удалению узлов без доступных узлов для выполнения задач выпуска задания.

| Переменная | Описание |
| --- | --- |
| $CPUPercent |Средний объем использования ЦП в процентах. |
| $WallClockSeconds |Затраченное время в секундах. |
| $MemoryBytes |Среднее количество используемых мегабайт. |
| $DiskBytes |Среднее количество гигабайт, используемых на локальных дисках. |
| $DiskReadBytes |Число переданных байтов. |
| $DiskWriteBytes |Количество записанных байт. |
| $DiskReadOps |Количество операций чтения с диска. |
| $DiskWriteOps |Количество операций записи на диск. |
| $NetworkInBytes |Количество входящих байт. |
| $NetworkOutBytes |Количество исходящих байт. |
| $SampleNodeCount |Количество вычислительных узлов. |
| $ActiveTasks |Количество задач, готовых к выполнению, но еще не выполняющихся. Сюда входят все задачи в активном состоянии, зависимости которых удовлетворены. Задачи в активном состоянии, зависимости которых не выполнены, не включаются в значение $ActiveTasks. Для задачи с несколькими экземплярами $ActiveTasks будет включать число экземпляров, заданное для этой задачи.|
| $RunningTasks |Количество задач в состоянии выполнения. |
| $PendingTasks |Сумма $ActiveTasks и $RunningTasks. |
| $SucceededTasks |Количество успешно выполненных задач. |
| $FailedTasks |Количество задач, которые не удалось выполнить. |
| $TaskSlotsPerNode |Количество слотов задач, которые могут использоваться для выполнения параллельных задач на одном кластерном узле в пуле. |
| $CurrentDedicatedNodes |Текущее количество выделенных вычислительных узлов. |
| $CurrentLowPriorityNodes |Текущее количество вычислительных узлов с низким приоритетом, включая все замещенные узлы. |
| $PreemptedNodeCount | Количество узлов в пуле, которые находятся в замещенном состоянии. |

> [!TIP]
> Эти переменные, доступные только для чтения, являются *объектами* , которые предоставляют различные методы для доступа к данным, связанным с каждым из них. Дополнительные сведения см. в разделе [Получение выборки данных](#obtain-sample-data) далее в этой статье.

> [!NOTE]
> Используется `$RunningTasks` при масштабировании на основе числа задач, выполняемых в момент времени, а также `$ActiveTasks` при масштабировании в зависимости от количества задач, которые были поставлены в очередь для выполнения.

## <a name="types"></a>Типы

Формулы автомасштабирования поддерживают следующие типы:

- double
- doubleVec
- doubleVecList
- строка
- timestamp — составная структура, которая содержит следующие члены:
  - year
  - month (1-12)
  - day (1-31)
  - weekday (в формате числа, например 1 — понедельник)
  - hour (час в 24-часовом формате, например 13 соответствует 13:00)
  - minute (00–59)
  - second (00–59)
- timeInterval
  - TimeInterval_Zero
  - TimeInterval_100ns
  - TimeInterval_Microsecond
  - TimeInterval_Millisecond
  - TimeInterval_Second
  - TimeInterval_Minute
  - TimeInterval_Hour
  - TimeInterval_Day
  - TimeInterval_Week
  - TimeInterval_Year

## <a name="operations"></a>Операции

Для перечисленных в предыдущем разделе типов разрешены перечисленные ниже операции.

| Операция | Поддерживаемые операторы | Тип результата |
| --- | --- | --- |
| double *оператор* double |+, -, *, / |double |
| double *оператор* timeinterval |* |timeInterval |
| doubleVec *оператор* double |+, -, *, / |doubleVec |
| doubleVec *оператор* doubleVec |+, -, *, / |doubleVec |
| timeinterval *оператор* double |*, / |timeInterval |
| timeinterval *оператор* timeinterval |+, – |timeInterval |
| timeinterval *оператор* timestamp |+ |TIMESTAMP |
| timestamp *оператор* timeinterval |+ |TIMESTAMP |
| timestamp *оператор* timestamp |- |timeInterval |
| *оператор* Double |-, ! |double |
| *оператор* timeInterval |- |timeInterval |
| double *оператор* double |<, <=, ==, >=, >, != |double |
| string *оператор* string |<, <=, ==, >=, >, != |double |
| timestamp *оператор* timestamp |<, <=, ==, >=, >, != |double |
| timeinterval *оператор* timeinterval |<, <=, ==, >=, >, != |double |
| double *оператор* double |&&, &#124;&#124; |double |

При тестировании double с тернарным оператором (`double ? statement1 : statement2`) ненулевое значение равно **true**, а нулевое — **false**.

## <a name="functions"></a>Функции

Эти стандартные **функции** можно использовать при определении формулы автомасштабирования.

| Компонент | Возвращаемый тип | Описание |
| --- | --- | --- |
| avg(doubleVecList) |double |Среднее значение для всех значений в doubleVecList. |
| len(doubleVecList) |double |Возвращает длину вектора, созданного из doubleVecList. |
| lg(double) |double |Возвращает логарифм double по основанию 2. |
| lg(doubleVecList) |doubleVec |Возвращает покомпонентный логарифм по основанию 2 от значения doubleVecList. В качестве параметра необходимо явно передать vec(double). В противном случае предполагается использование версии lg(double). |
| ln(double) |double |Возвращает натуральный логарифм double. |
| ln(doubleVecList) |doubleVec |Возвращает натуральный логарифм double. |
| log(double) |double |Возвращает логарифм double по основанию 10. |
| log(doubleVecList) |doubleVec |Возвращает покомпонентный логарифм по основанию 10 от значения doubleVecList. В качестве одного параметра double необходимо явно передать vec(double). В противном случае предполагается использование версии log(double). |
| max(doubleVecList) |double |Возвращает максимальное значение в doubleVecList. |
| min(doubleVecList) |double |Возвращает минимальное значение в doubleVecList. |
| norm(doubleVecList) |double |Возвращает 2-норму вектора, созданного из doubleVecList. |
| percentile(doubleVec v, double p) |double |Возвращает элемент процентиля вектора v. |
| rand() |double |Возвращает случайное значение от 0,0 до 1,0. |
| range(doubleVecList) |double |Возвращает разницу между минимальным и максимальным значениями в doubleVecList. |
| std(doubleVecList) |double |Возвращает среднеквадратичное отклонение выборки для значений в doubleVecList. |
| stop() | |Останавливает вычисление выражения автоматического масштабирования. |
| sum(doubleVecList) |double |Возвращает сумму всех компонентов doubleVecList. |
| time(string dateTime="") |TIMESTAMP |Возвращает метку времени текущего времени, если никакие параметры не передаются, или отметка времени строки dateTime, если она передана. Поддерживаемые форматы даты и времени: W3C-DTF и RFC 1123. |
| val(doubleVec v, double i) |double |Возвращает значение элемента с индексом i в векторе v с начальным индексом 0. |

Некоторые функции, описанные в предыдущей таблице, могут принимать список в качестве аргумента. Список значений, разделенных запятыми, — это любая комбинация типов *double* и *doubleVec*. Пример:

`doubleVecList := ( (double | doubleVec)+(, (double | doubleVec) )* )?`

Значение *doubleVecList* перед оценкой преобразуется в одно значение *doubleVec*. Например, если `v = [1,2,3]`, то вызов `avg(v)` эквивалентен вызову `avg(1,2,3)`. Вызов `avg(v, 7)` эквивалентен вызову `avg(1,2,3,7)`.

## <a name="metrics"></a>Метрики

При определении формулы можно использовать метрики ресурсов и задач. Целевое количество выделенных узлов в пуле определяется на основе данных метрики, которые были получены и оценены. Дополнительные сведения о каждой метрике см. в разделе " [переменные](#variables) " выше.

<table>
  <tr>
    <th>Метрика</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td><b>Ресурс</b></td>
    <td><p>Метрики ресурсов основаны на использовании ресурсов ЦП, памяти и пропускной способности вычислительных узлов, а также количестве узлов.</p>
        <p> Для внесения изменений с учетом количества узлов используются следующие служебные переменные:</p>
    <p><ul>
            <li>$TargetDedicatedNodes</li>
            <li>$TargetLowPriorityNodes</li>
            <li>$CurrentDedicatedNodes</li>
            <li>$CurrentLowPriorityNodes</li>
            <li>$PreemptedNodeCount</li>
            <li>$SampleNodeCount</li>
    </ul></p>
    <p>Для внесения изменений с учетом потребляемых ресурсов используются следующие служебные переменные:</p>
    <p><ul>
      <li>$CPUPercent</li>
      <li>$WallClockSeconds</li>
      <li>$MemoryBytes</li>
      <li>$DiskBytes</li>
      <li>$DiskReadBytes</li>
      <li>$DiskWriteBytes</li>
      <li>$DiskReadOps</li>
      <li>$DiskWriteOps</li>
      <li>$NetworkInBytes</li>
      <li>$NetworkOutBytes</li></ul></p>
  </tr>
  <tr>
    <td><b>Задача</b></td>
    <td><p>Метрики задач основаны на состоянии задач (активные, ожидающие и завершенные). Для внесения изменений в размер пула с учетом метрик задач используются следующие служебные переменные:</p>
    <p><ul>
      <li>$ActiveTasks</li>
      <li>$RunningTasks</li>
      <li>$PendingTasks</li>
      <li>$SucceededTasks</li>
            <li>$FailedTasks</li></ul></p>
        </td>
  </tr>
</table>

## <a name="obtain-sample-data"></a>Получение выборки данных

Основной операцией формулы автомасштабирования является получение данных о задачах и ресурсах (выборки), а затем Настройка размера пула на основе этих данных. Поэтому важно четко понимать, как формулы автомасштабирования взаимодействуют с примерами.

### <a name="methods"></a>Методы

Формулы автомасштабирования действуют для выборки данных метрик, предоставляемых пакетной службой. Формула будет увеличивать или уменьшать размер пула в зависимости от полученных значений. Определяемые службой переменные — это объекты, предоставляющие методы для доступа к данным, связанным с этим объектом. Например, следующее выражение иллюстрирует запрос для получения данных об использовании ЦП за последние пять минут.

```
$CPUPercent.GetSample(TimeInterval_Minute * 5)
```

Для получения образца данных о переменных, определяемых службой, можно использовать следующие методы.

| Метод | Описание |
| --- | --- |
| GetSample() |Метод `GetSample()` возвращает вектор выборок данных.<br/><br/>Выборка — это данные метрики за 30 секунд. Другими словами, выборки делаются каждые 30 секунд. Но, как описано ниже, существует задержка между получением выборки и моментом, когда выборка станет доступна формуле. Таким образом, не все выборки за заданный период времени могут быть доступны для оценки формулой.<ul><li>`doubleVec GetSample(double count)`: Указывает число выборок, получаемых из последних собранных выборок. `GetSample(1)` возвращает последнюю доступную выборку. Однако для таких метрик, как, `$CPUPercent` `GetSample(1)` не следует использовать, так как невозможно выяснить, *когда* был собран пример. Это может быть недавно, или, из-за проблем с системой, оно может быть намного более старым. В таких случаях лучше использовать интервал времени, как показано ниже.<li>`doubleVec GetSample((timestamp or timeinterval) startTime [, double samplePercent])`: Задает интервал времени для сбора демонстрационных данных. Также можно указать долю выборок, которые должны быть доступны в течение запрошенного интервала времени. Например, `$CPUPercent.GetSample(TimeInterval_Minute * 10)` возвращает 20 выборок, если в журнале содержатся все образцы за последние 10 минут `CPUPercent` . Если последняя минута истории была недоступна, возвращаются только 18 выборок. В этом случае произойдет сбой из- `$CPUPercent.GetSample(TimeInterval_Minute * 10, 95)` за того, что доступны только 90 процентов образцов, но они `$CPUPercent.GetSample(TimeInterval_Minute * 10, 80)` будут успешными.<li>`doubleVec GetSample((timestamp or timeinterval) startTime, (timestamp or timeinterval) endTime [, double samplePercent])`: Задает интервал времени для сбора данных с временем начала и временем окончания. Как упоминалось выше, существует задержка между сбором выборки и тем, когда она становится доступной для формулы. Эту задержку следует учитывать при использовании метода `GetSample`. Ознакомьтесь с `GetSamplePercent` ниже. |
| GetSamplePeriod() |Возвращает период выборок, которые были получены в историческом наборе данных выборок. |
| Count() |Возвращает общее количество выборок в журнале метрик. |
| HistoryBeginTime() |Возвращает метку времени самой старой доступной выборки данных метрики. |
| GetSamplePercent() |Возвращает процент выборок, которые доступны для заданного интервала времени. Например, `doubleVec GetSamplePercent( (timestamp or timeinterval) startTime [, (timestamp or timeinterval) endTime] )`. Так как метод `GetSample` завершается сбоем, то если процент возвращаемых выборок меньше указанного в параметре `samplePercent`, можно сначала воспользоваться методом `GetSamplePercent` для проверки. Затем при недостаточном количестве выборок можно выполнить другое действие без прерывания оценки автоматического масштабирования. |

### <a name="samples"></a>Примеры

Пакетная служба периодически принимает выборки метрик задач и ресурсов, делая их доступными для формул автомасштабирования. Эти выборки записываются пакетной службой каждые 30 секунд. Однако обычно имеется задержка между временем записи этих выборок и временем, когда формулы автоматического масштабирования получают к ним доступ (и могут прочесть их). Кроме того, образцы могут не записываться для определенного интервала из-за таких факторов, как сеть или другие проблемы с инфраструктурой.

### <a name="sample-percentage"></a>Процент выборок

При передаче `samplePercent` в метод `GetSample()` или при вызове метода `GetSamplePercent()` знак _процента_ означает сравнение общего возможного количества выборок, записанных пакетной службой, и количества выборок, которые доступны для формулы автомасштабирования.

Для примера рассмотрим промежуток времени в 10 минут. Так как выборка записывается каждые 30 секунд в течение 10-минутного интервала времени, максимальное общее число выборок, записанное пакетной службой, будет составлять 20 выборок (2 в минуту). Однако из-за задержек, присущих механизму отчетности, или других проблем в Azure возможна ситуация, когда только 15 выборок будут доступны для формулы автоматического масштабирования. Поэтому, например, за этот 10-минутный период для формулы может быть доступно только 75 % от общего количества записанных выборок.

### <a name="getsample-and-sample-ranges"></a>Метод GetSample() и диапазоны выборок

Формулы автомасштабирования увеличивают и уменьшают пулы, добавляя или удаляя узлы. Так как узлы изменяют деньги, убедитесь, что в формулах используется интеллектуальный метод анализа, основанный на достаточном объеме данных. В формулах рекомендуется использовать анализ тенденций. С таким анализом пулы увеличиваются и уменьшаются на основе диапазона собранных выборок.

С этой целью используйте метод `GetSample(interval look-back start, interval look-back end)` для возврата вектора выборок.

```
$runningTasksSample = $RunningTasks.GetSample(1 * TimeInterval_Minute, 6 * TimeInterval_Minute);
```

Когда пакетная служба вычисляет приведенную выше строку, она возвращает диапазон выборок в виде вектора значений. Пример:

```
$runningTasksSample=[1,1,1,1,1,1,1,1,1,1];
```

Собрав вектор выборок, можно использовать функции, например `min()`, `max()` и `avg()`, чтобы извлечь из собранного диапазона информативные значения.

Для повышения безопасности можно настроить сбой вычисления формулы в случае, если процент выборок за определенный период окажется меньше заданного значения. Если для формулы настроен принудительный сбой вычисления, пакетная служба прекращает выполнение расчетов по формуле, когда недоступен заданный процент выборок. Размер пула при этом изменяться не будет. Чтобы указать необходимый процент выборок для успешного вычисления, укажите его как третий параметр в методе `GetSample()`. Здесь указано, что обязательный процент выборок равен 75 %:

```
$runningTasksSample = $RunningTasks.GetSample(60 * TimeInterval_Second, 120 * TimeInterval_Second, 75);
```

Так как в образце доступности может возникнуть задержка, следует всегда указывать диапазон времени с временем начала просмотра, которое старше одной минуты. Передача выборок через систему занимает около минуты, поэтому примеры в диапазоне `(0 * TimeInterval_Second, 60 * TimeInterval_Second)` могут быть недоступны. Опять же, можно использовать параметр процента `GetSample()` для принудительного требования определенного процента выборок.

> [!IMPORTANT]
> Мы настоятельно рекомендуем **не полагаться *только* на метод `GetSample(1)` в формулах автомасштабирования**. Это объясняется тем, что метод `GetSample(1)` запрашивает у пакетной службы последнюю доступную выборку независимо от того, как давно она была получена. Поскольку это только одна выборка, которая к тому же может быть устаревшей, она может не давать общее представление о последнем состоянии задачи или ресурса. Если метод `GetSample(1)`все же используется, убедитесь, что он является частью большей инструкции, а не единственной точкой данных, от которой зависит ваша формула.

## <a name="write-an-autoscale-formula"></a>Написание формулы автомасштабирования

Формула автомасштабирования создается путем формирования инструкций с помощью указанных выше компонентов и объединения этих инструкций в полную формулу. В этом разделе мы создадим пример формулы автомасштабирования, которая может выполнять реальные решения по масштабированию и вносить изменения.

Сначала определим требования к новой формуле автомасштабирования. Формула должна выполнять следующее:

- Увеличивать целевое количество выделенных вычислительных узлов в пуле при высокой загрузке ЦП.
- Уменьшать целевое количество выделенных вычислительных узлов в пуле при низкой загрузке ЦП.
- Всегда ограничивать максимальное количество выделенных узлов на уровне 400.
- При уменьшении числа узлов не удаляйте узлы, на которых выполняются задачи. При необходимости дождитесь завершения задач, прежде чем удалять узлы.

Первая инструкция в нашей формуле увеличит количество узлов во время высокой загрузки ЦП. Мы определим инструкцию, которая заполняет определяемую пользователем переменную ( `$totalDedicatedNodes` ) значением 110% от текущего целевого числа выделенных узлов, но только в том случае, если минимальное среднее использование ЦП за последние 10 минут превышало 70%. В противном случае используется значение для текущего числа выделенных узлов.

```
$totalDedicatedNodes =
    (min($CPUPercent.GetSample(TimeInterval_Minute * 10)) > 0.7) ?
    ($CurrentDedicatedNodes * 1.1) : $CurrentDedicatedNodes;
```

Чтобы уменьшить количество выделенных узлов во время низкой загрузки ЦП, следующая инструкция в нашей формуле устанавливает одну и ту же `$totalDedicatedNodes` переменную в 90 процентов от текущего целевого числа выделенных узлов, если средняя загрузка ЦП за последние 60 минут была менее 20%. В противном случае используется текущее значение `$totalDedicatedNodes` , заполненное в приведенной выше инструкции.

```
$totalDedicatedNodes =
    (avg($CPUPercent.GetSample(TimeInterval_Minute * 60)) < 0.2) ?
    ($CurrentDedicatedNodes * 0.9) : $totalDedicatedNodes;
```

Теперь мы будем ограничивать целевое количество выделенных кластерных узлов максимум 400.

```
$TargetDedicatedNodes = min(400, $totalDedicatedNodes)
```

Наконец, мы добавим, чтобы узлы не удалялись, пока их задачи не будут завершены.

```
$NodeDeallocationOption = taskcompletion;
```

Вот полная формула:

```
$totalDedicatedNodes =
    (min($CPUPercent.GetSample(TimeInterval_Minute * 10)) > 0.7) ?
    ($CurrentDedicatedNodes * 1.1) : $CurrentDedicatedNodes;
$totalDedicatedNodes =
    (avg($CPUPercent.GetSample(TimeInterval_Minute * 60)) < 0.2) ?
    ($CurrentDedicatedNodes * 0.9) : $totalDedicatedNodes;
$TargetDedicatedNodes = min(400, $totalDedicatedNodes)
$NodeDeallocationOption = taskcompletion;
```

> [!NOTE]
> Если выбрано значение, в строки формулы можно включить комментарии и разрывы строк. Также имейте в виду, что отсутствие точек с запятой может привести к ошибкам оценки.

## <a name="automatic-scaling-interval"></a>Интервал автоматического масштабирования

По умолчанию пакетная служба изменяет размер пула по указанной формуле автомасштабирования каждые 15 минут. Этот интервал можно настроить с помощью следующих свойств пула:

- [CloudPool.AutoScaleEvaluationInterval](/dotnet/api/microsoft.azure.batch.cloudpool.autoscaleevaluationinterval) (.NET пакетной службы)
- [autoScaleEvaluationInterval](/rest/api/batchservice/enable-automatic-scaling-on-a-pool) (REST API)

Минимальный интервал составляет пять минут, а максимальный — 168 часов. Если указан интервал за пределами этого диапазона, пакетная служба возвращает ошибку "Неправильный запрос (400)".

> [!NOTE]
> В настоящее время автоматическое масштабирование предназначено не для реагирования на изменения в течение нескольких секунд, а для постепенного изменения размера пула в ходе выполнения рабочей нагрузки.

## <a name="create-an-autoscale-enabled-pool-with-batch-sdks"></a>Создание пула с поддержкой автомасштабирования с помощью пакетов SDK пакетной службы

Настройки автомасштабирования можно указать с помощью любых [пакетов SDK пакетной службы](batch-apis-tools.md#azure-accounts-for-batch-development), [REST API пакетной службы](/rest/api/batchservice/), [командлетов PowerShell пакетной службы](batch-powershell-cmdlets-get-started.md) или [интерфейса командной строки пакетной службы](batch-cli-get-started.md). В этом разделе представлены примеры для .NET и Python.

### <a name="net"></a>.NET

Чтобы создать пул с поддержкой автомасштабирования в .NET, выполните указанные ниже действия.

1. Создайте пул с помощью метода [BatchClient.PoolOperations.CreatePool](/dotnet/api/microsoft.azure.batch.pooloperations.createpool).
1. Задайте для свойства [CloudPool.AutoScaleEnabled](/dotnet/api/microsoft.azure.batch.cloudpool.autoscaleenabled) значение `true`.
1. Задайте свойство [CloudPool.AutoScaleFormula](/dotnet/api/microsoft.azure.batch.cloudpool.autoscaleformula) с помощью формулы автомасштабирования.
1. (Необязательно.) Задайте свойство [CloudPool.AutoScaleEvaluationInterval](/dotnet/api/microsoft.azure.batch.cloudpool.autoscaleevaluationinterval) (значение по умолчанию — 15 минут).
1. Зафиксируйте пул с помощью метода [CloudPool.Commit](/dotnet/api/microsoft.azure.batch.cloudpool.commit) или [CommitAsync](/dotnet/api/microsoft.azure.batch.cloudpool.commitasync).

В следующем примере создается пул с поддержкой автомасштабирования в .NET. Формула автомасштабирования пула задает целевое количество выделенных узлов равным 5 в понедельниках, а значение 1 — каждый второй день недели. [Интервал автомасштабирования](#automatic-scaling-interval) составляет 30 минут. В этом и других фрагментах кода C#, приведенных в этой статье, `myBatchClient` представляет собой правильно инициализированный экземпляр класса [BatchClient](/dotnet/api/microsoft.azure.batch.batchclient).

```csharp
CloudPool pool = myBatchClient.PoolOperations.CreatePool(
                    poolId: "mypool",
                    virtualMachineSize: "standard_d1_v2",
                    cloudServiceConfiguration: new CloudServiceConfiguration(osFamily: "5"));
pool.AutoScaleEnabled = true;
pool.AutoScaleFormula = "$TargetDedicatedNodes = (time().weekday == 1 ? 5:1);";
pool.AutoScaleEvaluationInterval = TimeSpan.FromMinutes(30);
await pool.CommitAsync();
```

> [!IMPORTANT]
> При создании пула с включенным автомасштабированием не указывайте параметр _таржетдедикатеднодес_ или _таржетловприоритинодес_ в вызове **CreatePool**. Вместо этого укажите свойства **AutoScaleEnabled** и **AutoScaleFormula** для пула. Значения этих свойств определяют целевое количество каждого типа узлов.
>
> Чтобы вручную изменить размер пула с поддержкой автомасштабирования (например, с помощью [BatchClient. PoolOperations. ресизепуласинк](/dotnet/api/microsoft.azure.batch.pooloperations.resizepoolasync)), необходимо сначала отключить автоматическое масштабирование в пуле, а затем изменить его размер.

### <a name="python"></a>Python

Чтобы создать пул с поддержкой автомасштабирования с помощью пакета SDK для Python, выполните следующие действия.

1. Создайте пул и укажите его конфигурацию.
1. Добавьте пул в клиент службы.
1. Включите автомасштабирование для пула с использованием созданной вами формулы.

Эти действия показаны в следующем примере.

```python
# Create a pool; specify configuration
new_pool = batch.models.PoolAddParameter(
    id="autoscale-enabled-pool",
    virtual_machine_configuration=batchmodels.VirtualMachineConfiguration(
        image_reference=batchmodels.ImageReference(
          publisher="Canonical",
          offer="UbuntuServer",
          sku="18.04-LTS",
          version="latest"
            ),
        node_agent_sku_id="batch.node.ubuntu 18.04"),
    vm_size="STANDARD_D1_v2",
    target_dedicated_nodes=0,
    target_low_priority_nodes=0
)
batch_service_client.pool.add(new_pool) # Add the pool to the service client

formula = """$curTime = time();
             $workHours = $curTime.hour >= 8 && $curTime.hour < 18;
             $isWeekday = $curTime.weekday >= 1 && $curTime.weekday <= 5;
             $isWorkingWeekdayHour = $workHours && $isWeekday;
             $TargetDedicated = $isWorkingWeekdayHour ? 20:10;""";

# Enable autoscale; specify the formula
response = batch_service_client.pool.enable_auto_scale(pool_id, auto_scale_formula=formula,
                                            auto_scale_evaluation_interval=datetime.timedelta(minutes=10),
                                            pool_enable_auto_scale_options=None,
                                            custom_headers=None, raw=False)
```

> [!TIP]
> Дополнительные примеры использования пакета средств разработки для Python см. в [репозитории для быстрого начала работы с пакетной службой на Python](https://github.com/Azure-Samples/batch-python-quickstart) на сайте GitHub.

## <a name="enable-autoscaling-on-an-existing-pool"></a>Включение автомасштабирования в имеющемся пуле

Каждый пакет SDK Batch предоставляет способ включения автоматического масштабирования. Пример:

- [BatchClient.PoolOperations.EnableAutoScaleAsync](/dotnet/api/microsoft.azure.batch.pooloperations.enableautoscaleasync) (.NET для пакетной службы)
- [Включение автомасштабирования для пула](/rest/api/batchservice/enable-automatic-scaling-on-a-pool) (REST API)

При включении автомасштабирования в существующем пуле учитывайте следующее.

- Если Автомасштабирование в пуле отключено, при выполнении запроса необходимо указать допустимую формулу автомасштабирования. При необходимости можно указать интервал автоматического масштабирования. Если интервал не указан, используется значение по умолчанию, равное 15 минутам.
- Если в пуле включено Автомасштабирование, можно указать новую формулу, новый интервал или и то, и другое. Необходимо указать по крайней мере одно из этих свойств.
  - При указании нового интервала автоматического масштабирования существующее расписание останавливается и запускается новое расписание. Время начала нового расписания — это время подачи запроса на включение автомасштабирования.
  - Если опустить формулу или интервал автомасштабирования, пакетная служба продолжит использовать текущее значение этого параметра.

> [!NOTE]
> Если вы указали значения для параметров *таржетдедикатеднодес* или *таржетловприоритинодес* метода **CreatePool** при создании пула в .NET или для сравниваемых параметров на другом языке, эти значения игнорируются при вычислении формулы автомасштабирования.

В этом примере C# для включения автомасштабирования в существующем пуле используется библиотека [.NET пакетной](/dotnet/api/microsoft.azure.batch) службы.

```csharp
// Define the autoscaling formula. This formula sets the target number of nodes
// to 5 on Mondays, and 1 on every other day of the week
string myAutoScaleFormula = "$TargetDedicatedNodes = (time().weekday == 1 ? 5:1);";

// Set the autoscale formula on the existing pool
await myBatchClient.PoolOperations.EnableAutoScaleAsync(
    "myexistingpool",
    autoscaleFormula: myAutoScaleFormula);
```

### <a name="update-an-autoscale-formula"></a>Обновление формулы автомасштабирования

Чтобы обновить формулу для существующего пула с поддержкой автомасштабирования, вызовите операцию для включения автомасштабирования еще раз с новой формулой. Например, если при выполнении приведенного ниже кода .NET автомасштабирование уже включено в `myexistingpool`, формула автомасштабирования заменяется содержимым `myNewFormula`.

```csharp
await myBatchClient.PoolOperations.EnableAutoScaleAsync(
    "myexistingpool",
    autoscaleFormula: myNewFormula);
```

### <a name="update-the-autoscale-interval"></a>Обновление интервала автомасштабирования

Чтобы обновить интервал оценки автомасштабирования для существующего пула с поддержкой автомасштабирования, вызовите операцию для включения автомасштабирования еще раз с новым интервалом. Например, чтобы задать для интервала оценки автомасштабирования значение 60 минут в пуле с уже включенным автомасштабированием, необходимо сделать следующее:

```csharp
await myBatchClient.PoolOperations.EnableAutoScaleAsync(
    "myexistingpool",
    autoscaleEvaluationInterval: TimeSpan.FromMinutes(60));
```

## <a name="evaluate-an-autoscale-formula"></a>Оценка формулы автомасштабирования

Прежде чем применить формулу к пулу, ее можно оценить. Это позволяет протестировать результаты формулы до их помещения в рабочую среду.

Прежде чем можно будет оценить формулу автомасштабирования, необходимо включить Автомасштабирование в пуле с допустимой формулой, например с помощью однострочной формулы `$TargetDedicatedNodes = 0` . Затем для оценки формулы, которую требуется протестировать, выполните одно из следующих действий:

- Вызовите метод [BatchClient.PoolOperations.EvaluateAutoScale](/dotnet/api/microsoft.azure.batch.pooloperations.evaluateautoscale) или [EvaluateAutoScaleAsync](/dotnet/api/microsoft.azure.batch.pooloperations.evaluateautoscaleasync).

    Для выполнения оценки этим методам .NET пакетной службы требуется идентификатор имеющегося пула и строка, содержащая формулу автомасштабирования.

- [Оцените формулу автомасштабирования.](/rest/api/batchservice/evaluate-an-automatic-scaling-formula)

    В этом запросе REST API укажите идентификатор пула в универсальном коде ресурса и формулу автомасштабирования в элементе *autoScaleFormula* текста запроса. Ответ операции содержит все сведения об ошибках, которые могут быть связаны с формулой.

В этом примере [.NET для пакетной](/dotnet/api/microsoft.azure.batch) службы вычисляется формула автомасштабирования. Если в пуле еще не используется Автомасштабирование, сначала включите его.

```csharp
// First obtain a reference to an existing pool
CloudPool pool = await batchClient.PoolOperations.GetPoolAsync("myExistingPool");

// If autoscaling isn't already enabled on the pool, enable it.
// You can't evaluate an autoscale formula on a non-autoscale-enabled pool.
if (pool.AutoScaleEnabled == false)
{
    // We need a valid autoscale formula to enable autoscaling on the
    // pool. This formula is valid, but won't resize the pool:
    await pool.EnableAutoScaleAsync(
        autoscaleFormula: "$TargetDedicatedNodes = $CurrentDedicatedNodes;",
        autoscaleEvaluationInterval: TimeSpan.FromMinutes(5));

    // Batch limits EnableAutoScaleAsync calls to once every 30 seconds.
    // Because we want to apply our new autoscale formula below if it
    // evaluates successfully, and we *just* enabled autoscaling on
    // this pool, we pause here to ensure we pass that threshold.
    Thread.Sleep(TimeSpan.FromSeconds(31));

    // Refresh the properties of the pool so that we've got the
    // latest value for AutoScaleEnabled
    await pool.RefreshAsync();
}

// We must ensure that autoscaling is enabled on the pool prior to
// evaluating a formula
if (pool.AutoScaleEnabled == true)
{
    // The formula to evaluate - adjusts target number of nodes based on
    // day of week and time of day
    string myFormula = @"
        $curTime = time();
        $workHours = $curTime.hour >= 8 && $curTime.hour < 18;
        $isWeekday = $curTime.weekday >= 1 && $curTime.weekday <= 5;
        $isWorkingWeekdayHour = $workHours && $isWeekday;
        $TargetDedicatedNodes = $isWorkingWeekdayHour ? 20:10;
    ";

    // Perform the autoscale formula evaluation. Note that this code does not
    // actually apply the formula to the pool.
    AutoScaleRun eval =
        await batchClient.PoolOperations.EvaluateAutoScaleAsync(pool.Id, myFormula);

    if (eval.Error == null)
    {
        // Evaluation success - print the results of the AutoScaleRun.
        // This will display the values of each variable as evaluated by the
        // autoscale formula.
        Console.WriteLine("AutoScaleRun.Results: " +
            eval.Results.Replace("$", "\n    $"));

        // Apply the formula to the pool since it evaluated successfully
        await batchClient.PoolOperations.EnableAutoScaleAsync(pool.Id, myFormula);
    }
    else
    {
        // Evaluation failed, output the message associated with the error
        Console.WriteLine("AutoScaleRun.Error.Message: " +
            eval.Error.Message);
    }
}
```

В случае успешного вычисления формулы, показанной в этом фрагменте, будет получен результат, подобный следующему:

```
AutoScaleRun.Results:
    $TargetDedicatedNodes=10;
    $NodeDeallocationOption=requeue;
    $curTime=2016-10-13T19:18:47.805Z;
    $isWeekday=1;
    $isWorkingWeekdayHour=0;
    $workHours=0
```

## <a name="get-information-about-autoscale-runs"></a>Получение сведений о выполнениях автомасштабирования

Чтобы убедиться в том, что формула работает правильно, мы рекомендуем периодически проверять результаты автомасштабирования, которое пакетная служба выполняет в пуле. Чтобы сделать это, получите (или обновите) ссылку на пул, а затем проверьте свойства последнего запуска автомасштабирования.

В .NET пакетной службы свойство [CloudPool.AutoScaleRun](/dotnet/api/microsoft.azure.batch.cloudpool.autoscalerun) обладает несколькими свойствами, которые предоставляют сведения о последнем выполнении автомасштабирования в пуле.

- [AutoScaleRun.Timestamp.](/dotnet/api/microsoft.azure.batch.autoscalerun.timestamp)
- [AutoScaleRun.Results;](/dotnet/api/microsoft.azure.batch.autoscalerun.results)
- [AutoScaleRun.Error;](/dotnet/api/microsoft.azure.batch.autoscalerun.error)

В REST API запрос [Получение сведений о пуле](/rest/api/batchservice/get-information-about-a-pool) возвращает сведения о пуле, в том числе результаты последнего выполнения автомасштабирования, в свойстве [autoScaleRun](/rest/api/batchservice/get-information-about-a-pool).

В следующем примере C# используется библиотека .NET пакетной службы для вывода сведений о последнем запуске автомасштабирования в пуле _myPool_.

```csharp
await Cloud pool = myBatchClient.PoolOperations.GetPoolAsync("myPool");
Console.WriteLine("Last execution: " + pool.AutoScaleRun.Timestamp);
Console.WriteLine("Result:" + pool.AutoScaleRun.Results.Replace("$", "\n  $"));
Console.WriteLine("Error: " + pool.AutoScaleRun.Error);
```

Пример выходных данных из предыдущего примера:

```
Last execution: 10/14/2016 18:36:43
Result:
  $TargetDedicatedNodes=10;
  $NodeDeallocationOption=requeue;
  $curTime=2016-10-14T18:36:43.282Z;
  $isWeekday=1;
  $isWorkingWeekdayHour=0;
  $workHours=0
Error:
```

## <a name="get-autoscale-run-history-using-pool-autoscale-events"></a>Получение журнала выполнения автомасштабирования с помощью событий автомасштабирования пула
Можно также проверить журнал автоматического масштабирования, выполнив запрос к [пулаутоскаливент](batch-pool-autoscale-event.md). Это событие создается пакетной службой для записи каждого вхождения вычисления формулы автомасштабирования и выполнения, что может быть полезно для устранения потенциальных проблем.

Пример события для Пулаутоскаливент:
```json
{
    "id": "poolId",
    "timestamp": "2020-09-21T23:41:36.750Z",
    "formula": "...",
    "results": "$TargetDedicatedNodes=10;$NodeDeallocationOption=requeue;$curTime=2016-10-14T18:36:43.282Z;$isWeekday=1;$isWorkingWeekdayHour=0;$workHours=0",
    "error": {
        "code": "",
        "message": "",
        "values": []
    }
}
```

## <a name="example-autoscale-formulas"></a>Примеры формул автомасштабирования

Давайте рассмотрим некоторые формулы, которые демонстрируют различные способы настройки количества вычислительных ресурсов в пуле.

### <a name="example-1-time-based-adjustment"></a>Пример 1: Изменение с учетом времени

Предположим, вы хотите изменять размер пула в зависимости от дня недели и времени дня. В этом примере показано, как уменьшать и увеличивать количество узлов в пуле соответствующим образом.

Формула сначала получает значение текущего времени. В рабочие дни (1–5) и часы (8:00–18:00) целевой размер пула равен 20 узлам. В противном случае он равен 10 узлам.

```
$curTime = time();
$workHours = $curTime.hour >= 8 && $curTime.hour < 18;
$isWeekday = $curTime.weekday >= 1 && $curTime.weekday <= 5;
$isWorkingWeekdayHour = $workHours && $isWeekday;
$TargetDedicatedNodes = $isWorkingWeekdayHour ? 20:10;
$NodeDeallocationOption = taskcompletion;
```

Для `$curTime` можно настроить время местного часового пояса, добавив `time()` к произведению значения `TimeZoneInterval_Hour` и смещения от UTC. Например, для часового пояса "Горное время США (лето)" укажите значение `$curTime = time() + (-6 * TimeInterval_Hour);`. Не забывайте, что смещение необходимо корректировать при переходе на летнее время и обратно (если применимо).

### <a name="example-2-task-based-adjustment"></a>Пример 2. Изменение с учетом задачи

В этом примере C# размер пула корректируется в зависимости от числа задач в очереди. В строки формулы мы включили комментарии и разрывы строк.

```csharp
// Get pending tasks for the past 15 minutes.
$samples = $PendingTasks.GetSamplePercent(TimeInterval_Minute * 15);
// If we have fewer than 70 percent data points, we use the last sample point,
// otherwise we use the maximum of last sample point and the history average.
$tasks = $samples < 70 ? max(0,$PendingTasks.GetSample(1)) : max( $PendingTasks.GetSample(1), avg($PendingTasks.GetSample(TimeInterval_Minute * 15)));
// If number of pending tasks is not 0, set targetVM to pending tasks, otherwise
// half of current dedicated.
$targetVMs = $tasks > 0? $tasks:max(0, $TargetDedicatedNodes/2);
// The pool size is capped at 20, if target VM value is more than that, set it
// to 20. This value should be adjusted according to your use case.
$TargetDedicatedNodes = max(0, min($targetVMs, 20));
// Set node deallocation mode - let running tasks finish before removing a node
$NodeDeallocationOption = taskcompletion;
```

### <a name="example-3-accounting-for-parallel-tasks"></a>Пример 3. Параллельные задачи

В этом примере на C# изменяется размер пула в зависимости от числа задач. Эта формула также учитывает значение [таскслотсперноде](/dotnet/api/microsoft.azure.batch.cloudpool.taskslotspernode) , установленное для пула. Такой подход полезен, если в пуле поддерживается [параллельное выполнение задач](batch-parallel-node-tasks.md).

```csharp
// Determine whether 70 percent of the samples have been recorded in the past
// 15 minutes; if not, use last sample
$samples = $ActiveTasks.GetSamplePercent(TimeInterval_Minute * 15);
$tasks = $samples < 70 ? max(0,$ActiveTasks.GetSample(1)) : max( $ActiveTasks.GetSample(1),avg($ActiveTasks.GetSample(TimeInterval_Minute * 15)));
// Set the number of nodes to add to one-fourth the number of active tasks
// (the TaskSlotsPerNode property on this pool is set to 4, adjust
// this number for your use case)
$cores = $TargetDedicatedNodes * 4;
$extraVMs = (($tasks - $cores) + 3) / 4;
$targetVMs = ($TargetDedicatedNodes + $extraVMs);
// Attempt to grow the number of compute nodes to match the number of active
// tasks, with a maximum of 3
$TargetDedicatedNodes = max(0,min($targetVMs,3));
// Keep the nodes active until the tasks finish
$NodeDeallocationOption = taskcompletion;
```

### <a name="example-4-setting-an-initial-pool-size"></a>Пример 4. Настройка исходного размера пула

В этом примере показан пример на языке C# с формулой автомасштабирования, которая устанавливает размер пула в указанное число узлов для начального периода времени. После этого он корректирует размер пула в зависимости от числа выполняющихся и активных задач.

В частности, эта формула выполняет следующие действия:

- Она задает исходный размер пула в 4 узла.
- Не изменяет размер пула в течение первых 10 минут его жизненного цикла.
- После первых 10 минут она получает максимальное количество запущенных и активных задач за последние 60 минут.
  - Если оба значения равны 0 (то есть за 60 минут не было ни активных, ни запущенных задач), то размер пула устанавливается в 0.
  - Если любое из значений больше нуля, изменений не производится.

```csharp
string now = DateTime.UtcNow.ToString("r");
string formula = string.Format(@"
    $TargetDedicatedNodes = {1};
    lifespan         = time() - time(""{0}"");
    span             = TimeInterval_Minute * 60;
    startup          = TimeInterval_Minute * 10;
    ratio            = 50;

    $TargetDedicatedNodes = (lifespan > startup ? (max($RunningTasks.GetSample(span, ratio), $ActiveTasks.GetSample(span, ratio)) == 0 ? 0 : $TargetDedicatedNodes) : {1});
    ", now, 4);
```

## <a name="next-steps"></a>Дальнейшие действия

- Узнайте, как [одновременно выполнять несколько задач на вычисленных узлах в пуле](batch-parallel-node-tasks.md). Вместе с автомасштабированием это позволяет сократить длительность задания для некоторых рабочих нагрузок, экономя деньги.
- Узнайте, как [эффективно выполнять запросы к пакетной службе Azure](batch-efficient-list-queries.md) для дальнейшей эффективности.
