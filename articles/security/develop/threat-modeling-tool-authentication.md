---
title: Проверка подлинности. Средство моделирования угроз Microsoft Azure | Документация Майкрософт
description: Сведения об устранении проверки подлинности в Threat Modeling Tool. См. сведения об устранении рисков и просмотр примеров кода.
services: security
documentationcenter: na
author: jegeib
manager: jegeib
editor: jegeib
ms.assetid: na
ms.service: security
ms.subservice: security-develop
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 02/07/2017
ms.author: jegeib
ms.custom: has-adal-ref, devx-track-js, devx-track-csharp
ms.openlocfilehash: ee4dd70faab9ed44b1aa6ca8ca0ec517c7746f66
ms.sourcegitcommit: 867cb1b7a1f3a1f0b427282c648d411d0ca4f81f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "94832536"
---
# <a name="security-frame-authentication--mitigations"></a>Механизм безопасности. Проверка подлинности | Устранение рисков

| Продукт или служба | Статья |
| --------------- | ------- |
| **Веб-приложение**    | <ul><li>[Рассмотрите возможность использования стандартного механизма проверки подлинности для проверки подлинности в веб-приложении](#standard-authn-web-app)</li><li>[Приложения должны надежно обрабатывать сценарии неудачной проверки подлинности](#handle-failed-authn)</li><li>[Включение пошаговой или адаптивной проверки подлинности](#step-up-adaptive-authn)</li><li>[Интерфейсы администрирования должны быть заблокированы соответствующим образом](#admin-interface-lockdown)</li><li>[Безопасное внедрение функциональных возможностей забытых паролей](#forgot-pword-fxn)</li><li>[Проверка реализации политики паролей и учетных записей](#pword-account-policy)</li><li>[Реализуйте элементы управления, чтобы предотвратить перечисление имен пользователей](#controls-username-enum)</li></ul> |
| **База данных** | <ul><li>[По возможности используйте проверку подлинности Windows для подключения к SQL Server](#win-authn-sql)</li><li>[Если возможно использовать Azure Active Directory проверку подлинности для подключения к базе данных SQL](#aad-authn-sql)</li><li>[Если используется режим проверки подлинности SQL, обеспечьте применение политики учетных записей и паролей на сервере SQL Server](#authn-account-pword)</li><li>[Не используйте проверку подлинности SQL в автономных базах данных](#autn-contained-db)</li></ul> |
| **Концентратор событий Azure** | <ul><li>[Используйте учетные данные проверки подлинности на уровне отдельного устройства с помощью маркеров SaS](#authn-sas-tokens)</li></ul> |
| **Граница доверия Azure** | <ul><li>[Включение многофакторной идентификации Azure AD для администраторов Azure](#multi-factor-azure-admin)</li></ul> |
| **Граница доверия Service Fabric** | <ul><li>[Ограничение анонимного доступа к кластеру Service Fabric](#anon-access-cluster)</li><li>[Убедитесь, что Service Fabric сертификат "клиент-узел" отличается от сертификата "узел-узел".](#fabric-cn-nn)</li><li>[Использование AAD для проверки подлинности клиентов в кластерах Service Fabric](#aad-client-fabric)</li><li>[Нужно использовать сертификаты Service Fabric, полученные из утвержденного Центра сертификации](#fabric-cert-ca)</li></ul> |
| **Сервер удостоверений** | <ul><li>[Использовать стандартные сценарии проверки подлинности, поддерживаемые сервером удостоверений](#standard-authn-id)</li><li>[Переопределение кэша токенов сервера удостоверений по умолчанию с помощью масштабируемой альтернативы](#override-token)</li></ul> |
| **Граница доверия между компьютерами** | <ul><li>[Двоичные файлы развернутого приложения должны иметь цифровую подпись](#binaries-signed)</li></ul> |
| **WCF** | <ul><li>[Включение проверки подлинности при подключении к очередям MSMQ в WCF](#msmq-queues)</li><li>[WCF: не присваивайте атрибуту message clientCredentialType значение None](#message-none)</li><li>[WCF — не устанавливайте для транспорта clientCredentialType значение None](#transport-none)</li></ul> |
| **Веб-интерфейс API** | <ul><li>[Убедитесь, что для защиты веб-API используются стандартные методы проверки подлинности](#authn-secure-api)</li></ul> |
| **Azure AD** | <ul><li>[Используйте стандартные сценарии проверки подлинности, поддерживаемые Azure Active Directory](#authn-aad)</li><li>[Переопределите кэш маркеров ADAL по умолчанию масштабируемой альтернативой](#adal-scalable)</li><li>[Для предотвращения воспроизведения маркеров проверки подлинности ADAL нужно использовать свойство TokenReplayCache](#tokenreplaycache-adal)</li><li>[Использование библиотек ADAL для управления запросами маркеров от клиентов OAuth2 к AAD (или локальной службе AD)](#adal-oauth2)</li></ul> |
| **Полевой шлюз Интернета вещей** | <ul><li>[Проверяйте подлинность устройств, подключаемых к полевому шлюзу](#authn-devices-field)</li></ul> |
| **Облачный шлюз Интернета вещей** | <ul><li>[Устройства, подключаемые к облачному шлюзу, должны проходить проверку подлинности](#authn-devices-cloud)</li><li>[Использовать учетные данные проверки подлинности для каждого устройства](#authn-cred)</li></ul> |
| **Хранилище Azure** | <ul><li>[Анонимный доступ на чтение должен быть предоставлен только к необходимым контейнерам и большим двоичным объектам](#req-containers-anon)</li><li>[Предоставьте ограниченный доступ к объектам в службе хранилища Azure с помощью SAS или SAP](#limited-access-sas)</li></ul> |

## <a name="consider-using-a-standard-authentication-mechanism-to-authenticate-to-web-application"></a><a id="standard-authn-web-app"></a>Рассмотрите возможность использования стандартного механизма проверки подлинности в веб-приложениях

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| Сведения | <p>Проверка подлинности — это процесс, во время которого сущность подтверждает свою подлинность с помощью учетных данных, таких как имя пользователя и пароль. Существует множество протоколов проверки подлинности, включая следующие:</p><ul><li>Client certificates</li><li>на основе Windows;</li><li>на основе форм;</li><li>федерация: ADFS;</li><li>федерация: Azure AD;</li><li>федерация: сервер удостоверений.</li></ul><p>Рассмотрите возможность использования стандартного механизма проверки подлинности для идентификации исходного процесса.</p>|

## <a name="applications-must-handle-failed-authentication-scenarios-securely"></a><a id="handle-failed-authn"></a>Приложения должны надежно обрабатывать сценарии неудачной проверки подлинности

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| Сведения | <p>Приложения, которые явно проверяют подлинность пользователей, должны безопасно обрабатывать сценарии неудачной проверки подлинности. Механизм проверки подлинности должен:</p><ul><li>запрещать доступ к привилегированным ресурсам при сбое проверки подлинности;</li><li>отображать общее сообщение об ошибке после неудачной проверки подлинности и запрета доступа.</li></ul><p>Проверьте, обеспечивает ли механизм проверки подлинности следующее:</p><ul><li>защиту привилегированных ресурсов после неудачных попыток входа;</li><li>отображение общего сообщения об ошибке после неудачной проверки подлинности и запрета доступа;</li><li>отключение учетных записей после слишком большого количества неудачных попыток.</li><ul>|

## <a name="enable-step-up-or-adaptive-authentication"></a><a id="step-up-adaptive-authn"></a>Включите проверку подлинности повышенного уровня или адаптивную проверку подлинности

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| Сведения | <p>Убедитесь, что приложение имеет дополнительную авторизацию (проверку подлинности повышенного уровня или адаптивную проверку подлинности через службу Многофакторной идентификации, например с отправкой одноразового пароля в SMS, сообщении электронной почты и т. д. или запрос повторной проверки подлинности), которую пользователь должен пройти, прежде чем получить доступ к конфиденциальной информации. Это правило также применяется для внесения критически важных изменений в учетную запись или в действие.</p><p>Это означает, что адаптация проверки подлинности должна быть реализована таким образом, чтобы приложение правильно применяло контекстно-зависимую авторизацию и не допускало несанкционированные манипуляции, например путем изменения параметров.</p>|

## <a name="ensure-that-administrative-interfaces-are-appropriately-locked-down"></a><a id="admin-interface-lockdown"></a>Интерфейсы администрирования должны быть заблокированы соответствующим образом

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| Сведения | Для начала предоставьте доступ к интерфейсу администрирования только для исходного диапазона IP-адресов. Если это решение невозможно, рекомендуется применить проверку подлинности повышенного уровня или адаптивную проверку подлинности для входа в интерфейс администрирования. |

## <a name="implement-forgot-password-functionalities-securely"></a><a id="forgot-pword-fxn"></a>Реализуйте безопасный механизм восстановления пароля

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| Сведения | <p>Прежде всего убедитесь, что в случае потери паролей и для восстановления по другим причинам отправляется ссылка, содержащая маркер активации с ограниченным временем действия, а не сам пароль. Также перед отправкой ссылки может потребоваться дополнительная проверка подлинности на основе программных маркеров (SMS-маркер, собственное мобильное приложение и т. д.). Во-вторых, вам не следует блокировать учетные записи пользователей во время процедуры получения нового пароля.</p><p>Это может привести к атаке типа "отказ в обслуживании" всякий раз, когда злоумышленник решит намеренно блокировать пользователей с помощью автоматизированных атак. В-третьих, сообщение, которое отображается во время выполнения запроса нового пароля, должно быть обобщенным во избежание перечисления имен пользователей. В-четвертых, всегда запрещайте использовать старые пароли и реализуйте политику надежных паролей.</p> |

## <a name="ensure-that-password-and-account-policy-are-implemented"></a><a id="pword-account-policy"></a>Настройте применение политик учетных записей и паролей

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| Сведения | <p>Политика паролей и учетных записей должна быть реализована в соответствии с политикой организации и рекомендациями.</p><p>Для защиты от атак методом прямого подбора и подбора на основе словаря необходимо реализовать политику надежных паролей, чтобы пользователи создавали сложные пароли (например, длиной не менее 12 символов, а также содержащие алфавитно-цифровые или специальные символы).</p><p>Политики блокировки учетных записей можно реализовать следующим образом:</p><ul><li>**Мягкая блокировка.** Может быть хорошим вариантом для защиты пользователей от атак методом прямого подбора. Например, каждый раз, когда пользователь вводит неверный пароль три раза, приложение может заблокировать учетную запись в течение минуты, чтобы замедлить процесс подбора пароля, сделав его менее выгодным для продолжения работы злоумышленника. Если бы в этом примере были реализованы контрмеры с фиксированной блокировкой, вы получите "DoS", окончательно блокируя учетные записи. Кроме того, приложение может создать одноразовый пароль и отправить его пользователю по внештатному каналу (по электронной почте, SMS и т. д.). Как вариант, можно реализовать проверку CAPTCHA по достижении порогового значения числа неудачных попыток.</li><li>**Жесткая блокировка:** Этот тип блокировки следует применять всякий раз, когда вы обнаружите, что пользователь может атаковать приложение, и пронумеровать его с помощью постоянного блокирования своей учетной записи до тех пор, пока у команды ответа не было времени на выполнение судебных расследований. После этого процесса вы можете предоставить пользователю обратную учетную запись или предпринять другие юридические действия. Такой подход не позволит злоумышленнику продолжить атаки на приложение и инфраструктуру.</li></ul><p>Для защиты от атак на прогнозируемые учетные записи и учетные записи по умолчанию все ключи и пароли должны быть заменяемыми, а также быть созданы или заменены с момента их создания.</p><p>Если приложение автоматически создает пароли, они должны создаваться случайным образом и иметь высокий уровень энтропии.</p>|

## <a name="implement-controls-to-prevent-username-enumeration"></a><a id="controls-username-enum"></a>Реализуйте элементы управления для предотвращения перечисления имен пользователей

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Шаги** | Во избежание перечисления имен пользователей все сообщения об ошибках должны быть обобщенными. Иногда не удается избежать утечки информации при использовании определенного компонента или функции, например страницы регистрации пользователя. В таких случаях, чтобы предотвратить автоматизированные атаки, необходимо использовать методы ограничения скорости обращений к странице, например CAPTCHA. |

## <a name="when-possible-use-windows-authentication-for-connecting-to-sql-server"></a><a id="win-authn-sql"></a>По возможности используйте проверку подлинности Windows для подключения к SQL Server

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | База данных |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Локальные |
| **Атрибуты**              | Версия SQL: все |
| **Справочные материалы**              | [Выбор режима проверки подлинности](/sql/relational-databases/security/choose-an-authentication-mode) |
| **Шаги** | Режим проверки подлинности Windows использует протокол безопасности Kerberos, реализует политику паролей в отношении проверки сложности надежных паролей, поддерживает блокировку учетных записей и истечение срока пароля.|

## <a name="when-possible-use-azure-active-directory-authentication-for-connecting-to-sql-database"></a><a id="aad-authn-sql"></a>По возможности используйте проверку подлинности Azure Active Directory для подключения к базе данных SQL

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | База данных |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | SQL Azure |
| **Атрибуты**              | Версия SQL: 12 |
| **Справочные материалы**              | [Подключение к базе данных SQL с использованием аутентификации Azure Active Directory](../../azure-sql/database/authentication-aad-overview.md) |
| **Шаги** | **Минимальная версия.** Чтобы разрешить базе данных SQL использовать проверку подлинности AAD в каталоге Майкрософт, необходимо использовать базу данных SQL Azure версии 12. |

## <a name="when-sql-authentication-mode-is-used-ensure-that-account-and-password-policy-are-enforced-on-sql-server"></a><a id="authn-account-pword"></a>Если используется режим проверки подлинности SQL, обеспечьте применение политики учетных записей и паролей на сервере SQL Server

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | База данных |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [SQL Server политики паролей](/previous-versions/sql/sql-server-2012/ms161959(v=sql.110)) |
| **Шаги** | При использовании проверки подлинности SQL Server создаются имена входа, которые не основаны на учетных записях Windows. Имя пользователя и пароль создаются и хранятся в SQL Server. SQL Server может использовать механизмы политики паролей Windows. К паролям, используемым в SQL Server, можно применить те же политики ограничения срока действия и сложности, которые применяются в Windows. |

## <a name="do-not-use-sql-authentication-in-contained-databases"></a><a id="autn-contained-db"></a>Не используйте проверку подлинности SQL в автономных базах данных

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | База данных |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Локальное, SQL Azure |
| **Атрибуты**              | Версия SQL: MSSQL2012, версия SQL: 12 |
| **Справочные материалы**              | [Рекомендации по обеспечению безопасности автономных баз данных](/sql/relational-databases/databases/security-best-practices-with-contained-databases) |
| **Шаги** | Отсутствие принудительной политики паролей может увеличить вероятность установки слабых учетных данных в автономной базе данных. Используйте проверку подлинности Windows. |

## <a name="use-per-device-authentication-credentials-using-sas-tokens"></a><a id="authn-sas-tokens"></a>Используйте учетные данные проверки подлинности на уровне отдельного устройства с помощью маркеров SaS

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | концентратору событий Azure |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Общие сведения о проверке подлинности в Центрах событий Azure и модели безопасности](../../event-hubs/authenticate-shared-access-signature.md) |
| **Шаги** | <p>В основе модели безопасности Центров событий лежит сочетание издателей событий и маркеров подписанных URL-адресов (SAS). Имя издателя представляет идентификатор устройства, которое получает маркер. Это поможет связать маркеры, созданные с помощью соответствующих устройств.</p><p>Все сообщения помечаются отправителем на стороне службы, что дает возможность обнаруживать попытки подделки происхождения в полезных данных. При проверке подлинности устройств создавайте маркер SaS для каждого устройства с использованием уникального издателя.</p>|

## <a name="enable-azure-ad-multi-factor-authentication-for-azure-administrators"></a><a id="multi-factor-azure-admin"></a>Включение многофакторной идентификации Azure AD для администраторов Azure

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Граница доверия Azure |
| **Этап SDL**               | Развертывание |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Что такое Многофакторная идентификация Azure AD?](../../active-directory/authentication/concept-mfa-howitworks.md) |
| **Шаги** | <p>Многофакторная идентификация Azure (MFA) — это метод аутентификации, который требует применения более одного метода проверки и добавляет критически важный второй уровень безопасности для операций входа и транзакций пользователя. Во время работы он требует использования двух и более методов проверки следующего характера:</p><ul><li>Известные вам сведения (обычно это пароль)</li><li>Имеющееся у вас оборудование (доверенное устройство, которое трудно дублировать, например телефон)</li><li>Что-то, относящееся непосредственно к вам (биометрические данные).</li><ul>|

## <a name="restrict-anonymous-access-to-service-fabric-cluster"></a><a id="anon-access-cluster"></a>Запретите анонимный доступ к кластеру Service Fabric

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Граница доверия Service Fabric |
| **Этап SDL**               | Развертывание |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Среда: Azure  |
| **Справочные материалы**              | [Сценарии защиты кластера Service Fabric](../../service-fabric/service-fabric-cluster-security.md) |
| **Шаги** | <p>Кластеры всегда должны быть защищены для предотвращения подключения к ним неавторизованных пользователей, особенно в тех случаях, когда на кластере выполняются рабочие нагрузки в рабочей среде.</p><p>При создании кластера Service Fabric убедитесь, что для режима безопасности задано значение "seсure", и настройте требуемый сертификат сервера X.509. Создание незащищенного кластера позволит любому анонимному пользователю подключаться к нему, если конечные точки управления кластером общедоступны через Интернет.</p>|

## <a name="ensure-that-service-fabric-client-to-node-certificate-is-different-from-node-to-node-certificate"></a><a id="fabric-cn-nn"></a>Сертификат Service Fabric для обмена данными между клиентом и узлом должен отличаться от простого сертификата для обмена данными между узлами

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Граница доверия Service Fabric |
| **Этап SDL**               | Развертывание |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Среда: Azure, автономная |
| **Справочные материалы**              | [Сценарии защиты кластера Service Fabric](../../service-fabric/service-fabric-cluster-security.md#client-to-node-certificate-security), [Безопасное подключение к кластеру](../../service-fabric/service-fabric-connect-to-secure-cluster.md) |
| **Шаги** | <p>Безопасность обмена данными между клиентами и узлами на основе сертификатов настраивается при создании кластера (на портале Azure, с помощью шаблонов Resource Manager или автономного шаблона JSON). Для этого указывается сертификат клиента администрирования и (или) пользовательский сертификат клиента.</p><p>Эти сертификаты должны отличаться от основного и дополнительного сертификатов, указанных для защиты обмена данными между узлами.</p>|

## <a name="use-aad-to-authenticate-clients-to-service-fabric-clusters"></a><a id="aad-client-fabric"></a>Используйте AAD для проверки подлинности клиентов в кластерах Service Fabric

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Граница доверия Service Fabric |
| **Этап SDL**               | Развертывание |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Среда: Azure |
| **Справочные материалы**              | [Рекомендации по обеспечению безопасности](../../service-fabric/service-fabric-cluster-security.md#security-recommendations) |
| **Шаги** | Для защиты доступа к конечным точкам управления, помимо сертификатов клиентов, кластеры под управлением Azure также могут использовать Azure Active Directory (AAD). Чтобы обеспечить безопасность обмена данными между узлами в кластерах Azure, рекомендуется использовать безопасность AAD для аутентификации клиентов и сертификатов.|

## <a name="ensure-that-service-fabric-certificates-are-obtained-from-an-approved-certificate-authority-ca"></a><a id="fabric-cert-ca"></a>Нужно использовать сертификаты Service Fabric, полученные из утвержденного Центра сертификации

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Граница доверия Service Fabric |
| **Этап SDL**               | Развертывание |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Среда: Azure |
| **Справочные материалы**              | [Сертификаты X.509 и Service Fabric](../../service-fabric/service-fabric-cluster-security.md#x509-certificates-and-service-fabric) |
| **Шаги** | <p>Для проверки подлинности узлов и клиентов Service Fabric использует сертификаты сервера X.509.</p><p>При использовании сертификатов в Service Fabric следует учитывать некоторые важные моменты:</p><ul><li>Сертификаты, которые используются в кластерах, выполняющих рабочие нагрузки в рабочей среде, следует создать с помощью правильно настроенной службы сертификации Windows Server или получить из утвержденного центра сертификации. Центр сертификации может быть утвержденным внешним центром сертификации или правильно управляемой внутренней инфраструктурой открытых ключей (PKI).</li><li>Никогда не используйте в рабочей среде какие-либо временные или тестовые сертификаты, созданные с помощью таких инструментов, как MakeCert.exe.</li><li>Можно использовать самозаверяющий сертификат, но это следует делать только для тестовых кластеров, а не в рабочей среде.</li></ul>|

## <a name="use-standard-authentication-scenarios-supported-by-identity-server"></a><a id="standard-authn-id"></a>Используйте стандартные сценарии проверки подлинности, поддерживаемые сервером удостоверений

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Сервер удостоверений |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [IdentityServer3. Общая картина](https://identityserver.github.io/Documentation/docsv2/overview/bigPicture.html) |
| **Шаги** | <p>Ниже приведены типичные взаимодействия, поддерживаемые сервером удостоверений.</p><ul><li>Браузеры взаимодействуют с веб-приложениями.</li><li>Веб-приложения взаимодействуют с веб-API (иногда самостоятельно, иногда от имени пользователя).</li><li>Браузерные приложения взаимодействуют с веб-API.</li><li>Собственные приложения взаимодействуют с веб-API.</li><li>Серверные приложения взаимодействуют с веб-API.</li><li>Веб-API взаимодействуют с веб-API (иногда самостоятельно, иногда от имени пользователя).</li></ul>|

## <a name="override-the-default-identity-server-token-cache-with-a-scalable-alternative"></a><a id="override-token"></a>Переопределите кэш маркеров сервера удостоверений по умолчанию масштабируемым альтернативным кэшем

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Сервер удостоверений |
| **Этап SDL**               | Развертывание |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Развертывание сервера удостоверений. Кэширование](https://identityserver.github.io/Documentation/docsv2/advanced/deployment.html) |
| **Шаги** | <p>Сервер удостоверений имеет простой встроенный кэш, работающий в памяти. Хотя он хорошо подходит для небольших собственных приложений, он не масштабируется для приложений среднего уровня и приложений уровня сервера по следующим причинам.</p><ul><li>Доступ к этим приложениям осуществляют несколько пользователей одновременно. Если сохранять все маркеры доступа в одном хранилище, могут возникнуть трудности с изоляцией, которые вызовут проблемы при увеличении масштаба. При множестве пользователей с количеством маркеров, равным количеству ресурсов, к которым приложение обращается от их имени, может стать больше ресурсоемких операций поиска сопоставлений.</li><li>Эти приложения обычно развертываются в распределенной топологии, где несколько узлов должны иметь доступ к одному кэшу.</li><li>Кэшированные маркеры должны выдерживать перезапуски и деактивации процесса.</li><li>По указанным выше причинам при реализации веб-приложений рекомендуется переопределить кэш маркеров сервера удостоверений по умолчанию масштабируемым альтернативным кэшем, например кэшем Azure для Redis.</li></ul>|

## <a name="ensure-that-deployed-applications-binaries-are-digitally-signed"></a><a id="binaries-signed"></a>Двоичные файлы развернутого приложения должны иметь цифровую подпись

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Отношения доверия между компьютерами |
| **Этап SDL**               | Развертывание |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Шаги** | Убедитесь, что все двоичные файлы развернутого приложения имеют цифровую подпись, что дает возможность проверить их целостность.|

## <a name="enable-authentication-when-connecting-to-msmq-queues-in-wcf"></a><a id="msmq-queues"></a>Включите проверку подлинности при подключении к очередям MSMQ в WCF

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | WCF |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальные, .NET Framework 3 |
| **Атрибуты**              | Недоступно |
| **Справочные материалы**              | [MSDN](/previous-versions/msp-n-p/ff648500(v=pandp.10)) |
| **Шаги** | Если при подключении к очередям MSMQ программе не удается включить проверку подлинности, злоумышленник может анонимно отправить сообщения в очередь для обработки. Если для подключения к очереди MSMQ, которая используется для доставки сообщения в другую программу, проверка подлинности отсутствует, злоумышленник может анонимно отправить вредоносное сообщение.|

### <a name="example"></a>Пример
Элемент `<netMsmqBinding/>` расположенного ниже файла конфигурации WCF указывает WCF отключить проверку подлинности при подключении к очереди MSMQ для доставки сообщений.
```
<bindings>
    <netMsmqBinding>
        <binding>
            <security>
                <transport msmqAuthenticationMode=""None"" />
            </security>
        </binding>
    </netMsmqBinding>
</bindings>
```
Настройте в MSMQ обязательную проверку подлинности сертификата или домена Windows для всех входящих или исходящих сообщений.

### <a name="example"></a>Пример
Элемент `<netMsmqBinding/>` расположенного ниже файла конфигурации WCF указывает WCF включить проверку подлинности сертификата при подключении к очереди MSMQ. Проверка подлинности клиента выполняется с использованием сертификатов X.509. Сертификат клиента должен присутствовать в хранилище сертификатов сервера.
```
<bindings>
    <netMsmqBinding>
        <binding>
            <security>
                <transport msmqAuthenticationMode=""Certificate"" />
            </security>
        </binding>
    </netMsmqBinding>
</bindings>
```

## <a name="wcf-do-not-set-message-clientcredentialtype-to-none"></a><a id="message-none"></a>WCF: не присваивайте атрибуту message clientCredentialType значение None

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | WCF |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | .NET Framework 3 |
| **Атрибуты**              | Тип учетных данных клиента: None |
| **Справочные материалы**              | [MSDN](/previous-versions/msp-n-p/ff648500(v=pandp.10)), [Fortify](https://community.microfocus.com/t5/UFT-Discussions/UFT-API-Test-with-WCF-wsHttpBinding/m-p/600927) |
| **Шаги** | Отсутствие проверки подлинности означает, что каждый может получить доступ к этой службе. Служба, которая не выполняет проверку подлинности своих клиентов, предоставляет доступ всем пользователям. Настройте в приложении проверку подлинности учетных данных клиента. Это можно сделать, задав для атрибута message clientCredentialType значение Windows или Certificate. |

### <a name="example"></a>Пример
```
<message clientCredentialType=""Certificate""/>
```

## <a name="wcf-do-not-set-transport-clientcredentialtype-to-none"></a><a id="transport-none"></a>WCF: не присваивайте атрибуту transport clientCredentialType значение None

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | WCF |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальные, .NET Framework 3 |
| **Атрибуты**              | Тип учетных данных клиента: None |
| **Справочные материалы**              | [MSDN](/previous-versions/msp-n-p/ff648500(v=pandp.10)), [Fortify](https://community.microfocus.com/t5/UFT-Discussions/UFT-API-Test-with-WCF-wsHttpBinding/m-p/600927) |
| **Шаги** | Отсутствие проверки подлинности означает, что каждый может получить доступ к этой службе. Служба, которая не выполняет проверку подлинности своих клиентов, предоставляет доступ к своим функциям всем пользователям. Настройте в приложении проверку подлинности учетных данных клиента. Это можно сделать, задав для атрибута transport clientCredentialType значение Windows или Certificate. |

### <a name="example"></a>Пример
```
<transport clientCredentialType=""Certificate""/>
```

## <a name="ensure-that-standard-authentication-techniques-are-used-to-secure-web-apis"></a><a id="authn-secure-api"></a>Для защиты веб-API нужно использовать стандартные методы проверки подлинности

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-API |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Проверка подлинности и авторизация в веб-API ASP.NET](https://www.asp.net/web-api/overview/security/authentication-and-authorization-in-aspnet-web-api), [сведения о внешних службах проверки подлинности с веб-API ASP.NET (C#)](https://www.asp.net/web-api/overview/security/external-authentication-services) |
| **Шаги** | <p>Проверка подлинности — это процесс, во время которого сущность подтверждает свою подлинность с помощью учетных данных, таких как имя пользователя и пароль. Существует множество протоколов проверки подлинности, включая следующие:</p><ul><li>Client certificates</li><li>на основе Windows;</li><li>на основе форм;</li><li>федерация: ADFS;</li><li>федерация: Azure AD;</li><li>федерация: сервер удостоверений.</li></ul><p>Ссылки в разделе справочных сведений предоставляют низкоуровневые сведения о том, как можно реализовать каждую схему проверки подлинности для защиты веб-API.</p>|

## <a name="use-standard-authentication-scenarios-supported-by-azure-active-directory"></a><a id="authn-aad"></a>Используйте стандартные сценарии проверки подлинности, поддерживаемые Azure Active Directory

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Azure AD |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Сценарии аутентификации в Azure Active Directory](../../active-directory/develop/authentication-vs-authorization.md), [Примеры кода Azure Active Directory](../../active-directory/azuread-dev/sample-v1-code.md), [Руководство разработчика по Azure Active Directory](../../active-directory/develop/index.yml) |
| **Шаги** | <p>Azure Active Directory (Azure AD) упрощает аутентификацию для разработчиков, предоставляя удостоверение как услугу, благодаря поддержке стандартных протоколов, например OAuth 2.0 и OpenID Connect. Ниже приведены пять основных сценариев приложений, которые поддерживает служба Azure AD.</p><ul><li>Из веб-браузера в веб-приложение. Пользователю нужно войти в веб-приложение, защиту которого выполняет Azure AD.</li><li>Одностраничное приложение (SPA). Пользователю нужно войти в одностраничное приложение, защиту которого выполняет Azure AD.</li><li>Из собственного приложения в веб-интерфейс API. Собственному приложению, которое выполняется на телефоне, планшете или ПК, требуется проверить подлинность пользователя для получения ресурсов из веб-интерфейса API, защиту которого обеспечивает Azure AD.</li><li>Из веб-приложения в веб-интерфейс API. Веб-приложению требуется получать ресурсы из веб-интерфейса API, защиту которого обеспечивает Azure AD.</li><li>Из управляющей программы или серверного приложения в веб-интерфейс API. Управляющей программе (демону) или серверному приложению, в котором нет веб-интерфейса пользователя, требуется получить ресурсы из веб-интерфейса API, защиту которого обеспечивает Azure AD.</li></ul><p>Используйте ссылки в разделе справочных сведений, чтобы получить низкоуровневые сведения о реализации.</p>|

## <a name="override-the-default-adal-token-cache-with-a-scalable-alternative"></a><a id="adal-scalable"></a>Переопределите кэш маркера ADAL по умолчанию масштабируемым альтернативным кэшем

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Azure AD |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Современная проверка подлинности с помощью Azure Active Directory для веб-приложений](/archive/blogs/microsoft_press/new-book-modern-authentication-with-azure-active-directory-for-web-applications), [запись блога об использовании Redis в качестве кэша маркеров ADAL](https://blogs.msdn.microsoft.com/mrochon/2016/09/19/using-redis-as-adal-token-cache/)  |
| **Шаги** | <p>Кэш по умолчанию, который использует ADAL, — это работающий в памяти кэш, который зависит от статического хранилища и доступен на уровне процессов. Хотя он подходит для собственных приложений, он не масштабируется для приложений среднего уровня и приложений уровня сервера по следующим причинам.</p><ul><li>Доступ к этим приложениям осуществляют несколько пользователей одновременно. Если сохранять все маркеры доступа в одном хранилище, могут возникнуть трудности с изоляцией, которые вызовут проблемы при увеличении масштаба. При множестве пользователей с количеством маркеров, равным количеству ресурсов, к которым приложение обращается от их имени, может стать больше ресурсоемких операций поиска сопоставлений.</li><li>Эти приложения обычно развертываются в распределенной топологии, где несколько узлов должны иметь доступ к одному кэшу.</li><li>Кэшированные маркеры должны выдерживать перезапуски и деактивации процесса.</li></ul><p>По указанным выше причинам при реализации веб-приложений рекомендуется переопределить кэш маркеров ADAL по умолчанию масштабируемым альтернативным кэшем, например кэшем Azure для Redis.</p>|

## <a name="ensure-that-tokenreplaycache-is-used-to-prevent-the-replay-of-adal-authentication-tokens"></a><a id="tokenreplaycache-adal"></a>Для предотвращения воспроизведения маркеров проверки подлинности ADAL нужно использовать свойство TokenReplayCache

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Azure AD |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Современная проверка подлинности с помощью Azure Active Directory для веб-приложений](/archive/blogs/microsoft_press/new-book-modern-authentication-with-azure-active-directory-for-web-applications) |
| **Шаги** | <p>Свойство TokenReplayCache позволяет разработчикам определять кэш воспроизведения маркеров, хранилище, которое можно использовать для сохранения маркеров, чтобы предотвратить использование повторяющихся маркеров.</p><p>Эта мера защиты от распространенных атак с использованием воспроизведения маркеров. Злоумышленник, который перехватывает маркер, отправленный при входе в систему, может попытаться снова отправить его в приложение ("воспроизвести" его), чтобы создать новый сеанс. Например, в потоке предоставления кода OIDC после успешной проверки подлинности пользователя запрос к конечной точке "/signin-oidc" проверяющей стороны выполняется с параметрами "id_token", "code" и "state".</p><p>Проверяющая сторона проверяет запрос и создает новый сеанс. Если злоумышленник перехватил и воспроизвел этот запрос, он может успешно создать сеанс, выдав себя за пользователя. Наличие специального утверждения в OpenID Connect может ограничить, но не полностью исключить подобные атаки. Чтобы защитить свои приложения, разработчики могут реализовать интерфейс ITokenReplayCache и присвоить экземпляр свойству TokenReplayCache.</p>|

### <a name="example"></a>Пример
```csharp
// ITokenReplayCache defined in ADAL
public interface ITokenReplayCache
{
bool TryAdd(string securityToken, DateTime expiresOn);
bool TryFind(string securityToken);
}
```

### <a name="example"></a>Пример
Ниже приведен пример реализации интерфейса ITokenReplayCache. (Выполните соответствующие настройки и реализуйте платформу кэширования конкретного проекта.)
```csharp
public class TokenReplayCache : ITokenReplayCache
{
    private readonly ICacheProvider cache; // Your project-specific cache provider
    public TokenReplayCache(ICacheProvider cache)
    {
        this.cache = cache;
    }
    public bool TryAdd(string securityToken, DateTime expiresOn)
    {
        if (this.cache.Get<string>(securityToken) == null)
        {
            this.cache.Set(securityToken, securityToken);
            return true;
        }
        return false;
    }
    public bool TryFind(string securityToken)
    {
        return this.cache.Get<string>(securityToken) != null;
    }
}
```
Ссылку на реализованный кэш нужно добавить в параметрах OIDC с помощью свойства TokenValidationParameters следующим образом.
```csharp
OpenIdConnectOptions openIdConnectOptions = new OpenIdConnectOptions
{
    AutomaticAuthenticate = true,
    ... // other configuration properties follow..
    TokenValidationParameters = new TokenValidationParameters
    {
        TokenReplayCache = new TokenReplayCache(/*Inject your cache provider*/);
    }
}
```

Чтобы проверить эффективность данной конфигурации, войдите в локальное приложение, защищенное с помощью OIDC, и запишите запрос к конечной точке `"/signin-oidc"` в Fiddler. Если защита не включена, воспроизведение этого запроса в Fiddler приведет к созданию нового файла cookie сеанса. При воспроизведении запроса после добавления защиты с помощью свойства TokenReplayCache приложение выдаст исключение следующего типа: `SecurityTokenReplayDetectedException: IDX10228: The securityToken has previously been validated, securityToken: 'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik1uQ19WWmNBVGZNNXBPWWlKSE1iYTlnb0VLWSIsImtpZCI6Ik1uQ1......`

## <a name="use-adal-libraries-to-manage-token-requests-from-oauth2-clients-to-aad-or-on-premises-ad"></a><a id="adal-oauth2"></a>Используйте библиотеки ADAL для управления запросами маркеров от клиентов OAuth2 к AAD (или к локальной службе AD)

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Azure AD |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [ADAL](../../active-directory/azuread-dev/active-directory-authentication-libraries.md) |
| **Шаги** | <p>Библиотека проверки подлинности Azure AD (ADAL) позволяет разработчикам клиентских приложений легко проверять подлинность пользователей в облачной или локальной Active Directory (AD) и получать маркеры доступа для защиты вызовов API.</p><p>ADAL имеет множество функций, которые упрощают проверку подлинности для разработчиков. К ним относятся поддержка асинхронных операций, настраиваемый кэш маркеров, в котором хранятся маркеры доступа и маркеры обновления, автоматическое обновление маркера, когда срок действия маркера доступа истекает и маркер обновления доступен, и многие другие функции.</p><p>ADAL берет на себя большую часть сложных операций и позволяет разработчику сосредоточиться на бизнес-логике своего приложения и легко защитить ресурсы, не будучи экспертом в области безопасности. Отдельные библиотеки доступны для .NET, JavaScript (клиент и Node.js), Python, iOS, Android и Java.</p>|

## <a name="authenticate-devices-connecting-to-the-field-gateway"></a><a id="authn-devices-field"></a>Проверяйте подлинность устройств, подключаемых к полевому шлюзу

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Полевой шлюз Интернета вещей |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Шаги** | Настройте полевой шлюз таким образом, чтобы он выполнял проверку подлинности каждого устройства, прежде чем получать от них данные и упрощать взаимодействие вышестоящих объектов с облачным шлюзом. Кроме того, настройте подключение устройств с помощью учетных данных на уровне отдельного устройства, чтобы уникально идентифицировать отдельные устройства.|

## <a name="ensure-that-devices-connecting-to-cloud-gateway-are-authenticated"></a><a id="authn-devices-cloud"></a>Устройства, подключаемые к облачному шлюзу, должны проходить проверку подлинности

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Облачный шлюз Интернета вещей |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальное, C#, Node.js  |
| **Атрибуты**              | Н/д, выбор шлюза: Центр Интернета вещей Azure |
| **Справочные материалы**              | "Н/д", [центр Интернета вещей Azure с .NET](../../iot-hub/quickstart-send-telemetry-dotnet.md), [Начало работы с центром Интернета вещей и node JS](../../iot-hub/quickstart-send-telemetry-node.md), [безопасность Интернета вещей с SAS и сертификатами](../../iot-hub/iot-hub-devguide-security.md), [репозиторий Git](https://github.com/Azure/azure-iot-sdks/) |
| **Шаги** | <ul><li>**Универсальное.** Выполняйте проверку подлинности устройства с использованием протокола TLS или IPSec. Инфраструктура должна поддерживать общие ключи для тех устройств, которые не выполняют полное асимметричное шифрование. Используйте Azure AD, OAuth.</li><li>**C#.** При создании экземпляра DeviceClient по умолчанию метод Create создает экземпляр DeviceClient, который использует протокол AMQP для связи с Центром Интернета вещей. Для использования протокола HTTPS используйте переопределение метода Create, чтобы указать протокол. Если вы используете протокол HTTPS, вам также следует добавить в свой проект пакет NuGet `Microsoft.AspNet.WebApi.Client`, чтобы включить пространство имен `System.Net.Http.Formatting`.</li></ul>|

### <a name="example"></a>Пример
```csharp
static DeviceClient deviceClient;

static string deviceKey = "{device key}";
static string iotHubUri = "{iot hub hostname}";

var messageString = "{message in string format}";
var message = new Message(Encoding.ASCII.GetBytes(messageString));

deviceClient = DeviceClient.Create(iotHubUri, new DeviceAuthenticationWithRegistrySymmetricKey("myFirstDevice", deviceKey));

await deviceClient.SendEventAsync(message);
```

### <a name="example"></a>Пример
**Проверка подлинности Node.js**
#### <a name="symmetric-key"></a>Симметричный ключ
* Создание центра Интернета вещей в Azure
* Создайте запись в реестре удостоверений устройств.
    ```javascript
    var device = new iothub.Device(null);
    device.deviceId = <DeviceId >
    registry.create(device, function(err, deviceInfo, res) {})
    ```
* Создайте виртуальное устройство.
    ```javascript
    var clientFromConnectionString = require('azure-iot-device-amqp').clientFromConnectionString;
    var Message = require('azure-iot-device').Message;
    var connectionString = 'HostName=<HostName>DeviceId=<DeviceId>SharedAccessKey=<SharedAccessKey>';
    var client = clientFromConnectionString(connectionString);
    ```
  #### <a name="sas-token"></a>Маркер SAS
* Создается в системе при использовании симметричного ключа, но его также можно создать и использовать явным образом.
* Определите протокол: `var Http = require('azure-iot-device-http').Http;`
* Создайте маркер SAS:
    ```javascript
    resourceUri = encodeURIComponent(resourceUri.toLowerCase()).toLowerCase();
    var deviceName = "<deviceName >";
    var expires = (Date.now() / 1000) + expiresInMins * 60;
    var toSign = resourceUri + '\n' + expires;
    // using crypto
    var decodedPassword = new Buffer(signingKey, 'base64').toString('binary');
    const hmac = crypto.createHmac('sha256', decodedPassword);
    hmac.update(toSign);
    var base64signature = hmac.digest('base64');
    var base64UriEncoded = encodeURIComponent(base64signature);
    // construct authorization string
    var token = "SharedAccessSignature sr=" + resourceUri + "%2fdevices%2f"+deviceName+"&sig="
  + base64UriEncoded + "&se=" + expires;
    if (policyName) token += "&skn="+policyName;
    return token;
    ```
* Подключитесь с помощью маркера SAS:
    ```javascript
    Client.fromSharedAccessSignature(sas, Http);
    ```
  #### <a name="certificates"></a>Сертификаты
* Создайте самозаверяющий сертификат X509 с помощью любого средства, такого как OpenSSL, чтобы создать файлы CERT и KEY для хранения сертификата и ключа соответственно.
* Подготовьте устройство, которое принимает безопасное подключение с использованием сертификатов.
    ```javascript
    var connectionString = '<connectionString>';
    var registry = iothub.Registry.fromConnectionString(connectionString);
    var deviceJSON = {deviceId:"<deviceId>",
    authentication: {
        x509Thumbprint: {
        primaryThumbprint: "<PrimaryThumbprint>",
        secondaryThumbprint: "<SecondaryThumbprint>"
        }
    }}
    var device = deviceJSON;
    registry.create(device, function (err) {});
    ```
* Подключите устройство с помощью сертификата.
    ```javascript
    var Protocol = require('azure-iot-device-http').Http;
    var Client = require('azure-iot-device').Client;
    var connectionString = 'HostName=<HostName>DeviceId=<DeviceId>x509=true';
    var client = Client.fromConnectionString(connectionString, Protocol);
    var options = {
        key: fs.readFileSync('./key.pem', 'utf8'),
        cert: fs.readFileSync('./server.crt', 'utf8')
    };
    // Calling setOptions with the x509 certificate and key (and optionally, passphrase) will configure the client //transport to use x509 when connecting to IoT Hub
    client.setOptions(options);
    //call fn to execute after the connection is set up
    client.open(fn);
    ```

## <a name="use-per-device-authentication-credentials"></a><a id="authn-cred"></a>Используйте учетные данные проверки подлинности на уровне отдельного устройства

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Облачный шлюз Интернета вещей  |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Выбор шлюза: Центр Интернета вещей Azure |
| **Справочные материалы**              | [Маркеры безопасности Центра Интернета вещей Azure](../../iot-hub/iot-hub-devguide-security.md) |
| **Шаги** | Используйте учетные данные проверки подлинности с помощью маркеров SAS на основе ключа устройства или сертификата клиента для каждого отдельного устройства вместо политик общего доступа на уровне Центра Интернета вещей. Это предотвратит повторное использование маркеров проверки подлинности одного устройства или полевого шлюза другим устройством. |

## <a name="ensure-that-only-the-required-containers-and-blobs-are-given-anonymous-read-access"></a><a id="req-containers-anon"></a>Анонимный доступ на чтение должен быть предоставлен только к необходимым контейнерам и большим двоичным объектам

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Хранилище Azure |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Тип хранилища: большой двоичный объект |
| **Справочные материалы**              | [Управление анонимным доступом на чтение к контейнерам и большим двоичным объектам](../../storage/blobs/anonymous-read-access-configure.md), [Использование подписанных URL-адресов (SAS): общие сведения о модели SAS](../../storage/common/storage-sas-overview.md) |
| **Шаги** | <p>По умолчанию контейнер и все большие двоичные объекты внутри него доступны только владельцу учетной записи хранения. Чтобы предоставить анонимным пользователями доступ на их чтение, следует разрешить общий доступ к контейнеру. Анонимные пользователи могут считывать данные большого двоичного объекта из общедоступного контейнера, при этом их запросы не будут проходить аутентификацию.</p><p>Доступны следующие возможности управления доступом к контейнеру.</p><ul><li>Полный общий доступ на чтение: контейнер и данные больших двоичных объектов можно считывать с помощью анонимного запроса. Клиенты могут перечислять BLOB-объекты внутри контейнера с помощью анонимного запроса, но не могут перечислять контейнеры в учетной записи хранения.</li><li>Общий доступ на чтение только для больших двоичных объектов: данные больших двоичных объектов в этом контейнере можно считать с помощью анонимного запроса, но данные контейнера недоступны. Клиенты не могут перечислять большие двоичные объекты внутри с помощью анонимного запроса.</li><li>Без общего доступа для чтения: контейнер и данные больших двоичных объектов может считывать только владелец учетной записи.</li></ul><p>Анонимный доступ лучше всего подходит для сценариев, когда определенные большие двоичные объекты нужно сделать всегда доступными для анонимного доступа на чтение. Для осуществления детального контроля можно создать подписанный URL-адрес, который позволит делегировать ограниченный доступ на определенный временной интервал, используя разные разрешения. Проверьте, чтобы случайно не был предоставлен анонимный доступ к контейнерам и большим двоичным объектам, которые могут содержать конфиденциальные данные.</p>|

## <a name="grant-limited-access-to-objects-in-azure-storage-using-sas-or-sap"></a><a id="limited-access-sas"></a>Предоставьте ограниченный доступ к объектам в службе хранилища Azure с помощью SAS или SAP

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Хранилище Azure |
| **Этап SDL**               | Сборка |
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно |
| **Справочные материалы**              | [Использование подписанных URL-адресов (SAS): общие сведения о модели SAS](../../storage/common/storage-sas-overview.md), [Подписанные URL-адреса. Часть 2: создание и использование подписанного URL-адреса в службе BLOB-объектов](../../storage/common/storage-sas-overview.md), [сведения о делегировании доступа к объектам в учетной записи с помощью подписанных URL-адресов и хранимых политик доступа](../../storage/blobs/security-recommendations.md#identity-and-access-management) |
| **Шаги** | <p>Подписанный URL-адрес (SAS) — это эффективное средство для предоставления другим клиентам ограниченного доступа к объектам в вашей учетной записи хранения без предоставления ключа доступа к вашей учетной записи. Подпись общего доступа — это URI, который в своих параметрах запроса содержит все сведения, необходимые доступа к ресурсу хранилища с прохождением проверки подлинности. Для доступа к ресурсам хранилища с помощью SAS клиенту достаточно передать SAS в соответствующий конструктор или метод.</p><p>Подпись общего доступа можно использовать, когда доступ к ресурсам в вашей учетной записи хранения требуется предоставить клиенту, которому нельзя доверить ключ учетной записи. Ключи вашей учетной записи хранения включают в себя как первичный, так и вторичный ключ, и оба этих ключа предоставляют административный доступ к вашей учетной записи и всем ее ресурсам. Предоставление любого из ключей учетной записи делает ее уязвимой вредоносного или небрежного использования. Подписи общего доступа обеспечивают безопасную альтернативу, позволяющую другим клиентам считывать, записывать и удалять данные в вашей учетной записи хранения в соответствии с выданными вами разрешениями и без потребности в ключе учетной записи.</p><p>Если у вас есть логически связанный и относительно постоянный набор параметров, лучше использовать хранимую политику доступа. Та как подписанный URL-адрес, полученный на основе хранимой политики доступа, можно отозвать немедленно, рекомендуется использовать хранимые политики доступа всегда, когда это возможно.</p>|