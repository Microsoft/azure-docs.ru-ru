---
title: Общие сведения о поддержке Azure MQTT в Центре Интернета вещей | Документация Майкрософт
description: Поддержка устройств, подключающихся к конечной точке центра Интернета вещей с помощью протокола MQTT. Содержит сведения о встроенной поддержке MQTT в пакетах SDK для устройств Azure IoT.
author: robinsh
ms.service: iot-hub
services: iot-hub
ms.topic: conceptual
ms.date: 10/12/2018
ms.author: robinsh
ms.custom:
- amqp
- mqtt
- 'Role: IoT Device'
- 'Role: Cloud Development'
- contperf-fy21q1
- fasttrack-edit
- iot
ms.openlocfilehash: df706a83c4892c15140e5d5c827a248156b66069
ms.sourcegitcommit: 97c48e630ec22edc12a0f8e4e592d1676323d7b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/18/2021
ms.locfileid: "101095675"
---
# <a name="communicate-with-your-iot-hub-using-the-mqtt-protocol"></a>Взаимодействие с Центром Интернета вещей с помощью протокола MQTT

Центр Интернета вещей позволяет устройствам взаимодействовать с конечными точками устройств Центра Интернета вещей с помощью:

* протокола [MQTT версии 3.1.1](https://mqtt.org/) на порту 8883;
* протокола MQTT версии 3.1.1 через WebSocket на порту 443.

Центр Интернета вещей не является полнофункциональным брокером MQTT и не поддерживает все функциональные возможности, указанные в стандарте MQTT версии 3.1.1. В этой статье описывается, как устройства могут использовать поддерживаемые MQTT поведения для связи с Центром Интернета вещей.

[!INCLUDE [iot-hub-basic](../../includes/iot-hub-basic-partial.md)]

Весь обмен данными Центра Интернета вещей с устройствами защищен с помощью протокола TLS/SSL. Таким образом, Центр Интернета вещей не поддерживает небезопасные подключения через порт 1883.

## <a name="connecting-to-iot-hub"></a>Подключение к Центру Интернета вещей

На устройстве протокол MQTT можно использовать для подключения к Центру Интернета вещей с помощью любого из следующих способов.

* Посредством библиотеки в [пакетах SDK для Azure IoT](https://github.com/Azure/azure-iot-sdks).
* Непосредственно с помощью протокола MQTT.

Порт MQTT (8883) блокируется во многих корпоративных и образовательных сетевых средах. Если в брандмауэре не удается открыть порт 8883, рекомендуется использовать MQTT через веб-сокеты. MQTT через веб-сокеты передает данные через порт 443, который почти всегда открыт в сетевых средах. Чтобы узнать, как указать протоколы MQTT и MQTT через веб-сокеты при использовании пакетов SDK для Azure IoT, см. раздел [Использование пакетов SDK для устройств](#using-the-device-sdks).

## <a name="using-the-device-sdks"></a>Использование пакетов SDK для устройств

Доступны [пакеты SDK для устройств](https://github.com/Azure/azure-iot-sdks) с поддержкой протокола MQTT для Java, Node.js, C, C# и Python. Для установки подключения к Центру Интернета вещей пакеты SDK для устройств используют стандартную строку подключения к Центру Интернета вещей. Чтобы использовать протокол MQTT, параметр протокола клиента должен быть задан как **MQTT**. В параметре протокола клиента можно также указать MQTT через веб-сокеты. По умолчанию пакеты SDK для устройств подключаются к Центру Интернета вещей, если для флага **CleanSession** установлено значение **0**, и используют **качество обслуживания первого уровня** для обмена сообщениями с Центром Интернета вещей. Хотя можно настроить **качество обслуживания 0** для ускорения обмена сообщениями, следует отметить, что доставка не гарантирована и не подтверждена. По этой причине **качество обслуживания 0** часто упоминается как «пожар и забыть».

Когда устройство подключено к Центру Интернета вещей, пакеты SDK для устройства предоставляют методы, позволяющие устройству осуществлять обмен сообщениями с Центром Интернета вещей.

В следующей таблице содержатся ссылки на примеры кода для каждого поддерживаемого языка и указаны параметры, используемые для подключения к Центру Интернета вещей по протоколу MQTT и MQTT через веб-сокеты.

| Язык | Параметр протокола MQTT | Параметр протокола MQTT через веб-сокеты
| --- | --- | --- |
| [Node.js](https://github.com/Azure/azure-iot-sdk-node/blob/master/device/samples/simple_sample_device.js) | azure-iot-device-mqtt.Mqtt | azure-iot-device-mqtt.MqttWs |
| [Java](https://github.com/Azure/azure-iot-sdk-java/blob/master/device/iot-device-samples/send-receive-sample/src/main/java/samples/com/microsoft/azure/sdk/iot/SendReceive.java) |[IotHubClientProtocol](/java/api/com.microsoft.azure.sdk.iot.device.iothubclientprotocol?view=azure-java-stable&preserve-view=true).MQTT | IotHubClientProtocol.MQTT_WS |
| [C](https://github.com/Azure/azure-iot-sdk-c/tree/master/iothub_client/samples/iothub_client_sample_mqtt_dm) | [MQTT_Protocol](/azure/iot-hub/iot-c-sdk-ref/iothubtransportmqtt-h/mqtt-protocol) | [MQTT_WebSocket_Protocol](/azure/iot-hub/iot-c-sdk-ref/iothubtransportmqtt-websockets-h/mqtt-websocket-protocol) |
| [C#](https://github.com/Azure/azure-iot-sdk-csharp/tree/master/iothub/device/samples) | [TransportType](/dotnet/api/microsoft.azure.devices.client.transporttype?view=azure-dotnet&preserve-view=true).Mqtt | Если происходит сбой MQTT, для TransportType.Mqtt используется MQTT через веб-сокеты. Если нужно задать только протокол MQTT через веб-сокеты, используйте TransportType.Mqtt_WebSocket_Only. |
| [Python](https://github.com/Azure/azure-iot-sdk-python/tree/master/azure-iot-device/samples) | Поддерживает MQTT по умолчанию | Добавьте `websockets=True` в вызов, чтобы создать клиент. |

В следующем фрагменте кода показано, как указать протокол MQTT через веб-сокеты при использовании пакета SDK Node.js для Azure IoT:

```javascript
var Client = require('azure-iot-device').Client;
var Protocol = require('azure-iot-device-mqtt').MqttWs;
var client = Client.fromConnectionString(deviceConnectionString, Protocol);
```

В следующем фрагменте кода показано, как указать протокол MQTT через веб-сокеты при использовании пакета SDK Python для Azure IoT:

```python
from azure.iot.device.aio import IoTHubDeviceClient
device_client = IoTHubDeviceClient.create_from_connection_string(deviceConnectionString, websockets=True)
```

### <a name="default-keep-alive-timeout"></a>Время ожидания проверки активности по умолчанию

Чтобы обеспечить постоянную активность подключения клиента c Центром Интернета вещей, служба и клиент регулярно отправляют друг другу *проверки связи*. Клиент, использующий пакет SDK для IoT, отправляет проверку связи через интервал, указанный в следующей таблице.

|Язык  |Интервал проверки активности по умолчанию  |Настраивается  |
|---------|---------|---------|
|Node.js     |   180 секунд      |     нет    |
|Java     |    230 секунд     |     нет    |
|C     | 240 секунд |  [Да](https://github.com/Azure/azure-iot-sdk-c/blob/master/doc/Iothub_sdk_options.md#mqtt-transport)   |
|C#     | 300 секунд |  [Да](https://github.com/Azure/azure-iot-sdk-csharp/blob/master/iothub/device/src/Transport/Mqtt/MqttTransportSettings.cs#L89)   |
|Python   | 60 секунд |  нет   |

После [спецификации MQTT](http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718081)интервал проверки связи для поддержания активности в центре интернета вещей 1,5 раз превышает значение срока поддержания клиента. При этом Центр Интернета вещей ограничивает максимальное время ожидания на стороне сервера значением 29,45 минут (1767 секунд), так как все службы Azure привязаны к времени ожидания неактивного подключения TCP в Azure Load Balancer, которое составляет 29,45 минут. 

Например, устройство, использующее пакет SDK для Java, отправляет проверку связи для проверки активности, а затем теряет подключение к сети. Через 230 секунд устройство не отвечает на проверку связи, так как она находится в автономном режиме. Но Центр Интернета вещей не закрывает подключение немедленно — он ожидает еще `(230 * 1.5) - 230 = 115` секунд, прежде чем отключить устройство с ошибкой [404104 DeviceConnectionClosedRemotely](iot-hub-troubleshoot-error-404104-deviceconnectionclosedremotely.md). 

Максимальное значение интервала проверки активности клиента, которое можно задать, — `1767 / 1.5 = 1177` секунд. Любой трафик сбрасывает отсчет интервала проверки активности. Например, обновление маркера SAS сбрасывает интервал проверки активности.

### <a name="migrating-a-device-app-from-amqp-to-mqtt"></a>Переход от AMQP на MQTT в приложении устройства

Если вы используете [пакеты SDK для устройств](https://github.com/Azure/azure-iot-sdks), для переключения с использования AMQP на MQTT требуется изменить параметр протокола в инициализации клиента, как было сказано ранее.

При этом обязательно проверьте следующее:

* AMQP возвращает ошибки для многих условий, а MQTT завершает подключение. В результате может потребоваться изменить логику обработки исключений.

* MQTT не поддерживает операции *отклонения* при получении [сообщений из облака на устройство](iot-hub-devguide-messaging.md). Если нужно, чтобы внутреннее приложение получало ответы от приложения для устройства, стоит использовать [прямые методы](iot-hub-devguide-direct-methods.md).

* AMQP не поддерживается в пакете SDK для Python.

## <a name="example-in-c-using-mqtt-without-an-azure-iot-sdk"></a>Пример в C с использованием MQTT без пакета SDK для Azure IoT

В [примере репозитория IOT MQTT](https://github.com/Azure-Samples/IoTMQTTSample)вы найдете несколько демонстрационных проектов C/C++, показывающих, как отправлять сообщения телеметрии, и получать события с помощью центра Интернета вещей, не используя пакет SDK для Azure IOT C. 

В этих примерах для отправки сообщений в брокер MQTT, реализованный в центре Интернета вещей, используется библиотека Eclipse Москуитто.

Сведения о том, как адаптировать примеры для использования соглашений [Azure iot Самонастраивающийся](../iot-pnp/overview-iot-plug-and-play.md) , см. в разделе [учебник. Использование MQTT для разработки клиента центра Интернета вещей Самонастраивающийся](../iot-pnp/tutorial-use-mqtt.md).

Этот репозиторий включает следующее содержимое.

**Для Windows.**

* TelemetryMQTTWin32: содержит код для отправки сообщения телеметрии в центр Интернета вещей Azure, который создается и запускается на компьютере Windows.

* SubscribeMQTTWin32: содержит код для подписки на события определенного центра Интернета вещей на компьютере Windows.

* DeviceTwinMQTTWin32: содержит код для запроса событий двойника устройства в центре Интернета вещей на компьютере Windows и подписки на них.

* PnPMQTTWin32: содержит код для отправки сообщения телеметрии с помощью возможностей устройств IoT самонастраивающийся в центр Интернета вещей Azure, которые создаются и запускаются на компьютере Windows. Дополнительные сведения см. в статье [IoT Самонастраивающийся](../iot-pnp/overview-iot-plug-and-play.md)

**Для Linux.**

* MQTTLinux: содержит код и скрипт сборки для запуска в Linux (на данный момент протестированы в WSL, Ubuntu и Raspbian).

* LinuxConsoleVS2019: содержит тот же код, но в проекте VS2019, предназначенном для WSL (подсистема Windows для Linux). В этом проекте можно пошагово отлаживать выполняемый в Linux код в Visual Studio.

**Для mosquitto_pub.**

Эта папка содержит два примера команд, которые используются со служебным инструментом mosquitto_pub, предоставляемым Mosquitto.org.

* Mosquitto_sendmessage: для отправки простого текстового сообщения в центр Интернета вещей Azure, выполняющий роль устройства.

* Mosquitto_subscribe: для просмотра событий, происходящих в центре Интернета вещей Azure.

## <a name="using-the-mqtt-protocol-directly-as-a-device"></a>Непосредственное использование протокола MQTT (как устройство)

Если устройство не может использовать пакеты SDK для устройств, оно может подключаться к общедоступным конечным точкам устройства по протоколу MQTT по порту 8883. В пакете **CONNECT** устройство должно использовать следующие значения.

* В поле **Идентификатор клиента** укажите значение **идентификатор устройства**.

* В поле **Username** (Имя пользователя) укажите значение `{iothubhostname}/{device_id}/?api-version=2018-06-30`, где `{iothubhostname}` — это полная запись CName Центра Интернета вещей.

    Например, если имя Центра Интернета вещей — **contoso.azure-devices.net**, а имя устройства — **MyDevice01**, то полное поле **Username** (Имя пользователя) должно содержать:

    `contoso.azure-devices.net/MyDevice01/?api-version=2018-06-30`

* В поле **Пароль** укажите маркер SAS. Формат маркера SAS аналогичен описанному для протоколов HTTPS и AMQP:

  `SharedAccessSignature sig={signature-string}&se={expiry}&sr={URL-encoded-resourceURI}`

  > [!NOTE]
  > При использовании аутентификации с помощью сертификата X.509 пароли маркеров SAS не требуются. Дополнительные сведения см. в статье [Настройка безопасности X. 509 в центре Интернета вещей Azure](iot-hub-security-x509-get-started.md) и следуйте инструкциям в [разделе Настройка TLS/SSL](#tlsssl-configuration).

  Дополнительные сведения о способах создания маркеров SAS см. в соответствующем разделе статьи [Управление доступом к Центру Интернета вещей](iot-hub-devguide-security.md#use-sas-tokens-in-a-device-app).

  При тестировании можно также использовать кросс-платформенные [инструменты Azure IOT для Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=vsciot-vscode.azure-iot-tools) или команду расширения CLI [AZ-SAS-Token](/cli/azure/ext/azure-iot/iot/hub?view=azure-cli-latest#ext-azure-iot-az-iot-hub-generate-sas-token&preserve-view=true) , чтобы быстро создать маркер SAS, который можно скопировать и вставить в свой собственный код.

### <a name="for-azure-iot-tools"></a>Инструкции для Azure IoT Tools

1. Разверните вкладку **AZURE IOT HUB DEVICES** (Устройства Центра Интернета вещей Azure) в левом нижнем углу Visual Studio Code.
  
2. Щелкните устройство правой кнопкой мыши и выберите **Generate SAS Token for Device** (Создать маркер безопасности SAS для этого устройства).
  
3. Задайте **время истечения срока действия** и нажмите клавишу "ВВОД".
  
4. Маркер SAS создается и копируется в буфер обмена.

   Созданный маркер SAS имеет следующую структуру.

   `HostName={your hub name}.azure-devices.net;DeviceId=javadevice;SharedAccessSignature=SharedAccessSignature sr={your hub name}.azure-devices.net%2Fdevices%2FMyDevice01%2Fapi-version%3D2016-11-14&sig=vSgHBMUG.....Ntg%3d&se=1456481802`

   Его часть используется в поле **Пароль** для подключения с использованием MQTT:

   `SharedAccessSignature sr={your hub name}.azure-devices.net%2Fdevices%2FMyDevice01%2Fapi-version%3D2016-11-14&sig=vSgHBMUG.....Ntg%3d&se=1456481802`

Для пакетов подключения и отключения MQTT Центр Интернета вещей создает событие в канале **мониторинга операций**. Это событие содержит дополнительные сведения, которые помогут устранить неполадки с подключением.

Приложение устройства может указать сообщение **Will** в пакете **CONNECT**. Приложение для устройства должно использовать `devices/{device_id}/messages/events/` или `devices/{device_id}/messages/events/{property_bag}` в качестве значения параметра **Will topic name** (Будущее имя раздела) для определения **будущих сообщений**, которые будут пересылаться в качестве сообщения телеметрии. В этом случае, если сетевое соединение закрыто, но пакет **DISCONNECT** ранее не был получен с устройства, то концентратор Центр Интернета вещей отправляет сообщение **Will**, содержащееся в пакете **CONNECT**, в канал телеметрии. Канал телеметрии может быть либо конечной точкой **События** по умолчанию, либо настраиваемой конечной точкой, определяемой маршрутизацией Центра Интернета вещей. Сообщение имеет свойство **iothub-MessageType** со значением **Will**, назначенным ему.

## <a name="using-the-mqtt-protocol-directly-as-a-module"></a>Непосредственное использование протокола MQTT (как модуль)

Подключение к центру Интернета вещей через MQTT с помощью удостоверения модуля аналогично устройству (описанному [в разделе об использовании протокола MQTT непосредственно в качестве устройства](#using-the-mqtt-protocol-directly-as-a-device)), но необходимо использовать следующее:

* Задайте идентификатор клиента `{device_id}/{module_id}`.

* При аутентификации с использованием имени пользователя и пароля задайте для имени пользователя значение `<hubname>.azure-devices.net/{device_id}/{module_id}/?api-version=2018-06-30` и используйте в качестве пароля маркер SAS, связанный с удостоверением модуля.

* Используйте `devices/{device_id}/modules/{module_id}/messages/events/` в качестве раздела для публикации телеметрии.

* Используйте `devices/{device_id}/modules/{module_id}/messages/events/` как раздел WILL.

* Разделы двойников GET и PATCH идентичны для модулей и устройств.

* Раздел состояния двойников идентичны для модулей и устройств.

## <a name="tlsssl-configuration"></a>конфигурация протокола TLS/SSL

Чтобы напрямую использовать протокол MQTT, ваш клиент *должен* подключиться по протоколу TLS/SSL. Попытки пропустить этот шаг будут завершаться ошибками соединения.

Чтобы установить соединение TLS, может потребоваться скачать корневой сертификат DigiCert Baltimore и добавить ссылку на него. Этот сертификат используется в Azure для обеспечения безопасного подключения. Он хранится в репозитории [Azure-iot-sdk-c](https://github.com/Azure/azure-iot-sdk-c/blob/master/certs/certs.c). Дополнительные сведения об этих сертификатах можно найти на [веб-сайте Digicert](https://www.digicert.com/digicert-root-certificates.htm).

Пример реализации с помощью версии библиотеки [Paho MQTT](https://pypi.python.org/pypi/paho-mqtt) для Python от Eclipse Foundation может выглядеть следующим образом.

Сначала установите библиотеку Paho из командной строки:

```cmd/sh
pip install paho-mqtt
```

Затем запустите клиент в сценарии Python. Замените заполнители следующим образом.

* `<local path to digicert.cer>` — путь к локальному файлу, содержащему корневой сертификат DigiCert Baltimore. Этот файл можно создать путем копирования сведений о сертификате из [certs.c](https://github.com/Azure/azure-iot-sdk-c/blob/master/certs/certs.c) в пакете Центра Интернета вещей Azure для C. Укажите строки `-----BEGIN CERTIFICATE-----` и `-----END CERTIFICATE-----`, удалите метки `"` в начале и в конце каждой строки, а также удалите знаки `\r\n` в конце каждой строки.

* `<device id from device registry>` — идентификатор устройства, добавленного в Центр Интернета вещей.

* `<generated SAS token>` — маркер SAS для устройства, созданного как описано ранее в этой статье.

* `<iot hub name>` — имя Центра Интернета вещей.

```python
from paho.mqtt import client as mqtt
import ssl

path_to_root_cert = "<local path to digicert.cer file>"
device_id = "<device id from device registry>"
sas_token = "<generated SAS token>"
iot_hub_name = "<iot hub name>"


def on_connect(client, userdata, flags, rc):
    print("Device connected with result code: " + str(rc))


def on_disconnect(client, userdata, rc):
    print("Device disconnected with result code: " + str(rc))


def on_publish(client, userdata, mid):
    print("Device sent message")


client = mqtt.Client(client_id=device_id, protocol=mqtt.MQTTv311)

client.on_connect = on_connect
client.on_disconnect = on_disconnect
client.on_publish = on_publish

client.username_pw_set(username=iot_hub_name+".azure-devices.net/" +
                       device_id + "/?api-version=2018-06-30", password=sas_token)

client.tls_set(ca_certs=path_to_root_cert, certfile=None, keyfile=None,
               cert_reqs=ssl.CERT_REQUIRED, tls_version=ssl.PROTOCOL_TLSv1_2, ciphers=None)
client.tls_insecure_set(False)

client.connect(iot_hub_name+".azure-devices.net", port=8883)

client.publish("devices/" + device_id + "/messages/events/", "{id=123}", qos=1)
client.loop_forever()
```

Чтобы выполнить проверку подлинности с помощью сертификата устройства, внесите в фрагмент кода выше следующие изменения (сведения о подготовке к проверке подлинности на основе сертификата см. в разделе [Как получить сертификат ЦС X.509](./iot-hub-x509ca-overview.md#how-to-get-an-x509-ca-certificate)).

```python
# Create the client as before
# ...

# Set the username but not the password on your client
client.username_pw_set(username=iot_hub_name+".azure-devices.net/" +
                       device_id + "/?api-version=2018-06-30", password=None)

# Set the certificate and key paths on your client
cert_file = "<local path to your certificate file>"
key_file = "<local path to your device key file>"
client.tls_set(ca_certs=path_to_root_cert, certfile=cert_file, keyfile=key_file,
               cert_reqs=ssl.CERT_REQUIRED, tls_version=ssl.PROTOCOL_TLSv1_2, ciphers=None)

# Connect as before
client.connect(iot_hub_name+".azure-devices.net", port=8883)
```

## <a name="sending-device-to-cloud-messages"></a>Отправка сообщений из устройства в облако

После успешного подключения устройство может отправлять сообщения в Центр Интернета вещей, используя `devices/{device_id}/messages/events/` или `devices/{device_id}/messages/events/{property_bag}` в качестве значения параметра **Имя раздела**. Элемент `{property_bag}` позволяет устройству отправлять сообщения с дополнительными свойствами в формате URL-адреса. Пример:

```text
RFC 2396-encoded(<PropertyName1>)=RFC 2396-encoded(<PropertyValue1>)&RFC 2396-encoded(<PropertyName2>)=RFC 2396-encoded(<PropertyValue2>)…
```

> [!NOTE]
> В этом элементе `{property_bag}` используется та же кодировка символов, что и для строк запросов в протоколе HTTPS.

Ниже приведен список реакций на события, характерных для реализации Центра Интернета вещей:

* Центр Интернета вещей не поддерживает сообщения со вторым уровнем качества обслуживания. Если приложение для устройства публикует сообщение со **вторым уровнем качества обслуживания**, то Центр Интернета вещей закрывает сетевое подключение.

* Центр Интернета вещей не сохраняет сообщения retain. Если устройство отправляет сообщение с флагом " **хранить** ", равным 1, центр Интернета вещей добавляет в сообщение свойство **mqtt-удержать** приложение. В этом случае Центр Интернета вещей не хранит сообщение retain, а передает его во внутреннее приложение.

* Центр Интернета вещей поддерживает только одно активное подключение MQTT на устройство. Любое новое подключение MQTT от имени одного и того же идентификатора устройства приведет к удалению существующего подключения из центра Интернета вещей, а **400027 коннектионфорцефулликлоседонневконнектион** будет зарегистрирован в журналах центра Интернета вещей.


Дополнительные сведения см. в статье [Отправка сообщений с устройства в облако и из облака на устройство с помощью Центра Интернета вещей](iot-hub-devguide-messaging.md).

## <a name="receiving-cloud-to-device-messages"></a>Получение сообщений из облака на устройство

Для получения сообщений из Центра Интернета вещей устройство должно подписаться с использованием `devices/{device_id}/messages/devicebound/#` в качестве значения параметра **Topic Filter** (Фильтр разделов). Многоуровневый подстановочный знак `#` в параметре Topic Filter (Фильтр разделов) используется только для того, чтобы разрешить устройству получать дополнительные свойства в имени раздела. В Центре Интернета вещей запрещено использовать подстановочные знаки `#` или `?` для фильтрации подразделов. Так как Центр Интернета вещей не является универсальным брокером службы сообщений на основе шаблона "издатель-подписчик", то он поддерживает только задокументированные имена и фильтры разделов.

Устройство не получает никаких сообщений из центра Интернета вещей, пока оно не будет успешно подписано на конечную точку конкретного устройства, представленное `devices/{device_id}/messages/devicebound/#` фильтром разделов. Когда подписка выполнена, устройство получает сообщения, переданные из облака на устройство, только с момента подписки. Если устройство подключается с флагом **CleanSession**, имеющим значение **0**, то подписка будет сохраняться в разных сеансах. В этом случае при следующем подключении с флагом **CleanSession 0** устройство получает ожидающие сообщения, отправленные на него, пока оно было отключено. Если устройство использует флаг **CleanSession** со значением **1**, то оно не будет получать сообщения из Центра Интернета вещей, пока не будет подписано на конечную точку устройства.

Центр Интернета вещей передает сообщения с **именем раздела** `devices/{device_id}/messages/devicebound/` или `devices/{device_id}/messages/devicebound/{property_bag}` при наличии свойств сообщения. `{property_bag}` содержит закодированные в формате URL-адреса пары "ключ-значение" свойств сообщения. В контейнер свойств входят только свойства приложений и задаваемые пользователем системные свойства (такие как **messageId** или **correlationId**). Имена системных свойств имеют префикс **$** , свойства приложений используют исходное имя свойства без префикса. Дополнительные сведения о формате контейнера свойств см. в разделе [Отправка сообщений с устройства в облако](#sending-device-to-cloud-messages).

В сообщениях, отправляемых из облака на устройство, значения в контейнере свойств представлены в следующей таблице.

| Значение свойства | Представление | Описание |
|----|----|----|
| `null` | `key` | В контейнере свойств отображается только ключ. |
| пустая строка | `key=` | Ключ, за которым следует знак равенства без значения |
| значение, отличное от NULL, непустое | `key=value` | Ключ, за которым следует знак равенства и значение |

В следующем примере показан контейнер свойств, содержащий три свойства приложения: **Prop1** со значением `null` ; **Prop2**, пустая строка (""); и **Prop3** со значением «строка».

```mqtt
/?prop1&prop2=&prop3=a%20string
```

Если приложение для устройства подписывается на раздел со **вторым уровнем качества обслуживания**, то Центр Интернета вещей присваивает пакету **SUBACK** уровень качества обслуживания не выше первого. После этого Центр Интернета вещей доставляет сообщения на устройство, используя первый уровень качества обслуживания.

## <a name="retrieving-a-device-twins-properties"></a>Получение свойств двойника устройства

Сначала устройство подписывается на `$iothub/twin/res/#`, чтобы получать ответы операций. Затем оно отправляет пустое сообщение в раздел `$iothub/twin/GET/?$rid={request id}` с заполненным значением **request ID** (идентификатор запроса). Затем служба отправляет ответное сообщение, содержащее данные двойника устройства в разделе `$iothub/twin/res/{status}/?$rid={request id}`, используя то же значение **идентификатора запроса**, что и в запросе.

Идентификатор запроса может быть любым допустимым значением свойства сообщения в соответствии с [руководством разработчика по обмену сообщениями в центре Интернета вещей](iot-hub-devguide-messaging.md), а состояние проверяется как целое число.

Текст ответа содержит раздел properties двойника устройства, как показано в следующем примере ответа:

```json
{
    "desired": {
        "telemetrySendFrequency": "5m",
        "$version": 12
    },
    "reported": {
        "telemetrySendFrequency": "5m",
        "batteryLevel": 55,
        "$version": 123
    }
}
```

Возможны следующие коды состояний:

|Состояние | Описание |
| ----- | ----------- |
| 200 | Успешно |
| 429 | Слишком много запросов (регулирование), как указано в статье [Квоты и регулирование в Центре Интернета вещей](iot-hub-devguide-quotas-throttling.md) |
| 5** | ошибки сервера; |

Дополнительные сведения см. в документации [разработчика двойников для устройства](iot-hub-devguide-device-twins.md).

## <a name="update-device-twins-reported-properties"></a>Обновление сообщаемых свойств двойника устройства

Чтобы обновить сообщаемые свойства, устройство отправляет запрос в Центр Интернета вещей с помощью публикации в указанном разделе MQTT. После обработки запроса Центр Интернета вещей выводит ответ с состоянием "Успех" или "Сбой" операции обновления путем публикации в другом разделе. Это устройство может быть подписано на раздел, чтобы уведомить его о запросе на обновление двойника. Чтобы реализовать этот тип взаимодействия "запрос — ответ" в MQTT, мы используем понятие идентификатора запроса (`$rid`), изначально предоставленное устройством в запросе на обновление. Этот идентификатор запроса также включается в ответ Центра Интернета вещей, чтобы позволить устройству сопоставить ответ с конкретным более ранним запросом.

Следующая последовательность действий описывает, как устройство обновляет сообщаемые свойства в двойнике устройства в Центре Интернета вещей:

1. Сначала устройство должно подписаться на раздел `$iothub/twin/res/#`, чтобы получать ответы операций из Центра Интернета вещей.

2. Устройство отправляет сообщение, содержащее обновление двойника устройства, в раздел `$iothub/twin/PATCH/properties/reported/?$rid={request id}`. Это сообщение содержит значение **request ID** (идентификатор запроса).

3. Затем служба отправляет ответное сообщение, содержащее новое значение ETag для коллекции сообщаемых свойств в разделе `$iothub/twin/res/{status}/?$rid={request id}`. В этом ответном сообщении используется то же значение **request ID**, что и в запросе.

Текст запроса содержит документ JSON, в котором имеются новые значения для переданных свойств. Каждый элемент документа JSON обновляет или добавляет соответствующий компонент в документе двойника устройства. Набор элементов, который `null` удаляет элемент из содержащего объекта. Пример:

```json
{
    "telemetrySendFrequency": "35m",
    "batteryLevel": 60
}
```

Возможны следующие коды состояний:

|Состояние | Описание |
| ----- | ----------- |
| 204 | Успех (содержимое не возвращается) |
| 400 | Недопустимый запрос. Неправильно сформированный JSON. |
| 429 | Слишком много запросов (регулирование), как указано в статье [Квоты и регулирование в Центре Интернета вещей](iot-hub-devguide-quotas-throttling.md) |
| 5** | ошибки сервера; |

Фрагмент кода Python, приведенный ниже, демонстрирует процесс обновления свойств, сообщаемых двойником, по MQTT (с помощью клиента Paho MQTT):

```python
from paho.mqtt import client as mqtt

# authenticate the client with IoT Hub (not shown here)

client.subscribe("$iothub/twin/res/#")
rid = "1"
twin_reported_property_patch = "{\"firmware_version\": \"v1.1\"}"
client.publish("$iothub/twin/PATCH/properties/reported/?$rid=" +
               rid, twin_reported_property_patch, qos=0)
```

При успешном выполнении операции обновления сообщаемых двойником свойств, указанных выше, в сообщении публикации из Центра Интернета вещей будет следующий раздел: `$iothub/twin/res/204/?$rid=1&$version=6`, где `204` — это код состояния, указывающий на успешность, `$rid=1` соответствует идентификатору запроса, предоставленному устройством в коде, а `$version` соответствует версии раздела сообщаемых двойником устройства свойств после обновления.

Дополнительные сведения см. в документации [разработчика двойников для устройства](iot-hub-devguide-device-twins.md).

## <a name="receiving-desired-properties-update-notifications"></a>Получение уведомлений об обновлении требуемых свойств

При подключении устройства Центр Интернета вещей отправляет уведомления в раздел `$iothub/twin/PATCH/properties/desired/?$version={new version}`, в котором находится содержимое обновления, выполненного серверной частью решения. Пример:

```json
{
    "telemetrySendFrequency": "5m",
    "route": null,
    "$version": 8
}
```

В обновлениях свойств значение `null` означает, что элемент объекта JSON удаляется. Кроме того, обратите внимание, что `$version` содержит новую версию раздела с требуемыми свойствами двойника.

> [!IMPORTANT]
> Центр Интернета вещей создает уведомления об изменении только в том случае, если устройства подключены. Убедитесь, что выполняется [процедура повторного подключения устройства](iot-hub-devguide-device-twins.md#device-reconnection-flow), чтобы требуемые свойства продолжали синхронизироваться между Центром Интернета вещей и приложением для устройства.

Дополнительные сведения см. в документации [разработчика двойников для устройства](iot-hub-devguide-device-twins.md).

## <a name="respond-to-a-direct-method"></a>Ответ на прямой метод

Сначала устройство должно подписаться на `$iothub/methods/POST/#`. Центр Интернета вещей отправляет запросы метода в раздел `$iothub/methods/POST/{method name}/?$rid={request id}` с допустимым документом JSON или без текста.

В качестве ответа устройство отправляет сообщение без текста или с допустимой строкой JSON в раздел `$iothub/methods/res/{status}/?$rid={request id}`. В этом сообщении значение **request ID** должно совпадать с идентификатором в сообщении запроса, а в качестве **status** должно быть указано целое число.

Дополнительные сведения см. в документации [разработчика прямых методов](iot-hub-devguide-direct-methods.md).

## <a name="additional-considerations"></a>Дополнительные сведения

Последнее замечание. Если на стороне облака требуется настроить реакцию на событие протокола MQTT, ознакомьтесь со статьей [Поддержка дополнительных протоколов для Центра Интернета вещей](iot-hub-protocol-gateway.md). Это программное обеспечение позволяет развернуть шлюз протокола с высокой производительностью, который взаимодействует непосредственно с Центром Интернета вещей. Шлюз протокола Azure IoT позволяет настроить протокол устройства для уже существующих развертываний MQTT или других настраиваемых протоколов. Однако при этом подходе необходимо запустить настраиваемый шлюз протокола и управлять им.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о протоколе MQTT см. в [документации по MQTT](https://mqtt.org/).

Дополнительные сведения о планировании развертывания Центра Интернета вещей см. в следующих руководствах:

* [Каталог устройств, сертифицированных по программе Azure Certified for IoT](https://catalog.azureiotsolutions.com/)
* [Поддержка дополнительных протоколов](iot-hub-protocol-gateway.md)
* [Сравнение с Центрами событий](iot-hub-compare-event-hubs.md)
* [Масштабирование, высокий уровень доступности и аварийное восстановление](iot-hub-scaling.md)

Для дальнейшего изучения возможностей Центра Интернета вещей см. следующие статьи:

* [Руководство разработчика для Центра Интернета вещей](iot-hub-devguide.md)
* [Краткое руководство. Развертывание первого модуля IoT Edge на устройстве под управлением 64-разрядной ОС Linux](../iot-edge/quickstart-linux.md)
