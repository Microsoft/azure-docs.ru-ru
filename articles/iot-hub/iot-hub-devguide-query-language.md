---
title: Общие сведения о языке запросов Центра Интернета вещей Azure | Документация Майкрософт
description: Руководство разработчика. Описание похожего на SQL языка запросов Центра Интернета вещей, который используется для получения сведений о двойниках устройств и модулей, а также заданиях из Центра Интернета вещей.
author: robinsh
ms.service: iot-hub
services: iot-hub
ms.topic: conceptual
ms.date: 10/29/2018
ms.author: robinsh
ms.custom: devx-track-csharp
ms.openlocfilehash: cae2bcb1a3302814a426fa0cb2dfb36ba1b013fa
ms.sourcegitcommit: f7eda3db606407f94c6dc6c3316e0651ee5ca37c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/05/2021
ms.locfileid: "102218372"
---
# <a name="iot-hub-query-language-for-device-and-module-twins-jobs-and-message-routing"></a>Язык запросов Центра Интернета вещей для двойников устройств и двойников модулей, заданий и маршрутизации сообщений

Центр Интернета вещей предоставляет мощный язык, подобный SQL, для получения сведений о [двойниковах устройств](iot-hub-devguide-device-twins.md), [модулях двойников](iot-hub-devguide-module-twins.md), [заданиях](iot-hub-devguide-jobs.md)и [маршрутизации сообщений](iot-hub-devguide-messages-d2c.md). В этой статье представлены:

* общие сведения об основных возможностях языка запросов Центра Интернета вещей;
* подробное описание языка. Дополнительные сведения о языке запросов для маршрутизации сообщений см. в [этой статье](../iot-hub/iot-hub-devguide-routing-query-syntax.md).

[!INCLUDE [iot-hub-basic](../../includes/iot-hub-basic-partial.md)]

## <a name="device-and-module-twin-queries"></a>Запросы двойников устройств и модулей

[Двойниковы устройств](iot-hub-devguide-device-twins.md) и [двойников модуля](iot-hub-devguide-module-twins.md) могут содержать произвольные объекты JSON в качестве тегов и свойств. Центр Интернета вещей позволяет выполнять запросы к двойникам устройств и двойникам модулей как к одному документу JSON, содержащему все сведения о двойниках.

Предположим, что двойники устройств в Центре Интернета вещей имеют следующую структуру (структура двойников модулей будет выглядеть так же и содержать элемент moduleId):

```json
{
    "deviceId": "myDeviceId",
    "etag": "AAAAAAAAAAc=",
    "status": "enabled",
    "statusUpdateTime": "0001-01-01T00:00:00",
    "connectionState": "Disconnected",
    "lastActivityTime": "0001-01-01T00:00:00",
    "cloudToDeviceMessageCount": 0,
    "authenticationType": "sas",
    "x509Thumbprint": {
        "primaryThumbprint": null,
        "secondaryThumbprint": null
    },
    "version": 2,
    "tags": {
        "location": {
            "region": "US",
            "plant": "Redmond43"
        }
    },
    "properties": {
        "desired": {
            "telemetryConfig": {
                "configId": "db00ebf5-eeeb-42be-86a1-458cccb69e57",
                "sendFrequencyInSecs": 300
            },
            "$metadata": {
            ...
            },
            "$version": 4
        },
        "reported": {
            "connectivity": {
                "type": "cellular"
            },
            "telemetryConfig": {
                "configId": "db00ebf5-eeeb-42be-86a1-458cccb69e57",
                "sendFrequencyInSecs": 300,
                "status": "Success"
            },
            "$metadata": {
            ...
            },
            "$version": 7
        }
    }
}
```

### <a name="device-twin-queries"></a>Запросы двойника устройства

Центр Интернета вещей предоставляет двойники устройства как коллекцию документов с именем **devices**. Например, следующий запрос получает весь набор двойников устройства:

```sql
SELECT * FROM devices
```

> [!NOTE]
> [Пакеты SDK для Azure IoT](iot-hub-devguide-sdks.md) поддерживают разбивку на страницы объемных результатов.

Центр Интернета вещей позволяет получить двойники устройств, отфильтрованные по произвольным условиям. Например, для получения двойников устройств, где тег **location.region** имеет значение **US**, используйте следующий запрос:

```sql
SELECT * FROM devices
WHERE tags.location.region = 'US'
```

Кроме того, поддерживаются логические операторы и арифметические сравнения. Например, для получения двойников устройств, которые находятся в США и настроены для отправки телеметрии не чаще раза в минуту, используйте следующий запрос:

```sql
SELECT * FROM devices
  WHERE tags.location.region = 'US'
    AND properties.reported.telemetryConfig.sendFrequencyInSecs >= 60
```

Для удобства можно также использовать константы массива с операторами **IN** ("входит") и **NIN** ("не входит"). Например, для получения двойников устройств, сообщающих о подключении по Wi-Fi или проводной сети, используйте следующий запрос:

```sql
SELECT * FROM devices
  WHERE properties.reported.connectivity IN ['wired', 'wifi']
```

Часто требуется определить все двойники устройств, содержащие определенное свойство. Для этой цели Центр Интернета вещей поддерживает функцию `is_defined()`. Например, для получения двойников устройств, которые определяют свойство `connectivity`, используется следующий запрос:

```SQL
SELECT * FROM devices
  WHERE is_defined(properties.reported.connectivity)
```

Полное описание возможностей фильтрации см. в разделе [Предложение WHERE](iot-hub-devguide-query-language.md#where-clause).

Кроме того, поддерживаются группирование и агрегаты. Например, чтобы найти количество устройств в каждом состоянии конфигурации телеметрии, используйте следующий запрос:

```sql
SELECT properties.reported.telemetryConfig.status AS status,
    COUNT() AS numberOfDevices
  FROM devices
  GROUP BY properties.reported.telemetryConfig.status
```

Этот запрос группировки вернет результат, как в следующем примере:

```json
[
    {
        "numberOfDevices": 3,
        "status": "Success"
    },
    {
        "numberOfDevices": 2,
        "status": "Pending"
    },
    {
        "numberOfDevices": 1,
        "status": "Error"
    }
]
```

В этом примере три устройства сообщают об успешной конфигурации, два все еще применяют конфигурацию и одно сообщило об ошибке.

Запросы проекции позволяют разработчикам настроить возврат только требуемых свойств. Например, чтобы узнать время последнего действия всех отключенных устройств, используйте следующий запрос:

```sql
SELECT LastActivityTime FROM devices WHERE status = 'enabled'
```

### <a name="module-twin-queries"></a>Запросы двойника модуля

Запросы к модулю двойников похожи на запросы к двойникову устройства, но используют другую коллекцию или пространство имен. вместо **устройств** вы запрашиваете из **устройств. modules**:

```sql
SELECT * FROM devices.modules
```

Мы не рекомендуем объединять коллекции devices и devices.modules. Если нужно выполнить запрос к двойникам модулей на всех устройствах, используйте для этого теги. Этот запрос вернет список всех двойников модулей с состоянием scanning на всех устройствах:

```sql
SELECT * FROM devices.modules WHERE properties.reported.status = 'scanning'
```

Этот запрос вернет список всех двойников модулей с состоянием scanning, но только в определенном наборе устройств:

```sql
SELECT * FROM devices.modules
  WHERE properties.reported.status = 'scanning'
  AND deviceId IN ['device1', 'device2']
```

### <a name="c-example"></a>Пример в C#

Функция обработки запросов предоставляется в [пакете SDK для служб C#](iot-hub-devguide-sdks.md) в классе **RegistryManager**.

Ниже приведен пример простого запроса:

```csharp
var query = registryManager.CreateQuery("SELECT * FROM devices", 100);
while (query.HasMoreResults)
{
    var page = await query.GetNextAsTwinAsync();
    foreach (var twin in page)
    {
        // do work on twin object
    }
}
```

Объект **query** создается с размером страницы (до 100). Затем несколько страниц извлекаются путем вызова методов **GetNextAsTwinAsync** несколько раз.

Объект query предоставляет несколько значений **Next**, которые зависят от параметра десериализации, необходимого для запроса. Например, двойник устройства или объекты задания, или обычные JSON при использовании проекций.

### <a name="nodejs-example"></a>Пример для Node.js

Функция обработки запросов предоставляется в [пакете SDK службы Azure IoT для Node.js](iot-hub-devguide-sdks.md) в объекте **Registry**.

Ниже приведен пример простого запроса:

```javascript
var query = registry.createQuery('SELECT * FROM devices', 100);
var onResults = function(err, results) {
    if (err) {
        console.error('Failed to fetch the results: ' + err.message);
    } else {
        // Do something with the results
        results.forEach(function(twin) {
            console.log(twin.deviceId);
        });

        if (query.hasMoreResults) {
            query.nextAsTwin(onResults);
        }
    }
};
query.nextAsTwin(onResults);
```

Объект **query** создается с размером страницы (до 100). Затем несколько страниц извлекаются путем вызова метода **nextAsTwin** несколько раз.

Объект query предоставляет несколько значений **Next**, которые зависят от параметра десериализации, необходимого для запроса. Например, двойник устройства или объекты задания, или обычные JSON при использовании проекций.

### <a name="limitations"></a>Ограничения

> [!IMPORTANT]
> Результаты запросов могут поступать с задержкой в несколько минут и не учитывать последние значения в двойниках устройств. При запросе двойникова каждого устройства по ИДЕНТИФИКАТОРу используйте [REST API получения двойника](/java/api/com.microsoft.azure.sdk.iot.device.devicetwin). Этот API всегда возвращает последние значения и имеет более высокие пределы регулирования. Вы можете вручную выдать REST API или использовать аналогичные функции в одном из [пакетов SDK службы центра Интернета вещей Azure](iot-hub-devguide-sdks.md#azure-iot-hub-service-sdks).

В настоящее время сравнения поддерживаются только между типами-примитивами (не объектами), например, `... WHERE properties.desired.config = properties.reported.config` поддерживается только в том случае, если эти свойства имеют примитивные значения.

## <a name="get-started-with-jobs-queries"></a>Начало работы с запросами заданий

[Задания](iot-hub-devguide-jobs.md) позволяют выполнять операции с наборами устройств. Каждый двойник устройства содержит сведения о заданиях, в которых он участвует, в коллекции с именем **jobs**.

```json
{
    "deviceId": "myDeviceId",
    "etag": "AAAAAAAAAAc=",
    "tags": {
        ...
    },
    "properties": {
        ...
    },
    "jobs": [
        {
            "deviceId": "myDeviceId",
            "jobId": "myJobId",
            "jobType": "scheduleTwinUpdate",
            "status": "completed",
            "startTimeUtc": "2016-09-29T18:18:52.7418462",
            "endTimeUtc": "2016-09-29T18:20:52.7418462",
            "createdDateTimeUtc": "2016-09-29T18:18:56.7787107Z",
            "lastUpdatedDateTimeUtc": "2016-09-29T18:18:56.8894408Z",
            "outcome": {
                "deviceMethodResponse": null
            }
        },
        ...
    ]
}
```

В настоящее время к этой коллекции можно выполнить запрос как к **devices.jobs** на языке запросов Центра Интернета вещей.

> [!IMPORTANT]
> В настоящее время свойство jobs никогда не возвращается при запросах двойников устройств. То есть при запросах, содержащих FROM devices. Доступ к свойству задания можно получить только непосредственно с помощью запросов, использующих `FROM devices.jobs`.
>
>

Например, чтобы получить все задания (выполненные и запланированные), влияющие на одно устройство, можно использовать следующий запрос:

```sql
SELECT * FROM devices.jobs
  WHERE devices.jobs.deviceId = 'myDeviceId'
```

Обратите внимание, как этот запрос предоставляет сведения о состоянии конкретного устройства (и, возможно, ответ на прямой метод) в каждом возвращенном задании.

Все свойства объектов в коллекции **devices.jobs** можно также отфильтровать с помощью произвольных логических условий.

Например, чтобы получить все завершенные задания по обновлению двойников устройств, созданных после сентября 2016 года для определенного устройства, используйте следующий запрос:

```sql
SELECT * FROM devices.jobs
  WHERE devices.jobs.deviceId = 'myDeviceId'
    AND devices.jobs.jobType = 'scheduleTwinUpdate'
    AND devices.jobs.status = 'completed'
    AND devices.jobs.createdTimeUtc > '2016-09-01'
```

Вы также можете получить результаты по одному заданию для каждого устройства.

```sql
SELECT * FROM devices.jobs
  WHERE devices.jobs.jobId = 'myJobId'
```

### <a name="limitations"></a>Ограничения

В настоящее время запросы к **devices.jobs** не поддерживают следующие элементы:

* проекции, поэтому можно использовать только `SELECT *`;
* условия, касающиеся двойника устройства, и свойства задания (см. предыдущий раздел);
* выполняемые агрегаты, например count, avg, group by.

## <a name="basics-of-an-iot-hub-query"></a>Основные сведения о запросе Центра Интернета вещей

Каждый запрос Центра Интернета вещей состоит из предложений SELECT и FROM, а также необязательных предложений WHERE и GROUP BY. Каждый запрос выполняется для коллекции документов JSON, например двойников устройств. Предложение FROM указывает коллекцию документов для итерации (**Devices**, **Devices. modules** или **Devices.jobs**). Затем применяется фильтр в предложении WHERE. С использованием агрегации результаты этого шага сгруппированы, как указано в предложении GROUP BY. Для каждой группы создается строка, как указано в предложении SELECT.

```sql
SELECT <select_list>
  FROM <from_specification>
  [WHERE <filter_condition>]
  [GROUP BY <group_specification>]
```

## <a name="from-clause"></a>Предложение FROM

Предложение **FROM <from_specification>** может принимать только три значения: **с устройств** для запроса двойникова устройства, **с устройств. модули** для запроса двойников модуля или **из Devices.jobs** для запроса сведений о задании для каждого устройства.

## <a name="where-clause"></a>WHERE, предложение

Предложение **WHERE <условие_фильтрации>** является необязательным. Оно определяет одно или несколько условий, которым должны соответствовать документы JSON в коллекции FROM, чтобы быть включенными в результат. Любой документ JSON должен при вычислении указанных условий возвращать значение true, чтобы быть включенным в результат.

Допустимые условия описаны в разделе [Выражения и условия](iot-hub-devguide-query-language.md#expressions-and-conditions).

## <a name="select-clause"></a>Предложение SELECT

Предложение **SELECT <список_для_выбора>** является обязательным. Оно указывает значения, которые будут получены из запроса. Здесь задаются значения JSON, которые используются для создания новых объектов JSON.
На этапе проекции для каждого элемента, отфильтрованного (и при необходимости сгруппированного) подмножества коллекции FROM создается объект JSON. Этот объект собран из значений, которые указаны в предложении SELECT.

Далее приводится грамматика предложения SELECT:

```
SELECT [TOP <max number>] <projection list>

<projection_list> ::=
    '*'
    | <projection_element> AS alias [, <projection_element> AS alias]+

<projection_element> :==
    attribute_name
    | <projection_element> '.' attribute_name
    | <aggregate>

<aggregate> :==
    count()
    | avg(<projection_element>)
    | sum(<projection_element>)
    | min(<projection_element>)
    | max(<projection_element>)
```

**Attribute_name** относится к любому свойству документа JSON в коллекции FROM. Некоторые примеры предложений SELECT можно найти в разделе о начале работы с запросами двойника устройства.

В настоящее время предложения для осуществления выбора, отличные от **SELECT*** , поддерживаются только в статистических запросах к двойникам устройств.

## <a name="group-by-clause"></a>Предложение GROUP BY

Предложение **GROUP BY <спецификация_группирования>** является необязательным. Оно выполняется после фильтра, указанного в предложении WHERE, и перед проекцией, указанной в предложении SELECT. Оно группирует документы на основе значения атрибута. Эти группы используются для создания статистических значений, как указано в предложении SELECT.

Ниже представлен пример запроса с использованием предложения GROUP BY:

```sql
SELECT properties.reported.telemetryConfig.status AS status,
    COUNT() AS numberOfDevices
FROM devices
GROUP BY properties.reported.telemetryConfig.status
```

Далее указан формальный синтаксис предложения GROUP BY:

```
GROUP BY <group_by_element>
<group_by_element> :==
    attribute_name
    | < group_by_element > '.' attribute_name
```

**Attribute_name** относится к любому свойству документа JSON в коллекции FROM.

В настоящее время предложение GROUP BY поддерживается только при запросе к двойникам устройств.

> [!IMPORTANT]
> Сейчас термин `group` обрабатывается как специальное ключевое слово в запросах. Если вы используете `group` в качестве имени свойства, заключите этот термин в двойные скобки, чтобы избежать ошибок. Например, так: `SELECT * FROM devices WHERE tags.[[group]].name = 'some_value'`.
>

## <a name="expressions-and-conditions"></a>Выражения и условия

В общем *выражение*:

* возвращает экземпляр типа JSON (например, логическое значение, число, строка, массив или объект);
* определяется обработкой данных, поступающих из документа JSON устройства, и констант с помощью встроенных операторов и функций.

*Условия* — это выражения, результатом вычисления которых является логическое значение. Любая другая константа, отличная от логической **true**, считается **false**. Это правило включает значение **null**, **не определено**, любой экземпляр объекта или массива, любую строку и логическое значение **false**.

Выражения имеют следующий синтаксис:

```
<expression> ::=
    <constant> |
    attribute_name |
    <function_call> |
    <expression> binary_operator <expression> |
    <create_array_expression> |
    '(' <expression> ')'

<function_call> ::=
    <function_name> '(' expression ')'

<constant> ::=
    <undefined_constant>
    | <null_constant>
    | <number_constant>
    | <string_constant>
    | <array_constant>

<undefined_constant> ::= undefined
<null_constant> ::= null
<number_constant> ::= decimal_literal | hexadecimal_literal
<string_constant> ::= string_literal
<array_constant> ::= '[' <constant> [, <constant>]+ ']'
```

Чтобы понять, что означает каждый символ в синтаксисе выражений, ознакомьтесь со следующей таблицей:

| Символ | Определение |
| --- | --- |
| attribute_name | Любое свойство документа JSON в коллекции **FROM**. |
| binary_operator | Любой бинарный оператор, перечисленный в разделе [Операторы](#operators). |
| function_name| Любая функция, перечисленная в разделе [Функции](#functions). |
| decimal_literal |Число с плавающей запятой в десятичном представлении. |
| hexadecimal_literal |Число, выраженное строкой "0x", за которым следует строка шестнадцатеричных цифр. |
| string_literal |Строковые литералы — это строки Юникода, представленные в виде последовательности из нуля или более знаков Юникода или escape-последовательностей. Строковые литералы заключаются в одинарные или двойные кавычки. В знаках Юникода, определяемых 4 шестнадцатеричными цифрами, разрешено использовать escape-символы `\'`, `\"`, `\\` и `\uXXXX`. |

### <a name="operators"></a>Операторы

Поддерживаются следующие операторы:

| Семейство | Операторы |
| --- | --- |
| Арифметические |+, -, *, /, % |
| Логические |AND, OR, NOT |
| Сравнение |=, !=, <, >, <=, >=, <> |

### <a name="functions"></a>Функции

В запросах двойников и заданий поддерживается только одна функция.

| Компонент | Описание |
| -------- | ----------- |
| IS_DEFINED(Свойство) | Возвращает логическое значение, указывающее, назначено ли свойству значение (в том числе значение `null`). |

В условиях маршрута поддерживаются следующие математические функции.

| Компонент | Описание |
| -------- | ----------- |
| ABS(x) | Возвращает модуль (положительное значение) указанного числового выражения. |
| EXP(x) | Возвращает значение экспоненты для указанного числового выражения (e^x). |
| POWER(x,y) | Возвращает результат возведения указанного числового выражения в заданную степень (x^y).|
| SQUARE(x)    | Возвращает квадратный корень из указанного числового значения. |
| CEILING(x) | Возвращает наименьшее целочисленное значение, которое больше или равно указанному числовому выражению. |
| FLOOR(x) | Возвращает наибольшее целое число, меньшее или равное указанному числовому выражению. |
| SIGN(x) | Возвращает знак указанного числового выражения (+1 для положительных чисел, 0 для нуля или -1 для отрицательных).|
| SQRT(x) | Возвращает квадратный корень из указанного числового значения. |

В условиях маршрута поддерживаются следующие функции проверки и приведения типов.

| Компонент | Описание |
| -------- | ----------- |
| AS_NUMBER | Преобразует входную строку в число. Возвращает `noop`, если аргумент является числом, или `Undefined`, если строка не представляет число.|
| IS_ARRAY | Возвращает логическое значение, указывающее, является ли указанное выражение массивом. |
| IS_BOOL | Возвращает логическое значение, указывающее, является ли указанное выражение логическим значением. |
| IS_DEFINED | Возвращает логическое значение, указывающее, назначено ли свойству значение. Это поддерживается только в том случае, если значение является типом-примитивом. Типы-примитивы включают строку, логическое значение, число или `null` . DateTime, типы объектов и массивы не поддерживаются. |
| IS_NULL | Возвращает логическое значение, указывающее, является ли указанное выражение значением Null. |
| IS_NUMBER | Возвращает логическое значение, указывающее, является ли указанное выражение числовым значением. |
| IS_OBJECT | Возвращает логическое значение, указывающее, является ли указанное выражение объектом JSON. |
| IS_PRIMITIVE | Возвращает логическое значение, указывающее, является ли указанное выражение примитивом (строкой, логическим значением, числовым значением или `null`). |
| IS_STRING | Возвращает логическое значение, указывающее, является ли указанное выражение строковым значением. |

В условиях маршрутов поддерживаются следующие строковые функции.

| Компонент | Описание |
| -------- | ----------- |
| CONCAT(x, y, …) | Возвращает строку, являющуюся результатом объединения двух или более строковых значений. |
| LENGTH(x) | Возвращает число символов указанного строкового выражения.|
| LOWER(x) | Возвращает строковое выражение после преобразования символов верхнего регистра в нижний. |
| UPPER(x) | Возвращает строковое выражение после преобразования символов нижнего регистра в верхний. |
| SUBSTRING(строка, начало[, длина]) | Возвращает часть строкового выражения, начиная с указанной позиции (отсчет начинается с нуля) и до достижения указанной длины (или до конца строки). |
| INDEX_OF(строка, фрагмент) | Возвращает начальную позицию первого вхождения второго строкового выражения в первое указанное строковое выражение или –1, если строка не найдена.|
| STARTS_WITH(x, y) | Возвращает значение логического типа, указывающее, начинается ли первое строковое выражение вторым. |
| ENDS_WITH(x, y) | Возвращает значение логического типа, указывающее, заканчивается ли первое строковое выражение вторым. |
| CONTAINS(x,y) | Возвращает значение логического типа, указывающее, содержит ли первое строковое выражение второе. |

## <a name="next-steps"></a>Дальнейшие действия

Узнайте, как выполнять запросы в своих приложениях с помощью [пакетов SDK для Azure IoT](iot-hub-devguide-sdks.md).