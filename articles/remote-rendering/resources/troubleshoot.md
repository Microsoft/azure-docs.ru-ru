---
title: Диагностика
description: Сведения об устранении неполадок для Удаленной отрисовки Azure
author: florianborn71
ms.author: flborn
ms.date: 02/25/2020
ms.topic: troubleshooting
ms.openlocfilehash: 34a947a2a0f6d8c87c0580f273130b671b4f17fc
ms.sourcegitcommit: a4533b9d3d4cd6bb6faf92dd91c2c3e1f98ab86a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2020
ms.locfileid: "97722238"
---
# <a name="troubleshoot"></a>Диагностика

На этой странице перечислены распространенные проблемы, мешающие Удаленной отрисовке Azure, и способы их устранения.

## <a name="cant-link-storage-account-to-arr-account"></a>Не удается связать учетную запись хранения с учетной записью ARR

Иногда во время [связывания учетной записи хранения](../how-tos/create-an-account.md#link-storage-accounts) учетной записи Удаленной отрисовки нет в списке. Чтобы устранить эту проблему, перейдите к учетную запись ARR в портал Azure и выберите **Удостоверение** в группе **Параметры** слева. Убедитесь, что **Состояние** имеет значение **Вкл.** .
![Отладчик фреймов Unity](./media/troubleshoot-portal-identity.png)

## <a name="client-cant-connect-to-server"></a>Клиенту не удается подключиться к серверу

Убедитесь, что брандмауэры (на устройстве, внутри маршрутизаторов и т. д.) не блокируют порты, указанные в [требованиях к системе](../overview/system-requirements.md#network-firewall).

## <a name="error-disconnected-videoformatnotavailable"></a>Ошибка " `Disconnected: VideoFormatNotAvailable` "

Убедитесь, что GPU поддерживает аппаратное декодирование видео. См. раздел [Разработка ПК](../overview/system-requirements.md#development-pc).

Если вы работаете на ноутбуке с двумя графическими процессорами, возможно, что GPU, который вы используете по умолчанию, не предоставляет функции декодирования аппаратного видео. Если это так, попробуйте заставить приложение использовать другой GPU. Это часто возможно в параметрах драйвера GPU.

## <a name="retrieve-sessionconversion-status-fails"></a>Не удается получить состояние сеанса или преобразования

Отправка команд REST API слишком часто приведет к тому, что сервер будет регулировать и возвращать ошибку в конечном итоге. Код состояния HTTP в случае регулирования — 429 ("слишком много запросов"). Поэтому очень важно, чтобы между последовательными вызовами была задержка в **5–10 секунд**.

Примечание. это ограничение не только влияет на вызовы REST API только при вызове напрямую, но также на аналоги C#/C + +, такие как `Session.GetPropertiesAsync` , `Session.RenewAsync` или `Frontend.GetAssetConversionStatusAsync` .

Если вы набираете регулирование на стороне сервера, измените код так, чтобы вызовы не вызывались реже. Сервер будет сбрасывать состояние регулирования каждую минуту, чтобы можно было выполнить повторное выполнение кода через минуту.

## <a name="h265-codec-not-available"></a>Кодек H265 недоступен

Существует две причины, по которым сервер может отказаться от подключения с `codec not available` ошибкой.

**Кодек H265 не установлен:**

сначала убедитесь, что установлены расширения видео **HEVC**, как упоминалось в разделе [Программное обеспечение](../overview/system-requirements.md#software) требований к системе.

Если проблемы продолжают возникать, убедитесь, что ваша графическая плата поддерживает H265 и у вас установлена последняя версия драйвера графики. Сведения о поставщике см. в разделе [ПК разработки](../overview/system-requirements.md#development-pc) системных требований для конкретного поставщика.

**Кодек установлен, но его нельзя использовать:**

причиной этой проблемы является неправильная настройка безопасности для библиотек DLL. Эта проблема не проявляется при попытке просмотра видео, закодированных с помощью H265. Переустановка кодека тоже не решает проблему. Вместо этого выполните следующие действия.

1. Откройте **консоль PowerShell с правами администратора**

    ```PowerShell
    Get-AppxPackage -Name Microsoft.HEVCVideoExtension
    ```
  
    Эта команда должна выводить `InstallLocation` кодека, например:
  
    ```cmd
    InstallLocation   : C:\Program Files\WindowsApps\Microsoft.HEVCVideoExtension_1.0.23254.0_x64__5wasdgertewe
    ```

1. Открыть папку в проводнике Windows
1. Необходимо использовать **x86** и вложенную папку **x64**. Щелкните правой кнопкой мыши одну из папок и выберите **Свойства**.
    1. Выберите вкладку **Безопасность** и нажмите кнопку **Дополнительно**.
    1. Щелкните **Изменить** для **Владельца**.
    1. Введите **Администраторы** в текстовое поле.
    1. Щелкните **Проверить имена** и **ОК**.
1. Повторите предыдущие шаги для всех узлов кластера.
1. Кроме того, повторите описанные выше действия для каждого файла DLL в обеих папках. Должны быть все четыре библиотеки DLL.

Чтобы убедиться, что параметры теперь верны, сделайте это для каждой из четырех библиотек DLL:

1. последовательно выберите **Свойства > Безопасность > Изменить**.
1. Просмотрите список всех **Групп и пользователей** и убедитесь, что у каждого из них есть набор прав **Чтение & выполнение** (флажок в столбце **Разрешить** должен быть установлен).

## <a name="low-video-quality"></a>Низкое качество видео

Качество видео может быть снижено либо из-за качества соединения, либо из-за отсутствия видеокодека H265.

* См. шаги по [выявлению проблем с сетью](#unstable-holograms).
* См. [требования к системе](../overview/system-requirements.md#development-pc) для установки последней версии графического драйвера.

## <a name="video-recorded-with-mrc-does-not-reflect-the-quality-of-the-live-experience"></a>Видео, записанное в соответствии с помощью съемки смешанной реальности, не похоже на прямой эфир

Видео можно записать в HoloLens с помощью [записи смешанной реальности (нормативная ситуация)](/windows/mixed-reality/mixed-reality-capture-for-developers). Однако качество полученного видео хуже, чем прямой эфир:
* Частота видео ограничена 30 Гц, а не 60 Гц.
* Видеоизображения не проходят этап обработки [репроецирования на поздних этапах](../overview/features/late-stage-reprojection.md), поэтому видео кажется более зернистым.

Эти эффекты являются ограничениями техники записи.

## <a name="black-screen-after-successful-model-loading"></a>Черный экран после успешной загрузки модели

Если вы подключаетесь к среде рендеринга и успешно загрузили модель, но увидели только черный экран, это возможно по отдельным причинам.

Перед выполнением более подробного анализа рекомендуется протестировать следующие вещи.

* Установлен ли кодек H265? Хотя реализована поддержка кодека H264, бывают случаи, когда она работает неправильно. См. [требования к системе](../overview/system-requirements.md#development-pc) для установки последней версии графического драйвера.
* При использовании проекта Unity закройте Unity, удалите временную *библиотеку* и папку *obj* в каталоге проекта, а затем снова загрузите и повторите сборку проекта. В некоторых случаях кэшированные данные вызвали неправильное функционирование тестовых данных.

Если эти два действия не помогли, необходимо выяснить, получены ли видеокадры клиентом. Это можно запросить программно, как описано в главе [Запросы производительности на стороне сервера](../overview/features/performance-queries.md). В `FrameStatistics struct` есть элемент, указывающий на количество полученных видеокадров. Если это число больше 0 и со временем увеличивается, клиент получает фактические видеокадры с сервера. Следовательно, это проблема на стороне клиента.

### <a name="common-client-side-issues"></a>Распространенные проблемы на стороне клиента

**Модель превышает ограничения выбранной виртуальной машины, в частности максимальное количество полигонов:**

См. [ограничения на конкретные размеры сервера](../reference/limits.md#overall-number-of-polygons).

**Модель не находится внутри фрустум камеры:**

во многих случаях модель отображается правильно, но находится за пределами усеченной пирамиды камеры. Распространенной причиной является то, что модель была экспортирована с осью, сильно смещенной относительно центра, потому она обрезана панелью обрезки камеры. Он позволяет программно запрашивать ограничивающий прямоугольник модели и визуализировать поле с помощью Unity в виде строки или распечатывать его значения в журнале отладки.

Кроме того, процесс преобразования создает [выходной JSON-файл](../how-tos/conversion/get-information.md) вместе с преобразованной моделью. Чтобы отладить проблемы позиционирования модели, стоит взглянуть на `boundingBox` запись в разделе [outputStatistics](../how-tos/conversion/get-information.md#the-outputstatistics-section):

```JSON
{
    ...
    "outputStatistics": {
        ...
        "boundingBox": {
            "min": [
                -43.52,
                -61.775,
                -79.6416
            ],
            "max": [
                43.52,
                61.775,
                79.6416
            ]
        }
    }
}
```

ограничивающий прямоугольник описывается координатами `min` и `max` в трехмерном пространстве, в метрах. Таким образом, координата 1000,0 означает, что она находится на расстоянии 1 километра от источника.

Возможны две проблемы с этим ограничивающим прямоугольником, что делает часть фигуры невидимой.
* **Прямоугольник может быть позиционирован не по центру**, поэтому объект обрезается из-за обрезки дальних краев. Значения `boundingBox` в этом случае будут выглядеть следующим образом: `min = [-2000, -5,-5], max = [-1990, 5,5]`, используя большое смещение на оси x в качестве примера. Чтобы устранить проблему такого типа, включите параметр `recenterToOrigin` в [конфигурации преобразования модели](../how-tos/conversion/configure-model-conversion.md).
* **Прямоугольник можно центрировать, но порядок величин слишком большой**. Это означает, что, хотя камера запускается в центре модели, ее геометрия обрезается во всех направлениях. Типичные значения `boundingBox` в этом случае будут выглядеть следующим образом: `min = [-1000,-1000,-1000], max = [1000,1000,1000]`. Причиной такого типа проблемы обычно является несоответствие масштабирования единиц. Чтобы скомпенсировать это, укажите [значение масштабирования во время преобразования](../how-tos/conversion/configure-model-conversion.md#geometry-parameters) или разметьте исходную модель правильными единицами. Масштабирование можно также применить к корневому узлу при загрузке модели во время выполнения.

**Конвейер рендеринга Unity не включает обработчики рендеринга:**

Модуль удаленного рендеринга Azure подключается к конвейеру рендеринга Unity, чтобы выполнить композицию кадров с видео и репроекцию. Чтобы убедиться, что эти обработчики существуют, откройте меню *:::no-loc text="Window > Analysis > Frame debugger":::* . Включите его и убедитесь, что для `HolographicRemotingCallbackPass` в конвейере есть две записи:

![Конвейер прорисовки Unity](./media/troubleshoot-unity-pipeline.png)

## <a name="checkerboard-pattern-is-rendered-after-model-loading"></a>Шаблон шахматной доски отображается после загрузки модели

Если отображаемое изображение выглядит следующим образом: на ![ снимке экрана показана сетка черно-белых квадратов с меню Сервис.](../reference/media/checkerboard.png)
Затем модуль подготовки отчетов обращается к [пределам многоугольников для стандартного размера конфигурации](../reference/vm-sizes.md). Чтобы устранить эту проблемы, переключитесь на размер конфигурации **Premium** или сократите количество видимых многоугольников.

## <a name="the-rendered-image-in-unity-is-upside-down"></a>Визуализированный образ в Unity является перевернутым

Обязательно следуйте указаниям в [руководстве по Unity: Просмотр удаленных моделей](../tutorials/unity/view-remote-models/view-remote-models.md) в точности. Перевернутое изображение указывает, что Unity требуется для создания целевого объекта отрисовки на экране. В настоящее время такое поведение не поддерживается и создает огромное воздействие на производительность в HoloLens 2.

Причиной этой проблемы могут быть MSAA, HDR или включить обработку после обработки. Убедитесь, что выбран профиль низкого качества и в Unity задано значение по умолчанию. Для этого перейдите к разделу *изменение > параметры проекта... > качество*.

## <a name="unity-code-using-the-remote-rendering-api-doesnt-compile"></a>Код Unity, использующий API удаленного рендеринга, не компилируется

### <a name="use-debug-when-compiling-for-unity-editor"></a>Использовать отладку при компиляции для редактора Unity

Переключить *тип сборки* решения Unity на режим **Отладки**. При тестировании ARR в редакторе Unity определение `UNITY_EDITOR` доступно только в сборках типа "Отладка". Обратите внимание, что это не относится к типу сборки для [развернутых приложений](../quickstarts/deploy-to-hololens.md), где предпочтительнее использовать сборки типа "Выпуск".

### <a name="compile-failures-when-compiling-unity-samples-for-hololens-2"></a>Ошибки компиляции при компиляции примеров Unity для HoloLens 2

При попытке компиляции примеров Unity (краткое руководство, ShowCaseApp,..) для HoloLens 2 мы наблюдали непериодические сбои. Visual Studio заявляет о невозможности скопировать некоторые файлы, хотя они там находятся. Если вы столкнулись с этой проблемой, сделайте следующее.
* Удалите все временные файлы Unity из проекта и повторите попытку. Закройте Unity, удалите временную *библиотеку* и папку *obj* в каталоге проекта, а затем снова загрузите и повторите сборку проекта.
* Убедитесь, что проекты расположены в каталоге на диске с достаточно коротким путем, так как иногда на этапе копирования возникают проблемы с длинными именами файлов.
* Если это не поможет, возможно, MS Sense влияет на копирование. Чтобы настроить исключение, выполните команду реестра из командной строки (требуются права администратора):
    ```cmd
    reg.exe ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Advanced Threat Protection" /v groupIds /t REG_SZ /d "Unity”
    ```
    
### <a name="arm64-builds-for-unity-projects-fail-because-audiopluginmshrtfdll-is-missing"></a>Не удается выполнить сборки Arm64 для проектов Unity, так как отсутствует AudioPluginMsHRTF.dll

`AudioPluginMsHRTF.dll`Для Arm64 был добавлен в пакет *Windows Mixed Reality* *(com. Unity. XR. виндовсмр. Metro)* в версии 3.0.1. Убедитесь, что установлена версия 3.0.1 или более поздняя с помощью диспетчера пакетов Unity. В строке меню Unity перейдите к *окну > диспетчер пакетов* и найдите пакет *Windows Mixed Reality* .

## <a name="native-c-based-application-does-not-compile"></a>Собственное приложение на основе C++ не компилируется

### <a name="library-not-found-error-for-uwp-application-or-dll"></a>Ошибка "Библиотека не найдена" для приложения UWP или библиотеки DLL

В пакете NuGet C++ есть файл `microsoft.azure.remoterendering.Cpp.targets` , который определяет, какую из двоичных версий следует использовать. Для обнаружения `UWP` условий в файле проверяется на наличие `ApplicationType == 'Windows Store'` . Поэтому необходимо убедиться, что этот тип задан в проекте. Это следует учитывать при создании приложения UWP или библиотеки DLL с помощью мастера проектов Visual Studio.

## <a name="unstable-holograms"></a>Нестабильная голограмма

Если готовые к просмотру объекты перемещаются вместе с перемещениями головок, могут возникать проблемы с *репроецированием на поздних этапах* (LSR). Дополнительные сведения о том, как обрабатывать такую ситуацию, см. в разделе [Репроецирование на поздних этапах](../overview/features/late-stage-reprojection.md).

Другими причинами нестабильной голограммы (дергание, искривление, колебание или прыжки) может быть плохое сетевое подключение, в частности недостаточная пропускная способность сети или слишком высокая задержка. Хорошим индикатором качества сетевого подключения является [значение статистики](../overview/features/performance-queries.md) производительности`ARRServiceStats.VideoFramesReused`. Повторно используемые кадры указывают на ситуации, когда старый видеокадр необходимо повторно использовать на стороне клиента, поскольку новый видеокадр был недоступен, например из-за потери пакетов или из-за вариаций задержки сети. Если `ARRServiceStats.VideoFramesReused` часто больше нуля, это указывает на проблему с сетью.

Другое значение, на которое следует обратить внимание, — `ARRServiceStats.LatencyPoseToReceiveAvg`. Оно должно быть постоянно ниже 100 мс. Просмотр более высоких значений может означать, что вы подключены к центру обработки данных, который находится на слишком далеком расстоянии.

Список возможных рисков см. в [рекомендации по подключению к сети](../reference/network-requirements.md#guidelines-for-network-connectivity).

## <a name="z-fighting"></a>Z-конфликт

Хотя функция ARR предлагает [возможность устранения проблем с отрешениями z](../overview/features/z-fighting-mitigation.md), по-прежнему может отображаться в сцене. Это руководство нацелено на устранение этих оставшихся проблем.

### <a name="recommended-steps"></a>Рекомендуемые действия

Используйте следующий рабочий процесс для устранения проблем с z:

1. Протестируйте сцену с параметрами по умолчанию ARR (устранение рисков по z для)

1. Отключение борьбы с z-смягчением с помощью [API](../overview/features/z-fighting-mitigation.md) 

1. Изменение плоскости вблизи и дальней камеры на более близкий диапазон

1. Устранение неполадок сцены с помощью следующего раздела

### <a name="investigating-remaining-z-fighting"></a>Исследование оставшейся борьбы с z

Если описанные выше действия были исчерпаны, а оставшаяся потеря по оси z неприемлема, то необходимо исследовать базовую причину борьбы с z. Как указано на [странице функции по устранению рисков с точки зрения z](../overview/features/z-fighting-mitigation.md), существуют две основные причины для борьбы с z: потери точности глубины в дальнем конце диапазона глубины, а также поверхности, пересекающие копланар. Снижение точности глубины — это математическая возможность, которую можно уменьшить, выполнив шаг 3 выше. Поверхности копланар указывают на изъян исходного ресурса и лучше исправлены в исходных данных.

ARR имеет функцию для определения, могут ли поверхности отменять z-борьба: [выделение в шахматном](../overview/features/z-fighting-mitigation.md)порядке. Можно также определить визуальное, что вызывает отправку z. В следующей анимации показан пример потери с глубиной точности на расстоянии, а во втором — пример почти копланар поверхностей:

![В анимации показан пример потери с глубиной точности на расстоянии.](./media/depth-precision-z-fighting.gif)  ![В анимации показан пример почти копланар поверхностей.](./media/coplanar-z-fighting.gif)

Сравните эти примеры с z-отработкой, чтобы определить причину или при необходимости выполнить этот пошаговый рабочий процесс:

1. Поместите камеру над поверхностью борьбы с z, чтобы увидеть их непосредственно на поверхности.
1. Медленно переносите камеру в сторону от поверхностей.
1. Если все время отправляются по оси z, поверхности вполне копланар. 
1. Если в большинстве случаев подойдет борьба за z, поверхности будут почти копланар.
1. Если отправку по z видно только с самого края, причина в том, что у нее нет точности глубины.

Поверхности копланар могут иметь ряд различных причин.

* Объект был дублирован приложением экспорта из-за ошибки или различных подходов к рабочему процессу.

    Проверьте эти проблемы с помощью соответствующей поддержки приложений и приложений.

* Поверхности дублируются и отправляются для появления в виде двойных модулей подготовки отчетов, использующих внешний вид и внешние лица.

    Импорт с помощью [преобразования модели](../how-tos/conversion/model-conversion.md) определяет основную одностороннюю модель. В качестве значения по умолчанию подразумевается двойная сторона. Поверхность будет подготовлена к просмотру как тонкая стенка с физическим правильным освещением с обеих сторон. Односторонняя сторона может полагаться на флаги в исходном ресурсе или явным образом принудительно при [преобразовании модели](../how-tos/conversion/model-conversion.md). Кроме того, при необходимости [односторонний режим](../overview/features/single-sided-rendering.md) может иметь значение "нормальный".

* Объекты пересекаются в исходных ресурсах.

     Объекты, преобразованные таким образом, что некоторые из их поверхностей перекрываются, также создают возможность откладываться на z. Преобразование частей дерева сцены в импортированной сцене в ARR также может привести к возникновению этой проблемы.

* Поверхности являются намеренноми, созданными для сенсорного ввода, например декалс или Text в стенах.

## <a name="graphics-artifacts-using-multi-pass-stereo-rendering-in-native-c-apps"></a>Графические артефакты с использованием многопроходного стерео отрисовки в собственных приложениях C++

В некоторых случаях пользовательские приложения C++, использующие многопроходный режим рендеринга для локального содержимого (отрисовка левого и правого глаз в отдельных проходах) после вызова [**блитремотефраме**](../concepts/graphics-bindings.md#render-remote-image) , могут вызвать ошибку драйвера. Ошибка приводит к сбою недетерминированной растеризации, что приводит к случайному исчезновению отдельных треугольников или частей треугольников локального содержимого. По соображениям производительности рекомендуется отображать локальное содержимое с помощью более современных однопроходных стерео-методов отрисовки, например с помощью **SV_RenderTargetArrayIndex**.

## <a name="next-steps"></a>Дальнейшие действия

* [Требования к системе](../overview/system-requirements.md)
* [Требования к сети](../reference/network-requirements.md)