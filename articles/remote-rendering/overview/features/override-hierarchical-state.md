---
title: Переопределение иерархического состояния
description: Описание компонентов переопределения иерархического состояния.
author: florianborn71
ms.author: flborn
ms.date: 02/10/2020
ms.topic: article
ms.custom: devx-track-csharp
ms.openlocfilehash: 851a87885ac765c829e8c2be9fd1205e22906ca9
ms.sourcegitcommit: 867cb1b7a1f3a1f0b427282c648d411d0ca4f81f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "94445160"
---
# <a name="hierarchical-state-override"></a>Переопределение иерархического состояния

Во многих случаях необходимо динамически изменять внешний вид частей [модели](../../concepts/models.md), например скрывать поддиаграммы или переключать части на прозрачную визуализацию. Изменять материалы для каждой затронутой части не очень практично, так как для этого требуется итеративно обрабатывать весь граф сцены, а также управлять клонированием материалов и назначать их на каждом узле.

Чтобы решить такую задачу с минимально возможными издержками, используйте `HierarchicalStateOverrideComponent`. Этот компонент реализует обновление иерархического состояния для произвольных ветвей графа сцены. Это означает, что состояние можно определить на любом уровне графа сцены, и оно будет передаваться вниз по иерархии до того места, где будет переопределено другим состоянием или применено к конечному объекту.

В качестве примера мы рассмотрим модель автомобиля, который нам нужно сделать полностью прозрачным, за исключением внутренностей двигателя. Такой вариант использования требует всего двух экземпляров компонента:

* Первый компонент назначается корневому узлу модели, чтобы включить прозрачную отрисовку для всего автомобиля.
* Второй компонент назначается корневому узлу двигателя, где состояние явным образом переопределяется (режим прозрачности отключается).

## <a name="features"></a>Компоненты

Ниже представлен полный фиксированный набор состояний, которые могут быть переопределены.

* **`Hidden`**: Соответствующие сетки в графе сцены скрыты или показаны.
* **`Tint color`**: Визуализированный объект может быть оттенок цвета с индивидуальным цветом оттенка и насыщенностью оттенка. На рисунке ниже демонстрируется выделение цветом обода колеса.
  
  ![Цвет оттенка, используемый для включения зеленого объекта](./media/color-tint.png)

* **`See-through`**: Геометрия визуализируется полупрозрачным образом, например для отображения внутренних частей объекта. На следующем рисунке мы видим, что весь автомобиль отрисовывается в режиме прозрачности, за исключением красного тормозного суппорта:

  ![Режим просмотра "в режиме", используемый для выделения прозрачных объектов](./media/see-through.png)

  > [!IMPORTANT]
  > Эффект прозрачности работает, только если включен [режим отрисовки](../../concepts/rendering-modes.md) *TileBasedComposition*.

* **`Shell`**: Геометрия подготавливается к просмотру как прозрачная, нанасыщенная оболочкой. Этот режим позволяет выносить неважные части сцены, сохраняя при этом смысл формы и относительного позиционирования. Чтобы изменить внешний вид отрисовки оболочки, используйте состояние [шеллрендерингсеттингс](shell-effect.md) . На рисунке ниже показано, что модель автомобиля полностью визуализирована оболочкой, за исключением синей пружины:

  ![Режим оболочки, используемый для исчезновения конкретных объектов](./media/shell.png)

  > [!IMPORTANT]
  > Воздействие оболочки работает только при использовании [режима рендеринга](../../concepts/rendering-modes.md) *тилебаседкомпоситион* .

* **`Selected`**: Геометрия отображается с [контуром выделения](outlines.md).

  ![Параметр структуры, используемый для выделения выбранной части](./media/selection-outline.png)

* **`DisableCollision`**: Геометрия исключена из [пространственных запросов](spatial-queries.md). **`Hidden`** Флаг не влияет на флаг состояния столкновений, поэтому эти два флага часто устанавливаются вместе.

* **`UseCutPlaneFilterMask`**: Используйте отдельную битовую маску фильтра для управления выделением вырезанной плоскости. Этот флаг определяет, должна ли отдельная Маска фильтра использоваться или наследоваться от ее родителя. Сама битовая маска фильтра задается с помощью `CutPlaneFilterMask` Свойства. Подробные сведения о том, как работает фильтрация, см. в [абзаце Выборочная вырезание плоскостей](cut-planes.md#selective-cut-planes). См. Следующий пример, в котором только кирпич и RIM вырезаются, а оставшаяся часть сцены остается без изменений.
![Выборочная вырезание плоскостей](./media/selective-cut-planes-hierarchical-override.png)


> [!TIP]
> В качестве альтернативы отключению и пространственному запросу для полной вложенной диаграммы `enabled` состояние игрового объекта можно переключить. Если иерархия отключена, это имеет приоритет над любым `HierarchicalStateOverrideComponent` .

## <a name="hierarchical-overrides"></a>Иерархические переопределения

`HierarchicalStateOverrideComponent` можно присоединить на нескольких уровнях иерархии объектов. Для каждого типа сущности может существовать только один компонент каждого типа, поэтому каждый `HierarchicalStateOverrideComponent` управляет одновременно состояниями сокрытия, прозрачности, выбора, цветовых оттенков и столкновений.

Это означает, что каждое состояние определяется одним из следующих значений:

* `ForceOn` — состояние включено для всей сетки, начиная с этого узла и ниже;
* `ForceOff` — состояние отключено для всей сетки, начиная с этого узла и ниже;
* `InheritFromParent` — этот компонент переопределения не влияет на это состояние.

Состояния можно изменять напрямую или с помощью функции `SetState`:

```cs
HierarchicalStateOverrideComponent component = ...;

// set one state directly
component.HiddenState = HierarchicalEnableState.ForceOn;

// set a state with the SetState function
component.SetState(HierarchicalStates.SeeThrough, HierarchicalEnableState.InheritFromParent);

// set multiple states at once with the SetState function
component.SetState(HierarchicalStates.Hidden | HierarchicalStates.DisableCollision, HierarchicalEnableState.ForceOff);
```

```cpp
ApiHandle<HierarchicalStateOverrideComponent> component = ...;

// set one state directly
component->SetHiddenState(HierarchicalEnableState::ForceOn);

// or: set a state with the SetState function
component->SetState(HierarchicalStates::SeeThrough, HierarchicalEnableState::InheritFromParent);

// set multiple states at once with the SetState function
component->SetState(
    (HierarchicalStates)((int32_t)HierarchicalStates::Hidden | (int32_t)HierarchicalStates::DisableCollision), HierarchicalEnableState::ForceOff);

```

### <a name="tint-color"></a>Цвет оттенка

`tint color`Переопределение является немного особым, так как у него есть состояние ON/OFF/наследование и свойство оттенка цвета. Значение альфа-канала для цвета оттенка определяет весовой коэффициент эффекта окраски. Если задано значение 0,0, цвет оттенка не виден, а если задано значение 1,0, объект отрисовывается с чистым цветом оттенком. При промежуточных значениях итоговый цвет объекта смешивается с цветом оттенка. Цвет оттенка можно изменять для каждого кадра, чтобы создать цветовую анимацию.

## <a name="performance-considerations"></a>Вопросы производительности

Экземпляр `HierarchicalStateOverrideComponent` сам по себе не требует много ресурсов в среде выполнения. Но мы рекомендуем не увеличивать без необходимости количество активных компонентов. Например, при реализации системы выбора объектов с отрисовкой выделения рекомендуется удалить этот компонент при снятии выделения. Если вы будете хранить компоненты с нейтральными свойствами, нагрузка будет быстро повышаться.

Прозрачная отрисовка создает больше нагрузки на GPU сервера, чем стандартная отрисовка. Если *прозрачность* включена для больших частей графа сцены, и при этом несколько уровней геометрии остаются видимыми, это может существенно влиять на производительность. То же самое допустимо для объектов с [контурами выбора](../../overview/features/outlines.md#performance) и для [отрисовки оболочки](../../overview/features/shell-effect.md#performance) . 

## <a name="api-documentation"></a>Документирование API

* [Класс C# Хиерарчикалстатеоверридекомпонент](/dotnet/api/microsoft.azure.remoterendering.hierarchicalstateoverridecomponent)
* [Класс C++ Хиерарчикалстатеоверридекомпонент](/cpp/api/remote-rendering/hierarchicalstateoverridecomponent)

## <a name="next-steps"></a>Дальнейшие действия

* [Контуры](../../overview/features/outlines.md)
* [Режимы отрисовки](../../concepts/rendering-modes.md)
* [Пространственные запросы](../../overview/features/spatial-queries.md)