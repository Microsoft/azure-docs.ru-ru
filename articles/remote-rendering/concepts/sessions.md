---
title: Сеансы Удаленной отрисовки
description: Описание сеанса Удаленной отрисовки.
author: jakrams
ms.author: jakras
ms.date: 02/21/2020
ms.topic: conceptual
ms.custom: devx-track-csharp
ms.openlocfilehash: 79f3f93338d15562dcc37857d63bc8b2d7e96b05
ms.sourcegitcommit: 7ec45b7325e36debadb960bae4cf33164176bc24
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/16/2021
ms.locfileid: "100530558"
---
# <a name="remote-rendering-sessions"></a>Сеансы Удаленной отрисовки

В Удаленной отрисовке Azure (ARR) *сеанс* является ключевым понятием. В этой статье объясняется, что такое сеанс.

## <a name="overview"></a>Обзор

Удаленная отрисовка Azure разгружает сложные задачи отрисовки в облако. Эти задачи отрисовки не могут быть выполнены любым сервером, так как в большинстве облачных серверов отсутствует GPU. Ввиду объема задействованных данных и жесткого требования получать результаты с интерактивной частотой кадров ответственность за то, какой сервер обрабатывает запрос того или иного пользователя, также не может перекладываться на другой компьютер в реальном времени, как это допускается для более универсального интернет-трафика.

Это означает, что при использовании Удаленной отрисовки Azure облачный сервер с необходимыми возможностями оборудования должен быть зарезервирован исключительно для обработки запросов отрисовки. К *сеансу* относится все, что участвует во взаимодействии с этим сервером. Он начинается с начального запроса на резервирование (*аренду*) компьютера, затем выполняются все команды для загрузки и обработки моделей, а завершается сеанс освобождением аренды на облачном сервере.

## <a name="managing-sessions"></a>Управление сеансами

Существует несколько способов управления сеансами и взаимодействия с ними. Независимый от языка способ создания, обновления и завершения сеансов основывается на [REST API управления сеансами](../how-tos/session-rest-api.md). В C# и C++ эти операции предоставляются через классы `RemoteRenderingClient` и `RenderingSession`. Для приложений Unity существуют дополнительные служебные функции, предоставляемые компонентом `ARRServiceUnity`.

После *подключения* к активному сеансу такие операции, как [загрузка моделей](models.md) и взаимодействие с ними, предоставляются через класс `RenderingSession`.

### <a name="managing-multiple-sessions-simultaneously"></a>Одновременное управление несколькими сеансами

Невозможно полностью *подключиться* к нескольким сеансам с одного устройства. Тем не менее вы можете создавать, отслеживать и завершать любое количество сеансов из одного приложения. Если приложению не нужно подключаться к сеансу, его не нужно запускать на таком устройстве, как HoloLens 2. Такой вариант использования может быть реализован в том случае, если требуется управлять сеансами с помощью централизованного механизма. Например, можно создать веб-приложение, в котором несколько планшетов и устройств HoloLens могут войти в систему. Затем приложение может отображать на планшетах параметры, например для выбора отображаемой модели САПР. Если пользователь сделает выбор, эти сведения передаются на все устройства HoloLens для создания общего интерфейса.

## <a name="session-phases"></a>Этапы сеанса

Каждый сеанс проходит несколько этапов.

### <a name="session-startup"></a>Запуск сеанса

Когда вы указываете ARR [создать новый сеанс](../how-tos/session-rest-api.md), первым делом эта служба возвращает [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) сеанса. Этот UUID позволяет запрашивать сведения о сеансе. UUID и некоторые основные сведения о сеансе сохраняются в течение 30 дней, поэтому эти данные можно запросить даже после остановки сеанса. На этом этапе **состоянием сеанса** будет **Запуск**.

Затем Удаленная отрисовка Azure пытается найти сервер, на котором можно разместить ваш сеанс. Для этого поиска используются два параметра. Во-первых, будут резервироваться серверы только в вашем [регионе](../reference/regions.md). Это обусловлено тем, что задержка в сети между регионами может быть слишком высокой, чтобы гарантировать приемлемый результат. Второй фактор — требуемый *размер*, который вы указали. В каждом регионе существует ограниченное количество серверов, которые могут выполнить запрос размера уровня " [*стандартный*](../reference/vm-sizes.md) " или " [*премиум*](../reference/vm-sizes.md) ". Следовательно, если все серверы запрошенного размера в вашем регионе в настоящее время используются, создание сеанса завершится ошибкой. Причину сбоя [можно запросить](../how-tos/session-rest-api.md).

> [!IMPORTANT]
> Если вы запрашиваете *стандартный* Размер сервера и запрос завершается сбоем из-за высокого спроса, это не означает, что запрос сервера *Premium* также завершится сбоем. Поэтому, если это возможность, можно попробовать вернуться к размеру сервера *Premium* .

Когда служба находит подходящий сервер, ей нужно скопировать на него соответствующую виртуальную машину, чтобы превратить этот сервер в узел Удаленной отрисовки Azure. Этот процесс занимает несколько минут. После этого виртуальная машина загрузится, а **состояние сеанса** изменится на **Готово**.

На этом этапе сервер находится в режиме ожидания входных данных. Именно на этом этапе начинает взиматься плата за службу.

### <a name="connecting-to-a-session"></a>Подключение к сеансу

Когда сеанс *готов*, к нему можно *подключиться*. После подключения устройство может отправлять команды для загрузки и изменения моделей. Каждый узел ARR одновременно обслуживает только одно клиентское устройство, поэтому, когда клиент подключается к сеансу, он имеет монопольный контроль над отрисованным содержимым. Это также означает, что производительность отрисовки не будет изменяться по неподвластным вам причинам.

> [!IMPORTANT]
> Хотя к сеансу может *подключиться* только один клиент, основные сведения о сеансе, например его текущее состояние, можно запросить без подключения.

Пока устройство подключено к сеансу, попытки других устройств подключиться будут завершаться сбоем. Однако после отключения подключенного устройства (самостоятельного или из-за какого-либо сбоя) сеанс примет другой запрос на подключение. Все предыдущие состояния (загруженные модели и т. д.) отменяются, чтобы при следующем подключении устройства сеанс был очищен. Таким образом, сеансы можно многократно использовать с помощью разных устройств. Кроме того, в большинстве случаев можно скрыть дополнительные временные затраты на запуск сеанса от пользователя.

> [!IMPORTANT]
> Удаленный сервер никогда не изменяет состояние данных на стороне клиента. Все изменения данных (например, обновление преобразований и запросы на загрузку) должны выполняться клиентским приложением. Все действия немедленно обновляют состояние клиента.

### <a name="session-end"></a>Окончание сеанса

При запросе нового сеанса указывается *максимальный срок аренды*, обычно в диапазоне от 1 до 8 часов. Это время, в течение которого узел будет принимать ваши входные данные.

Существуют две распространенные причины завершения сеанса. Либо вы вручную запрашиваете остановку сеанса, либо истекает максимальный срок аренды. В обоих случаях все активные подключения к узлу мгновенно закрываются и служба завершает работу на этом сервере. Затем сервер возвращается в пул Azure и может использоваться для других задач. Остановку сеанса невозможно откатить или отменить. Запрос **состояния** остановленного сеанса вернет значение **Остановлено** или **Просрочено** в зависимости от того, был ли сеанс завершен вручную или истек его максимальный срок аренды.

Сеанс также может быть остановлен из-за какого-либо сбоя.

Во всех случаях после остановки сеанса плата уже не взымается.

> [!WARNING]
> Факты подключения к сеансу и их длительность не влияют на выставление счетов. Плата за службу зависит от *длительности сеанса*, что означает время, в течение которого сервер зарезервирован исключительно для вас и требуемые возможности оборудования ( [выделенный размер](../reference/vm-sizes.md)). Если вы запустили сеанс, подключились на пять минут, а затем не остановили сеанс, и он работал до истечения срока аренды, вам будет выставлен счет за полный срок аренды сеанса. И наоборот, *максимальный срок аренды* — это страховка. Не имеет значения, запросили ли вы сеанс со сроком аренды в восемь часов, а затем использовали его только пять минут, если затем вы вручную остановили этот сеанс.

#### <a name="extend-a-sessions-lease-time"></a>Продление срока аренды сеанса

Вы можете [продлить срок аренды](../how-tos/session-rest-api.md) активного сеанса, если это необходимо.

## <a name="example-code"></a>Пример кода

В приведенном ниже коде показана простая реализация запуска сеанса, ожидания состояния *готовности*, подключения, а затем отключения и завершения.

```cs
RemoteRenderingInitialization init = new RemoteRenderingInitialization();
// fill out RemoteRenderingInitialization parameters...

RemoteManagerStatic.StartupRemoteRendering(init);

SessionConfiguration sessionConfig = new SessionConfiguration();
// fill out sessionConfig details...

RemoteRenderingClient client = new RemoteRenderingClient(sessionConfig);

RenderingSessionCreationOptions rendererOptions = new RenderingSessionCreationOptions();
// fill out rendererOptions...

CreateRenderingSessionResult result = await client.CreateNewRenderingSessionAsync(rendererOptions);

RenderingSession session = result.Session;
RenderingSessionProperties sessionProperties;
while (true)
{
    var propertiesResult = await session.GetPropertiesAsync();
    sessionProperties = propertiesResult.SessionProperties;
    if (sessionProperties.Status != RenderingSessionStatus.Starting &&
        sessionProperties.Status != RenderingSessionStatus.Unknown)
    {
        break;
    }
    // REST calls must not be issued too frequently, otherwise the server returns failure code 429 ("too many requests"). So we insert the recommended delay of 10s
    await Task.Delay(TimeSpan.FromSeconds(10));
}

if (sessionProperties.Status != RenderingSessionStatus.Ready)
{
    // Do some error handling and either terminate or retry.
}

// Connect to server
ConnectionStatus connectStatus = await session.ConnectAsync(new RendererInitOptions());

// Connected!

while (...)
{
    // per frame update

    session.Connection.Update();
}

// Disconnect
session.Disconnect();

// stop the session
await session.StopAsync();

// shut down the remote rendering SDK
RemoteManagerStatic.ShutdownRemoteRendering();
```

Код может осуществлять обслуживание, обработку и выполнение запросов для нескольких экземпляров `RemoteRenderingClient` и `RenderingSession`. Но только одно устройство может одновременно подключаться к `RenderingSession`.

Время существования виртуальной машины не привязано к экземпляру `RemoteRenderingClient` или `RenderingSession`. Для завершения сеанса необходимо вызвать `RenderingSession.StopAsync`.

Постоянный идентификатор сеанса можно запросить с помощью `RenderingSession.SessionUuid()` и сохранить в локальный кэш. С помощью этого идентификатора приложение может вызвать `RemoteRenderingClient.OpenRenderingSessionAsync` для привязки к этому сеансу.

Если `RenderingSession.IsConnected` имеет значение true, то `RenderingSession.Connection` возвращает экземпляр `RenderingConnection`, который содержит функции, позволяющие [загружать модели](models.md), управлять [сущностями](entities.md) и [запрашивать сведения](../overview/features/spatial-queries.md) об отрисованной сцене.

## <a name="api-documentation"></a>Документирование API

* [Класс C# Рендерингсессион](/dotnet/api/microsoft.azure.remoterendering.renderingsession)
* [C# Ремотерендерингклиент. Креатеневрендерингсессионасинк ()](/dotnet/api/microsoft.azure.remoterendering.remoterenderingclient.createnewrenderingsessionasync)
* [C# Ремотерендерингклиент. Опенрендерингсессионасинк ()](/dotnet/api/microsoft.azure.remoterendering.remoterenderingclient.openrenderingsessionasync)
* [Класс C++ Рендерингсессион](/cpp/api/remote-rendering/renderingsession)
* [C++ Ремотерендерингклиент:: Креатеневрендерингсессионасинк](/cpp/api/remote-rendering/remoterenderingclient#createnewrenderingsessionasync)
* [C++ Ремотерендерингклиент:: Опенрендерингсессион](/cpp/api/remote-rendering/remoterenderingclient#openrenderingsession)

## <a name="next-steps"></a>Дальнейшие действия

* [Сущности](entities.md)
* [Модели](models.md)