---
title: Модульное тестирование служб с отслеживанием состояния в Azure Service Fabric
description: Узнайте о концепциях и методах модульного тестирования служб с отслеживанием состояния в Service Fabric.
ms.topic: conceptual
ms.date: 09/04/2018
ms.openlocfilehash: 12e8a47d9685dee12594f4e2afaa848d9688d185
ms.sourcegitcommit: 867cb1b7a1f3a1f0b427282c648d411d0ca4f81f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "75433910"
---
# <a name="unit-testing-stateful-services-in-service-fabric"></a>Модульное тестирование служб с отслеживанием состояния в Service Fabric

В этой статье описываются концепции и методы модульного тестирования служб с отслеживанием состояния в Service Fabric. Модульное тестирование в Service Fabric следует рассмотреть потому, что код приложения активно выполняется в разных контекстах. В этой статье описываются методы, позволяющие обеспечить поддержку кода приложения в каждом из различных контекстов, в которых он может выполняться.

## <a name="unit-testing-and-mocking"></a>Макетирование и модульное тестирование
Модульное тестирование в контексте этой статьи — это автоматическое тестирование, которое может быть выполнено в контексте средства выполнения тестов, такого как MSTest или NUnit. Модульные тесты в этой статье не выполняют операций с удаленным ресурсом, таким как база данных или RESTFul API. Эти удаленные ресурсы следует смакетировать. Макетирование в контексте этой статьи создает фиктивные возвращаемые значения для удаленных ресурсов, а также записывает и контролирует их.

### <a name="service-fabric-considerations"></a>Рекомендации по Service Fabric
Для выполнения модульного тестирования службы с отслеживанием состояния Service Fabric есть несколько рекомендаций. Во-первых, служебный код выполняется на нескольких узлах, но под разными ролями. Модульные тесты должны оценивать код в каждой роли для достижения полного охвата. Мы будем рассматривать такие роли, как первичная, активная вторичная, неактивная вторичная и неизвестная. Роль None не требует особого покрытия, так как Service Fabric считает эту роль недействительной или нулевой. Во-вторых, каждый узел будет изменять свою роль в любой заданной точке. Чтобы достичь полного охвата, путь выполнения кода должен быть протестирован с появлением изменений роли.

## <a name="why-unit-test-stateful-services"></a>Зачем использовать службы с отслеживанием состояния для модульных тестов? 
Модульное тестирование служб с отслеживанием состояния может помочь выявить некоторые распространенные ошибки, которые необязательно будут обнаружены обычным приложением или модульным тестированием домена. Например, если служба с отслеживанием состояния имеет какое-либо состояние в памяти, этот тип тестирования может проверить, что это состояние в памяти синхронизируется для каждой реплики. Этот тип тестирования может также проверять, что служба с отслеживанием состояния соответствующим образом реагирует на токены отмены, переданные с помощью оркестрации Service Fabric. Когда срабатывает отмена, служба должна останавливать любые долго выполняющиеся или асинхронные операции.  

## <a name="common-practices"></a>Общие рекомендации

В следующем разделе приведены рекомендации по наиболее распространенным методам модульного тестирования службы с отслеживанием состояния. Также рекомендуется, чтобы уровень макетирования максимально соответствовал оркестрации и управлению состоянием в Service Fabric. [ServiceFabric.Mocks](https://www.nuget.org/packages/ServiceFabric.Mocks/) 3.3.0 или более поздней версии — это одна из таких библиотек, которая предоставляет рекомендуемую стандартную функциональность и следует описанным ниже методам.

### <a name="arrangement"></a>Упорядочение

#### <a name="use-multiple-service-instances"></a>Использование нескольких экземпляров службы
Модульные тесты должны выполнять несколько экземпляров службы с отслеживанием состояния. Эта процедура имитирует то, что фактически происходит в кластере, где Service Fabric подготавливает несколько реплик для выполнения службы на разных узлах. Каждый из этих экземпляров будет выполняться в разном контексте. При запуске тестирования каждый экземпляр должен быть подготовлен с конфигурацией роли, ожидаемой в кластере. Например, если служба должна иметь размер целевой реплики 3, Service Fabric нужно подготовить три реплики на разных узлах. Одна из реплик является первичной, а две другие — активными вторичными.

В большинстве случаев путь выполнения службы будет немного отличаться для каждой из этих ролей. Например, если служба не должна принимать запросы от активной вторичной реплики, можно выполнить проверку для этого случая: должно быть передано информационное исключение, которое указывает, что запрос был предпринят на вторичной реплике. Наличие нескольких экземпляров позволит протестировать эту ситуацию.

Кроме того, при наличии нескольких экземпляров тесты могут переключать роли каждого из этих экземпляров, чтобы проверить соответствие ответов, несмотря на изменения роли.

#### <a name="mock-the-state-manager"></a>Макетирование диспетчера состояний
Диспетчер состояний должен рассматриваться как удаленный ресурс и поэтому должен макетироваться. При макетировании диспетчера состояний требуется базовое хранилище в памяти, позволяющее отслеживать, что сохраняется в диспетчере состояний, чтобы эту информацию можно было прочитать и проверить. Для этого можно создать экземпляры макетирования каждого из типов надежных коллекций. В рамках этих макетов используйте тип данных, который тесно связан с операциями, выполняемыми с этой коллекцией. Ниже приведены некоторые предлагаемые типы данных для каждой надежной коллекции.

- IReliableDictionary<TKey, TValue> -> System.Collections.Concurrent.ConcurrentDictionary<TKey, TValue>
- IReliableQueue\<T> -> System.Collections.Generic.Queue\<T>
- IReliableConcurrentQueue\<T> -> System.Collections.Concurrent.ConcurrentQueue\<T>

#### <a name="many-state-manager-instances-single-storage"></a>Несколько экземпляров диспетчера состояний и одно хранилище
Как упоминалось ранее, диспетчеры состояний и надежные коллекции должны рассматриваться как удаленные ресурсы. Следовательно, эти ресурсы должны и будут макетироваться в модульных тестах. Тем не менее при запуске нескольких экземпляров службы с отслеживанием состояния будет непросто поддерживать синхронизацию каждого запущенного диспетчера состояний в разных экземплярах службы с отслеживанием состояния. Когда служба с отслеживанием состояния работает в кластере, Service Fabric заботится о том, чтобы поддерживать диспетчер состояний каждой вторичной реплики в согласованности с первичной репликой. Поэтому тесты должны выполняться одинаково, чтобы они могли имитировать изменения ролей.

Простым способом достижения этой синхронизации может быть использование одноэлементного шаблона для базового объекта, который хранит данные, записанные в каждую надежную коллекцию. Например, если служба с отслеживанием состояния использует `IReliableDictionary<string, string>`. Диспетчер макетирования состояний должен возвращать макет `IReliableDictionary<string, string>`. Этот макет может использовать `ConcurrentDictionary<string, string>` для отслеживания записанных пар "ключ — значение". `ConcurrentDictionary<string, string>` должен быть одноэлементным, используемым всеми экземплярами диспетчера состояний, переданными в службу.

#### <a name="keep-track-of-cancellation-tokens"></a>Отслеживание токенов отмены
Токены отмены — это важный, но тем не менее часто игнорируемый аспект служб с отслеживанием состояния. Когда Service Fabric запускает первичную реплику для службы с отслеживанием состояния, предоставляется токен отмены. Он предназначен для передачи сигнала службе, когда экземпляр удаляется или понижается до другой роли. Служба с отслеживанием состояния должна остановить любые длительные или асинхронные операции, чтобы Service Fabric могла завершить рабочий процесс изменения ролей.

В ходе выполнения модульных тестов любые токены отмены, которые предоставляются для RunAsync, ChangeRoleAsync, OpenAsync и CloseAsync, должны сохраняться. Благодаря удержанию этих токенов тесты могут смоделировать завершение работы или понижение службы и убедиться, что она отвечает соответствующим образом.

#### <a name="test-end-to-end-with-mocked-remote-resources"></a>Сквозное тестирование с макетированными удаленными ресурсами
Модульные тесты должны выполнять как можно больше кода приложения, который может модифицировать состояние службы с отслеживанием состояния. Рекомендуется, чтобы тесты были более сквозными по своему характеру. Используются макеты для записи, имитации или проверки взаимодействия удаленных ресурсов. Это включает в себя взаимодействие с диспетчером состояний и надежными коллекциями. Следующий фрагмент кода демонстрирует пример сквозного тестирования:

```
    Given stateful service named "fabric:/MyApp/MyService" is created
    And a new replica is created as "Primary" with id "111"
    And a new replica is created as "IdleSecondary" with id "222"
    And a new replica is created as "IdleSecondary" with id "333"
    And all idle secondary replicas are promoted to active secondary
    When a request is made to add the an employee "John Smith"
    And the active secondary replica "222" is promoted to primary
    And a request is made to get all employees
    Then the request should should return the "John Smith" employee
```

Этот тест проверяет, что данные, записанные в одной реплике, доступны для вторичной реплики, когда она повышается до первичной. Предположим, что надежная коллекция является резервным хранилищем данных о сотрудниках. Потенциальный сбой, который может быть выявлен этим тестом, заключается в том, что код приложения не выполнил `CommitAsync` в транзакции для сохранения данных нового сотрудника. В этом случае второй запрос на получение данных сотрудников не будет возвращать данные сотрудника, добавленного в первом запросе.

### <a name="acting"></a>Действие
#### <a name="mimic-service-fabric-replica-orchestration"></a>Имитация оркестрации реплики в Service Fabric
При управлении несколькими экземплярами службы тесты должны инициализировать и удалять эти службы таким же образом, как и при выполняемой в Service Fabric оркестрации. Например, когда служба создается в новой первичной реплике, Service Fabric будет вызывать CreateServiceReplicaListener, OpenAsync, ChangeRoleAsync и RunAsync. События жизненного цикла описаны в следующих разделах:

- [Запуск службы с отслеживанием состояния](service-fabric-reliable-services-lifecycle.md#stateful-service-startup)
- [Завершение работы службы с отслеживанием состояния](service-fabric-reliable-services-lifecycle.md#stateful-service-shutdown)
- [Переключения первичной реплики службы с отслеживанием состояния](service-fabric-reliable-services-lifecycle.md#stateful-service-primary-swaps)

#### <a name="run-replica-role-changes"></a>Выполнение изменений роли реплики
Модульные тесты должны изменять роли экземпляров службы таким же образом, как и при выполняемой в Service Fabric оркестрации. Механизм изменения состояния роли описан в следующей статье:

[Реплики и экземпляры](service-fabric-concepts-replica-lifecycle.md#replica-role)

Моделирование изменений роли является одним из наиболее важных аспектов тестирования и может выявить проблемы, при которых состояния реплик не согласованы друг с другом. Несогласованное состояние реплики может возникнуть из-за сохранения состояния в памяти в переменных экземпляра уровня класса или статических переменных экземпляра. Примерами этого могут быть токены отмены, перечисления и объекты или значения конфигурации. Это также гарантирует, что служба соблюдает токены отмены, предоставленные во время вызова метода RunAsync, чтобы разрешить изменение роли. Имитация изменения роли также может выявить проблемы, которые могут возникнуть, если код не предназначен для вызова RunAsync несколько раз.

#### <a name="cancel-cancellation-tokens"></a>Отмена токенов отмены
Следует выполнить модульные тесты, где в методе RunAsync должен отменяться предоставленный токен отмены. Это позволит проверить, что служба завершает работу должным образом. Во время этого отключения все длительные или асинхронные операции должны быть остановлены. Пример длительного процесса, который может существовать в службе, — ожидание передачи сообщений в надежной очереди. Он может находиться непосредственно в RunAsync или в фоновом потоке. Реализация должна включать логику выхода из операции, если этот токен отмены отменяется.

Если службы с отслеживанием состояния используют любое состояние кэша или состояние в памяти, которое должно существовать только в первичной реплике, оно должно быть удалено. Это необходимо для обеспечения согласованности этого состояния, если узел снова станет основным. Тестирование отмены позволит проверить, правильно ли освобождено это состояние.

#### <a name="execute-requests-against-multiple-replicas"></a>Выполнение запросов в нескольких репликах
Тесты подтверждения должны выполнять один и тот же запрос в разных репликах. При совместном использовании с изменением роли может возникнуть проблема согласованности. Пример теста может выполнять следующие действия:
1. Выполнять запрос на запись к текущей первичной реплике.
2. Выполнять запрос на чтение к текущей первичной реплике, который возвращает данные, записанные на шаге 1.
3. Повышать уровень с вторичного до первичного. При этом текущая первичная реплика также понижается до вторичной.
4. Выполнять тот же запрос на чтение, что и на шаге 2, к новой вторичной реплике.

На последнем этапе тест может подтвердить, что возвращенные данные согласованы. Потенциальная проблема, которая может быть обнаружена, заключается в том, что данные, возвращаемые службой, могут быть в памяти, но в конечном итоге архивироваться надежной коллекцией. Эти данные в памяти могут не синхронизироваться должным образом с тем, что существует в надежной коллекции.

Данные в памяти обычно используются для создания вторичных индексов или агрегатов данных, которые существуют в надежной коллекции.

### <a name="asserting"></a>Подтверждение
#### <a name="ensure-responses-match-across-replicas"></a>Обеспечение соответствия ответов между репликами
Модульные тесты должны подтверждать, что ответ на данный запрос согласован между несколькими репликами после повышения их уровня до первичного. Это может вызвать потенциальные проблемы, когда данные, предоставленные в ответе, либо не архивированы в надежной коллекции, либо хранятся в памяти без механизма синхронизации данных между репликами. Это гарантирует, что служба отправит обратно согласованные ответы после перебалансировки Service Fabric или перейдет к новой первичной реплике.

#### <a name="verify-service-respects-cancellation"></a>Проверка соблюдения отмены службой
Следует проверить фактическое завершение длительных или асинхронных процессов, которые должны быть прекращены при отмене токена отмены. Таким образом гарантируется, что, несмотря на изменения ролей реплики, процессы, которые не должны продолжать выполнение во вторичной реплике, останавливаются до завершения перехода. Это также может выявить проблемы, при которых такой процесс блокирует запрос на изменение роли или завершение работы от Service Fabric.

#### <a name="verify-which-replicas-should-serve-requests"></a>Проверка того, какие реплики должны обслуживать запросы
Тесты должны подтверждать ожидаемое поведение, если запрос направляется ко вторичной реплике. Service Fabric предоставляет возможность обслуживать запросы вторичным репликам. Тем не менее операции записи в надежные коллекции возможны только из первичной реплики. Если ваше приложение предусматривает обслуживание запросов только первичными репликами или обрабатывание вторичными репликами только подмножества запросов, тогда тесты должны подтверждать ожидаемое поведение как для положительных, так и для отрицательных случаев. В отрицательном случае запрос направляется к реплике, которая не должна его обрабатывать, а в положительном — наоборот.

## <a name="next-steps"></a>Дальнейшие действия
[Создание модульных тестов для служб с отслеживанием состояния](service-fabric-how-to-unit-test-stateful-services.md)
