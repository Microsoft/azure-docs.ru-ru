---
title: Общие сведения об Azure Service Fabric с управлением API
description: Эта статья содержит вводную информацию об использовании службы управления API Azure в качестве шлюза к приложениям Service Fabric.
ms.topic: conceptual
ms.date: 06/22/2017
ms.openlocfilehash: 32f47d62cc9dda7cc88421dbf616bf69ffe152fc
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "96575692"
---
# <a name="service-fabric-with-azure-api-management-overview"></a>Общие сведения о Service Fabric со службой управления API Azure

Обычно, облачным приложениям требуется интерфейсный шлюз, который предоставляет единую точку передачи входящего трафика пользователей, устройств или других приложений. В Service Fabric шлюз может быть любой службой без отслеживания состояния, например [ASP.NET Core приложением](service-fabric-reliable-services-communication-aspnetcore.md), или другой службой, предназначенной для исходящего трафика, например [концентраторов событий](../event-hubs/index.yml), [центра Интернета вещей](../iot-hub/index.yml)или службы [управления API Azure](../api-management/index.yml).

Эта статья содержит вводную информацию об использовании службы управления API Azure в качестве шлюза к приложениям Service Fabric. Служба управления API непосредственно интегрируется с Service Fabric. Это позволяет публиковать интерфейсы API с широким набором правил маршрутизации к внутренним службам Service Fabric.

## <a name="availability"></a>Доступность

> [!IMPORTANT]
> Эта функция доступна в ценовой категории **Премиум** и **Разработка** управления API, так как необходима поддержка виртуальной сети.

## <a name="architecture"></a>Архитектура

Общая архитектура Service Fabric основана на одностраничном веб-приложении, которое выполняет HTTP-вызовы к внутренним службам, предоставляющим API-интерфейсы HTTP. Пример такой архитектуры см. в статье [Service Fabric Getting Started Sample](https://github.com/Azure-Samples/service-fabric-dotnet-getting-started) (Пример приложения для начала работы с Service Fabric).

В рамках этого сценария в качестве шлюза к приложению Service Fabric используется веб-служба без отслеживания состояния. При этом подходе вам потребуется написать веб-службу с поддержкой проксирования HTTP-запросов к внутренним службам, как показано на следующей схеме:

![Схема, показывающая, как веб-служба без отслеживания состояния выступает в качестве шлюза в приложение Service Fabric.][sf-web-app-stateless-gateway]

По мере роста сложности приложений усложняются и шлюзы, которые должны представлять API в различных внутренних службах. Служба управления API Azure обрабатывает сложные API-интерфейсы, а также задает правила маршрутизации, поддерживает управление доступом, ограничение скорости, мониторинг, ведение журналов событий и кэширование ответов. При этом вам не нужно выполнять сложные действия. Кроме того, служба управления API Azure поддерживает такие возможности Service Fabric, как обнаружение служб, разрешение разделов и выбор реплик. Это обеспечивает возможность интеллектуального перенаправления запросов непосредственно к внутренним службам в Service Fabric, за счет чего вам не нужно писать собственный шлюз API без отслеживания состояния. 

В этом сценарии пользовательский веб-интерфейс по-прежнему обрабатывается веб-службой, а передача HTTP-вызовов API и управление ими осуществляется через службу управления API Azure, как показано на следующей схеме:

![Схема, показывающая, как веб-интерфейс по-прежнему обслуживается через веб-службу, а вызовы API HTTP управляются и направляются через службу управления API Azure.][sf-apim-web-app]

## <a name="application-scenarios"></a>Сценарии приложений

На платформе Service Fabric могут размещаться как службы с отслеживанием состояния, так и службы без отслеживания состояния. Их секционирование осуществляется на основе одной из трех схем: одноэлементное, по диапазонам значений Int64 и по именам. Разрешение конечной точки службы требует определения отдельного раздела конкретного экземпляра службы. При разрешении конечной точки службы следует указать имя экземпляра службы (например, `fabric:/myapp/myservice`), а также определенный раздел службы. Это не требуется делать при использовании одноэлементного секционирования.

Служба управления API Azure поддерживает любое сочетание служб без отслеживания состояния, служб с отслеживанием состояния, а также любые схемы секционирования.

## <a name="send-traffic-to-a-stateless-service"></a>Отправка трафика в службу без отслеживания состояния

В самом простом случае трафик перенаправляется к экземпляру службы без отслеживания состояния. С этой целью операция службы управления API содержит политику обработки входящего трафика в серверной части Service Fabric, которая сопоставляет запрос с определенным экземпляром службы без отслеживания состояния в серверной части Service Fabric. Запросы, отправленные в эту службу, отправляются случайному экземпляру службы.

**Пример**

В следующем сценарии приложение Service Fabric содержит службу без отслеживания состояния `fabric:/app/fooservice`, которая обеспечивает доступ к внутреннему API-интерфейсу HTTP. Имя экземпляра службы хорошо известно. Его можно жестко задать непосредственно в политике обработки входящего трафика службы управления API. 

![Схема, показывающая приложение Service Fabric, содержит службу без отслеживания состояния, которая предоставляет внутренний API-интерфейс HTTP.][sf-apim-static-stateless]

## <a name="send-traffic-to-a-stateful-service"></a>Отправка трафика в службу с отслеживанием состояния

Так же как и в предыдущем сценарии, трафик можно перенаправлять к экземпляру службы с отслеживанием состояния. В этом случае операция службы управления API содержит политику обработки входящего трафика в серверной части Service Fabric, которая сопоставляет запрос с определенным разделом конкретного экземпляра службы *с отслеживанием состояния*. Раздел, с которым сопоставляется каждый запрос, вычисляется на основе метода с применением лямбда-выражения с использованием некоторых входных данных из входящего HTTP-запроса, например значение URL-адреса. В политике можно реализовать отправку запросов только к первичной реплике или к случайной реплике, как в случае с операциями чтения.

**Пример**

В следующем сценарии приложение Service Fabric содержит секционированную службу с отслеживанием состояния `fabric:/app/userservice`, которая обеспечивает доступ к внутреннему API-интерфейсу HTTP. Имя экземпляра службы хорошо известно. Его можно жестко задать непосредственно в политике обработки входящего трафика службы управления API.  

Секционирование службы осуществляется на основе схемы секционирования Int64 с использованием двух разделов и диапазона ключей, охватывающего значения от `Int64.MinValue` до `Int64.MaxValue`. Серверная политика вычисляет ключ раздела в пределах диапазона, преобразовав значение `id` в пути запроса URL-адреса в 64-битное целое число. Ключ раздела можно вычислить с помощью любого алгоритма. 

![Обзор топологии Service Fabric со службой управления API Azure][sf-apim-static-stateful]

## <a name="send-traffic-to-multiple-stateless-services"></a>Отправка трафика в несколько служб без отслеживания состояния

В более сложных сценариях вы можете определить операцию службы управления API, которая сопоставляет запросы с несколькими экземплярами службы. В этом случае каждая операция службы с отслеживанием состояния должна содержать политику, сопоставляющую запросы с определенным экземпляром службы на основе значений из входящего HTTP-запроса, например значений из URL-адреса или строки запроса, и разделом в экземпляре службы.

С этой целью операция службы управления API содержит политику обработки входящего трафика в серверной части Service Fabric, которая сопоставляет запрос с экземпляром службы без отслеживания состояния в серверной части Service Fabric на основе значения из входящего HTTP-запроса. Запросы к службе отправляются на случайный экземпляр службы.

**Пример**

В этом примере создается новый экземпляр службы без отслеживания состояния для каждого пользователя приложения с динамически созданным именем на основе следующей формулы:

- `fabric:/app/users/<username>`

  Каждая служба имеет уникальное имя, но эти имена не известны заранее, так как службы создаются на основе входных данных пользователя или администратора, из-за чего их нельзя жестко задать в политиках APIM или правилах маршрутизации. Вместо этого в определении серверной политики создается имя службы, к которой отправляется запрос, на основе значения `name` из пути запроса URL-адреса. Пример:

  - Запрос к `/api/users/foo` перенаправляется к экземпляру службы `fabric:/app/users/foo`.
  - Запрос к `/api/users/bar` перенаправляется к экземпляру службы `fabric:/app/users/bar`.

![Схема, на которой показан пример, в котором создается новый экземпляр службы без отслеживания состояния для каждого пользователя приложения с динамически формируемым именем.][sf-apim-dynamic-stateless]

## <a name="send-traffic-to-multiple-stateful-services"></a>Отправка трафика в несколько служб с отслеживанием состояния

Так же как и в примере со службой без отслеживания состояния, операция службы управления API может сопоставлять запросы с несколькими экземплярами служб **с отслеживанием состояния**. В этом случае, возможно, также потребуется разрешить разделы всех экземпляров служб с отслеживанием состояния.

С этой целью операция службы управления API содержит политику обработки входящего трафика в серверной части Service Fabric, которая сопоставляет запрос с экземпляром службы с отслеживанием состояния в серверной части Service Fabric на основе значения из входящего HTTP-запроса. Помимо сопоставления запроса с определенным экземпляром службы, его можно также сопоставить с определенным разделом экземпляра службы и при необходимости с первичной или случайной вторичной репликой в разделе.

**Пример**

В этом примере создается новый экземпляр службы с отслеживанием состояния для каждого пользователя приложения с динамически созданным именем на основе следующей формулы:

- `fabric:/app/users/<username>`

  Каждая служба имеет уникальное имя, но эти имена не известны заранее, так как службы создаются на основе входных данных пользователя или администратора, из-за чего их нельзя жестко задать в политиках APIM или правилах маршрутизации. Вместо этого в определении серверной политики создается имя службы, к которой отправляется запрос, на основе значения `name` из пути запроса URL-адреса. Пример:

  - Запрос к `/api/users/foo` перенаправляется к экземпляру службы `fabric:/app/users/foo`.
  - Запрос к `/api/users/bar` перенаправляется к экземпляру службы `fabric:/app/users/bar`.

Секционирование каждого экземпляра службы осуществляется на основе схемы секционирования Int64 с использованием двух разделов и диапазона ключей, охватывающего значения от `Int64.MinValue` до `Int64.MaxValue`. Серверная политика вычисляет ключ раздела в пределах диапазона, преобразовав значение `id` в пути запроса URL-адреса в 64-битное целое число. Ключ раздела можно вычислить с помощью любого алгоритма. 

![Схема, показывающая, что каждый экземпляр службы также секционирован с использованием схемы секционирования Int64 с двумя секциями и диапазон ключей, охватывающий Int64. MinValue до Int64. MaxValue.][sf-apim-dynamic-stateful]

## <a name="next-steps"></a>Дальнейшие действия

Выполните указания в [этом руководстве](service-fabric-tutorial-deploy-api-management.md), чтобы настроить свой первый кластер Service Fabric со службой управления API и реализовать через нее отправку запросов к своим службам.

<!-- links -->

<!-- pics -->
[sf-apim-web-app]: ./media/service-fabric-api-management-overview/sf-apim-web-app.png
[sf-web-app-stateless-gateway]: ./media/service-fabric-api-management-overview/sf-web-app-stateless-gateway.png
[sf-apim-static-stateless]: ./media/service-fabric-api-management-overview/sf-apim-static-stateless.png
[sf-apim-static-stateful]: ./media/service-fabric-api-management-overview/sf-apim-static-stateful.png
[sf-apim-dynamic-stateless]: ./media/service-fabric-api-management-overview/sf-apim-dynamic-stateless.png
[sf-apim-dynamic-stateful]: ./media/service-fabric-api-management-overview/sf-apim-dynamic-stateful.png
