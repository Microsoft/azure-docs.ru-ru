---
title: Общие сведения о жизненном цикле Reliable Services
description: Сведения о событиях жизненного цикла в приложении Azure Service Fabric Reliable Services для служб с отслеживанием состояния и без отслеживания состояния.
author: masnider
ms.topic: conceptual
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 6ea8fa6933052374721d8d205d5b07386c807ae2
ms.sourcegitcommit: a055089dd6195fde2555b27a84ae052b668a18c7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/26/2021
ms.locfileid: "98784602"
---
# <a name="reliable-services-lifecycle-overview"></a>Жизненный цикл Reliable Services
> [!div class="op_single_selector"]
> * [C# в Windows](service-fabric-reliable-services-lifecycle.md)
> * [Java в Linux](service-fabric-reliable-services-lifecycle-java.md)
>
>

Если речь идет о жизненных циклах служб Reliable Services в Azure Service Fabric, наиболее важны основные аспекты. Как правило, жизненный цикл состоит из следующих этапов.

- Во время запуска:
  - создаются службы;
  - службы могут создавать и возвращать ни одного или несколько прослушивателей;
  - все возвращаемые прослушиватели открываются, что разрешает взаимодействовать со службой;
  - вызывается метод **RunAsync** службы, позволяя службе выполнять длительные задания или фоновую работу.
- Во время завершения работы:
  - Токен отмены, переданный в **RunAsync** , отменяется, и прослушиватели закрываются.
  - после этого уничтожается сам объект службы.

Следует отметить некоторые моменты, связанные с точным порядком этих событий. Порядок событий может немного изменяться в зависимости от того, предусматривают ли Reliable Services отслеживание состояния. В случае со службами с отслеживанием состояния нужно иметь дело со сценарием переключения первичной реплики. Во время этой процедуры первичная роль передается другой реплике (или возвращается) без завершения работы службы. И, наконец, необходимо учитывать условия ошибок и сбоев.

## <a name="stateless-service-startup"></a>Запуск службы без отслеживания состояния
Жизненный цикл службы без отслеживания состояния прост. Ниже приведен порядок событий.

1. Создается служба.
2. Затем одновременно происходят две вещи:
    - Вызывается метод `StatelessService.CreateServiceInstanceListeners()` и открываются все возвращаемые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.
    - Вызывается метод службы `StatelessService.RunAsync()`.
3. Вызывается метод `StatelessService.OnOpenAsync()` службы, если он присутствует. Этот вызов представляет собой редко используемое переопределение, но оно доступно. В этот момент можно запустить расширенные задачи инициализации службы.

Важно помнить, что между вызовами методов для создания и открытия прослушивателей и **RunAsync** нет упорядоченности. Прослушиватели могут быть открыты перед запуском **RunAsync**. Аналогичным образом метод **RunAsync** можно вызвать перед открытием или созданием прослушивателей связи. Если синхронизация не требуется, она остается в качестве упражнения для разработчика. Ниже приведены некоторые распространенные решения.

  - Иногда прослушиватели не могут работать, пока не будут сформированы другие сведения или выполнены некоторые задачи. Для служб без отслеживания состояния, работа которых обычно может быть выполнена в других расположениях, например: 
    - в конструкторе службы;
    - во время вызова `CreateServiceInstanceListeners()`;
    - при создании самого прослушивателя.
  - Иногда код в **RunAsync** не запускается, пока прослушиватели открыты. В этом случае необходима дополнительная координация. Одним из распространенных решений является то, что в слушателях есть флаг, указывающий время завершения их работы. Затем этот флаг проверяется в **RunAsync**, прежде чем будет продолжена фактическая работа.

## <a name="stateless-service-shutdown"></a>Завершение работы службы без отслеживания состояния
Для завершения работы службы без отслеживания состояния те же операции выполняются в обратном порядке.

1. В параллельном режиме:
    - Закрываются все открытые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.
    - Токен отмены, переданный в `RunAsync()`, отменяется. В результате проверки свойства `IsCancellationRequested` токена отмены возвращается значение true, а при вызове метода `ThrowIfCancellationRequested` маркера возвращается `OperationCanceledException`.
2. После завершения `CloseAsync()` для каждого прослушивателя также завершается `RunAsync()` и вызывается метод `StatelessService.OnCloseAsync()` службы, если он присутствует.  OnCloseAsync вызывается, когда работу экземпляра службы без отслеживания состояния планируется корректно завершить. Это может произойти при обновлении кода службы, перемещении экземпляра службы в целях балансировки нагрузки или при обнаружении временной ошибки. Обычно `StatelessService.OnCloseAsync()` не переопределяется, но позволяет безопасно закрыть все ресурсы, остановить все фоновые задачи, завершить сохранение внешнего состояния или закрыть существующие подключения.
3. После выполнения метода `StatelessService.OnCloseAsync()` объект службы уничтожается.

## <a name="stateful-service-startup"></a>Запуск службы с отслеживанием состояния
Запуск службы с отслеживанием состояния имеет лишь несколько отличий по сравнению со службой без отслеживания состояния. Для запуска службы с отслеживанием состояния порядок событий выглядит следующим образом:

1. Создается служба.
2. вызывается метод `StatefulServiceBase.OnOpenAsync()`; Этот вызов редко переопределяется в службе.
3. Ниже приведены действия, которые выполняются параллельно.
    - Вызывается метод `StatefulServiceBase.CreateServiceReplicaListeners()`. 
      - Если служба является первичной, открываются все возвращенные прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.
      - Если служба является вторичной, то открываются только прослушиватели, помеченные как `ListenOnSecondary = true`. Открытые прослушиватели для вторичных служб используются реже.
    - Если сейчас служба является первичной, то вызывается метод `StatefulServiceBase.RunAsync()`.
4. После завершения всех вызовов `OpenAsync()` прослушивателя реплик и вызова `RunAsync()` вызывается `StatefulServiceBase.OnChangeRoleAsync()`. Этот вызов редко переопределяется в службе.

Как и в случае со службами без отслеживания состояния, между порядком, в котором прослушиватели создаются и открываются, а также вызовом **RunAsync** отсутствует координация. Если требуется координация, то решение будет во многом схожим. Есть лишь одно дополнение для службы с отслеживанием состояния. Предположим, что для вызовов, поступающих в прослушиватели связи, требуется наличие сведений в некоторых [надежных коллекциях](service-fabric-reliable-services-reliable-collections.md).

   > [!NOTE]  
   > Так как прослушиватели связи могут быть открыты до того, как надежные коллекции будут доступны для чтения или записи, и до начала **RunAsync** , требуется дополнительная координация. Простейшее и самое распространенное решение для прослушивателей связи — вернуть код ошибки, который клиент использует для повторного запроса.

## <a name="stateful-service-shutdown"></a>Завершение работы службы с отслеживанием состояния
Как и в случае со службами без отслеживания состояния, события жизненного цикла во время завершения работы совпадают с событиями во время запуска, но происходят в обратном порядке. При завершении работы службы с отслеживанием состояния происходят следующие события.

1. В параллельном режиме:
    - Закрываются все открытые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.
    - Токен отмены, переданный в `RunAsync()`, отменяется. В результате проверки свойства `IsCancellationRequested` токена отмены возвращается значение true, а при вызове метода `ThrowIfCancellationRequested` маркера возвращается `OperationCanceledException`.
2. Как только `CloseAsync()` завершается для каждого прослушивателя, также завершается `RunAsync()` и вызывается `StatefulServiceBase.OnChangeRoleAsync()` службы. Этот вызов редко переопределяется в службе.

   > [!NOTE]  
   > Если это первичная реплика, необходимо подождать завершения **RunAsync**.

3. После завершения метода `StatefulServiceBase.OnChangeRoleAsync()` вызывается метод `StatefulServiceBase.OnCloseAsync()`. Этот вызов представляет собой редко используемое переопределение, но оно доступно.
3. После выполнения метода `StatefulServiceBase.OnCloseAsync()` объект службы уничтожается.

## <a name="stateful-service-primary-swaps"></a>Переключения первичной реплики службы с отслеживанием состояния
Во время выполнения службы с отслеживанием состояния только первичные реплики этих служб с отслеживанием состояния открывают прослушиватели связи и вызываемый метод **RunAsync** . Вторичные реплики создаются, но не видят последующие вызовы. Пока выполняется служба с отслеживанием состояния, первичная реплика может измениться в результате сбоя или оптимизации балансировки кластера. Что это означает с точки зрения событий жизненного цикла, которые может видеть реплика? Поведение, которое видит реплика с отслеживанием состояния, зависит от того, что происходит во время переключения: понижение или повышение реплики.

### <a name="for-the-primary-thats-demoted"></a>При пониженной первичной реплике
Для пониженной первичной реплики Service Fabric требуется, чтобы эта реплика остановила обработку сообщений и выполнение любой фоновой работы. Это выглядит аналогично завершению работы службы. Отличие в том, что служба не уничтожается и не закрывается, так как остается вторичной. Вызываются следующие API.

1. В параллельном режиме:
    - Закрываются все открытые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.
    - Токен отмены, переданный в `RunAsync()`, отменяется. В результате проверки свойства `IsCancellationRequested` токена отмены возвращается значение true, а при вызове метода `ThrowIfCancellationRequested` маркера возвращается `OperationCanceledException`.
2. Как только `CloseAsync()` завершается для каждого прослушивателя, также завершается `RunAsync()` и вызывается `StatefulServiceBase.OnChangeRoleAsync()` службы. Этот вызов редко переопределяется в службе.

### <a name="for-the-secondary-thats-promoted"></a>При повышении уровня вторичной реплики
Аналогичным образом Service Fabric необходимо, чтобы вторичная реплика с повышенным уровнем начала ожидать передачи сообщений и запустила все фоновые задачи, которые необходимо выполнить. Эта процедура соответствует процессу создания службы за исключением того, что сама реплика уже существует. Вызываются следующие API.

1. В параллельном режиме:
    - Вызывается метод `StatefulServiceBase.CreateServiceReplicaListeners()` и открываются все возвращаемые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.
    - Вызывается метод службы `StatefulServiceBase.RunAsync()`.
2. После завершения всех вызовов `OpenAsync()` прослушивателя реплик и вызова `RunAsync()` вызывается `StatefulServiceBase.OnChangeRoleAsync()`. Этот вызов редко переопределяется в службе.

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a>Распространенные проблемы во время завершения работы службы с отслеживанием состояния и понижения уровня первичной реплики
Service Fabric изменяет первичную реплику службы с отслеживанием состояния по ряду причин. Наиболее распространенными являются [балансировка кластера](service-fabric-cluster-resource-manager-balancing.md) и [обновление приложения](service-fabric-application-upgrade.md). Во время этих операций (а также во время штатного завершения работы службы, т. е. как при ее удалении) очень важно, чтобы служба учитывала `CancellationToken`. 

Службы, которые не обрабатывают отмену аккуратно, могут вызывать несколько проблем. Эти операции выполняются медленно, так как Service Fabric ожидает корректную остановку служб. В конечном счете это может привести к сбоям обновлений из-за истечения времени ожидания и откату. Если не использовать токен отмены, это может также нарушить балансировку кластеров. Кластеры становятся несбалансированными, потому что узлы нагружаются, но реорганизация служб невозможна, так как их перемещение занимает слишком много времени. 

Так как это службы с отслеживанием состояния, то, скорее всего, они используют [надежные коллекции](service-fabric-reliable-services-reliable-collections.md). Когда в Service Fabric понижается уровень первичной реплики, то в первую очередь отменяется доступ на запись к базовому состоянию. Это приводит ко второму ряду проблем, которые могут повлиять на жизненный цикл службы. Коллекции возвращают исключения на основании времени и операции с репликой (перемещение или завершение работы). Эти исключения должны обрабатываться правильно. Исключения, вызванные Service Fabric, относятся к постоянным [( `FabricException` )](/dotnet/api/system.fabric.fabricexception) и временным [( `FabricTransientException` )](/dotnet/api/system.fabric.fabrictransientexception) категориям. Постоянные исключения должны быть зарегистрированы в журнале и порождены, тогда как для временных исключений возможен повтор породившей их операции в соответствии с логикой повтора.

Обработка исключений, которые поступают от `ReliableCollections`, в сочетании с событиями жизненного цикла службы является важной частью тестирования и проверки надежной службы. Перед развертыванием в рабочей среде рекомендуется запустить службу под нагрузкой во время выполнения обновлений и [хаотического тестирования](service-fabric-controlled-chaos.md). Эти простые действия помогут обеспечить правильную реализацию службы и обработку событий жизненного цикла.


## <a name="notes-on-the-service-lifecycle"></a>Примечания о жизненном цикле службы
  - Метод `RunAsync()` и вызовы `CreateServiceReplicaListeners/CreateServiceInstanceListeners` являются необязательны. В службе может использоваться один из них, оба или ни одного. Например, если служба выполняет всю работу в ответ на вызовы пользователя, реализовывать метод `RunAsync()` не нужно. Необходимы только прослушиватели связи и соответствующий код. Создание и возвращение прослушивателей связи является необязательным, так как у службы может быть только фоновая работа, поэтому достаточно реализовать `RunAsync()`.
  - Служба может успешно завершить `RunAsync()` и вернуться из него. Завершение не является состоянием сбоя. Завершение `RunAsync()` указывает на то, что фоновая работа службы выполнена. Для надежных служб с отслеживанием состояния `RunAsync()` вызывается снова, если уровень реплики понижен с первичной до вторичной, а затем обратно повышен до первичной.
  - Если служба выполняет выход из `RunAsync()`, порождая какое-либо непредвиденное исключение, это означает сбой. Объект службы завершает работу и появляется ошибка о работоспособности.
  - Несмотря на то, что возвращение этих методов не ограничивается по времени, вы не сможете записать никакие надежные коллекции, а значит, и выполнить какую-либо действительную задачу. После получения запроса на отмену рекомендуется возвращать методы как можно быстрее. Если служба не отвечает на такие вызовы API в течение приемлемого промежутка времени, Service Fabric может принудительно завершить работу службы. Обычно это происходит только во время обновления приложения или при удалении службы. По умолчанию время ожидания составляет 15 минут.
  - Сбои в пути `OnCloseAsync()` приводят к вызову `OnAbort()`, что является последней наилучшей возможностью для службы очистить и освободить все запрошенные ресурсы. Обычно такой вызов осуществляется при обнаружении на узле постоянной неисправности или когда платформа Service Fabric не может надежно управлять жизненным циклом экземпляра службы из-за внутренних сбоев.
  - `OnChangeRoleAsync()` вызывается, когда реплика службы с отслеживанием состояния меняет роль, например с первичной на вторичную, или наоборот. Основным репликам присваивается статус записи (им разрешено создавать и записывать надежные коллекции), а дополнительным — статус чтения (могут только читать из существующих надежных коллекций). Большинство операций службы с отслеживанием состояния выполняется в основной реплике. Вторичные реплики могут выполнять проверку, предусматривающую только чтение, создавать отчеты, выполнять интеллектуальный анализ данных, а также другие задания, доступные только для чтения.

## <a name="next-steps"></a>Дальнейшие действия
- [Обзор надежных служб](service-fabric-reliable-services-introduction.md)
- [Быстрый запуск Reliable Services](service-fabric-reliable-services-quick-start.md)
- [Реплики и экземпляры](service-fabric-concepts-replica-lifecycle.md)
