---
title: Обзор жизненного цикла субъекта Azure Service Fabric
description: Описание жизненного цикла Reliable Actors Service Fabric, сбора мусора и ручного удаления субъектов и их состояний.
ms.topic: conceptual
ms.date: 10/06/2017
ms.custom: devx-track-csharp
ms.openlocfilehash: 88db4bb2376cbc418d6954e274a18a6c18a280d1
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "96576049"
---
# <a name="actor-lifecycle-automatic-garbage-collection-and-manual-delete"></a>Жизненный цикл субъектов, автоматическая сборка мусора и удаление вручную
Субъект активируется при первом вызове любого из его методов. Субъект деактивируется, если он не используется в течение заданного периода времени (при этом среда выполнения субъектов собирает мусор). Субъект и его состояние можно также удалить вручную в любое время.

## <a name="actor-activation"></a>Активация субъекта
При активации субъекта происходит следующее:

* При поступлении вызова для субъекта, который еще не активен, создается новый субъект.
* Загружается состояние субъекта (если это субъект с отслеживанием состояния).
* Вызывается метод `OnActivateAsync` (C#) или `onActivateAsync` (Java) (он может быть переопределен в реализации субъекта).
* После этого субъект считается активным.

## <a name="actor-deactivation"></a>Деактивации субъекта
При деактивации субъекта происходит следующее:

* Если субъект не используется в течение некоторого периода времени, он удаляется из таблицы активных субъектов.
* Вызывается метод `OnDeactivateAsync` (C#) или `onDeactivateAsync` (Java) (он может быть переопределен в реализации субъекта). Это приводит к сбросу все таймеров для субъекта. Операции с субъектом, такие как изменение состояния, не должны вызываться из этого метода.

> [!TIP]
> Среда выполнения субъектов Service Fabric генерирует некоторые [события, связанные с активацией и деактивацией субъектов](service-fabric-reliable-actors-diagnostics.md#list-of-events-and-performance-counters). Они полезны при диагностике и мониторинге производительности.
>
>

### <a name="actor-garbage-collection"></a>Сборка мусора и субъекты
При деактивации субъекта ссылки на объект субъекта освобождаются и могут удаляться сборщиком мусора среды CLR или виртуальной машины Java в обычном режиме. Сборщик мусора удаляет только объект субъекта; он **не** удаляет состояние, сохраненное в диспетчере состояний субъектов. При следующей активации субъекта создается новый объект субъекта и восстанавливается его состояние.

Что считается "использованием" субъекта в контексте деактивации и сборки мусора?

* Получение вызова
* `IRemindable.ReceiveReminderAsync` (применимо только в том случае, если субъект использует напоминания).

> [!NOTE]
> Если субъект использует таймеры и выполняется обратный вызов по таймеру, он **не** считается "используемым".
>
>

Прежде чем перейти к подробному рассмотрению деактивации, важно определить два понятия:

* *Интервал сканирования*. Это интервал, с которым среда выполнения проверяет таблицу активных субъектов, чтобы определить, какие субъекты можно деактивировать и удалить во время сборки мусора. По умолчанию интервал равен 1 минуте.
* *Время ожидания простоя*. Это период времени, в течение которого субъект должен находиться в неиспользуемом состоянии (в состоянии простоя) до того, как он будет деактивирован и удален сборщиком мусора. По умолчанию это время равно 60 минутам.

Как правило, эти значения изменять не требуется. При необходимости этот период времени можно изменить, вызвав метод `ActorServiceSettings` при регистрации [службы субъектов](service-fabric-reliable-actors-platform.md):

```csharp
public class Program
{
    public static void Main(string[] args)
    {
        ActorRuntime.RegisterActorAsync<MyActor>((context, actorType) =>
                new ActorService(context, actorType,
                    settings:
                        new ActorServiceSettings()
                        {
                            ActorGarbageCollectionSettings =
                                new ActorGarbageCollectionSettings(10, 2)
                        }))
            .GetAwaiter()
            .GetResult();
    }
}
```

```Java
public class Program
{
    public static void main(String[] args)
    {
        ActorRuntime.registerActorAsync(
                MyActor.class,
                (context, actorTypeInfo) -> new FabricActorService(context, actorTypeInfo),
                timeout);
    }
}
```
Для каждого активного субъекта среда выполнения субъектов хранит информацию о времени, в течение которого он простаивает (не используется). Среда выполнения субъектов проверяет каждый из субъектов `ScanIntervalInSeconds` на наличие возможности сбора мусора и помечает ее в неактивном состоянии `IdleTimeoutInSeconds` .

При каждом использовании субъекта его время ожидания в состоянии простоя обнуляется. После этого субъект может быть удален сборщиком мусора только после бездействия в течение интервала времени, равного `IdleTimeoutInSeconds`. Считается, что субъект был использован, если метод вызван через интерфейс субъекта или если выполнен обратный вызов по напоминанию. **Не** считается, что субъект был использован, если выполняется обратный вызов по таймеру.

На следующей схеме показан жизненный цикл одного субъекта, демонстрирующий описанные принципы.

![Пример времени простоя][1]

В примере показано влияние вызова методов субъекта, напоминаний и таймеров на время жизни субъекта. Обратите внимание на следующие важные моменты:

* ScanInterval и IdleTimeout установлены в 5 и 10 соответственно. (Единицы не имеют значения, поскольку наша цель — лишь проиллюстрировать концепцию.)
* Поиск субъектов, которые нужно удалить во время сборки мусора, происходит при T = 0, 5, 10, 15, 20 и 25, так как интервал сканирования равен 5.
* Таймер срабатывает при T = 4, 8, 12, 16, 20 и 24, после чего выполняется обратный вызов. Это не влияет на время простоя субъекта.
* Вызов метода субъекта при T = 7 обнуляет время ожидания в состоянии простоя и откладывает удаление субъекта при сборке мусора.
* При T = 14 выполняется обратный вызов по напоминанию, что снова откладывает удаление субъекта при сборке мусора.
* На момент поиска объектов, которые можно удалить при сборке мусора, при T = 25 время простоя субъекта превышает заданное значение IdleTimeout (10) и субъект удаляется сборщиком мусора.

Субъект никогда не удаляется сборщиком мусора, если выполняется какой-либо из его методов, независимо от того, сколько времени занимает выполнение этого метода. Как упоминалось ранее, выполнение методов, определенных в интерфейсе субъекта, и обратных вызовов по напоминанию предотвращает сборку мусора, так как время простоя субъекта обнуляется. Выполнение обратных вызовов по таймеру не обнуляет время простоя. Однако сборка мусора для субъекта откладывается до завершения выполнения функции обратного вызова по таймеру.

## <a name="manually-deleting-actors-and-their-state"></a>Удаление субъектов и данных их состояния вручную
При удалении деактивированных субъектов удаляется только объект субъекта; из диспетчера состояний субъекта данные не удаляются. При повторной активации субъекта его данные снова становятся доступны в диспетчере состояний. Если субъекты, данные которых хранятся в диспетчере состояний, деактивируются и больше не активируются, может возникнуть необходимость в удалении связанных с ними данных.  Примеры удаления субъектов см. в статье [Удаление субъектов Reliable Actors и данных их состояния](service-fabric-reliable-actors-delete-actors.md).

## <a name="next-steps"></a>Дальнейшие действия
* [Таймеры и напоминания субъекта](service-fabric-reliable-actors-timers-reminders.md)
* [События субъекта](service-fabric-reliable-actors-events.md)
* [Повторный вход субъекта](service-fabric-reliable-actors-reentrancy.md)
* [Диагностика и мониторинг производительности в Reliable Actors](service-fabric-reliable-actors-diagnostics.md)
* [Справочная документация по API субъектов](/previous-versions/azure/dn971626(v=azure.100))
* [Пример кода на C#](https://github.com/Azure-Samples/service-fabric-dotnet-getting-started)
* [Пример кода Java](https://github.com/Azure-Samples/service-fabric-java-getting-started)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-lifecycle/garbage-collection.png
