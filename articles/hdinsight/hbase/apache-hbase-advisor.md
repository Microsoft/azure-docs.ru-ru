---
title: Оптимизация для рекомендаций советника по работе с кластерами
titleSuffix: Azure HDInsight
description: Оптимизируйте Apache HBase для рекомендаций по использованию советника по работе с кластерами в Azure HDInsight.
author: ramkrish86
ms.author: ramvasu
ms.service: hdinsight
ms.topic: conceptual
ms.date: 01/03/2021
ms.openlocfilehash: acb7a6aeb4084949be3b0ad40e770a414a13ab6d
ms.sourcegitcommit: 2f9f306fa5224595fa5f8ec6af498a0df4de08a8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/28/2021
ms.locfileid: "98943017"
---
# <a name="apache-hbase-advisories-in-azure-hdinsight"></a>Помощники по Apache HBase в Azure HDInsight

В этой статье описываются некоторые рекомендации, помогающие оптимизировать производительность Apache HBase в Azure HDInsight. 

## <a name="optimize-hbase-to-read-most-recently-written-data"></a>Оптимизация HBase для чтения последних записанных данных

Если ваш UseCase включает в себя чтение последних записанных данных из HBase, эти рекомендации помогут вам. Для обеспечения высокой производительности лучше всего обслуживать операции чтения HBase из memstore, а не из удаленного хранилища.

Рекомендации по запросам указывают на то, что для данного семейства столбцов в таблице > 75% операций чтения, которые поступают из memstore. Этот индикатор предполагает, что даже в том случае, если очистка выполняется в memstore, к которому необходим доступ к последнему файлу и который должен находиться в кэше. Данные сначала записываются в memstore, чтобы система обращается к последним данным. Существует вероятность того, что внутренние потоки очистки HBase обнаруживают, что заданный регион достиг размера 128M (по умолчанию) и может активировать сброс. Этот сценарий происходит даже в самых последних данных, которые были написаны, когда размер memstore 128M. Таким образом, для последующего чтения последних записей может потребоваться чтение файла, а не memstore. Поэтому лучше оптимизировать, что даже последние данные, которые недавно были сброшены, могут находиться в кэше.

Чтобы оптимизировать последние данные в кэше, рассмотрите следующие параметры конфигурации.

1. Задайте для параметра `hbase.rs.cacheblocksonwrite` значение `true`. Эта конфигурация по умолчанию в HDInsight HBase — `true` , поэтому убедитесь, что она не сброшена на `false` .

2. Увеличьте `hbase.hstore.compactionThreshold` значение, чтобы избежать запуска сжатия. По умолчанию это значение равно `3`. Вы можете увеличить его на более высокое значение, например `10` .

3. Если вы выполните шаг 2 и установите Компактионсрешолд, измените его `hbase.hstore.compaction.max` на более высокое значение `100` , а также увеличьте значение для параметра Конфигурация `hbase.hstore.blockingStoreFiles` на более высокое значение, например `300` .

4. Если вы уверены, что необходимо считывать только последние данные, установите `hbase.rs.cachecompactedblocksonwrite` для параметра Конфигурация значение **вкл**. Эта конфигурация сообщает системе, что даже в случае сжатия данные остаются в кэше. Конфигурации можно задать также на уровне семейства. 

   В оболочке HBase выполните следующую команду, чтобы задать `hbase.rs.cachecompactedblocksonwrite` конфигурацию:
   
   ```
   alter '<TableName>', {NAME => '<FamilyName>', CONFIGURATION => {'hbase.hstore.blockingStoreFiles' => '300'}}
   ```

5. Кэш блочных данных можно отключить для данного семейства в таблице. Убедитесь, что он включен **для семейств с** последними операциями чтения данных. По умолчанию блочный кэш включен для всех семейств в таблице. Если вы отключили кэш блоков для семейства и хотите включить его, используйте команду ALTER из оболочки HBase.

   Эти конфигурации помогают обеспечить доступность данных в кэше и то, что последние данные не подвергаются сжатию. Если срок жизни в вашем сценарии возможен, рассмотрите возможность использования сжатия с использованием многоуровневых дат. Дополнительные сведения см. в разделе [справочное руководство по Apache HBase: Дата многоуровневого сжатия](https://hbase.apache.org/book.html#ops.date.tiered)  

## <a name="optimize-the-flush-queue"></a>Оптимизация очереди на очистку

Эта рекомендация указывает, что для очистки HBase может потребоваться настройка. Текущая конфигурация для обработчиков очистки может быть недостаточно высокой для обработки трафика записи, что может привести к замедлению операций очистки.

В пользовательском интерфейсе сервера регионов Обратите внимание на увеличение размера очереди на запись после 100. Это пороговое значение указывает на то, что записи на диск замедляются, и может потребоваться настроить   `hbase.hstore.flusher.count` конфигурацию. Значение по умолчанию — 2. Убедитесь, что максимальное число потоков очистки не превышает 6.

Кроме того, ознакомьтесь с рекомендациями по настройке количества регионов. Если да, рекомендуем попробовать настройку региона, чтобы узнать, помогает ли он ускорить очистку. В противном случае настройка потоков очистки может помочь вам.

## <a name="region-count-tuning"></a>Настройка подсчета регионов

Рекомендации по настройке подсчета регионов указывают, что HBase заблокировал обновления, а число регионов может быть больше, чем оптимальный поддерживаемый размер кучи. Можно настроить размер кучи, размер memstore и число регионов.

В качестве примера сценария:

- Предположим, что размер кучи для сервера региона составляет 10 ГБ. По умолчанию `hbase.hregion.memstore.flush.size` используется значение `128M` . По умолчанию для объекта `hbase.regionserver.global.memstore.size` установлено значение `0.4`. Это означает, что из 10 ГБ выделяется 4 ГБ для memstore (глобально).

- Предположим, что существует равномерное распределение нагрузки на запись для всех регионов и при условии, что каждый регион растет до 128 МБ, а максимальное количество регионов в этой настройке — `32` регионы. Если на данном сервере региона настроено 32 регионов, система лучше не будет блокировать обновления.

- После установки этих параметров количество регионов составляет 100. Теперь глобальные memstore размером 4 ГБ разделяются в пределах 100 регионов. Так что фактически каждый регион получает только 40 МБ для memstore. Если операции записи являются однородными, система регулярно очищает и уменьшает размер < 40 МБ. Наличие большого количества потоков очистки может увеличить скорость записи на диск `hbase.hstore.flusher.count` .

Эти рекомендации означают, что было бы полезно пересчитать количество регионов на сервер, размер кучи и конфигурацию глобального memstore размера, а также настройку потоков очистки, чтобы избежать блокировки обновлений.

## <a name="compaction-queue-tuning"></a>Настройка очереди сжатия

Если размер очереди сжатия HBase увеличивается более 2000 и происходит периодически, можно увеличить количество потоков сжатия до большего значения.

Если для сжатия слишком много файлов, это может привести к увеличению потребления кучи, связанного с тем, как файлы взаимодействуют с файловой системой Azure. Поэтому лучше завершить сжатие как можно быстрее. Несколько раз в старых кластерах конфигурации сжатия, связанные с регулированием, могут привести к снижению скорости сжатия.

Проверьте конфигурации `hbase.hstore.compaction.throughput.lower.bound` и `hbase.hstore.compaction.throughput.higher.bound` . Если для них уже задано значение 50 млн и 100 млн, оставьте их как есть. Однако если вы настроили эти параметры на более низкое значение (что было в случае с более старыми кластерами), измените ограничения на 50 млн и 100 млн соответственно.

Конфигурации — `hbase.regionserver.thread.compaction.small` и `hbase.regionserver.thread.compaction.large` (значения по умолчанию — 1).
Ограничение максимального значения для этой конфигурации меньше 3.

## <a name="full-table-scan"></a>Полное сканирование таблицы

В полной версии рекомендаций по просмотру таблиц указано, что свыше 75% операций сканирования являются полными сканированием таблиц и регионов. Чтобы повысить производительность запросов, можно повторно перейти к методу, который код вызывает проверку. Примите во внимание следующие рекомендации.

* Задайте правильную строку начала и окончания для каждого сканирования.

* Используйте API **мултировранжефилтер** , чтобы выполнять запросы к различным диапазонам в одном вызове проверки. Дополнительные сведения см. в [документации по API мултировранжефилтер](https://hbase.apache.org/2.1/apidocs/org/apache/hadoop/hbase/filter/MultiRowRangeFilter.html).

* В тех случаях, когда требуется полная проверка таблицы или области, проверьте, есть ли возможность избежать использования кэша для этих запросов, чтобы другие запросы, использующие кэш, не проводили неактивные блоки. Чтобы проверки не использовали кэш, используйте API **сканирования** с параметром **сеткачинг (false)** в коде: 

   ```
   scan#setCaching(false)
   ```
   
## <a name="next-steps"></a>Дальнейшие действия

[Оптимизация Apache HBase с помощью Ambari](../optimize-hbase-ambari.md)
