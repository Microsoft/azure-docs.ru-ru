---
title: Performance tuning with result set caching (Настройка производительности с помощью упорядоченного кластеризованного индекса columnstore)
description: Рекомендации и соображения, которые следует знать при использовании упорядоченного кластеризованного индекса columnstore для повышения производительности запросов в выделенных пулах SQL.
services: synapse-analytics
author: XiaoyuMSFT
manager: craigg
ms.service: synapse-analytics
ms.topic: conceptual
ms.subservice: sql-dw
ms.date: 09/05/2019
ms.author: xiaoyul
ms.reviewer: nibruno; jrasnick
ms.custom: seo-lt-2019, azure-synapse
ms.openlocfilehash: afb6efcee2ad4f5cf25a411eed353ff2fc27d75c
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "96460783"
---
# <a name="performance-tuning-with-ordered-clustered-columnstore-index"></a>Performance tuning with result set caching (Настройка производительности с помощью упорядоченного кластеризованного индекса columnstore)  

Когда пользователи запрашивают таблицу columnstore в выделенном пуле SQL, оптимизатор проверяет минимальное и максимальное значения, хранящиеся в каждом сегменте.  Сегменты, находящиеся вне границ предиката запроса, не считываются с диска в память.  Запрос может повысить производительность, если количество сегментов для чтения и их общий размер невелики.   

## <a name="ordered-vs-non-ordered-clustered-columnstore-index"></a>Упорядоченный и неупорядоченный кластеризованный индекс columnstore

По умолчанию для каждой таблицы, созданной без параметра индекса, внутренний компонент (построитель индексов) создает на нем неупорядоченный кластеризованный индекс columnstore (CCI).  Данные в каждом столбце сжимаются в отдельный сегмент группы строк CCI.  Существуют метаданные для диапазона значений каждого сегмента, поэтому сегменты, находящиеся вне границ предиката запроса, не считываются с диска во время выполнения запроса.  CCI обеспечивает наивысший уровень сжатия данных и уменьшает размер сегментов для чтения, чтобы запросы могли выполняться быстрее. Однако поскольку построитель индексов не сортирует данные перед их сжатием в сегменты, могут возникать сегменты с перекрывающимися диапазонами значений, что приводит к тому, что запросы считывают больше сегментов с диска и занимают больше времени для завершения.  

При создании упорядоченного объекта CCI подсистема пула SQL сортирует существующие данные в памяти по ключам порядка, прежде чем построитель индексов сжимает их в сегменты индекса.  При использовании отсортированных данных перекрытие сегментов сокращается, позволяя запросам использовать более эффективное исключение сегментов и, таким образом, более высокую производительность, поскольку количество сегментов для чтения с диска меньше.  Если все данные могут быть отсортированы в памяти одновременно, перекрытие сегментов можно избежать.  В связи с большими таблицами в хранилищах данных этот сценарий не происходит часто.  

Чтобы проверить диапазоны сегментов для столбца, выполните следующую команду с именем таблицы и именем столбца:

```sql
SELECT o.name, pnp.index_id, 
cls.row_count, pnp.data_compression_desc, 
pnp.pdw_node_id, pnp.distribution_id, cls.segment_id, 
cls.column_id, 
cls.min_data_id, cls.max_data_id, 
cls.max_data_id-cls.min_data_id as difference
FROM sys.pdw_nodes_partitions AS pnp
   JOIN sys.pdw_nodes_tables AS Ntables ON pnp.object_id = NTables.object_id AND pnp.pdw_node_id = NTables.pdw_node_id
   JOIN sys.pdw_table_mappings AS Tmap  ON NTables.name = TMap.physical_name AND substring(TMap.physical_name,40, 10) = pnp.distribution_id
   JOIN sys.objects AS o ON TMap.object_id = o.object_id
   JOIN sys.pdw_nodes_column_store_segments AS cls ON pnp.partition_id = cls.partition_id AND pnp.distribution_id  = cls.distribution_id
JOIN sys.columns as cols ON o.object_id = cols.object_id AND cls.column_id = cols.column_id
WHERE o.name = '<Table Name>' and cols.name = '<Column Name>'  and TMap.physical_name  not like '%HdTable%'
ORDER BY o.name, pnp.distribution_id, cls.min_data_id 


```

> [!NOTE] 
> В упорядоченной таблице CCI новые данные, полученные в результате выполнения одного и того же пакета DML или операций загрузки данных, сортируются в пределах этого пакета, поэтому в таблице не существует глобальной сортировки по всем данным.  Пользователи могут перестроить упорядоченный объект CCI для сортировки всех данных в таблице.  В выделенном пуле SQL перестроение индекса columnstore является автономной операцией.  Для секционированной таблицы перестроение выполняется по одной секции за раз.  Данные в перестроенной секции находятся в автономном режиме и недоступны до завершения перестроения для этого раздела. 

## <a name="query-performance"></a>Производительность запросов

Увеличение производительности запроса от упорядоченного объекта CCI зависит от шаблонов запросов, размера данных, объема отсортированных данных, физической структуры сегментов, а также класса DWU и ресурсов, выбранных для выполнения запроса.  Прежде чем выбирать столбцы упорядочения при проектировании упорядоченной таблицы CCI, пользователям следует ознакомиться со всеми этими факторами.

Запросы со всеми этими шаблонами обычно выполняются быстрее с упорядоченным CCI.  
1. Запросы имеют предикаты равенства, неравенства или диапазона
1. Столбцы предиката и упорядоченные столбцы CCI одинаковы.  
1. Столбцы предиката используются в том же порядке, что и порядковый номер столбца в упорядоченных столбцах CCI.  
 
В этом примере в таблице T1 имеется кластеризованный индекс columnstore, упорядоченный в последовательности Col_C, Col_B и Col_A.

```sql

CREATE CLUSTERED COLUMNSTORE INDEX MyOrderedCCI ON  T1
ORDER (Col_C, Col_B, Col_A)

```

Производительность запроса 1 может быть больше от упорядоченного объекта CCI, чем в других трех запросах. 

```sql
-- Query #1: 

SELECT * FROM T1 WHERE Col_C = 'c' AND Col_B = 'b' AND Col_A = 'a';

-- Query #2

SELECT * FROM T1 WHERE Col_B = 'b' AND Col_C = 'c' AND Col_A = 'a';

-- Query #3
SELECT * FROM T1 WHERE Col_B = 'b' AND Col_A = 'a';

-- Query #4
SELECT * FROM T1 WHERE Col_A = 'a' AND Col_C = 'c';

```

## <a name="data-loading-performance"></a>Производительность загрузки данных

Производительность загрузки данных в упорядоченную таблицу CCI аналогична секционированной таблице.  Загрузка данных в упорядоченную таблицу CCI может занять больше времени, чем неупорядоченная таблица CCI, из-за операции сортировки данных, однако запросы могут выполняться быстрее с упорядоченным CCI.  

Ниже приведен пример сравнения производительности при загрузке данных в таблицы с разными схемами.

![Линейчатая диаграмма, показывающая сравнение производительности при загрузке данных в таблицы с разными схемами.](./media/performance-tuning-ordered-cci/cci-data-loading-performance.png)


Ниже приведен пример сравнения производительности между CCI и заказанным CCI.

![Performance_comparison_data_loading](./media/performance-tuning-ordered-cci/occi_query_performance.png)

 
## <a name="reduce-segment-overlapping"></a>Уменьшить перекрытие сегментов

Число перекрывающихся сегментов зависит от размера данных для сортировки, объема доступной памяти и параметра максимальной степени параллелизма (MAXDOP) во время упорядоченного создания CCI. Ниже приведены параметры для уменьшения перекрытия сегмента при создании упорядоченного CCI.

- Используйте класс ресурсов xlargerc в более высоком DWU, чтобы обеспечить больше памяти для сортировки данных перед тем, как построитель индексов сжимает данные в сегменты.  В сегменте индекса невозможно изменить физическое расположение данных.  Сортировка данных внутри сегмента или между сегментами отсутствует.  

- Создайте упорядоченный CCI с MAXDOP = 1.  Каждый поток, используемый для упорядочения создания CCI, работает с подмножеством данных и сортирует его локально.  Нет глобальной сортировки по данным, отсортированным различными потоками.  Использование параллельных потоков позволяет сократить время создания упорядоченного объекта CCI, но создаст более пересекающиеся сегменты, чем использование одного потока.  В настоящее время параметр MAXDOP поддерживается только при создании упорядоченной таблицы CCI с помощью CREATE TABLE в качестве команды SELECT.  Создание упорядоченного объекта CCI с помощью команд CREATE INDEX или CREATE TABLE не поддерживает параметр MAXDOP. Например,

```sql
CREATE TABLE Table1 WITH (DISTRIBUTION = HASH(c1), CLUSTERED COLUMNSTORE INDEX ORDER(c1) )
AS SELECT * FROM ExampleTable
OPTION (MAXDOP 1);
```

- Предварительно сортировать данные по ключам сортировки перед их загрузкой в таблицы.

Ниже приведен пример упорядоченного распределения таблицы CCI с нулевым сегментом, перекрывающимся по приведенным выше рекомендациям. Упорядоченная таблица CCI создается в базе данных DWU1000c с помощью CTAS из таблицы кучи размером 20 ГБ, использующей MAXDOP 1 и xlargerc.  CCI упорядочивается по столбцу BIGINT без повторяющихся значений.  

![Segment_No_Overlapping](./media/performance-tuning-ordered-cci/perfect-sorting-example.png)

## <a name="create-ordered-cci-on-large-tables"></a>Создание упорядоченного CCI в больших таблицах

Создание упорядоченного объекта CCI является автономной операцией.  Для таблиц без секций данные не будут доступны пользователям до тех пор, пока не завершится упорядоченный процесс создания CCI.   Для секционированных таблиц, так как подсистема создает упорядоченную секцию CCI по секциям, пользователи по-прежнему могут обращаться к данным в секциях, где упорядоченное создание CCI не выполняется.   С помощью этого параметра можно сократить время простоя при упорядоченном создании CCI в больших таблицах: 

1.    Создайте секции в целевой большой таблице (с именем Table_A).
2.    Создайте пустую упорядоченную таблицу CCI (которая называется Table_B) с той же таблицей и схемой секционирования, что и таблица A.
3.    Переключение одной секции из таблицы A в таблицу B.
4.    Выполните инструкцию ALTER INDEX <Ordered_CCI_Index> в <Table_B> Rebuild PARTITION = <Partition_ID> в таблице B, чтобы перестроить включенный в нее раздел.  
5.    Повторите шаги 3 и 4 для каждой секции в Table_A.
6.    После переключения всех секций с Table_A на Table_B и их перестроение, удаление Table_A и переименование Table_B в Table_A. 

## <a name="examples"></a>Примеры

**Конкретного. Для проверки упорядоченных столбцов и порядкового номера заказа:**

```sql
SELECT object_name(c.object_id) table_name, c.name column_name, i.column_store_order_ordinal 
FROM sys.index_columns i 
JOIN sys.columns c ON i.object_id = c.object_id AND c.column_id = i.column_id
WHERE column_store_order_ordinal <>0
```

**&. Чтобы изменить порядковый номер столбца, добавьте или удалите столбцы из списка Order или измените значение с CCI на упорядоченный CCI:**

```sql
CREATE CLUSTERED COLUMNSTORE INDEX InternetSales ON  InternetSales
ORDER (ProductKey, SalesAmount)
WITH (DROP_EXISTING = ON)
```

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные советы по разработке приведены в [обзоре разработки](sql-data-warehouse-overview-develop.md).
