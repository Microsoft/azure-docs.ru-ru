---
title: Функции машинного обучения с LUIS
description: Свойства добавляются в языковую модель, чтобы предоставить указания о принципах распознавания входных данных, которые требуется пометить или классифицировать.
ms.service: cognitive-services
ms.subservice: language-understanding
ms.topic: conceptual
ms.date: 09/22/2020
ms.openlocfilehash: da85abdff3d1022659f2d4e83fd14c5ae6003fc9
ms.sourcegitcommit: 867cb1b7a1f3a1f0b427282c648d411d0ca4f81f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "100546063"
---
# <a name="machine-learning-features"></a>Функции машинного обучения

В машинном обучении *функция*   — это отличительная черта или атрибут данных, которые отслеживает система, и рассказывается о них.

Функции машинного обучения предоставляют LUIS важные подсказки для поиска вещей, которые отличают концепцию. Они являются указаниями, которые LUIS могут использовать, но не являются жесткими правилами. LUIS использует эти указания в сочетании с метками для поиска данных.

Функцию можно описать как функцию, например f (x) = y. В примере utterance функция указывает, где искать отличительные признаки. Используйте эти сведения для создания схемы.

## <a name="types-of-features"></a>Типы функций

Функции являются обязательной частью структуры схемы. LUIS поддерживает как функции списки и модели фраз:

* Функция списка фраз
* Модель (цель или сущность) как функция

## <a name="find-features-in-your-example-utterances"></a>Найдите компоненты в вашем примере фразы продолжительностью

Поскольку LUIS является приложением на основе языка, эти функции основаны на тексте. Выберите текст, указывающий признаку, который необходимо различать. Для LUIS наименьшей единицей является *маркер*. Для английского языка маркер представляет собой непрерывный диапазон букв и цифр, не содержащий пробелов или знаков препинания.

Поскольку пробелы и знаки препинания не являются маркерами, сосредоточьтесь на тексте, который можно использовать в качестве функций. Не забывайте включать в себя разновидности слов, например:

* множественные формы
* командные времена
* сокращения;
* опечатки и опечатки

Определить, является ли текст, так как он отличает признак, должен:

* Совпадение с точным словом или фразой: рекомендуется добавить сущность регулярного выражения или сущность списка в качестве функции в сущность или намерение.
* Совпадение с известными понятиями, такими как даты, время или имена людей: использовать предварительно созданную сущность в качестве функции для сущности или намерения.
* Узнайте о новых примерах с течением времени: Используйте список фраз с примерами концепции в качестве функции для сущности или намерения.

## <a name="create-a-phrase-list-for-a-concept"></a>Создание списка фраз для концепции

Список фраз — это список слов или фраз, описывающих концепцию. Список фраз применяется в качестве совпадения без учета регистра на уровне токена.

При добавлении списка фраз можно задать эту функцию как **[глобальную](#global-features)**. Глобальный компонент применяется ко всему приложению.

### <a name="when-to-use-a-phrase-list"></a>Когда следует использовать список фраз

Используйте список фраз, если требуется, чтобы приложение LUIS обобщать и определяло новые элементы для концепции. Списки фраз подобны словарям, относящимся к домену. Они улучшают качество понимания целей и сущностей.

### <a name="how-to-use-a-phrase-list"></a>Использование списка фраз

С помощью списка фраз LUIS рассматривает контекст и обобщение, чтобы определить элементы, аналогичные, но не имеющие точного текста. Выполните следующие действия, чтобы использовать список фраз.

1. Начните с сущности машинного обучения:
    1. Добавьте пример фразы продолжительностью.
    1. Метка с сущностью машинного обучения.
1. Добавить список фраз:
    1. Добавьте слова со сходным значением. Не добавляйте все возможные слова или фразы. Вместо этого добавьте несколько слов или фраз за раз. Затем переучить и опубликуйте.
    1. Проверьте и добавьте предлагаемые слова.

### <a name="a-typical-scenario-for-a-phrase-list"></a>Типичный сценарий для списка фраз

Типичным сценарием для списка фраз является увеличение слов, относящихся к определенной идее.

Медицинские термины — хороший пример слов, которым может потребоваться список фраз для повышения их значимости. Эти термины могут иметь определенные физические, химические, серапеутик или абстрактные значения. LUIS не знает, что термины важны для предметной области, без списка фраз.

Для извлечения медицинских терминов:

1. Создайте пример фразы продолжительностью и пометка медицинских терминов в этих фразы продолжительностьюах.
2. Создайте список фраз с примерами терминов внутри предметной области. Этот список фраз должен включать в себя фактический термин с меткой и другие термины, описывающие ту же концепцию.
3. Добавьте список фраз в сущность или подсущность, которая извлекает концепцию, используемую в списке фраз. Наиболее распространенный сценарий — это компонент (дочерний) сущности машинного обучения. Если список фраз должен быть применен ко всем объектам или сущностям, пометьте список фраз как список глобальных фраз. Флаг **енабледфораллмоделс** управляет этой областью модели в API.

### <a name="token-matches-for-a-phrase-list"></a>Соответствие токенов для списка фраз

Список фраз всегда применяется на уровне токена. В следующей таблице показано, как список фраз, имеющий слово **Анна** , применяется к вариациям одних и тех же символов в указанном порядке.


| Вариант токена **Анна** | Совпадение списка фраз при обнаружении токена |
|--------------------------|---------------------------------------|
| **Петр**<br>**Петр**<br>           | Да — токен — **Анна**                  |
| **Петр**                    | Да — токен — **Анна**                  |
| **Anne**                     | Нет-токен **Anne**                  |

<a name="how-to-use-phrase-lists"></a>
<a name="how-to-use-a-phrase-lists"></a>
<a name="phrase-lists-help-identify-simple-exchangeable-entities"></a>

## <a name="a-model-as-a-feature-helps-another-model"></a>Модель в качестве функции помогает другой модели

Модель (намерение или сущность) можно добавить в качестве функции в другую модель (цель или сущность). Добавляя существующую цель или сущность в качестве функции, вы добавляете четко определенную концепцию с помеченными примерами.

При добавлении модели в качестве функции можно задать эту функцию следующим образом:
* **[Обязательный](#required-features)**. Необходимо найти необходимый компонент, чтобы модель возвращалась из конечной точки прогнозирования.
* **[Глобальный](#global-features)**. Глобальный компонент применяется ко всему приложению.

### <a name="when-to-use-an-entity-as-a-feature-to-an-intent"></a>Использование сущности в качестве функции для намерения

Добавьте сущность в качестве функции к намерениям, если обнаружение этой сущности имеет значительный смысл.

Например, если целью является резервирование рейса, например **букфлигхт**, и сущность представляет собой информацию о билетах (например, число рабочих мест, источник и назначение), то поиск сущности «билет-информация» должен добавить значительный вес к прогнозу цели **букфлигхт** .

### <a name="when-to-use-an-entity-as-a-feature-to-another-entity"></a>Когда следует использовать сущность в качестве функции для другой сущности

Сущность (A) должна быть добавлена в качестве функции в другую сущность (B), если обнаружение этой сущности (A) является значимым для прогноза сущности (B).

Например, если сущность «адрес доставки» содержится в подобъекте «улица-адрес», то поиск подсущности «Улица адреса» добавляет значительный вес к прогнозу для сущности «адрес доставки».

* Адрес доставки (сущность машинного обучения):

    * Номер улицы (подсущность)
    * Почтовый адрес (подсущность)
    * Город (подсущность)
    * Штат или провинция (подсущность)
    * Страна или регион (подсущность)
    * Почтовый индекс (подсущность)

## <a name="nested-subentities-with-features"></a>Вложенные подсущности с компонентами

Подсущность машинного обучения указывает, что концепция существует в родительской сущности. Родителем может быть другая подсущность или верхняя сущность. Значение вложенной сущности выступает в качестве функции к родительскому элементу.

Подсущность может содержать как список фраз, так и модель (другую сущность) в качестве функции.

Если в подсущность есть список фраз, она увеличивает словарь концепции, но не добавляет никаких сведений в ответ JSON прогноза.

Если подсущность имеет функцию другой сущности, ответ JSON включает извлеченные данные этой сущности.


## <a name="required-features"></a>Требуемые компоненты

Необходимо найти необходимый компонент, чтобы модель возвращалась из конечной точки прогнозирования. Используйте требуемую функцию, если известно, что входящие данные должны соответствовать этой функции.

Если текст utterance не соответствует требуемой функции, он не будет извлечен.

Для обязательной функции используется сущность, не относящаяся к машинному обучению:

* Сущность регулярного выражения
* Сущность списка
* Предварительно созданная сущность

Если вы уверены в том, что модель будет найдена в данных, установите эту функцию в соответствии с требованиями. Обязательный компонент не возвращает ничего, если он не найден.

Продолжение работы с примером адреса доставки:

Адрес доставки (сущность, полученная с компьютера)

 * Номер улицы (подсущность)
 * Почтовый адрес (подсущность)
 * Название улицы (подсущность)
 * Город (подсущность)
 * Штат или провинция (подсущность)
 * Страна или регион (подсущность)
 * Почтовый индекс (подсущность)

### <a name="required-feature-using-prebuilt-entities"></a>Обязательный компонент с использованием предварительно созданных сущностей

Предварительно созданные сущности, такие как город, штат и страна или регион, обычно являются закрытым набором списков, то есть они не меняются со временем. Эти сущности могут иметь соответствующие Рекомендуемые функции, и эти функции могут быть помечены как обязательные. Однако `isRequired` флаг связан только с той сущностью, которой он назначен, и не влияет на иерархию. Если предварительно созданная функция подчиненных сущностей не найдена, это не повлияет на обнаружение и возврат родительской сущности.

В качестве примера обязательного компонента следует рассмотреть возможность обнаружения адресов. Можно посчитать, что номер улицы должен быть обязательным. Это позволит пользователю ввести "1 Microsoft Way" или "один Microsoft Way", и оба будут разрешаться в цифру "1" для подсущности номера улицы. Дополнительные сведения см. в статье предварительно [созданная сущность ](luis-reference-prebuilt-entities.md) .

### <a name="required-feature-using-list-entities"></a>Обязательный компонент с использованием списка сущностей

[Сущность списка](reference-entity-list.md) используется как Список канонических имен вместе с их синонимами. Если utterance не содержит канонического имени или синонима, то в качестве обязательной функции эта сущность не возвращается в рамках конечной точки прогнозирования.

Предположим, что ваша компания поставляется только с ограниченным набором стран или регионов. Можно создать сущность списка, которая включает несколько способов ссылки на страну или регион для клиента. Если LUIS не находит точное совпадение в тексте utterance, то сущность (которая имеет требуемую функцию сущности List) не возвращается в прогнозе.

|Каноническое имя|Синонимы|
|--|--|
|США|США<br>США<br>США<br>США<br>0|

Клиентское приложение, например робот чата, может задать вопрос для получения дальнейших вопросов. Это помогает клиенту понять, что выбор страны или региона ограничен и является *обязательным*.

### <a name="required-feature-using-regular-expression-entities"></a>Обязательный компонент с использованием сущностей регулярных выражений

[Сущность регулярного выражения](reference-entity-regular-expression.md) , используемая в качестве обязательной функции, предоставляет широкие возможности для поиска текста.

В примере адреса доставки можно создать регулярное выражение, которое фиксирует правила синтаксиса почтовых индексов страны или региона.

## <a name="global-features"></a>Глобальные функции

Хотя наиболее распространенным применением является применение функции к конкретной модели, эту функцию можно настроить как **глобальную функцию** , чтобы применить ее ко всему приложению.

Чаще всего глобальная функция используется для добавления дополнительного словаря в приложение. Например, если клиенты используют основной язык, но предполагается, что они смогут использовать другой язык в рамках одного utterance, можно добавить функцию, включающую слова из дополнительного языка.

Так как пользователь предполагает использовать дополнительный язык в любой цели или сущности, добавьте слова из дополнительного языка в список фраз. Настройте список фраз как глобальный компонент.

## <a name="combine-features-for-added-benefit"></a>Объединение функций для дополнительного преимущества

Для описания характеристик или концепции можно использовать более одной функции. Общая пара заключается в использовании:

* Функция списка фраз. в качестве функций для одной и той же модели можно использовать несколько списков фраз.
* Модель в качестве компонента: предварительно [созданная сущность](luis-reference-prebuilt-entities.md), [сущность регулярного выражения](reference-entity-regular-expression.md), [сущность List](reference-entity-list.md). 

### <a name="example-ticket-booking-entity-features-for-a-travel-app"></a>Пример. функции сущностей для бронирования билетов для приложения в командировке  

В качестве базового примера рассмотрим приложение для резервирования рейса с _намерением_ зарезервированного рейса и _сущностью_ для резервирования билетов. Сущность резервирования билетов захватывает информацию, чтобы зарегистрировать билет на самолет в системе резервирования. 

Сущность машинного обучения для билета-Book содержит два вложенных объекта для захвата источника и назначения. Эти компоненты необходимо добавить в каждую подсущность, а не в сущность верхнего уровня.

:::image type="content" source="media/luis-concept-features/ticket-booking-entity.png" alt-text="Схема сущности тиккетбукинг":::

Сущность для резервирования билетов — это сущность машинного обучения с вложенными сущностями, включая _источник_ и _назначение_. Эти вложенные сущности указывают географическое расположение. Чтобы извлечь расположения и отличать _источник_ и _назначение_, каждая подсущность должна иметь функции.

|Type|Исходная подсущность |Целевая подсущность|
|--|--|--|
|Модель как функция|[geographyV2](luis-reference-prebuilt-geographyv2.md?tabs=V3) предварительно созданная сущность|[geographyV2](luis-reference-prebuilt-geographyv2.md?tabs=V3) предварительно созданная сущность|
|Список фраз|**Слова происхождения**: `start at` , `begin from` , `leave`|**Целевые слова**: `to` , `arrive` , `land at` , `go` , `going` , `stay` , `heading`|
|Список фраз|Коды аэропорта — один и тот же список для источника и назначения|Коды аэропорта — один и тот же список для источника и назначения|
|Список фраз|Имена в аэропорту — один и тот же список для источника и назначения|Коды аэропорта — один и тот же список для источника и назначения|

Если предполагается, что люди используют коды аэропорта и наименования аэропорта, то у LUIS должны быть списки фраз, в которых используются оба типа фраз. Коды аэропорта могут быть более распространенными при вводе текста в чат-бот, в то время как имена в аэропортах могут быть более распространенными при разговорном разговоре, например чат-бот с поддержкой речи.

Сведения о сопоставлении функций возвращаются только для моделей, а не для списков фраз, поскольку в JSON прогнозирования возвращаются только модели.

#### <a name="ticket-booking-labeling-in-the-intent"></a>Создание меток при резервировании билетов в намерении

После создания сущности машинного обучения необходимо добавить пример фразы продолжительностью к намерению и пометить родительскую сущность и все вложенные сущности.

Для примера резервирования билетов помечайте пример фразы продолжительностью в намерении с помощью `TicketBooking` сущности и всех вложенных сущностей в тексте.

:::image type="content" source="media/luis-concept-features/intent-example-utterances-machine-learning-entity.png" alt-text="Добавление меток к примеру речевого фрагмента":::

### <a name="example-pizza-ordering-app"></a>Пример: приложение заказа пиццы

Во втором примере рассмотрим приложение для ресторана на пиццу, которое получает заказы на пиццу, включая сведения о типе пиццы, который пользователь упорядочивает. Если возможно, для завершения обработки заказа необходимо извлечь все сведения о пицце.

Сущность машинного обучения в этом примере более сложена с вложенными подсущностями, списками фраз, предварительно созданными сущностями и пользовательскими сущностями.

:::image type="content" source="media/luis-concept-features/pizza-order-entity.png" alt-text="Схема сущности заказа пиццы":::

В этом примере используются функции на уровне подсущностей и дочернего элемента уровня подсущностей. Уровень, который получает список фраз или модель в качестве функции, является важной частью структуры сущности.

В то время как вложенные сущности могут иметь множество списков фраз в качестве функций, помогающих обнаружить сущность, каждая подсущность имеет только одну модель в качестве функции. В этом [приложении пиццы](https://github.com/Azure/pizza_luis_bot/blob/master/CognitiveModels/MicrosoftPizza.json)эти модели в основном перечислены.

:::image type="content" source="media/luis-concept-features/intent-example-utterances-machine-learning-entity-pizza.png" alt-text="Цель заказа пиццы с помеченным примером фразы продолжительностью":::

Правильно помеченный пример фразы продолжительностью отображает способ отображения вложенных сущностей. 


## <a name="best-practices"></a>Рекомендации

Ознакомьтесь [с рекомендациями](luis-concept-best-practices.md).

## <a name="next-steps"></a>Дальнейшие действия

* [Расширьте](schema-change-prediction-runtime.md) модели приложений в среде выполнения прогнозирования.
* Дополнительные сведения о добавлении компонентов в приложение LUIS см. в разделе [Добавление компонентов](luis-how-to-add-features.md) .
