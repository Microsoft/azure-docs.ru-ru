---
title: Настройка приложений Python в Linux
description: Узнайте, как с помощью портала Azure и Azure CLI настроить контейнер Python для выполнения веб-приложений.
ms.topic: quickstart
ms.date: 02/01/2021
ms.reviewer: astay; kraigb
ms.custom: mvc, seodec18, devx-track-python, devx-track-azurecli
ms.openlocfilehash: cfbbb7064fcadc06714b237066bb6a009246baac
ms.sourcegitcommit: c27a20b278f2ac758447418ea4c8c61e27927d6a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/03/2021
ms.locfileid: "101709093"
---
# <a name="configure-a-linux-python-app-for-azure-app-service"></a>Настройка приложения Python в Linux для Службы приложений Azure

В этой статье описывается, как [Служба приложений Azure](overview.md) запускает приложения Python, как перенести существующие приложения в Azure, а также как настроить поведение Службы приложений при необходимости. Приложения Python нужно развертывать со всеми необходимыми модулями [pip](https://pypi.org/project/pip/).

Механизм развертывания Службы приложений автоматически активирует виртуальное окружение и запускает команду `pip install -r requirements.txt` при развертывании [репозитория Git](deploy-local-git.md) или [ZIP-пакета](deploy-zip.md).

Это руководство содержит основные понятия и инструкции для разработчиков Python, которые используют встроенный контейнер Linux в Службе приложений. Если вы раньше не использовали Службу приложений Azure, сначала ознакомьтесь с [кратким руководством по Python](quickstart-python.md) и [учебником по использованию Python с PostgreSQL](tutorial-python-postgresql-app.md).

Для настройки можно использовать [портал Azure](https://portal.azure.com) или Azure CLI.

- На **портале Azure** используйте страницу **Параметры** > **Конфигурация**, как описано в статье [Настройка приложения Службы приложений на портале Azure](configure-common.md).

- В **Azure CLI** можно действовать двумя способами:

    - выполнять команды в [Azure Cloud Shell](../cloud-shell/overview.md);
    - запустить выполнение команд локально, установив последнюю версию [Azure CLI](/cli/azure/install-azure-cli), а затем войти в Azure с помощью команды [az login](/cli/azure/reference-index#az-login).
    
> [!NOTE]
> Сейчас для запуска приложения Python в Службе приложений рекомендуется использовать Linux. Возможности использования Windows описаны в статье [Работа с Python в Службе приложений Azure (Windows)](/visualstudio/python/managing-python-on-azure-app-service).

## <a name="configure-python-version"></a>Настройка версии Python

- **Портал Azure.** Воспользуйтесь вкладкой **Общие параметры** на странице **Конфигурация**, как описано в разделе [Настройка общих параметров](configure-common.md#configure-general-settings) для контейнеров Linux.

- **Azure CLI.**

    -  Отобразите текущую версию Python с помощью команды [az webapp config show](/cli/azure/webapp/config#az_webapp_config_show).
    
        ```azurecli
        az webapp config show --resource-group <resource-group-name> --name <app-name> --query linuxFxVersion
        ```
        
        Замените `<resource-group-name>` и `<app-name>` именами, подходящими для вашего веб-приложения.
    
    - Задайте версию Python с помощью команды [az webapp config set](/cli/azure/webapp/config#az_webapp_config_set).
        
        ```azurecli
        az webapp config set --resource-group <resource-group-name> --name <app-name> --linux-fx-version "PYTHON|3.7"
        ```
    
    - Отобразите все версии Python, поддерживаемые в Службе приложений Azure, с помощью команды [az webapp list-runtimes](/cli/azure/webapp#az_webapp_list_runtimes).
    
        ```azurecli
        az webapp list-runtimes --linux | grep PYTHON
        ```
    
Вы можете запустить неподдерживаемую версию Python, выполнив сборку собственного образа контейнера. Дополнительные сведения см. в статье об [использовании пользовательского образа Docker](tutorial-custom-container.md?pivots=container-linux).

<!-- <a> element here to preserve external links-->
<a name="access-environment-variables"></a>

## <a name="customize-build-automation"></a>Настройка автоматизации сборки

При развертывании приложения с помощью пакетов Git или ZIP система сборки Службы приложений, именуемая Oryx, выполняет следующие действия:

1. Запускает пользовательский скрипт предварительной сборки, если он задан с помощью параметра `PRE_BUILD_COMMAND`. (Этот скрипт может вызывать другие скрипты Python и Node.js, команды pip и npm, а также YARN и прочие средства на основе Node, например `yarn install` и `yarn build`.)

1. Выполните `pip install -r requirements.txt`. В корневой папке проекта должен присутствовать файл *requirements.txt*. В противном случае в процессе сборки будет выведено сообщение об ошибке: Could not find setup.py or requirements.txt; Not running pip install (Не удалось найти setup.py или requirements.txt. Не запущена установка pip).

1. Если *manage.py* находится в корне репозитория (что характерно для приложения Django), запускает *manage.py collectstatic*. Однако если для параметра `DISABLE_COLLECTSTATIC` задано значение `true`, этот шаг пропускается.

1. Запускает пользовательский скрипт последующей сборки, если он задан с помощью параметра `POST_BUILD_COMMAND`. (Этот скрипт также может вызывать другие скрипты Python и Node.js, команды pip и npm и средства на основе Node.)

По умолчанию параметры `PRE_BUILD_COMMAND`, `POST_BUILD_COMMAND` и `DISABLE_COLLECTSTATIC` пусты. 

- Чтобы отключить выполнение collectstatic при создании приложений Django, установите для параметра `DISABLE_COLLECTSTATIC` значение true.

- Чтобы выполнить команды перед сборкой, включите в параметр `PRE_BUILD_COMMAND` такую команду, как `echo Pre-build command`, или путь к файлу скрипта относительно корневого каталога проекта, например `scripts/prebuild.sh`. Во всех командах должны использоваться относительные пути к корневой папке проекта.

- Чтобы выполнить команды после сборки, включите в параметр `POST_BUILD_COMMAND` такую команду, как `echo Post-build command`, или путь к файлу скрипта относительно корневого каталога проекта, например `scripts/postbuild.sh`. Во всех командах должны использоваться относительные пути к корневой папке проекта.

Дополнительные параметры для настройки автоматизации сборки см. в статье [Конфигурация Oryx](https://github.com/microsoft/Oryx/blob/master/doc/configuration.md). 

Доступ к журналам сборки и развертывания описан в разделе [Доступ к журналам развертывания](#access-deployment-logs).

Дополнительные сведения о том, как Служба приложений выполняет и создает приложения Python в Linux, см. в статье о том, как [Oryx выявляет и создает приложения Python](https://github.com/microsoft/Oryx/blob/master/doc/runtimes/python.md).

> [!NOTE]
> Параметры `PRE_BUILD_SCRIPT_PATH` и `POST_BUILD_SCRIPT_PATH` идентичны `PRE_BUILD_COMMAND` и `POST_BUILD_COMMAND` и поддерживаются из соображений совместимости с прежними версиями.
> 
> Если параметр с именем `SCM_DO_BUILD_DURING_DEPLOYMENT` содержит значение `true` или 1, он запускает сборку в Oryx во время развертывания. Этот параметр имеет значение true при развертывании с помощью Git, команды Azure CLI, `az webapp up` и Visual Studio Code.

> [!NOTE]
> Во всех скриптах, выполняемых до и после сборки, следует всегда использовать относительные пути, поскольку контейнер сборки, в котором выполняется Oryx, отличается от контейнера среды выполнения, в котором выполняется приложение. Никогда не полагайтесь на точное размещение папки проекта приложения в контейнере (например, размещение в папке *site/wwwroot*).

## <a name="migrate-existing-applications-to-azure"></a>Миграция существующих приложений в Azure

Существующие веб-приложения можно повторно развернуть в Azure следующим образом:

1. **Исходный репозиторий**. Сохраните исходный код в подходящем репозитории, например GitHub. Позже при выполнении этого процесса это позволит настроить непрерывное развертывание.
    1. Файл *requirements.txt* должен находиться в корне репозитория, чтобы Служба приложений автоматически устанавливала необходимые пакеты.    

1. **База данных:**  — Если приложение зависит от базы данных, подготовьте необходимые ресурсы в Azure. См. [Учебник. Развертывание веб-приложения Django с помощью PostgreSQL](tutorial-python-postgresql-app.md#3-create-postgres-database-in-azure) с примером в разделе о создании базы данных.

1. **Ресурсы Службы приложений**. Создайте группу ресурсов, план и веб-приложение службы приложений для размещения приложения. Это можно сделать, выполнив начальное развертывание кода с помощью команды Azure CLI `az webapp up`, как показано в [учебнике по развертыванию веб-приложения Django с помощью PostgreSQL](tutorial-python-postgresql-app.md#4-deploy-the-code-to-azure-app-service) в разделе "Развертывание кода в Службе приложений Azure". Замените имена группы ресурсов, плана службы приложений и веб-приложения подходящими именами для вашего приложения.

1. **Переменные среды**. Если для приложения необходимы переменные среды, создайте эквивалентные [параметры приложения Службы приложений](configure-common.md#configure-app-settings). Эти параметры Службы приложений отображаются в коде в виде переменных среды, как описано в разделе [Доступ к параметрам приложения в виде переменных среды](#access-app-settings-as-environment-variables).
    - Эти параметры, например, часто управляют подключением к базе данных, как показано в [учебнике по развертыванию веб-приложения Django с помощью PostgreSQL](tutorial-python-postgresql-app.md#42-configure-environment-variables-to-connect-the-database) в разделе "Настройка переменных среды для подключения к базе данных".
    - Сведения об определенных параметрах для конкретных приложений Django см. в разделе [Параметры рабочей среды для приложений Django](#production-settings-for-django-apps).

1. **Запуск приложения**. Ознакомьтесь с разделом [Процесс запуска контейнера](#container-startup-process) далее в этой статье, чтобы понять, как Служба приложений пытается запустить приложение. По умолчанию Служба приложений использует веб-сервер Gunicorn, который должен найти объект приложения или папку *wsgi.py*. При необходимости можно [настроить команду запуска](#customize-startup-command).

1. **Непрерывное развертывание**. Настройте непрерывное развертывание. Если вы используете развертывание Azure Pipelines или Kudu, ознакомьтесь со статьей [Непрерывное развертывание в Службе приложений Azure](deploy-continuous-deployment.md). Если вы используете GitHub Actions, ознакомьтесь со статьей [Развертывание в Службе приложений с помощью GitHub Actions](deploy-github-actions.md).

1. **Настраиваемые действия**. Для выполнения действий (например, перенос базы данных Django) в контейнере Службы приложений, в котором размещено приложение, [подключитесь к контейнеру по протоколу SSH](configure-linux-open-ssh-session.md). Пример выполнения переноса базы данных Django см. в [учебнике по развертыванию веб-приложения Django с помощью PostgreSQL в разделе "Перенос базы данных"](tutorial-python-postgresql-app.md#43-run-django-database-migrations).
    - При использовании непрерывного развертывания эти действия можно выполнить с помощью команд после сборки, как описано выше в разделе [Настройка автоматизации сборки](#customize-build-automation).

Выполнив действия, вы сможете зафиксировать изменения в исходном репозитории и автоматически развернуть эти обновления в Службе приложений.

### <a name="production-settings-for-django-apps"></a>Параметры рабочей среды для приложений Django

В такой рабочей среде, как Служба приложений Azure, для приложений Django необходимо придерживаться [контрольного списка развертывания](https://docs.djangoproject.com/en/3.1/howto/deployment/checklist/) (djangoproject.com).

В следующей таблице описаны параметры рабочей среды, относящиеся к Azure. Эти параметры определяются в файле *setting.py* приложения.

| Настройка Django | Инструкции для Azure |
| --- | --- |
| `SECRET_KEY` | Сохраните значение в настройках Службы приложений, как описано в разделе [Доступ к параметрам приложения в виде переменных среды](#access-app-settings-as-environment-variables). Можно также [сохранить значение в качестве секрета в Azure Key Vault](../key-vault/secrets/quick-create-python.md). |
| `DEBUG` | Создайте параметр `DEBUG` в Службе приложений со значением 0 (false), а затем загрузите значение как переменную среды. В среде разработки создайте переменную среды `DEBUG` со значением 1 (true). |
| `ALLOWED_HOSTS` | В рабочей среде для Django требуется включить URL-адрес приложения в массив `ALLOWED_HOSTS` в *settings.py*. Этот URL-адрес можно получить во время выполнения с помощью кода `os.environ['WEBSITE_HOSTNAME']`. Служба приложений автоматически задает в качестве значения переменной среды `WEBSITE_HOSTNAME` URL-адрес приложения. |
| `DATABASES` | Определите параметры в Службе приложений для подключения к базе данных и загрузите их в виде переменных среды, чтобы заполнить словарь [`DATABASES`](https://docs.djangoproject.com/en/3.1/ref/settings/#std:setting-DATABASES). Можно также сохранить значения (особенно имя пользователя и пароль) в виде [секретов Azure Key Vault](../key-vault/secrets/quick-create-python.md). |

## <a name="serve-static-files-for-django-apps"></a>Выдача статических файлов для приложений Django

Если веб-приложение Django содержит статические файлы для интерфейса, сначала выполните инструкции из [раздела об управлении статическими файлами](https://docs.djangoproject.com/en/3.1/howto/static-files/) в документации по Django.

Для Службы приложений нужно внести следующие изменения:

1. Рекомендуем применить переменные среды (при локальной разработке) и параметры приложения (при развертывании в облаке) для динамической передачи значений `STATIC_URL` и `STATIC_ROOT` в Django. Пример:    

    ```python
    STATIC_URL = os.environ.get("DJANGO_STATIC_URL", "/static/")
    STATIC_ROOT = os.environ.get("DJANGO_STATIC_ROOT", "./static/")    
    ```

    `DJANGO_STATIC_URL` и `DJANGO_STATIC_ROOT` можно изменять по мере необходимости для локальных и облачных сред. Например, если в процессе сборки статических файлов они помещаются в папку с именем `django-static`, вы можете задать для `DJANGO_STATIC_URL` значение `/django-static/` вместо значения по умолчанию.

1. Если у вас есть выполняемый перед сборкой скрипт, с помощью которого создаются статические файлы в другой папке, включите эту папку в переменную Django `STATICFILES_DIRS`, чтобы процесс `collectstatic` в Django смог их найти. Например, если `yarn build` выполняется в папке для внешнего интерфейса, а YARN создает папку `build/static` со статическими файлами, включите эту папку следующим образом:

    ```python
    FRONTEND_DIR = "path-to-frontend-folder" 
    STATICFILES_DIRS = [os.path.join(FRONTEND_DIR, 'build', 'static')]    
    ```

    Здесь `FRONTEND_DIR` применяется, чтобы создать путь к месту запуска средства сборки (в нашем примере это YARN). Как обычно, вы можете использовать переменную среды и параметр приложения на свое усмотрение.

1. Добавьте `whitenoise` в файл *requirements.txt*. Пакет Python [Whitenoise](http://whitenoise.evans.io/en/stable/) (whitenoise.evans.io) упрощает обработку собственных статических файлов рабочего приложения Django. Whitenoise обслуживает файлы в той папке, имя которой указано в переменной Django `STATIC_ROOT`.

1. В файле *settings.py* добавьте для Whitenoise следующую строку:

    ```python
    STATICFILES_STORAGE = ('whitenoise.storage.CompressedManifestStaticFilesStorage')
    ```

1. Также включите Whitenoise в списки `MIDDLEWARE` и `INSTALLED_APPS`:

    ```python
    MIDDLEWARE = [
        "whitenoise.middleware.WhiteNoiseMiddleware",
        # Other values follow
    ]

    INSTALLED_APPS = [
        "whitenoise.runserver_nostatic",
        # Other values follow
    ]
    ```

## <a name="container-characteristics"></a>Характеристики контейнера

При развертывании в Службе приложений приложения Python выполняются в контейнере Linux Docker, который определен в [этом репозитории GitHub](https://github.com/Azure-App-Service/python). Конфигурации образов можно найти в каталогах для конкретных версий.

Этот контейнер отличается следующими характеристиками.

- Приложения запускаются с помощью [HTTP-сервера Gunicorn WSGI](https://gunicorn.org/), используя дополнительные аргументы `--bind=0.0.0.0 --timeout 600`.
    - Вы можете задать параметры конфигурации для Gunicorn с помощью файла *gunicorn.conf.py* в корневом каталоге проекта, как описано в [обзоре конфигурации Gunicorn](https://docs.gunicorn.org/en/stable/configure.html#configuration-file) (docs.gunicorn.org). Кроме того, можно [настроить команду запуска](#customize-startup-command).

    - Чтобы защитить веб-приложение от случайных или намеренных атак DDoS, Gunicorn запускается за обратным прокси-сервером Nginx, как описано в [документации по развертыванию Gunicorn](https://docs.gunicorn.org/en/latest/deploy.html) (docs.gunicorn.org).

- По умолчанию базовый образ контейнера включает в себя только веб-платформу Flask, но контейнер также поддерживает другие платформы, совместимые с WSGI и Python 3.6 и более новых версий, например Django.

- Чтобы установить дополнительные пакеты, такие как Django, создайте файл [*requirements.txt*](https://pip.pypa.io/en/stable/user_guide/#requirements-files) в корневой папке проекта, в котором будут заданы прямые зависимости. Тогда Служба приложений автоматически установит эти зависимости при развертывании проекта.

    Для установки зависимостей файл *requirements.txt* *должен* находиться в корневой папке проекта. В противном случае в процессе сборки будет выведено сообщение об ошибке: Could not find setup.py or requirements.txt; Not running pip install (Не удалось найти setup.py или requirements.txt. Не запущена установка pip). В случае этой ошибки проверьте расположение файла требований.

- Служба приложений автоматически определяет переменную среды с именем `WEBSITE_HOSTNAME`, используя URL-адрес веб-приложения, например `msdocs-hello-world.azurewebsites.net`. Она также определяет `WEBSITE_SITE_NAME`, используя имя приложения, например `msdocs-hello-world`. 
   
- npm и Node.js устанавливаются в контейнере, что позволяет запускать YARN и другие средства сборки на основе Node.

## <a name="container-startup-process"></a>Процесс запуска контейнера

Во время запуска служба приложений под управлением контейнера Linux выполнит следующие действия.

1. Используйте [пользовательскую команду запуска](#customize-startup-command), если предоставлена такая возможность.
2. Проверьте наличие [приложения Django](#django-app) и запустите для него сервер Gunicorn, если он обнаружен.
3. Проверьте наличие [приложения Flask](#flask-app) и запустите для него сервер Gunicorn, если он обнаружено.
4. Если другие приложения не найдены, запускается приложение по умолчанию, встроенное в контейнер.

В следующих разделах приведены дополнительные сведения о каждом параметре.

### <a name="django-app"></a>Приложение Django

Для приложений Django служба приложений выполняет поиск файла с именем `wsgi.py` в вашем коде приложения, а затем запускает Gunicorn, используя следующую команду:

```bash
# <module> is the name of the folder that contains wsgi.py
gunicorn --bind=0.0.0.0 --timeout 600 <module>.wsgi
```

Если необходим более точный контроль над командой запуска, используйте [пользовательские команды запуска](#customize-startup-command), замените `<module>` именем папки, содержащей *wsgi.py*, и добавьте аргумент `--chdir`, если этот модуль расположен не в корневой папке проекта. Например, если *wsgi.py* находится во вложенной папке *knboard/backend/config* корневой папки проекта, используйте аргументы `--chdir knboard/backend config.wsgi`.

Чтобы включить ведение журнала в рабочей среде, добавьте параметры `--access-logfile` и `--error-logfile`, как показано в примерах [пользовательских команд запуска](#customize-startup-command).

### <a name="flask-app"></a>Приложение Flask

Для Flask Служба приложений выполняет поиск файла с именем *application.py* или *app.py* и запускает Gunicorn следующим образом:

```bash
# If application.py
gunicorn --bind=0.0.0.0 --timeout 600 application:app

# If app.py
gunicorn --bind=0.0.0.0 --timeout 600 app:app
```

Если модуль основного приложения содержится в другом файле, используйте другое имя для объекта приложения или, если вы хотите указать дополнительные аргументы для Gunicorn, используйте [пользовательские команды запуска](#customize-startup-command).

### <a name="default-behavior"></a>Поведение по умолчанию

Если в Службе приложений не найдена пользовательская команда, приложение Django или Flask, тогда она запускает приложение по умолчанию с разрешением только для чтения, расположенное в папке _opt/defaultsite_ (как показано на следующем изображении).

Если вы уже развернули код, но по-прежнему видите приложение по умолчанию, перейдите к разделу устранения неполадок ([Приложение не отображается](#app-doesnt-appear)).

[![Служба приложений по умолчанию на веб-странице Linux](media/configure-language-python/default-python-app.png)](#app-doesnt-appear)

Если вы ожидаете, что вместо приложения по умолчанию должно отображаться развернутое приложение, перейдите к разделу устранения неполадок ([Приложение не отображается](#app-doesnt-appear)).

## <a name="customize-startup-command"></a>Настройка команды запуска

Как упоминалось ранее в этой статье, вы можете задать параметры конфигурации для Gunicorn с помощью файла *gunicorn.conf.py* в корневом каталоге проекта, как описано в [обзоре конфигурации Gunicorn](https://docs.gunicorn.org/en/stable/configure.html#configuration-file).

Если такой конфигурации недостаточно, для управления поведением при запуске контейнера можно указать в файле команд запуска пользовательскую команду запуска или несколько команд. Для файла команд запуска можно использовать любое выбранное имя, например *startup.sh*, *startup.cmd*, *startup.txt* и т. д.

Во всех командах должны использоваться относительные пути к корневой папке проекта.

Чтобы указать команду или файл команд запуска, выполните следующие действия.

- **Портал Azure.** Перейдите на страницу **Конфигурация** приложения, а затем выберите **Общие параметры**. В поле **Команда запуска** вставьте полный текст команды запуска либо укажите имя файла команд запуска. Затем нажмите кнопку **Сохранить**, чтобы применить изменения. Сведения о контейнерах Linux см. в разделе [Настройка общих параметров](configure-common.md#configure-general-settings).

- **Azure CLI.** Используйте команду [az webapp config set](/cli/azure/webapp/config#az_webapp_config_set) с параметром `--startup-file`, чтобы задать команду или файл запуска.

    ```azurecli
    az webapp config set --resource-group <resource-group-name> --name <app-name> --startup-file "<custom-command>"
    ```
        
    Замените `<custom-command>` полным текстом команды запуска или именем файла команд запуска.
        
Служба приложений игнорирует все ошибки, происходящие при обработке пользовательской команды или файла запуска, и продолжает процесс запуска путем поиска приложений Django и Flask. Если поведение отличается от ожидаемого, проверьте, нет ли ошибок в команде или файле запуска, и убедитесь, что файл команд запуска развернут в Службе приложений вместе с кодом вашего приложения. Дополнительные сведения можно также почерпнуть из [журналов диагностики](#access-diagnostic-logs). Просмотрите также страницу **Диагностика и решение проблем** на [портале Azure](https://portal.azure.com).

### <a name="example-startup-commands"></a>Примеры команд запуска

- **Добавление аргументов Gunicorn**. В следующем примере в командную строку Gunicorn для запуска приложения Django добавляется `--workers=4`. 

    ```bash
    # <module-path> is the relative path to the folder that contains the module
    # that contains wsgi.py; <module> is the name of the folder containing wsgi.py.
    gunicorn --bind=0.0.0.0 --timeout 600 --workers=4 --chdir <module_path> <module>.wsgi
    ```    

    Дополнительные сведения см. в статье [Running Gunicorn](https://docs.gunicorn.org/en/stable/run.html) (Запуск Gunicorn) (docs.gunicorn.org).

- **Включение ведения журнала для Django в рабочей среде**. Добавьте в командную строку аргументы `--access-logfile '-'` и `--error-logfile '-'`.

    ```bash    
    # '-' for the log files means stdout for --access-logfile and stderr for --error-logfile.
    gunicorn --bind=0.0.0.0 --timeout 600 --workers=4 --chdir <module_path> <module>.wsgi --access-logfile '-' --error-logfile '-'
    ```    

    Эти журналы будут отображаться в [потоке журналов Службы приложений](#access-diagnostic-logs).

    Дополнительные сведения см. в разделе о [ведении журналов Gunicorn](https://docs.gunicorn.org/en/stable/settings.html#logging) (docs.gunicorn.org).
    
- **Настраиваемый основной модуль Flask**. По умолчанию Служба приложений предполагает, что основным модулем приложения Flask является *application.py* или *app.py*. Если у основного модуля другое имя, необходимо настроить команду запуска. Например, если вы используете приложение Flask, основным модулем которого является *hello.py*, а объект приложения Flask в этом файле имеет имя `myapp`, команда будет выглядеть следующим образом:

    ```bash
    gunicorn --bind=0.0.0.0 --timeout 600 hello:myapp
    ```
    
    Если главный модуль находится в подпапке, например `website`, укажите эту подпапку с помощью аргумента `--chdir`:
    
    ```bash
    gunicorn --bind=0.0.0.0 --timeout 600 --chdir website hello:myapp
    ```
    
- **Использование сервера, отличного от Gunicorn**. Чтобы использовать другой веб-сервер, например [aiohttp](https://aiohttp.readthedocs.io/en/stable/web_quickstart.html), используйте соответствующую команду в качестве команды запуска или в файле команд запуска.

    ```bash
    python3.7 -m aiohttp.web -H localhost -P 8080 package.module:init_func
    ```

## <a name="access-app-settings-as-environment-variables"></a>Доступ к параметрам приложения в виде переменных среды

Параметры приложения — это значения, хранящиеся в облаке специально для вашего приложения, как описано в разделе [Настройка параметров приложения](configure-common.md#configure-app-settings). Эти параметры доступны для кода приложения в виде переменных среды и вызываются с помощью стандартного шаблона [os.environ](https://docs.python.org/3/library/os.html#os.environ).

Например, если вы создали параметр приложения с именем `DATABASE_SERVER`, следующий код извлечет значение этого параметра.

```python
db_server = os.environ['DATABASE_SERVER']
```

## <a name="detect-https-session"></a>Обнаружение сеанса HTTPS

В Службе приложений [завершение SSL-запросов](https://wikipedia.org/wiki/TLS_termination_proxy) (wikipedia.org) происходит в подсистеме балансировки нагрузки сети, поэтому все HTTPS-запросы достигают вашего приложения в виде незашифрованных HTTP-запросов. Если логика вашего приложения проверяет, зашифрованы ли пользовательские запросы, проверяйте заголовок `X-Forwarded-Proto`.

```python
if 'X-Forwarded-Proto' in request.headers and request.headers['X-Forwarded-Proto'] == 'https':
# Do something when HTTPS is used
```

Популярные веб-платформы позволяют получить доступ к информации `X-Forwarded-*` в стандартном шаблоне приложения. В [CodeIgniter](https://codeigniter.com/) функция [is_https()](https://github.com/bcit-ci/CodeIgniter/blob/master/system/core/Common.php#L338-L365) по умолчанию проверяет значение `X_FORWARDED_PROTO`.

## <a name="access-diagnostic-logs"></a>Доступ к журналам диагностики

[!INCLUDE [Access diagnostic logs](../../includes/app-service-web-logs-access-linux-no-h.md)]

Чтобы получить доступ к журналам с помощью портала Azure, в приложении в меню слева выберите **Мониторинг** > **Поток журналов**.

## <a name="access-deployment-logs"></a>Доступ к журналам развертывания

При развертывании кода Служба приложений выполняет процесс сборки, описанный ранее в разделе [Настройка автоматизации сборки](#customize-build-automation). Так как сборка выполняется в собственном контейнере, журналы сборки хранятся отдельно от журналов диагностики приложения.

Чтобы открыть журналы развертывания, выполните указанные ниже действия:

1. На портале Azure для веб-приложения выберите элементы **Развертывание** > **Центр развертывания (предварительная версия)** в меню слева.
1. На вкладке **Журналы** выберите **Идентификатор фиксации** для последней фиксации.
1. На появившейся странице **Подробные сведения журнала** выберите ссылку **Показать журналы...** , которая отображается рядом с пунктом "Выполнение сборки oryx...".

В этих журналах отображаются проблемы со сборкой, такие как неверные зависимости в файле *requirements.txt* или ошибки в скриптах, выполняемых до или после сборки. Также здесь появятся ошибки, если имя файла требований отличается от *requirements.txt* или он размещен не в корневой папке проекта.

## <a name="open-ssh-session-in-browser"></a>Открытие сеанса SSH в браузере

[!INCLUDE [Open SSH session in browser](../../includes/app-service-web-ssh-connect-builtin-no-h.md)]

После успешного подключения к сеансу SSH в нижней части окна должно отобразиться сообщение SSH CONNECTION ESTABLISHED (SSH-соединение установлено). Если вы видите ошибку SSH_CONNECTION_CLOSED или сообщение о перезапуске контейнера, возможно наличие ошибки, которая мешает запуску контейнера приложения. Действия по исследованию возможных проблем см. в разделе [Устранение неполадок](#troubleshooting).

## <a name="troubleshooting"></a>Устранение неполадок

Как правило, при устранении неполадок прежде всего нужно проверить данные диагностики Службы приложений:

1. На портале Azure для веб-приложения выберите в меню слева пункт **Диагностика и решение проблем**.
1. Теперь выберите **Доступность и производительность**.
1. Изучите сведения в разделах **Журналы приложений**, **Сбой контейнера** и **Проблемы с контейнером**, где обычно отображаются распространенные проблемы.

Затем изучите [журналы развертывания](#access-deployment-logs) и [журналы приложения](#access-diagnostic-logs) на предмет сообщений об ошибках. Эти журналы часто указывают на конкретные проблемы, которые могут препятствовать развертыванию или запуску приложения. Например, сборка может завершаться ошибкой, если файл *requirements.txt* имеет неправильное имя или находится не в корневой папке проекта.

В следующих разделах приводятся дополнительные рекомендации по конкретным проблемам.

- [Приложение не отображается — отображается приложение по умолчанию](#app-doesnt-appear)
- [Приложение не отображается — выдается сообщение "Служба недоступна"](#service-unavailable)
- [Не удалось найти setup.py или requirements.txt](#could-not-find-setuppy-or-requirementstxt)
- [Ошибка ModuleNotFoundError при запуске](#modulenotfounderror-when-app-starts)
- [Пароли не отображаются при вводе в сеансе SSH](#other-issues)
- [Команды в сеансе SSH выглядят обрезанными](#other-issues)
- [Статические ресурсы не отображаются в приложении Django](#other-issues)
- [Неустранимая ошибка, требуется SSL-подключение](#other-issues)

#### <a name="app-doesnt-appear"></a>Приложение не отображается

- **После развертывания кода приложения отображается приложение по умолчанию.** [Приложение по умолчанию](#default-behavior) отображается потому, что код приложения не развернут в Службе приложений либо она не смогла найти ваш код приложения и применила приложение по умолчанию.

    - Перезапустите службу приложений, подождите 15–20 секунд и снова проверьте приложение.
    
    - Убедитесь, что вы используете службу приложений для Linux, а не экземпляр для Windows. В Azure CLI выполните команду `az webapp show --resource-group <resource-group-name> --name <app-name> --query kind`, заменив `<resource-group-name>` и `<app-name>` соответствующими значениями. Команда должна вывести строку `app,linux`. Если этого не произошло, заново создайте службу приложений и выберите Linux.
    
    - Используйте [SSH](#open-ssh-session-in-browser) для подключения непосредственно к контейнеру Службы приложений и убедитесь, что нужные файлы находятся в каталоге *site/wwwroot*. Если файлов здесь нет, выполните следующие действия:
      1. Создайте параметр приложения с именем `SCM_DO_BUILD_DURING_DEPLOYMENT` и значением 1, повторно разверните код, подождите несколько минут и снова попробуйте открыть его. Дополнительные сведения о создании параметров приложений см. в статье [Настройка приложения Службы приложений на портале Azure](configure-common.md).
      1. Проверьте процесс развертывания, затем [проверьте журналы развертывания](#access-deployment-logs), исправьте все ошибки и повторно разверните приложение.
    
    - Если файлы имеются, значит службе приложений не удалось определить конкретный загрузочный файл. Убедитесь, что ваше приложение структурировано, так как служба приложений ожидает [Djangо](#django-app) или [Flask](#flask-app) или использует [пользовательскую команду запуска](#customize-startup-command).

- <a name="service-unavailable"></a>**В браузере появилось сообщение "Служба недоступна".** Истекло время ожидания браузером ответа от Службы приложений, что указывает на то, что она успешно запустила сервер Gunicorn, но не смогла запустить приложение. Это может означать, что аргументы Gunicorn неверны или в коде приложения есть ошибка.

    - Обновите браузер, особенно если вы используете самую низкую ценовую категорию в плане службы приложений. Приложению может потребоваться больше времени для запуска, например при использовании бесплатных уровней, и оно начнет отвечать после обновления браузера.

    - Убедитесь, что ваше приложение структурировано, так как служба приложений ожидает [Djangо](#django-app) или [Flask](#flask-app) или использует [пользовательскую команду запуска](#customize-startup-command).

    - Проверьте, нет ли в [потоке журналов приложения](#access-diagnostic-logs) сообщений об ошибках. В этих журналах отобразятся любые ошибки в коде приложения.

#### <a name="could-not-find-setuppy-or-requirementstxt"></a>Не удалось найти setup.py или requirements.txt

- **В потоке журналов отображается сообщение Could not find setup.py or requirements.txt; Not running pip install (Не удалось найти setup.py или requirements.txt. Не запущена установка pip)** . Процессу сборки Oryx не удалось найти файл *requirements.txt*.

    - Подключитесь к контейнеру веб-приложения через [SSH](#open-ssh-session-in-browser) и убедитесь, что файл *requirements.txt* имеет правильное имя и размещен в папке *site/wwwroot*. Если он там отсутствует, убедитесь, что он существует в репозитории и включен в развертывание. Если он находится в отдельной папке, переместите его в корневую папку.

#### <a name="modulenotfounderror-when-app-starts"></a>Ошибка ModuleNotFoundError при запуске приложения

Если отображается ошибка `ModuleNotFoundError: No module named 'example'`, это означает, что Python не удалось найти один или несколько модулей при запуске приложения. Чаще всего это происходит при развертывании виртуальной среды с помощью кода. Виртуальные среды не являются переносимыми, поэтому их не следует развертывать с помощью кода приложения. Вместо этого позвольте Oryx создать виртуальную среду и установить пакеты в веб-приложение, создав параметр приложения `SCM_DO_BUILD_DURING_DEPLOYMENT` и задав для него значение `1`. Тогда Oryx будет устанавливать ваши пакеты при каждом развертывании в Службе приложений. Дополнительные сведения см. [в этой статье о переносимости виртуальных сред](https://azure.github.io/AppService/2020/12/11/cicd-for-python-apps.html).

#### <a name="other-issues"></a>Другие проблемы

- **Пароли не отображаются при вводе в сеансе SSH.** По соображениям безопасности сеанс SSH оставляет пароль скрытым при вводе. Но все символы успешно записываются, поэтому введите пароль как обычно и нажмите клавишу **ВВОД** после завершения.

- **Команды в сеансе SSH выглядят обрезанными.** Возможно, редактор не выполняет для команд перенос по строкам, но они все равно должны работать правильно.

- **Статические ресурсы не отображаются в приложении Django.** Убедитесь, что вы включили модуль [whitenoise](http://whitenoise.evans.io/en/stable/django.html)

- **Появляется сообщение "Fatal SSL Connection is Required" (Неустранимая ошибка, требуется SSL-подключение).** Проверьте имена пользователей и пароли, используемые в приложении для доступа к ресурсам (например, к базам данных).

## <a name="next-steps"></a>Дальнейшие действия

> [!div class="nextstepaction"]
> [Руководство. по использованию приложения Python с PostgreSQL](tutorial-python-postgresql-app.md)

> [!div class="nextstepaction"]
> [Руководство. по развертыванию из частного репозитория контейнеров](tutorial-custom-container.md?pivots=container-linux)

> [!div class="nextstepaction"]
> [Служба приложений под управлением Linux: вопросы и ответы](faq-app-service-linux.md)
