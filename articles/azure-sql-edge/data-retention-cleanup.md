---
title: Управление историческими данными с помощью политики хранения — Azure SQL ребр
description: Узнайте, как управлять историческими данными с помощью политики хранения в Azure SQL ребро.
keywords: SQL Server, хранение данных
services: sql-edge
ms.service: sql-edge
ms.topic: conceptual
author: SQLSourabh
ms.author: sourabha
ms.reviewer: sstein
ms.date: 09/04/2020
ms.openlocfilehash: f547f0b3219889b54364c4805c2dd5b183a9861a
ms.sourcegitcommit: 867cb1b7a1f3a1f0b427282c648d411d0ca4f81f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "93392373"
---
# <a name="manage-historical-data-with-retention-policy"></a>Управление историческими данными с помощью политики хранения

Хранение данных может быть включено для базы данных и любой базовой таблицы по отдельности, что позволяет пользователям создавать гибкие политики устаревания для таблиц и баз данных. Применение хранения данных является простым: для этого требуется только один параметр во время создания таблицы или как часть операции ALTER TABLE. 

После того как политика хранения данных определяемых для базы данных и базовой таблицы, запускается задача фонового таймера времени для удаления устаревших записей из таблицы, включенной для хранения данных. Идентификация совпадающих строк и их удаление из таблицы происходит прозрачно, в фоновой задаче, которая запланирована и выполняется системой. Условие возраста для строк таблицы проверяется на основе столбца, используемого `filter_column` в определении таблицы. Например, если в качестве срока хранения задана одна неделя, строки таблицы, доступные для очистки, соответствуют одному из следующих условий: 

- Если в столбце фильтра используется тип данных DATETIMEOFFSET, то условие `filter_column < DATEADD(WEEK, -1, SYSUTCDATETIME())`
- В противном случае условие `filter_column < DATEADD(WEEK, -1, SYSDATETIME())`

## <a name="data-retention-cleanup-phases"></a>Этапы очистки хранения данных

Операция очистки хранения данных состоит из двух этапов. 
- Этап обнаружения. на этом этапе операция очистки идентифицирует все таблицы в пользовательских базах данных для создания списка для очистки. Обнаружение выполняется один раз в день.
- Этап очистки — на этом этапе выполняется очистка всех таблиц с конечным периодом хранения данных, идентифицированных на этапе обнаружения. Если операция очистки не может быть выполнена для таблицы, эта таблица пропускается в текущем запуске и будет повторена в следующей итерации. Во время очистки используются следующие принципы.
    - Если устаревшая строка заблокирована другой транзакцией, эта строка пропускается. 
    - Очистка запускается с параметром времени ожидания блокировки по умолчанию (5 секунд). Если блокировки не могут быть получены в таблицах в течение периода ожидания, таблица пропускается в текущем запуске и будет повторена в следующей итерации.
    - Если во время очистки таблицы возникает ошибка, эта таблица пропускается и будет выбрана в следующей итерации.

## <a name="manual-cleanup"></a>Ручная очистка

В зависимости от параметров хранения данных в таблице и природы рабочей нагрузки в базе данных, возможно, что поток автоматической очистки может не полностью удалить все устаревшие строки во время его выполнения. Чтобы помочь в этом и позволить пользователям вручную удалять устаревшие строки, `sys.sp_cleanup_data_retention` хранимая процедура была введена в Azure SQL ребро. 

Эта хранимая процедура принимает три параметра. 
    - Имя схемы — имя схемы-владельца для таблицы. Это обязательный параметр. 
    - Table name — имя таблицы, для которой выполняется очистка вручную. Это обязательный параметр. 
    - ROWCOUNT (вывод) — выходная переменная. Возвращает число строк, очищенных с помощью ручной очистки SP. Этот параметр является необязательным. 

В следующем примере показано выполнение ручной очистки SP для таблицы `dbo.data_retention_table` .

```sql
declare @rowcnt bigint 
EXEC sys.sp_cleanup_data_retention 'dbo', 'data_retention_table', @rowcnt output 
select @rowcnt 
```

## <a name="how-obsolete-rows-are-deleted"></a>Удаление устаревших строк

Процесс очистки зависит от структуры индекса таблицы. Для выполнения устаревшей очистки данных для всех таблиц с ограниченным сроком хранения создается фоновая задача. Очистка логики индекса rowstore (сбалансированное дерево или куча) удаляет устаревшие строки в небольших блоках (до 10000) минимизации давления в журналах базы данных и подсистеме ввода-вывода. Несмотря на то что в логике очистки используется индекс сбалансированного дерева, порядок удаления строк, возраст которых превышает срок хранения, может не соблюдаться. В связи с этим не включайте в приложения никакие зависимости от порядка очистки.

Задача очистки для кластеризованного columnstore удаляет целые группы строк за один раз (обычно содержит 1 000 000 строк в каждой), что очень эффективно, особенно при создании и очистке данных в высоком темпе.

![Очистка хранения данных](./media/data-retention-cleanup/data-retention-cleanup.png)

Превосходное сжатие данных и эффективная очистка хранения делают кластеризованный индекс columnstore идеальным выбором для сценариев, когда Рабочая нагрузка быстро создает большой объем данных.

> [!Note]
> В случае индексов и куч сбалансированного дерева при хранении данных выполняется запрос DELETE к базовым таблицам, которые могут конфликтовать с триггерами DELETE в таблицах. Рекомендуется либо удалить триггеры Delete из таблиц, либо не включать хранение данных в таблицах, имеющих триггер DML DELETE.

## <a name="monitoring-data-retention-cleanup"></a>Очистка хранения данных мониторинга

Операции очистки политики хранения данных можно отслеживать с помощью расширенных событий (XEvents) в Azure SQL. Дополнительные сведения о расширенных событиях см. в [обзоре XEvents](/sql/relational-databases/extended-events/extended-events). 

Следующие шесть расширенных событий помогают отслеживанию состояния операций очистки. 

| Имя | Описание |
|------| ------------|
| data_retention_task_started  | Происходит при запуске фоновой задачи очистки таблиц с политикой хранения. |
| data_retention_task_completed  | Происходит при завершении фоновой задачи очистки таблиц с политикой хранения. |
| data_retention_task_exception  | Происходит, когда фоновая задача для очистки таблиц с политикой хранения завершается сбоем вне процесса очистки хранения, относящегося к таблице. |
| data_retention_cleanup_started  | Происходит при запуске очистки процесса таблицы с политикой хранения данных. |
| data_retention_cleanup_exception  | Происходит сбой процесса очистки таблицы с политикой хранения. |
| data_retention_cleanup_completed  | Происходит при завершении очистки процесса таблицы с политикой хранения данных. |  

Кроме того, `RING_BUFFER_DATA_RETENTION_CLEANUP` в динамическом административном представлении sys.dm_os_ring_buffers добавлен новый тип кольцевого буфера. Это представление можно использовать для отслеживания операций очистки хранения данных. 


## <a name="next-steps"></a>Дальнейшие действия
- [Политика хранения данных](data-retention-overview.md)
- [Включение и отключение политик хранения данных](data-retention-enable-disable.md)