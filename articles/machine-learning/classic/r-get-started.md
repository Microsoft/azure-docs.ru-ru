---
title: Использование R с Машинное обучение Studio (классическая модель) — Azure
description: Используйте это руководство по программированию на R для начала работы с Машинное обучение Azure Studio (классической) в R для создания решения для прогнозирования.
services: machine-learning
ms.service: machine-learning
ms.subservice: studio-classic
ms.topic: how-to
author: likebupt
ms.author: keli19
ms.custom: previous-author=heatherbshapiro, previous-ms.author=hshapiro
ms.date: 03/01/2019
ms.openlocfilehash: c619b51f9323477bda4f1ec99aeeb1bfa01028fc
ms.sourcegitcommit: 867cb1b7a1f3a1f0b427282c648d411d0ca4f81f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "100517745"
---
# <a name="get-started-with-azure-machine-learning-studio-classic-in-r"></a>Приступая к работе с Машинное обучение Azure Studio (классическая модель) в R

**ПРИМЕНИМО К:**  ![Флажок, который обозначает, что эта статья применима к Студии машинного обучения (классическая версия). ](../../../includes/media/aml-applies-to-skus/yes.png)Студия машинного обучения (классическая версия) ![Значок X, который обозначает, что эта статься применима к решению "Машинное обучение Azure". ](../../../includes/media/aml-applies-to-skus/no.png)[Машинное обучение Azure](../overview-what-is-machine-learning-studio.md#ml-studio-classic-vs-azure-machine-learning-studio)

<!-- Stephen F Elston, Ph.D. -->
В этом руководстве описано, как использовать Машинное обучение Azure Studio (классическая модель) для создания, тестирования и выполнения кода R. В итоге у вас будет полноценное решение для прогнозирования.

> [!div class="checklist"]
> * Создание кода для очистки и преобразования данных.
> * Анализируйте корреляции между несколькими переменными в нашем наборе данных.
> * Создание модели прогнозирования временных рядов для молоко производства.


Машинное обучение Studio (классическая модель) содержит множество мощных модулей машинного обучения и управления данными. С помощью языка программирования R это сочетание обеспечивает масштабируемость и простоту развертывания Машинное обучение Studio (классическая модель) с гибким и глубоким анализом R.

Прогнозирование — это широко используемый и полезный аналитический метод. Обычно используется диапазон от прогнозирования продаж сезонных элементов и определения оптимальных уровней запасов для прогнозирования макроэкономических переменных. Преимущественно при прогнозировании используются модели временных рядов. Данные временных рядов — данные, значения которых имеют индекс времени. Индекс времени может быть регулярным, например, каждый месяц или каждую минуту. Индекс времени также может быть нерегулярным. Модель временных рядов основана на данных временных рядов. Язык программирования R располагает гибкой структурой и широкими аналитическими возможностями для временных данных.

## <a name="get-the-data"></a>Получение данных

В этом руководстве вы используете данные о производстве и ценах на Калифорния, которые включают в себя ежемесячную информацию о производстве нескольких молочных продуктов и цену молоко FAT, которая является товаром теста производительности.

Данные, используемые в этой статье вместе с скриптами R, можно скачать из [мачинелеарнингсамплес-Notebooks/Studio-Samples](https://github.com/Azure-Samples/MachineLearningSamples-Notebooks/tree/master/studio-samples). Данные в файле `cadairydata.csv` первоначально были синтезированы на основе информации, доступной в университете [сайта Висконсина молочных рынков](https://dairymarkets.com).

## <a name="interact-with-r-language-in-machine-learning-studio-classic"></a><a id="mlstudio"></a>Взаимодействие с языком R в Машинное обучение Studio (классическая модель)

В этом разделе рассматриваются некоторые основные принципы взаимодействия с языком программирования R в среде Машинное обучение Studio (классическая модель). Язык R предоставляет мощный инструмент для создания пользовательских модулей аналитики и манипулирования данными в среде Машинное обучение Studio (классической).

Мы будем использовать RStudio для разработки, тестирования и отладки кода на R в небольшом масштабе. Затем этот код вырезается и вставляется в модуль [выполнить сценарий R][execute-r-script] , готовый к запуску в машинное обучение Studio (классическая модель).

### <a name="the-execute-r-script-module"></a>Модуль «Выполнение сценария R»

В среде Машинное обучение Studio (классическая модель) скрипты R выполняются в модуле [выполнить сценарий r][execute-r-script] . Пример модуля [выполнить сценарий R][execute-r-script] в машинное обучение Studio (классическая модель) показан здесь.

 ![Снимок экрана, на котором показан язык программирования R: модуль "выполнение скрипта R", выбранный в Машинное обучение Studio (классическая модель).](./media/r-quickstart/fig1.png)

На предыдущем рисунке показаны некоторые ключевые части среды Машинное обучение Studio (классическая модель) для работы с модулем [выполнить сценарий R][execute-r-script] :

* Модули эксперимента отображаются на центральной панели.
* Верхняя часть правой панели содержит окно, которое можно использовать для просмотра и редактирования скриптов R.
* В нижней части правой панели показаны некоторые свойства [сценария выполнить R][execute-r-script]. Чтобы просмотреть журналы ошибок и выходных данных, выберите соответствующие области этой панели.

В оставшейся части этой статьи мы обсудим [сценарий выполнения R][execute-r-script] более подробно.

При работе со сложными функциями R рекомендуется изменять, тестировать и отлаживать в RStudio. Как и при любой разработке программного обеспечения, расширьте код и протестируйте его в небольших и простых тестовых случаях. Затем вырезайте и вставляйте готовые функции в окно сценария модуля [Выполнить сценарий R][execute-r-script]. Такой подход позволяет использовать как интегрированную среду разработки (IDE) RStudio, так и возможности Машинное обучение Studio (классическая модель).

#### <a name="execute-r-code"></a>Выполнение кода R

Любой код R в модуле [выполнить сценарий r][execute-r-script] будет выполняться при запуске эксперимента, нажав кнопку **выполнить** . После завершения выполнения на значке [выполнить сценарий R][execute-r-script] появится галочка.

#### <a name="defensive-r-coding-for-machine-learning-studio-classic"></a>Защитное программирование на R для Машинное обучение Studio (классическая модель)

Если вы разрабатываете код R для, например, веб-службу с помощью Машинное обучение Studio (классическая модель), необходимо определенно спланировать, как код будет работать с непредвиденными входными данными и исключениями. Для обеспечения ясности мы не включали в себя способ проверки или обработки исключений в большинстве примеров кода. По мере продолжения мы предоставим вам несколько примеров функций с помощью функции обработки исключений R.

Если вам требуется более полная обработка исключений R, ознакомьтесь с соответствующими разделами книги Wickham, приведенными в разделе [Дополнительные материалы](#appendixb).

#### <a name="debug-and-test-r-in-machine-learning-studio-classic"></a>Отладка и тестирование R в Машинное обучение Studio (классическая модель)

Протестируйте и отлаживать код R в небольшом масштабе в RStudio. Существуют также случаи, когда необходимо отслеживание проблем кода R в самом [сценарии Execute r][execute-r-script] . Кроме того, рекомендуется проверять результаты в Машинное обучение Studio (классическая модель).

Выходные данные выполнения кода R и на платформе Машинное обучение Studio (классическая модель) находятся в основном в выходных данных. log. Некоторые дополнительные сведения находятся в журнале Error. log.

При возникновении ошибки в Машинное обучение Studio (классической версии) во время выполнения кода R первым разумеется, следует обратить внимание на Error. log. В этом файле могут быть полезные сообщения об ошибках, которые помогут вам понять и исправить свою ошибку. Чтобы просмотреть журнал ошибок., выберите **Просмотреть журнал ошибок** на панели свойств для [скрипта выполнения R][execute-r-script] , который содержит ошибку.

Например, мы запустили следующий код R с неопределенной переменной y в модуле [выполнить сценарий R][execute-r-script] .

```r
x <- 1.0
z <- x + y
```

Этот код не выполняется, что приводит к ошибке. При выборе параметра **Просмотреть журнал ошибок** на панели свойств выводится следующее.

  ![Снимок экрана, на котором отображается всплывающее сообщение об ошибке.](./media/r-quickstart/fig2.png)

Похоже, нужно просмотреть файл output.log, чтобы прочитать сообщение об ошибке в коде на R. Выберите модуль [выполнить сценарий R][execute-r-script] , а затем щелкните элемент **Просмотреть выходной файл журнала** на панели свойств справа. Откроется новое окно браузера, и появится следующее сообщение об ошибке.

```output
[Critical]     Error: Error 0063: The following error occurred during evaluation of R script:
---------- Start of error message from R ----------
object 'y' not found


object 'y' not found
----------- End of error message from R -----------
```

В сообщении об ошибке нет ничего неожиданного: проблема четко определена.

Чтобы проверить значение любого объекта в коде на R, можно обеспечить вывод этих значений в файл output.log. Правила проверки значений объектов в принципе те же, что и при интерактивном сеансе работы с R. Например, если ввести имя переменной в строке, значение объекта будет напечатано в файле Output. log.

#### <a name="packages-in-machine-learning-studio-classic"></a>Пакеты в Машинное обучение Studio (классическая модель)

Машинное обучение Studio (классическая модель) поставляется с более чем 350 предварительно установленными языковыми пакетами R. Чтобы увидеть список предустановленных пакетов, используйте приведенный ниже код в модуле [Выполнить сценарий R][execute-r-script].

```r
data.set <- data.frame(installed.packages())
maml.mapOutputPort("data.set")
```

Если вам пока не понятна последняя строка кода, не останавливайтесь. В оставшейся части этой статьи мы подробно рассмотрим использование R в среде Машинное обучение Studio (классической).

### <a name="introduction-to-rstudio"></a>Основные сведения об RStudio

RStudio — широко используемая интегрированная среда разработки для R. Мы будем использовать RStudio для редактирования, тестирования и отладки некоторых кодов R, используемых в этом руководством. После тестирования и подготовки кода R можно вырезать и вставить его из редактора RStudio в модуль [выполнения сценариев r][execute-r-script] машинное обучение Studio (классический).

Если на настольном компьютере не установлен язык программирования R, сделайте это сейчас. Бесплатные загружаемые файлы языка R с открытым кодом доступны в [полной архивной сети r (Cran)](https://www.r-project.org/). Доступны загружаемые файлы для Windows, macOS и Linux/UNIX. Выберите ближайшее зеркало и следуйте указаниям по загрузке. Кроме того, CRAN содержит много полезных пакетов аналитики и обработки данных.

Если вы не знакомы с RStudio, скачайте и установите версию для настольных систем. Файлы для загрузки RStudio для Windows, macOS и Linux/UNIX можно найти по адресу [RStudio](http://www.rstudio.com/products/RStudio/). Следуйте инструкциям по установке RStudio на компьютер.

Введение в учебник по RStudio можно найти в статье [Использование интегрированной среды разработки RStudio](https://support.rstudio.com/hc/sections/200107586-Using-RStudio).

Дополнительные сведения об использовании RStudio см. в [документации по RStudio](#appendixa).

## <a name="get-data-in-and-out-of-the-execute-r-script-module"></a><a id="scriptmodule"></a>Добавление данных в модуль «Выполнение сценария R» и их извлечение оттуда

В этом разделе мы обсудим, как получать данные в модуль « [выполнение сценария R][execute-r-script] » и из него. Также будет рассмотрена работа с различными типами данных, которые считываются из модуля [выполнение скрипта R][execute-r-script] и из него.

Полный код для этого раздела приведен в разделе [мачинелеарнингсамплес-Notebooks/Studio-Samples](https://github.com/Azure-Samples/MachineLearningSamples-Notebooks/tree/master/studio-samples).

### <a name="load-and-check-data"></a>Загрузка и проверка данных

#### <a name="load-the-dataset"></a><a id="loading"></a>Загрузка набора данных

Начнем с загрузки файла **csdairydata.csv** в машинное обучение Studio (классическая модель).

1. Запустите среду Машинное обучение Studio (классическая среда).
1. Выберите **+ создать** в левом нижнем углу экрана и выберите **набор данных**.
1. Выберите **из локального файла**, а затем нажмите кнопку **Обзор** , чтобы выбрать файл.
1. Убедитесь, что выбран **универсальный CSV-файл с заголовком (CSV)** в качестве типа для набора данных.
1. Установите флажок.
1. После отправки набора данных он должен отобразиться при выборе вкладки **наборы** данных.

#### <a name="create-an-experiment"></a>Создание эксперимента

Теперь, когда у нас есть данные в Машинное обучение Studio (классическая модель), необходимо создать эксперимент для анализа.  

1. Выберите **+ создать** в левом нижнем углу экрана и выберите **эксперимент**  >  **пустой эксперимент**.
1. Присвойте эксперименту имя, выбрав и изменив **эксперимент, созданный по** заголовку в верхней части страницы. Например, измените его на " **анализ молочных продуктов**".
1. В левой части страницы эксперимента выберите **сохраненные наборы данных**  >  **Мои** наборы данных. Вы увидите файл **cadairydata.csv** , который был отправлен ранее.
1. Перетащите **csdairydata.csv набор данных** на эксперимент.
1. В поле **Поиск элементов эксперимента** в верхней части левой панели введите [выполнить сценарий R][execute-r-script]. Модуль появится в списке поиска.
1. Перетащите модуль [выполнить сценарий R][execute-r-script] на свою палету.
1. Соедините выход **набора данныхcsdairydata.csv** с крайним левым входом (**dataSet1**) [скрипта выполнения R][execute-r-script].
1. Щелкните **Сохранить**.

На этом этапе ваш эксперимент должен выглядеть примерно так, как показано в этом примере.

![Схема, на которой показан эксперимент по анализу молочных продуктов CA с набором данных и выполнением модуля скрипта R.](./media/r-quickstart/fig3.png)


#### <a name="check-on-the-data"></a>Проверка данных

Давайте посмотрим на данные, которые мы загрузили в наш эксперимент. В эксперименте выберите выходные данные **cadairydata.csv набора данных** и нажмите кнопку **визуализировать**. Вы должны увидеть нечто вроде этой сводки.

![Снимок экрана, на котором показана сводка cadairydata.csv набора данных.](./media/r-quickstart/fig4.png)

В этом представлении отображается много полезной информации. Можно увидеть первые несколько строк набора данных. Если выбрать столбец, в разделе **статистики** отобразятся дополнительные сведения о столбце. Например, строка **тип функции** показывает, какие типы данных машинное обучение Studio (классическая модель), назначенных столбцу. Проверьте это представление, прежде чем приступать к серьезной работе.

### <a name="first-r-script"></a>Первый сценарий R

Давайте создадим простой первый скрипт R для экспериментов в Машинное обучение Studio (классическая модель). Мы создали и протестировали следующий скрипт в RStudio.

```r
## Only one of the following two lines should be used
## If running in Machine Learning Studio (classic), use the first line with maml.mapInputPort()
## If in RStudio, use the second line with read.csv()
cadairydata <- maml.mapInputPort(1)
# cadairydata  <- read.csv("cadairydata.csv", header = TRUE, stringsAsFactors = FALSE)
str(cadairydata)
pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = cadairydata)
## The following line should be executed only when running in
## Azure Machine Learning Studio (classic)
maml.mapOutputPort('cadairydata')
```

Теперь необходимо передавать этот скрипт в Машинное обучение Studio (классическая модель). Вы можете вырезать и вставить, но в этом случае перенесите R-скрипт с помощью файла ZIP.

### <a name="data-input-to-the-execute-r-script-module"></a>Ввод данных в модуль "Выполнение скрипта R"

Рассмотрим порты ввода модуля [Выполнить сценарий R][execute-r-script]. В этом примере мы продемонстрируем данные о продукции в Калифорнии в модуль [выполнить сценарий R][execute-r-script] .

У модуля [Выполнить сценарий R][execute-r-script] может быть три порта ввода. В зависимости от приложения можно использовать любой из этих входных данных. Можно также использовать сценарий R, который вообще не принимает входные данные.

Рассмотрим все порты ввода по порядку слева направо. Наведя курсор на порт, можно увидеть всплывающую подсказку с его именем.

#### <a name="script-bundle"></a>Пакет скриптов

Входные данные пакета сценариев позволяют передавать содержимое ZIP-файла в модуль [выполнить сценарий R][execute-r-script] . Для считывания содержимого ZIP-файла в код на R можно использовать одну из этих команд.

```r
source("src/yourfile.R") # Reads a zipped R script
load("src/yourData.rdata") # Reads a zipped R data file
```

> [!NOTE]
> Машинное обучение Studio (классическая модель) обрабатывает файлы в ZIP-файле так, как если бы они наименлись в каталоге src/, поэтому необходимо добавить к именам этих файлов префикс. Например, если ZIP-файл содержит файлы `yourfile.R` и `yourData.rdata` в корне ZIP-файла, эти файлы будут `src/yourfile.R` использованы как и `src/yourData.rdata` при использовании `source` и `load` .

Мы уже обсуждали загрузку наборов [данных в Load](#loading). После создания и тестирования скрипта R, показанного в предыдущем разделе, выполните следующие действия.

1. Сохраните скрипт R в файл с расширением .R. Мы вызываем файл скрипта **simpleplot. R**. Вот именно в файле:

   ```r
   ## Only one of the following two lines should be used
   ## If running in Machine Learning Studio (classic), use the first line with maml.mapInputPort()
   ## If in RStudio, use the second line with read.csv()
   cadairydata <- maml.mapInputPort(1)
   # cadairydata  <- read.csv("cadairydata.csv", header = TRUE, stringsAsFactors = FALSE)
   str(cadairydata)
   pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = cadairydata)
   ## The following line should be executed only when running in
   ## Azure Machine Learning Studio (classic)
   maml.mapOutputPort('cadairydata')
   ```

1. Создайте ZIP-файл и скопируйте сценарий в этот ZIP-файл. В Windows можно щелкнуть правой кнопкой мыши файл и выбрать **отправить в**  >  **сжатую папку**. Это действие создает новый ZIP-файл, содержащий **simpleplot. Файл R** .

1. Добавьте файл в **наборы данных** в машинное обучение Studio (классическая модель) и укажите тип в виде **ZIP**. Теперь вы увидите ZIP-файл среди своих наборов данных.

1. Перетащите ZIP-файл из **набора данных** на **холст студии машинного обучения (классический)**.

1. Соедините порт вывода значка **ZIP-данных** с портом ввода **Пакет сценариев** модуля [Выполнить сценарий R][execute-r-script].

1. Введите `source()` функцию с именем ZIP-файла в окно кода модуля [выполнить сценарий R][execute-r-script] . В этом случае мы указали `source("src/simpleplot.R")` .

1. Щелкните **Сохранить**.

После выполнения этих действий модуль [выполнить сценарий r][execute-r-script] выполняет скрипт r в ZIP-файле при выполнении эксперимента. На этом этапе ваш эксперимент должен выглядеть примерно так, как показано в этом примере.

![Схема, на которой показан эксперимент с помощью ZIP-скрипта R.](./media/r-quickstart/fig6.png)

#### <a name="dataset1"></a>Набор данных 1

С помощью порта ввода «Набор данных 1» можно передать прямоугольную таблицу данных в код на R. В нашем простом сценарии `maml.mapInputPort(1)` функция считывает данные с порта 1. Затем эти данные присваиваются имени переменной в вашем коде, тип которой — таблица данных. В нашем простом сценарии первая строка кода выполняет назначение.

```r
cadairydata <- maml.mapInputPort(1)
```

Запустите эксперимент, нажав кнопку **выполнить** . По завершении выполнения выберите модуль [выполнить сценарий R][execute-r-script] , а затем на панели Свойства выберите **Просмотреть журнал вывода** . В браузере откроется новая страница с содержимым файла output.log. При прокрутке вниз вы увидите нечто вроде приведенных ниже выходных данных.

```output
[ModuleOutput] InputDataStructure
[ModuleOutput]
[ModuleOutput] {
[ModuleOutput]  "InputName":Dataset1
[ModuleOutput]  "Rows":228
[ModuleOutput]  "Cols":9
[ModuleOutput]  "ColumnTypes":System.Int32,3,System.Double,5,System.String,1
[ModuleOutput] }
```

Дальше вниз на странице представлены более подробные сведения о столбцах, которые будут выглядеть примерно так, как на следующем выходе.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput]
[ModuleOutput] 'data.frame':    228 obs. of  9 variables:
[ModuleOutput]
[ModuleOutput]  $ Column 0         : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput]
[ModuleOutput]  $ Year.Month       : num  1995 1995 1995 1995 1995 ...
[ModuleOutput]
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput]
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput]
[ModuleOutput]  $ Month            : chr  "Jan" "Feb" "Mar" "Apr" ...
[ModuleOutput]
[ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
[ModuleOutput]
[ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
[ModuleOutput]
[ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
[ModuleOutput]
[ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...
```

Результаты преимущественно ожидаемые. В таблице данных 228 наблюдений и 9 столбцов. Можно увидеть имена столбцов, тип данных R и выборку для каждого столбца.

> [!NOTE]
> Эти же результаты можно получить с помощью порта вывода "Устройство R" модуля [Выполнить сценарий R][execute-r-script]. Выходные данные модуля [выполнить сценарий R][execute-r-script] будут обсуждаться в следующем разделе.  

#### <a name="dataset2"></a>Набор данных 2

Поведение портов ввода "Набор данных 2" такое же, как у портов "Набор данных 1". Используя эти входные данные, можно передать вторую прямоугольную таблицу данных в код R. Для передачи этих данных используется функция `maml.mapInputPort(2)`с аргументом 2.  

### <a name="execute-r-script-outputs"></a>Порты вывода модуля "Выполнение скрипта R"

#### <a name="output-a-dataframe"></a>Вывод таблицы данных

Через порт «Итоговый набор данных 1» можно вывести содержимое таблицы данных на R в виде прямоугольной таблицы с помощью функции `maml.mapOutputPort()` . В нашем простом сценарии R это действие выполняется следующей строкой.

```r
maml.mapOutputPort('cadairydata')
```

После запуска эксперимента выберите выходной порт DataSet1 и нажмите кнопку **визуализировать**. Вы должны увидеть нечто вроде этого примера.

![Снимок экрана, на котором показана визуализация выходных данных по молочным данным штата Калифорния.](./media/r-quickstart/fig7.png)

Выходные данные выглядят в точности так, как и входные — как и предполагалось.

### <a name="r-device-output"></a>Порт вывода "Устройство R"

Порт вывода "Устройство R" модуля [Выполнить сценарий R][execute-r-script] предназначен для вывода сообщений и графики. Как стандартный вывод данных, так и сообщения об ошибках на R направляются в порт вывода "Устройство R".

Чтобы просмотреть выходные данные устройства R, выберите порт и нажмите кнопку **визуализировать**. Ниже приведены стандартные выходные данные и стандартные ошибки из скрипта R.

![Снимок экрана, на котором показан стандартный вывод и стандартная ошибка из порта устройства R.](./media/r-quickstart/fig8.png)

Прокрутка вниз, мы видим выходные данные графического файла из нашего R script.

![Снимок экрана, на котором показаны графические выходные данные порта R для устройства.](./media/r-quickstart/fig9.png)

## <a name="data-filtering-and-transformation"></a><a id="filtering"></a>Фильтрация и преобразование данных

В этом разделе мы выполним некоторые базовые операции фильтрации данных и преобразования для данных по молочной продукции Калифорнии. К концу этого раздела мы будем иметь данные в формате, подходящем для создания аналитической модели.

В частности, в этом разделе мы выполним несколько распространенных задач по очистке и преобразованию данных: преобразование типов, фильтрацию по кадрам, добавление новых вычисленных столбцов и преобразования значений. Эти базовые навыки помогут вам справиться с любыми видами задач при решении практических проблем.

Полный код R для этого раздела доступен в [мачинелеарнингсамплес-Notebooks/Studio-Samples](https://github.com/Azure-Samples/MachineLearningSamples-Notebooks/tree/master/studio-samples).

### <a name="type-transformations"></a>Преобразование типов данных

Мы уже можем считать данные по молочной продукции Калифорнии в код на R модуля [Выполнить сценарий R][execute-r-script], но нужно убедиться, что данные в столбцах имеют нужный тип и формат.

R — динамически типизированный язык. Другими словами, при необходимости типы данных преобразуются из одного в другой. Атомарные типы данных в R включают в себя числовые, логические и символьные. Факторы используются для компактного хранения категориальных данных. Дополнительные сведения о типах данных см. в ссылках на [Дополнительные материалы](#appendixb).

При считывании табличных данных в R из внешнего источника всегда рекомендуется проверять результирующие типы в столбцах. Может потребоваться столбец типа character, но во многих случаях столбец будет отображаться как коэффициент или наоборот. В других случаях столбец, который вы считаете, должен быть числовым, представленным символьными данными, например "1,23", а не 1,23 как число с плавающей запятой.

К счастью, можно легко преобразовать один тип в другой, если сопоставление возможно. Например, нельзя преобразовать "Невада" в числовое значение, но можно преобразовать его в коэффициент (переменную категории). В качестве другого примера можно преобразовать числовое значение 1 в символ «1» или «множитель».

Синтаксис любого из этих преобразований прост: `as.datatype()`. Эти функции преобразования типов включают следующие функции.

* `as.numeric()`
* `as.character()`
* `as.logical()`
* `as.factor()`

Просмотрев типы данных столбцов, введенных в предыдущем разделе, все столбцы имеют тип numeric. Исключением является столбец с именем month, который имеет тип character. Давайте преобразуйте этот тип в фактор и протестируйте результаты.

Мы удалили строку, в которой была создана матрица точечной диаграммы, и добавили строку для преобразования столбца month в фактор. В этом эксперименте мы будем вырезать и вставлять код R в окно кода модуля [выполнить сценарий R][execute-r-script] . Вы также можете обновить ZIP-файл и передать его в Машинное обучение Studio (классический), но этот параметр займет несколько шагов.

```r
## Only one of the following two lines should be used
## If running in Machine Learning Studio (classic), use the first line with maml.mapInputPort()
## If in RStudio, use the second line with read.csv()
cadairydata <- maml.mapInputPort(1)
# cadairydata  <- read.csv("cadairydata.csv", header = TRUE, stringsAsFactors = FALSE)
## Ensure the coding is consistent and convert column to a factor
cadairydata$Month <- as.factor(cadairydata$Month)
str(cadairydata) # Check the result
## The following line should be executed only when running in
## Azure Machine Learning Studio (classic)
maml.mapOutputPort('cadairydata')
```

Выполните этот код и найдите в журнале сценарий R. Соответствующие данные из журнала показаны здесь.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  9 variables:
[ModuleOutput] 
[ModuleOutput]  $ Column 0         : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year.Month       : num  1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 14 levels "Apr","April",..: 6 5 9 1 11 8 7 3 14 13 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...
[ModuleOutput] 
[ModuleOutput] [1] "Saving variable  cadairydata  ..."
[ModuleOutput] 
[ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"
```

Тип месяца должен теперь иметь уровень " **множитель/14**". Этот тип является проблемой, так как в году всего 12 месяцев. Можно также проверить, что тип в **визуализации** номера порта результирующего набора данных — **Категория**.

Проблема заключается в том, что столбец month не был закодирован систематически. В некоторых случаях месяц называется Апрель, а в других — как Apr. Мы можем решить эту проблему, выполнив усечение строки до трех символов. Теперь строка кода выглядит так, как показано в следующем примере.

```r
## Ensure the coding is consistent and convert column to a factor
cadairydata$Month <- as.factor(substr(cadairydata$Month, 1, 3))
```

Повторно запустите эксперимент и просмотрите выходной журнал. Ожидаемые результаты показаны здесь.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  9 variables:
[ModuleOutput] 
[ModuleOutput]  $ Column 0         : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year.Month       : num  1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...
[ModuleOutput] 
[ModuleOutput] [1] "Saving variable  cadairydata  ..."
[ModuleOutput] 
[ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"
```


Теперь у нашей переменной — фактора — 12 уровней, как и положено.

### <a name="basic-dataframe-filtering"></a>Базовая фильтрация кадров данных

Таблицы данных R поддерживают массу возможностей фильтрации. Наборы данных можно разбивать на подмножества, используя логическую фильтрацию по строкам или столбцам. Во многих случаях вам потребуются сложные критерии фильтрации. Подробные примеры фильтрации кадров данных [см. в](#appendixb)справочных материалах.

Для нашего набора данных необходимо выполнить фильтрацию по одному биту. Если взглянуть на столбцы в кадре данных cadairydata, вы увидите два ненужных столбца. Первый столбец содержит номер строки, который не очень удобен. Второй, Year.Month, содержит избыточную информацию. С помощью кода на R мы можем легко исключить эти столбцы.

> [!NOTE]
> Теперь в этом разделе мы покажем вам дополнительный код, который мы добавляем в модуль [выполнить сценарий R][execute-r-script] . Мы добавим каждую новую строку *перед* `str()` функцией. Мы используем эту функцию для проверки результатов в Машинное обучение Studio (классическая модель).

Добавьте следующую строку в код R в модуле [выполнение скрипта r][execute-r-script] .

```r
# Remove two columns we do not need
cadairydata <- cadairydata[, c(-1, -2)]
```

Запустите этот код в эксперименте и проверьте результат в журнале вывода. Эти результаты показаны здесь.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  7 variables:
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...
[ModuleOutput] 
[ModuleOutput] [1] "Saving variable  cadairydata  ..."
[ModuleOutput] 
[ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"
```

Теперь мы получаем ожидаемые результаты.

### <a name="add-a-new-column"></a>Добавление нового столбца

Для создания моделей временных рядов удобно иметь столбец, содержащий месяцы с начала временного ряда. Мы создадим новый столбец месяц. Count.

Чтобы упростить организацию кода, мы создадим нашу первую простую функцию `num.month()` . Затем мы будем применять эту функцию для создания нового столбца в кадре данных. Новый код выглядит следующим образом:

```r
## Create a new column with the month count
## Function to find the number of months from the first
## month of the time series
num.month <- function(Year, Month) {
  ## Find the starting year
  min.year  <- min(Year)

  ## Compute the number of months from the start of the time series
  12 * (Year - min.year) + Month - 1
}

## Compute the new column for the dataframe
cadairydata$Month.Count <- num.month(cadairydata$Year, cadairydata$Month.Number)
```

Теперь запустите обновленный эксперимент и используйте выходной журнал для просмотра результатов. Эти результаты показаны здесь.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  8 variables:
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...
[ModuleOutput] 
[ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...
[ModuleOutput] 
[ModuleOutput] [1] "Saving variable  cadairydata  ..."
[ModuleOutput] 
[ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"
```


Похоже, все работает. У нас появился новый столбец с заданными значениями.

### <a name="value-transformations"></a>Преобразование значений

В этом разделе мы выполним некоторые простые преобразования значений в некоторых столбцах таблицы данных. Язык R поддерживает практически любые преобразования значений. Дополнительные примеры см. в ссылках на дополнительные [материалы](#appendixb).

Если взглянуть на значения в сводках таблицы данных, вы увидите нечто странное. Неужели мороженого в Калифорнии производят больше, чем молока? Нет, конечно, нет. Проблема заключается в том, что единицы измерения различаются. Цена относится к единицам США фунта, молоко в 1 000 000 США фунта, то есть в единицах по 1 000 галлонов США, а промысел Мак — в единицах 1 000 фунта США. Предполагая, что число морожений составляет около 6,5 фунта на галлон, можно легко выполнить умножение, чтобы преобразовать эти значения, чтобы они были в равной мере 1 000 фунта.

Для нашей модели прогнозирования мы используем модель мультипликативные для тренда и сезонной корректировки этих данных. Преобразование журнала позволяет нам использовать линейную модель, которая упрощает этот процесс. Логарифмическое преобразование можно применить в той же функции, в которой применяется множитель.

В следующем коде мы определим новую функцию `log.transform()` и применяем ее к строкам, содержащим числовые значения. Функция R `Map()` используется для того, чтобы применить функцию `log.transform()` к выбранным столбцам таблицы данных. `Map()`Функция аналогична функции `apply()` , но она позволяет получить более чем один список аргументов для функции. Обратите внимание, что список множителей предоставляет второй аргумент функции `log.transform()` . `na.omit()`Функция используется в качестве небольшой очистки, чтобы убедиться, что в кадре данных отсутствуют или не определены значения.

```r
log.transform <- function(invec, multiplier = 1) {
  ## Function for the transformation, which is the log
  ## of the input value times a multiplier

  warningmessages <- c("ERROR: Non-numeric argument encountered in function log.transform",
                       "ERROR: Arguments to function log.transform must be greate than zero",
                       "ERROR: Aggurment multiplier to funcition log.transform must be a scaler",
                       "ERROR: Invalid time seies value encountered in function log.transform"
                       )

  ## Check the input arguments
  if(!is.numeric(invec) | !is.numeric(multiplier)) {warning(warningmessages[1]); return(NA)}  
  if(any(invec < 0.0) | any(multiplier < 0.0)) {warning(warningmessages[2]); return(NA)}
  if(length(multiplier) != 1) {{warning(warningmessages[3]); return(NA)}}

  ## Wrap the multiplication in tryCatch
  ## If there is an exception, print the warning message to
  ## standard error and return NA
  tryCatch(log(multiplier * invec),
           error = function(e){warning(warningmessages[4]); NA})
}


## Apply the transformation function to the 4 columns
## of the dataframe with production data
multipliers  <- list(1.0, 6.5, 1000.0, 1000.0)
cadairydata[, 4:7] <- Map(log.transform, cadairydata[, 4:7], multipliers)

## Get rid of any rows with NA values
cadairydata <- na.omit(cadairydata)  
```

`log.transform()`Функция работает очень немного. Большая часть кода выполняет поиск потенциальных проблем с использованием аргументов или обрабатывает исключения, которые могут возникать во время вычислений. Вычисление выполняется только для нескольких строк этого кода.

Цель защитного программирования заключается в предотвращении сбоя одной функции, которая препятствует продолжению обработки. Непредвиденный сбой длительного анализа может оказаться неприятной для пользователей. Чтобы избежать этого, необходимо выбрать значения, возвращаемые по умолчанию, что уменьшит возможные негативные последствия. Также выдается сообщение, предупреждающее пользователя о проблеме.

Если вы не использовались для защитного программирования на языке R, весь этот код может оказаться огромным. Давайте подробно рассмотрим основные шаги:

1. Определяется вектор четырех сообщений. Они используются для передачи информации о некоторых потенциальных ошибках и исключениях, которые могут возникнуть при выполнении кода.
1. Для каждого варианта возвращается значение НД. Есть и другие возможности, у которых может быть меньше побочных эффектов. Например, можно вернуть вектор нулей или исходный входной вектор.
1. Выполняются проверки аргументов функций. В каждом случае при обнаружении ошибки возвращается значение по умолчанию и создается сообщение с помощью функции `warning()`. Мы используем, а не из- `warning()` `stop()` за того, что последний прекратит выполнение, что мы пытаемся избежать. Этот код написан в виде процедурного стиля, поскольку в данном случае функциональный подход был бы сложным и запутанным.
1. Вычисления журнала переносятся в оболочку, `tryCatch()` чтобы исключения не вызывали внезапной остановки обработки. Без `tryCatch()` этого большинство ошибок, вызванных функциями R, приводят к сигналу о фатальной ошибке, что делает именно это.

Выполните этот код на R в своем эксперименте и просмотрите вывод данных в файле output.log. Теперь вы увидите преобразованные значения четырех столбцов в журнале, как показано здесь.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  8 variables:
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  1.47 1.31 1.51 1.45 1.5 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  5.82 5.9 6.1 6.06 6.17 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  7.66 7.57 7.68 7.66 7.71 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  6.89 6.79 6.79 6.8 6.8 ...
[ModuleOutput] 
[ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...
[ModuleOutput] 
[ModuleOutput] [1] "Saving variable  cadairydata  ..."
[ModuleOutput] 
[ModuleOutput] [1] "Saving the following item(s):  .maml.oport1"
```

Как мы видим, значения изменились. Молоко Рабочая среда теперь значительно превышает все остальные молочные продукты продукта, и теперь мы рассмотрим шкалу журнала.

На этом этапе наши данные очищаются, и мы готовы к некоторым моделированию. Если взглянуть на сводку визуализации для выходных данных в модуле [выполнить сценарий R][execute-r-script] , вы увидите, что столбец month имеет по категориям 12 уникальных значений, что точно так же, как нам нужно.

## <a name="time-series-objects-and-correlation-analysis"></a><a id="timeseries"></a>Объекты временного ряда и корреляционный анализ

В этом разделе мы рассмотрим несколько базовых объектов временных рядов R и проанализируем корреляции между некоторыми переменными. Нашей целью является вывод таблицы данных, содержащей парные сведения о корреляции, при нескольких задержках.

Полный код R для этого раздела приведен в [мачинелеарнингсамплес-Notebooks/Studio-Samples](https://github.com/Azure-Samples/MachineLearningSamples-Notebooks/tree/master/studio-samples).

### <a name="time-series-objects-in-r"></a>Объекты временных рядов в языке R

Как уже упоминалось, временные ряды представляют собой ряды значений данных, индексированные по времени. Объекты временных рядов на R используются для создания индексов времени и управления ними. Использование объектов временных рядов имеет несколько преимуществ. Оно избавляет от необходимости вникать в подробности управления значениями индексов временных рядов, которые уже включены в объект. Кроме того, объекты временных рядов позволяют использовать многие методы временных рядов для построения графиков, печати, моделирования и т. д.

Класс временных рядов POSIXct довольно распространен и относительно прост. Этот класс временных рядов измеряет количество времени, прошедшее с начала эры UNIX — 1 января 1970 г. В этом примере мы будем использовать объекты временных рядов POSIXct. К другим широко используемым классам объектов временных рядов R относятся Zoo и XTS (расширяемые временные ряды).

### <a name="time-series-object-example"></a>Пример объекта временных рядов

Приступим к разбору примера. Перетащите новый модуль [выполнить сценарий R][execute-r-script] в свой эксперимент. Соединим порт вывода "Итоговый набор данных 1" существующего модуля [Выполнить сценарий R][execute-r-script] с портом ввода "Набор данных 1" нового модуля [Выполнить сценарий R][execute-r-script].

Как и в первом примере, мы будем проходить через пример. В некоторых случаях в каждом шаге будут показаны только добавочные дополнительные строки кода R.

#### <a name="read-the-dataframe"></a>Чтение таблицы данных

Для начала давайте считаем таблицу данных и убедимся, что мы получили тот результат, на который рассчитывали. Эту работу может выполнить следующий код:

```r
# Comment the following if using RStudio
cadairydata <- maml.mapInputPort(1)
str(cadairydata) # Check the results
```

Теперь выполним эксперимент. Журнал новой фигуры выполнить сценарий R должен выглядеть, как в этом примере.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  8 variables:
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  1.47 1.31 1.51 1.45 1.5 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  5.82 5.9 6.1 6.06 6.17 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  7.66 7.57 7.68 7.66 7.71 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  6.89 6.79 6.79 6.8 6.8 ...
[ModuleOutput] 
[ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...
```

У этих данных ожидаемый тип и формат. Теперь столбец month имеет тип Factor и имеет ожидаемое число уровней.

#### <a name="create-a-time-series-object"></a>Создание объекта временных рядов

В нашу таблицу данных нужно добавить объект временного ряда. Замените текущий код следующим кодом, который добавляет новый столбец класса POSIXct.

```r
# Comment the following if using RStudio
cadairydata <- maml.mapInputPort(1)

## Create a new column as a POSIXct object
Sys.setenv(TZ = "PST8PDT")
cadairydata$Time <- as.POSIXct(strptime(paste(as.character(cadairydata$Year), "-", as.character(cadairydata$Month.Number), "-01 00:00:00", sep = ""), "%Y-%m-%d %H:%M:%S"))

str(cadairydata) # Check the results
```

Теперь проверьте журнал. Он должен выглядеть, как в этом примере.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  9 variables:
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  1.47 1.31 1.51 1.45 1.5 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  5.82 5.9 6.1 6.06 6.17 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  7.66 7.57 7.68 7.66 7.71 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  6.89 6.79 6.79 6.8 6.8 ...
[ModuleOutput] 
[ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...
[ModuleOutput] 
[ModuleOutput]  $ Time             : POSIXct, format: "1995-01-01" "1995-02-01" ...
```

Как мы видим, действительно появился новый столбец класса POSIXct.

### <a name="explore-and-transform-the-data"></a>Просмотр и преобразование данных

Рассмотрим некоторые из переменных в этом наборе данных. Точечная диаграмма — это хороший способ быстро получить представление. Мы заменяем `str()` функцию в предыдущем коде R следующей строкой.

```r
pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = cadairydata, main = "Pairwise Scatterplots of dairy time series")
```

Запустите этот код и посмотрите, что произойдет. График, созданный на порте устройства R, должен выглядеть, как в этом примере.

![Снимок экрана, на котором показана матрица точечной диаграммы выбранных переменных.](./media/r-quickstart/fig17.png)

В отношениях между этими переменными существуют некоторые нечетные структуры. Возможно, эта структура возникает из тенденций в данных и из того факта, что переменные не были стандартизованы.

### <a name="correlation-analysis"></a>Корреляционный анализ

Чтобы выполнить анализ корреляции, необходимо как отменить тренд и стандартизировать переменные. Можно просто использовать функцию R `scale()` , которая масштабирует переменные и размещает их по центру. Возможно, это было бы быстрее. Но рассмотрим пример защитного программирования на языке R.

`ts.detrend()`Следующая функция выполняет обе эти операции. Следующие две строки кода вычитают тренд из данных и приводят значения к одному стандарту.

```r
ts.detrend <- function(ts, Time, min.length = 3){
  ## Function to de-trend and standardize a time series

  ## Define some messages if they are NULL  
  messages <- c('ERROR: ts.detrend requires arguments ts and Time to have the same length',
                'ERROR: ts.detrend requires argument ts to be of type numeric',
                paste('WARNING: ts.detrend has encountered a time series with length less than', as.character(min.length)),
                'ERROR: ts.detrend has encountered a Time argument not of class POSIXct',
                'ERROR: Detrend regression has failed in ts.detrend',
                'ERROR: Exception occurred in ts.detrend while standardizing time series in function ts.detrend'
  )
  # Create a vector of zeros to return as a default in some cases
  zerovec  <- rep(length(ts), 0.0)

  # The input arguments are not of the same length, return ts and quit
  if(length(Time) != length(ts)) {warning(messages[1]); return(ts)}

  # If the ts is not numeric, just return a zero vector and quit
  if(!is.numeric(ts)) {warning(messages[2]); return(zerovec)}

  # If the ts is too short, just return it and quit
  if((ts.length <- length(ts)) < min.length) {warning(messages[3]); return(ts)}

  ## Check that the Time variable is of class POSIXct
  if(class(cadairydata$Time)[[1]] != "POSIXct") {warning(messages[4]); return(ts)}

  ## De-trend the time series by using a linear model
  ts.frame  <- data.frame(ts = ts, Time = Time)
  tryCatch({ts <- ts - fitted(lm(ts ~ Time, data = ts.frame))},
           error = function(e){warning(messages[5]); zerovec})

  tryCatch( {stdev <- sqrt(sum((ts - mean(ts))^2))/(ts.length - 1)
             ts <- ts/stdev},
            error = function(e){warning(messages[6]); zerovec})

  ts
}  
## Apply the detrend.ts function to the variables of interest
df.detrend <- data.frame(lapply(cadairydata[, 4:7], ts.detrend, cadairydata$Time))

## Plot the results to look at the relationships
pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = df.detrend, main = "Pairwise Scatterplots of detrended standardized time series")
```

`ts.detrend()`Функция работает очень немного. Большая часть кода выполняет поиск потенциальных проблем с использованием аргументов или обрабатывает исключения, которые могут возникать во время вычислений. Фактически, только несколько строк кода выполняют вычисления.

Мы уже обсуждали пример защитного программирования при преобразовании значений. Оба блока вычислений выполняются внутри функции `tryCatch()`. Для некоторых ошибок имеет смысл вернуть исходный входной вектор. В других случаях возвращается вектор нулей.

Обратите внимание, что линейная регрессия, использующаяся для вычитания тренда, является регрессией временного ряда. Прогнозирующая переменная — это объект временного ряда.

После `ts.detrend()` определения мы применяем его к переменным, представляющим интерес в нашем кадре данных. Необходимо привести результирующий список, созданный `lapply()` к данным в кадре данных, с помощью `as.data.frame()` . Из-за защитных аспектов `ts.detrend()` , сбой обработки одной из переменных не помешает правильной обработке других.

В последней строке кода создается парная точечная диаграмма. После выполнения кода R на рисунке показаны результаты точечной диаграммы.

![Снимок экрана, показывающий парную точечную диаграмму с нетенденциями и стандартизованными временными рядами.](./media/r-quickstart/fig18.png)

Эти результаты можно сравнить с показанными в предыдущем примере. После удаления тренда и стандартизации переменных мы видим, что взаимосвязи переменных гораздо менее структурированы.

Код для вычисления корреляций как объектов взаимнокорреляционной функции (CCF-объектов) R следующий:

```r
## A function to compute pairwise correlations from a
## list of time series value vectors
pair.cor <- function(pair.ind, ts.list, lag.max = 1, plot = FALSE){
  ccf(ts.list[[pair.ind[1]]], ts.list[[pair.ind[2]]], lag.max = lag.max, plot = plot)
}

## A list of the pairwise indices
corpairs <- list(c(1,2), c(1,3), c(1,4), c(2,3), c(2,4), c(3,4))

## Compute the list of ccf objects
cadairycorrelations <- lapply(corpairs, pair.cor, df.detrend)  

cadairycorrelations
```

При выполнении этого кода создается журнал, показанный здесь.

```output
[ModuleOutput] Loading objects:
[ModuleOutput]   port1
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] [[1]]
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] Autocorrelations of series 'X', by lag
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput]    -1     0     1 
[ModuleOutput] 0.148 0.358 0.317 
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] [[2]]
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] Autocorrelations of series 'X', by lag
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput]     -1      0      1 
[ModuleOutput] -0.395 -0.186 -0.238 
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] [[3]]
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] Autocorrelations of series 'X', by lag
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput]     -1      0      1 
[ModuleOutput] -0.059 -0.089 -0.127 
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] [[4]]
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] Autocorrelations of series 'X', by lag
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput]    -1     0     1 
[ModuleOutput] 0.140 0.294 0.293 
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] [[5]]
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput] Autocorrelations of series 'X', by lag
[ModuleOutput] 
[ModuleOutput] 
[ModuleOutput]     -1      0      1 
[ModuleOutput] -0.002 -0.074 -0.124 
```

Для каждой задержки существует значение корреляции. Все эти значения корреляции слишком малы, чтобы быть значимыми. Мы можем заключить, что можно моделировать каждую переменную независимо друг от друга.

### <a name="output-a-dataframe"></a>Вывод таблицы данных
Парные корреляции были вычислены в виде списка объектов R CCF. Это представляет определенные сложности, поскольку порту вывода "Итоговый набор данных" требуется таблица данных на R. Кроме того, объект CCF сам является списком, и нам нужны только значения в первом элементе этого списка, корреляции по разным задержкам.

Следующий код извлекает значения задержек из списка CCF-объектов, которые и сами являются списками.

```r
df.correlations <- data.frame(do.call(rbind, lapply(cadairycorrelations, '[[', 1)))

c.names <- c("correlation pair", "-1 lag", "0 lag", "+1 lag")
r.names  <- c("Corr Cot Cheese - Ice Cream",
              "Corr Cot Cheese - Milk Prod",
              "Corr Cot Cheese - Fat Price",
              "Corr Ice Cream - Mik Prod",
              "Corr Ice Cream - Fat Price",
              "Corr Milk Prod - Fat Price")

## Build a dataframe with the row names column and the
## correlation dataframe and assign the column names
outframe <- cbind(r.names, df.correlations)
colnames(outframe) <- c.names
outframe


## WARNING!
## The following line works only in Azure Machine Learning Studio (classic)
## When running in RStudio, this code will result in an error
#maml.mapOutputPort('outframe')
```

Первая строка кода немного сложна, и некоторые объяснения могут помочь вам понять ее. Работая с внутренним, у нас есть:

1. Оператор **[[[** ] с аргументом **1** выбирает вектор корреляции с отсчетом от первого элемента списка объектов CCF.
1. Функция `do.call()` применяет функцию `rbind()` к элементам списка возвращаемых значений с помощью `lapply()`.
1. Функция `data.frame()` относит результаты, полученные от `do.call()`, к таблице данных.

Обратите внимание, что имена строк находятся в столбце таблицы данных. В этом случае имена строк сохраняются, когда они выводятся из [скрипта Execute R][execute-r-script].

При выполнении кода выводится результат, показанный здесь при выборе **визуализатора** для просмотра выходных данных через порт результирующего набора данных. Имена строк находятся в первом столбце, как и предполагалось.

![Снимок экрана, показывающий выходные данные результатов анализа корреляции.](./media/r-quickstart/fig20.png)

## <a name="time-series-example-seasonal-forecasting"></a><a id="seasonalforecasting"></a>Пример временных рядов: Сезонное прогнозирование

Наши данные теперь находятся в форме, подходящей для анализа, и мы определили, что между переменными нет существенных корреляций. Пойдем дальше и создадим прогностическую модель временных рядов. Используя эту модель, мы планируем прогнозировать молоко в эксплуатацию в течение 12 месяцев с 2013.

У нашей прогностической модели будет два компонента: тренд и сезонный компонент. Окончательный прогноз будет произведением этих двух компонентов. Модели такого типа называются мультипликативными. Альтернативой является аддитивная модель. Мы уже применили преобразование журнала к интересующим переменным, что делает анализ алгоритмизируемым.

Полный код R для этого раздела приведен в [мачинелеарнингсамплес-Notebooks/Studio-Samples](https://github.com/Azure-Samples/MachineLearningSamples-Notebooks/tree/master/studio-samples).

### <a name="create-the-dataframe-for-analysis"></a>Создание кадра данных для анализа

Для начала добавьте в эксперимент новый модуль [выполнить сценарий R][execute-r-script] . Соедините порт вывода Итоговый набор данных существующего модуля [Выполнить сценарий R][execute-r-script] с портом ввода **Набор данных 1** нового модуля. Результат должен выглядеть примерно так, как показано в этом примере.

![Схема, на которой показан эксперимент с добавленным новым модулем выполнить сценарий R.](./media/r-quickstart/fig21.png)

Как и в случае недавно выполненного корреляционного анализа, нужно добавить столбец с объектом временных рядов POSIXct. Следующий код добавит столбец.

```r
# If running in Machine Learning Studio (classic), uncomment the first line with maml.mapInputPort()
cadairydata <- maml.mapInputPort(1)

## Create a new column as a POSIXct object
Sys.setenv(TZ = "PST8PDT")
cadairydata$Time <- as.POSIXct(strptime(paste(as.character(cadairydata$Year), "-", as.character(cadairydata$Month.Number), "-01 00:00:00", sep = ""), "%Y-%m-%d %H:%M:%S"))

str(cadairydata)
```

Запустите этот код и взгляните на журнал. Результат должен выглядеть, как в этом примере.

```output
[ModuleOutput] [1] "Loading variable port1..."
[ModuleOutput] 
[ModuleOutput] 'data.frame':    228 obs. of  9 variables:
[ModuleOutput] 
[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
[ModuleOutput] 
[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
[ModuleOutput] 
[ModuleOutput]  $ Month            : Factor w/ 12 levels "Apr","Aug","Dec",..: 5 4 8 1 9 7 6 2 12 11 ...
[ModuleOutput] 
[ModuleOutput]  $ Cotagecheese.Prod: num  1.47 1.31 1.51 1.45 1.5 ...
[ModuleOutput] 
[ModuleOutput]  $ Icecream.Prod    : num  5.82 5.9 6.1 6.06 6.17 ...
[ModuleOutput] 
[ModuleOutput]  $ Milk.Prod        : num  7.66 7.57 7.68 7.66 7.71 ...
[ModuleOutput] 
[ModuleOutput]  $ N.CA.Fat.Price   : num  6.89 6.79 6.79 6.8 6.8 ...
[ModuleOutput] 
[ModuleOutput]  $ Month.Count      : num  0 1 2 3 4 5 6 7 8 9 ...
[ModuleOutput] 
[ModuleOutput]  $ Time             : POSIXct, format: "1995-01-01" "1995-02-01" ...
```

В результате мы готовы начать анализ.

### <a name="create-a-training-dataset"></a>Создание набора данных для обучения

В созданном кадре данных необходимо создать набор для обучения. Эти данные будут включать все наблюдения за исключением последних 12 (за 2013 год), которые станут тестовым набором данных. Приведенный ниже код разбивает таблицу данных на подмножества и создает графики переменных: цены и производства молочных продуктов. Затем мы создадим графику четырех переменных Production и Price. Анонимная функция используется для определения приращений графика и последующей итерации для списка оставшихся двух аргументов с помощью `Map()`. Если вы думаете, что цикл for будет работать здесь, вы можете правильно. Но поскольку R — функциональный язык, мы рассмотрим функциональный подход.

```r
cadairytrain <- cadairydata[1:216, ]

Ylabs  <- list("Log CA Cotage Cheese Production, 1000s lb",
               "Log CA Ice Cream Production, 1000s lb",
               "Log CA Milk Production 1000s lb",
               "Log North CA Milk Milk Fat Price per 1000 lb")

Map(function(y, Ylabs){plot(cadairytrain$Time, y, xlab = "Time", ylab = Ylabs, type = "l")}, cadairytrain[, 4:7], Ylabs)
```

При выполнении кода создается серия графиков временных рядов из выходных данных устройства R, показанных здесь. Ось времени относится к единицам дат, что является хорошим преимуществом метода построения временных рядов.

![Первый график с данными о производстве и ценах на продукты в Калифорнии.](./media/r-quickstart/unnamed-chunk-161.png)

![Вторая диаграмма временных рядов данных по производству и цене продуктов в Калифорнии.](./media/r-quickstart/unnamed-chunk-162.png)

![Третий график временных рядов данных по производству и цене продуктов в Калифорнии.](./media/r-quickstart/unnamed-chunk-163.png).

![Четвертый график временных рядов данных по производству и цене продуктов в Калифорнии](./media/r-quickstart/unnamed-chunk-164.png)

### <a name="a-trend-model"></a>Модель тренда

Теперь, когда мы создали объект временных рядов и Просмотрели данные, давайте начнем создать модель тренда для производственных данных в Калифорнии молоко. Можно использовать регрессию временных рядов. Это ясно из графика, что нам потребуется больше, чем наклон и перехватить, чтобы точно моделировать наблюдаемую тенденцию в обучающих данных.

Учитывая небольшой масштаб данных, мы создадим модель для тренда в RStudio, а затем вырежьте и вставьте полученную модель в Машинное обучение Studio (классический). RStudio предоставляет интерактивную среду для такого рода интерактивного анализа.

При первой попытке мы будем пытаться регрессию с степенью полинома до трех. Существуют реальные опасности чрезмерного подгонки этих типов моделей. Лучше избегать условий высокого порядка. `I()`Функция запрещает интерпретацию содержимого (интерпретирует содержимое как есть) и позволяет писать буквально интерпретируемую функцию в уравнении регрессии.

```r
milk.lm <- lm(Milk.Prod ~ Time + I(Month.Count^2) + I(Month.Count^3), data = cadairytrain)
summary(milk.lm)
```

Эта функция создает следующие выходные данные.

```output
##
## Call:
## lm(formula = Milk.Prod ~ Time + I(Month.Count^2) + I(Month.Count^3),
##     data = cadairytrain)
##
## Residuals:
##      Min       1Q   Median       3Q      Max
## -0.12667 -0.02730  0.00236  0.02943  0.10586
##
## Coefficients:
##                   Estimate Std. Error t value Pr(>|t|)
## (Intercept)       6.33e+00   1.45e-01   43.60   <2e-16 ***
## Time              1.63e-09   1.72e-10    9.47   <2e-16 ***
## I(Month.Count^2) -1.71e-06   4.89e-06   -0.35    0.726
## I(Month.Count^3) -3.24e-08   1.49e-08   -2.17    0.031 *  
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
##
## Residual standard error: 0.0418 on 212 degrees of freedom
## Multiple R-squared:  0.941,    Adjusted R-squared:  0.94
## F-statistic: 1.12e+03 on 3 and 212 DF,  p-value: <2e-16
```

Из значений P ( `Pr(>|t|)` ) в этих выходных данных видно, что квадратный термин может быть несущественным. Мы будем использовать `update()` функцию для изменения этой модели, удалив квадратный термин.

```r
milk.lm <- update(milk.lm, . ~ . - I(Month.Count^2))
summary(milk.lm)
```

Эта функция создает следующие выходные данные.

```output
##
## Call:
## lm(formula = Milk.Prod ~ Time + I(Month.Count^3), data = cadairytrain)
##
## Residuals:
##      Min       1Q   Median       3Q      Max
## -0.12597 -0.02659  0.00185  0.02963  0.10696
##
## Coefficients:
##                   Estimate Std. Error t value Pr(>|t|)
## (Intercept)       6.38e+00   4.07e-02   156.6   <2e-16 ***
## Time              1.57e-09   4.32e-11    36.3   <2e-16 ***
## I(Month.Count^3) -3.76e-08   2.50e-09   -15.1   <2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
##
## Residual standard error: 0.0417 on 213 degrees of freedom
## Multiple R-squared:  0.941,  Adjusted R-squared:  0.94
## F-statistic: 1.69e+03 on 2 and 213 DF,  p-value: <2e-16
```

Эти выходные данные выглядят лучше. Остались только значимые члены. Значение 2e-16 — это значение по умолчанию, которое не должно быть слишком серьезно.  

Для проверки корректности создадим график временных рядов данных молочного производства Калифорнии с использованием полученной линии тренда. Мы добавили следующий код в Машинное обучение Studio (классическая модель) для [выполнения скрипта R][execute-r-script] (не RStudio), чтобы создать модель и создать график. Результат показан в следующем примере.

```r
milk.lm <- lm(Milk.Prod ~ Time + I(Month.Count^3), data = cadairytrain)

plot(cadairytrain$Time, cadairytrain$Milk.Prod, xlab = "Time", ylab = "Log CA Milk Production 1000s lb", type = "l")
lines(cadairytrain$Time, predict(milk.lm, cadairytrain), lty = 2, col = 2)
```

![Данные молочного производства Калифорнии с моделью тренда](./media/r-quickstart/unnamed-chunk-18.png)

Как видим, модель тренда идеально соответствует данным. Кроме того, кажется, что нет свидетельства о чрезмерном доведении, например нечетной вигглес в кривой модели.

### <a name="seasonal-model"></a>Сезонная модель

Получив модель тренда, можно двигаться дальше и добавить сезонные составляющие. Мы будем использовать месяц года в качестве фиктивной переменной в линейной модели, чтобы записать помесячный результат. При вводе в модель переменных фактора пересечение не должно вычисляться. Если этого не сделать, формула будет чрезмерно заданной, а R удалит один из необходимых факторов, но сохранит условие перехвата.

Так как у нас есть удовлетворительная модель тренда, мы можем использовать `update()` функцию для добавления новых терминов в существующую модель. -1 в формуле обновления удаляет определяющий смещение член. Теперь продолжим в RStudio:

```r
milk.lm2 <- update(milk.lm, . ~ . + Month - 1)
summary(milk.lm2)
```

Эта функция создает следующие выходные данные.

```output
##
## Call:
## lm(formula = Milk.Prod ~ Time + I(Month.Count^3) + Month - 1,
##     data = cadairytrain)
##
## Residuals:
##      Min       1Q   Median       3Q      Max
## -0.06879 -0.01693  0.00346  0.01543  0.08726
##
## Coefficients:
##                   Estimate Std. Error t value Pr(>|t|)
## Time              1.57e-09   2.72e-11    57.7   <2e-16 ***
## I(Month.Count^3) -3.74e-08   1.57e-09   -23.8   <2e-16 ***
## MonthApr          6.40e+00   2.63e-02   243.3   <2e-16 ***
## MonthAug          6.38e+00   2.63e-02   242.2   <2e-16 ***
## MonthDec          6.38e+00   2.64e-02   241.9   <2e-16 ***
## MonthFeb          6.31e+00   2.63e-02   240.1   <2e-16 ***
## MonthJan          6.39e+00   2.63e-02   243.1   <2e-16 ***
## MonthJul          6.39e+00   2.63e-02   242.6   <2e-16 ***
## MonthJun          6.38e+00   2.63e-02   242.4   <2e-16 ***
## MonthMar          6.42e+00   2.63e-02   244.2   <2e-16 ***
## MonthMay          6.43e+00   2.63e-02   244.3   <2e-16 ***
## MonthNov          6.34e+00   2.63e-02   240.6   <2e-16 ***
## MonthOct          6.37e+00   2.63e-02   241.8   <2e-16 ***
## MonthSep          6.34e+00   2.63e-02   240.6   <2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
##
## Residual standard error: 0.0263 on 202 degrees of freedom
## Multiple R-squared:     1,    Adjusted R-squared:     1
## F-statistic: 1.42e+06 on 14 and 202 DF,  p-value: <2e-16
```

Мы видим, что в модели отсутствует определяющий смещение член, но есть 12 значимых факторов месяца. Этот результат — именно то, что мы хотели видеть.

Построим еще один график временного ряда данных по молочному производству Калифорнии, чтобы проверить работу модели. Мы добавили следующий код в Машинное обучение Studio (классический) для [выполнения сценария R][execute-r-script] , чтобы создать модель и построить график.

```r
milk.lm2 <- lm(Milk.Prod ~ Time + I(Month.Count^3) + Month - 1, data = cadairytrain)

plot(cadairytrain$Time, cadairytrain$Milk.Prod, xlab = "Time", ylab = "Log CA Milk Production 1000s lb", type = "l")
lines(cadairytrain$Time, predict(milk.lm2, cadairytrain), lty = 2, col = 2)
```

Выполнение этого кода в Машинное обучение Studio (классическая модель) создает график, показанный здесь.

![Данные молочного производства Калифорнии с моделью, включающей сезонные составляющие](./media/r-quickstart/unnamed-chunk-20.png)

По размеру данных, показанных в этом примере, достаточно поощрение. И тренд, и сезонная составляющая (в помесячном варианте) выглядят вполне разумно.

В качестве еще одной проверки нашей модели рассмотрим остатки. Приведенный ниже код вычисляет прогнозируемые значения наших двух моделей, вычисляет остатки для сезонной модели и отображает эти остатки для данных для обучения.

```r
## Compute predictions from our models
predict1  <- predict(milk.lm, cadairydata)
predict2  <- predict(milk.lm2, cadairydata)

## Compute and plot the residuals
residuals <- cadairydata$Milk.Prod - predict2
plot(cadairytrain$Time, residuals[1:216], xlab = "Time", ylab ="Residuals of Seasonal Model")
```

Остаточная диаграмма показана здесь.

![Остатки сезонной модели для обучающих данных.](./media/r-quickstart/unnamed-chunk-21.png)

Выглядит вполне логично. Нет никакой конкретной структуры, за 2008-2009 исключением того, что в ней не учитывается, что наша модель не особо хорошо важна.

График, показанный в этом примере, полезен для обнаружения всех шаблонов, зависящих от времени, в остатках. Явный подход к вычислениям и отображения остаточных остатков помещает остатки по времени на график. Если бы мы работали с графиком `milk.lm$residuals` , график не был бы в порядке времени.

Для построения ряда диагностических диаграмм можно также использовать функцию `plot.lm()`.

```r
## Show the diagnostic plots for the model
plot(milk.lm2, ask = FALSE)
```

Этот код создает ряд диагностических диаграмм, показанных в следующих примерах.

![Первая диагностическая диаграмма для сезонной модели.](./media/r-quickstart/unnamed-chunk-221.png)

![Вторая диагностическая диаграмма для сезонной модели.](./media/r-quickstart/unnamed-chunk-222.png)

![Третья диагностическая диаграмма для сезонной модели.](./media/r-quickstart/unnamed-chunk-223.png)

![Четвертая диагностическая диаграмма для сезонной модели.](./media/r-quickstart/unnamed-chunk-224.png)

На этих диаграммах можно увидеть несколько точек влияния, но они не дают поводов для серьезного беспокойства. Кроме того, в обычной графике Q-Q можно увидеть, что остаточные остатки близки к нормальному распространению, что является важным предположением для линейных моделей.

### <a name="forecasting-and-model-evaluation"></a>Прогнозирование и оценка моделей

Для выполнения нашего примера нужно выполнить еще одну задачу. Необходимо рассчитать прогнозы и измерить их отклонения от фактических данных. Составим прогноз на 12 месяцев 2013 года. Можно вычислить меру ошибок для этого прогноза до реальных данных, которые не являются частью нашего обучающего набора данных. Кроме того, можно сравнить эффективность, используя учебные данные за 18 лет и тестовые данные за 12 месяцев.

Для измерения эффективности моделей временных рядов используется несколько показателей. В нашем случае мы будем использовать ошибку root среднего квадрата (RMS). Следующая функция вычисляет среднеквадратическое отклонение между двумя рядами.

```r
RMS.error <- function(series1, series2, is.log = TRUE, min.length = 2){
  ## Function to compute the RMS error or difference between two
  ## series or vectors

  messages <- c("ERROR: Input arguments to function RMS.error of wrong type encountered",
                "ERROR: Input vector to function RMS.error is too short",
                "ERROR: Input vectors to function RMS.error must be of same length",
                "WARNING: Funtion rms.error has received invald input time series.")

  ## Check the arguments
  if(!is.numeric(series1) | !is.numeric(series2) | !is.logical(is.log) | !is.numeric(min.length)) {
    warning(messages[1])
    return(NA)}

  if(length(series1) < min.length) {
    warning(messages[2])
    return(NA)}

  if((length(series1) != length(series2))) {
       warning(messages[3])
    return(NA)}

  ## If is.log is TRUE exponentiate the values, else just copy
  if(is.log) {
    tryCatch( {
      temp1 <- exp(series1)
      temp2 <- exp(series2) },
      error = function(e){warning(messages[4]); NA}
    )
  } else {
    temp1 <- series1
    temp2 <- series2
  }

 ## Compute predictions from our models
predict1  <- predict(milk.lm, cadairydata)
predict2  <- predict(milk.lm2, cadairydata)

## Compute the RMS error in a dataframe
  tryCatch( {
    sqrt(sum((temp1 - temp2)^2) / length(temp1))},
    error = function(e){warning(messages[4]); NA})
}
```

Как и в `log.transform()` случае с функцией, о которой мы обсуждали в разделе «преобразования значений», в этой функции существует довольно много проверок ошибок и кода восстановления исключений. Задействованы те же принципы. Работа выполняется двумя фрагментами кода внутри функций `tryCatch()`. Во первых, временные ряды возведен, так как мы работаем с журналами значений. Во втором фрагменте вычисляется фактическое среднеквадратическое отклонение.

С помощью функции для измерения ошибки RMS давайте создадим и выберем кадр данных, содержащий ошибки RMS. Мы будем включать термины только для модели тренда и полную модель с сезонными факторами. Следующий код выполняет задание, используя две созданные линейные модели.

```r
## Compute the RMS error in a dataframe
## Include the row names in the first column so they will
## appear in the output of the Execute R Script
RMS.df  <-  data.frame(
rowNames = c("Trend Model", "Seasonal Model"),
  Traing = c(
  RMS.error(predict1[1:216], cadairydata$Milk.Prod[1:216]),
  RMS.error(predict2[1:216], cadairydata$Milk.Prod[1:216])),
  Forecast = c(
    RMS.error(predict1[217:228], cadairydata$Milk.Prod[217:228]),
    RMS.error(predict2[217:228], cadairydata$Milk.Prod[217:228]))
)
RMS.df

## The following line should be executed only when running in
## Azure Machine Learning Studio (classic)
maml.mapOutputPort('RMS.df')
```

Выполнение этого кода приводит к получению выходных данных, показанных на выходном порте результирующего набора данных.

![Снимок экрана, показывающий сравнение ошибок RMS для моделей.](./media/r-quickstart/fig26.png)

Как видно по этим результатам, после добавления к модели сезонных факторов среднеквадратическое отклонение значительно уменьшилось. Вполне ожидаемо, что отклонение для учебных данных чуть меньше, чем для прогноза.

## <a name="guide-to-rstudio-documentation"></a><a id="appendixa"></a>Руководство по RStudio документации

RStudio хорошо документирована. Ниже приведены ссылки на основные разделы документации по RStudio, чтобы приступить к работе.

* **Создание проектов**. Вы можете организовать код R и управлять ими в проектах с помощью RStudio. Дополнительные сведения см. [в разделе Использование проектов](https://support.rstudio.com/hc/articles/200526207-Using-Projects). Следуйте этим инструкциям и создайте проект для примеров кода R в этой статье.
* **Редактирование и выполнение кода r**. RStudio предоставляет интегрированную среду для редактирования и выполнения кода r. Дополнительные сведения см. в разделе [Редактирование и исполнение кода](https://support.rstudio.com/hc/articles/200484448-Editing-and-Executing-Code).
* **Отладка**: RStudio включает мощные возможности отладки. Дополнительные сведения об этих функциях см. [в разделе Отладка с помощью RStudio](https://support.rstudio.com/hc/articles/200713843-Debugging-with-RStudio). Дополнительные сведения о возможностях устранения неполадок в [точке останова см.](https://support.rstudio.com/hc/articles/200534337-Breakpoint-Troubleshooting)

## <a name="further-reading"></a><a id="appendixb"></a>Дополнительные материалы

В этом руководстве по программированию на языке R рассматриваются основы использования языка R с Машинное обучение Studio (классическая модель). Если вы не знакомы с R, в CRAN доступны два введения:

* Для начала лучше всего начать с [R для начинающих](https://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf) с Paradis Emmanuel.
* [Введение в R](https://cran.r-project.org/doc/manuals/R-intro.html) by W. N. Венаблес et al. переходит на более глубокое рассмотрение.

Существует множество книг по R, которые помогут вам приступить к работе:

* **Искусство программирования на языке r. Обзор статистической архитектуры программного обеспечения** с помощью Норман матлофф — это отличное введение в программирование на r.
* **R Cookbook** по пол титор предоставляет подход с проблемами и решением для использования языка R.
* **R в действии** Роберт кабакофф — еще одна полезная вводная книга. Вспомогательный [веб-сайт Quick R](https://www.statmethods.net/) — это полезный ресурс.
* **Inferno адскийа** Патрик-это юмористическом книга, которая работает с несколькими сложными и сложными темами, которые могут возникнуть при программировании на R. Книга доступна бесплатно на сайте [R Inferno адский](https://www.burns-stat.com/documents/books/the-r-inferno/).
* **Расширенный r** by Hadley Wickham предоставляет подробный обзор дополнительных тем в R. Интерактивная версия этой книги доступна бесплатно на [Advanced R](http://adv-r.had.co.nz/).
* **Ввод временных рядов с r** по пол Ковпертваит и Эндрю меткалфе предоставляет общие сведения об использовании R для анализа временных рядов. Множество других теоретических работ содержат примеры на языке R.

Ниже приведены некоторые полезные Интернет – ресурсы.

* [Представление задач Cran: анализ временных рядов](https://cran.r-project.org/web/views/TimeSeries.html) содержит каталог пакетов временных рядов R. Сведения о конкретных пакетах объектов временных рядов см. в документации по этому пакету.
* [Введение в r](https://www.datacamp.com/courses/introduction-to-r) — бесплатный интерактивный курс от объекта Camp, который научит R в комфортном браузере с помощью видеороликов и упражнений по написанию кода. Здесь представлены интерактивные учебники по последним методам кодирования на R и пакетам R.
* [Знакомство с программированием R — полное пошаговое руководством](https://www.datamentor.io/r-programming/) по работе с инструктором.
* У [программиста r](https://r-coder.com/) есть подробные руководства r и бесплатный курс r для начинающих.
* Руководство [R](https://www.cyclismo.org/tutorial/R/) по Келли черного от Кларксон университета — это краткий учебник.
* [Лучшие ресурсы по языку R для улучшения ваших навыков работы с данными](https://www.computerworld.com/article/2497464/business-intelligence-60-r-resources-to-improve-your-data-skills.html) содержат более 60 ресурсов R.

<!-- Module References -->
[execute-r-script]: /azure/machine-learning/studio-module-reference/execute-r-script
