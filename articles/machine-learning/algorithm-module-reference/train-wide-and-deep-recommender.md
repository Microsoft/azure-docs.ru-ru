---
title: Использование модуля углубленной рекомендации "обучение на уровне &"
titleSuffix: Azure Machine Learning
description: Узнайте, как использовать модуль углубленной рекомендации "обучение на уровне &" в конструкторе Машинное обучение Azure для обучения модели рекомендаций.
services: machine-learning
ms.service: machine-learning
ms.subservice: core
ms.topic: reference
author: likebupt
ms.author: keli19
ms.date: 06/12/2020
ms.openlocfilehash: d7dd7105ddb0d6503faefb996b84c0e53a62ce49
ms.sourcegitcommit: 867cb1b7a1f3a1f0b427282c648d411d0ca4f81f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "104655382"
---
# <a name="train-wide--deep-recommender"></a>Обучение углубленным & глубоким Советом
В этой статье описывается, как использовать модуль **углубленной рекомендации "обучение на уровне &** " в конструкторе машинное обучение Azure для обучения модели рекомендаций. Этот модуль основан на расширенном & глубоком обучении, предлагаемом Google.

Модуль **углубленной рекомендацией по Обучению &а** считывает набор данных для оценки пользовательских элементов и, при необходимости, некоторые функции пользователей и элементов. Он возвращает обученный широкий & подробный Совет.  После этого обученную модель можно использовать для создания прогнозов или рекомендаций рейтинга с помощью модуля [рекомендаций оценки Wide и Deep](score-wide-and-deep-recommender.md) .  

## <a name="more-about-recommendation-models-and-the-wide--deep-recommender"></a>Дополнительные сведения о моделях рекомендаций и расширенном & глубоком Совете  

Основная цель системы рекомендаций — рекомендовать один или несколько *элементов* *пользователям* системы. В качестве примеров элементов можно привести фильм, ресторан, книгу или песню. Пользователь может быть отдельным лицом, группой лиц или другой сущностью с предпочтениями элементов.  

Существует два основных подхода к системам рекомендаций. 

+ Первый — подход, **основанный на содержимом**, который использует признаки для пользователей и для элементов. Пользователи могут описываться свойствами, такими как возраст и пол, а элементы — такими свойствами, как автор и изготовитель. Типичные примеры систем рекомендаций на основе содержимого можно найти на сайтах знакомств. 
+ Второй подход — **совместная фильтрация**. При этом подходе используются только идентификаторы пользователей и элементы, и система получает неявные сведения об этих сущностях из (разреженной) матрицы оценок, присвоенных элементам пользователями. Мы можем получить сведения о пользователе на основе оцененных им элементов и пользователей, которые оценили те же элементы.  

Широкий & глубокой рекомендацией сочетает эти подходы, используя совместную фильтрацию с подходом, основанным на содержимом. Поэтому эта модель считается **гибридной моделью рекомендаций**. 

Как это работает: когда пользователь относительно неизвестен в системе, прогнозы улучшаются за счет использования сведений о функции пользователя, тем самым устраняя хорошо известную проблему "холодного" запуска. Однако после сбора достаточного количества оценок от конкретного пользователя можно создавать для него полностью персонализированные прогнозы на основе конкретных оценок, а не только признаков. Следовательно, происходит плавный переход от рекомендаций на основе содержимого к рекомендациям на основе совместной фильтрации. Даже если функции пользователя или элемента недоступны, широкие & глубоким рекомендацией по-прежнему будут работать в режиме фильтрации совместной работы.  

Дополнительные сведения о расширенном & глубоком Совете и его базовом алгоритме вероятностная можно найти в соответствующем справочном документе: [широкие & глубокое обучение для систем рекомендаций](https://arxiv.org/pdf/1606.07792.pdf).  

## <a name="how-to-configure-train-wide--deep-recommender"></a>Как настроить углубленную рекомендацию по обучению &  

+ [Подготовка обучающих данных](#prepare-data)
+ [Обучение модели](#train-the-model)

### <a name="prepare-data"></a>Подготовка данных

Прежде чем пытаться использовать модуль, важно, чтобы данные были в формате, ожидаемом моделью рекомендаций. Необходим обучающий набор данных по **оценке пользовательских элементов** , но можно также включить пользовательские функции и функции элементов (если они доступны) в отдельные наборы данных.

#### <a name="required-dataset-of-user-item-ratings"></a>Набор данных, необходимый для оценки пользовательских элементов

Входные данные, используемые для обучения, должны содержать верный тип данных в правильном формате: 

+ Первый столбец должен содержать идентификаторы пользователей.
+ Второй столбец должен содержать идентификаторы элементов.
+ Третий столбец содержит рейтинг для пары "пользователь-элемент". Значения рейтинга должны быть числовыми типами. 

Например, типичный набор оценок пользовательских элементов может выглядеть следующим образом:

|UserId|мовиеид|Рейтинг|
|------------|-------------|------------|
|1|68646|10|
|223|31381|10|

#### <a name="user-features-dataset-optional"></a>Набор данных пользовательских функций (необязательно)

Набор данных **пользовательских функций** должен содержать идентификаторы для пользователей и использовать те же идентификаторы, которые были указаны в первом столбце набора «пользователи-элементы-рейтинги». Остальные столбцы могут содержать любое количество функций, описывающих пользователей.  

Например, типичный набор пользовательских функций может выглядеть следующим образом: 

|UserId|возраст;|пол;|Расчета|Расположение|
|------------|--------------|-----------------------|---------------|------------|
|1|25|Мужской| Драма    |Европа|
|223|40|Женский|Зима|Азия|

#### <a name="item-features-dataset-optional"></a>Набор данных «функции элемента» (необязательно)

Набор признаков элементов должен содержать идентификаторы элементов в первом столбце. Остальные столбцы могут содержать любое количество описательных функций для элементов.  

Например, типичный набор функций элемента может выглядеть следующим образом:  

|мовиеид|Заголовок|Исходный язык|Жанров|Year;|
|-------------|-------------|-------------------|-----------|---------------|
|68646|Годфасер|Английский|Драма|1972|
|31381|Пропало с обмоткой|Английский|Журнал|1939|

### <a name="train-the-model"></a>Обучение модели

1.  Добавьте модуль " **обучение для всех и глубоких рекомендаций** " к эксперименту в конструкторе и подключите его к набору данных для обучения.  
  
2. Если у вас есть отдельный набор данных о пользовательских функциях и (или) функциях элемента, подключите их к модулю **обучения для всех уровней** .  
  
    - **Набор данных пользовательских функций**: Соедините набор данных, описывающий пользователей, со вторым входом.
    - **Набор функций элемента DataSet**: Соедините набор данных, описывающий элементы, с третьим входом.  
    
3.  **Эпохи**: указывает, сколько раз алгоритм должен обработать все обучающие данные. 

    Чем больше это значение, тем более адекватно обучение; Тем не менее, затраты на обучение больше и могут привести к чрезмерному перегонкам.

4. **Размер пакета**: введите количество учебных примеров, используемых в одном шаге обучения. 

     Этот параметр может повлиять на скорость обучения. Более высокий размер пакета приводит к уменьшению затрат времени, но может увеличить время конвергенции. Если пакет слишком велик для использования GPU или ЦП, может возникнуть ошибка памяти.

5.  **Оптимизатор широкой части**: выберите один оптимизатор, чтобы применить градиенты к широкой части модели.

6.  **Широкий темп обучения оптимизатора**: введите число от 0,0 до 2,0, определяющее скорость обучения для оптимизатора широкой части.

    Этот параметр определяет размер шага на каждом этапе обучения при переходе к функции минимума потери. Слишком большой темп обучения может вызвать переход на прыжка, в то время как слишком маленький темп обучения может вызвать проблему конвергенции.

7.  **Измерение перекрестной функции**: введите размер измерения, введя нужные идентификаторы пользователей и функции идентификаторов элементов. 

    В расширенной & глубокой рекомендацией по умолчанию выполняется преобразование между продуктами по идентификатору пользователя и идентификатору элемента. Полученный результат будет хэширован в соответствии с этим числом, чтобы гарантировать измерение.

8.  **Оптимизация глубокой части**: выберите один оптимизатор, чтобы применить градиенты к глубокой части модели.

9.  **Скорость обучения глубокой оптимизации**: введите число от 0,0 до 2,0, определяющее частоту обучения оптимизатора глубокой части.

10.  **Измерение внедрения пользователей**. Введите целое число, чтобы указать измерение внедрения идентификатора пользователя.

     Расширенная & глубокая рекомендация создает общие встраивания идентификатора пользователя и внедрение идентификаторов элементов для широкой и глубокой части.

11.  **Измерение внедрения элемента**: Введите целое число, чтобы указать измерение внедрения идентификатора элемента.

12.  Функции категоризации: **внедренное измерение**. Введите целое число, чтобы указать измерения для внедрения функций по категориям.

     В глубоком компоненте расширенного & глубокой рекомендацией для каждой функции категоризации применяется вектор внедрения. И эти векторы внедрения используют одно и то же измерение.

13.  **Скрытые единицы**: введите число скрытых узлов глубокого компонента. Номера узлов в каждом слое разделяются запятыми. Например, тип "1 000 500 100" указывает, что глубокий компонент имеет три слоя, а первый слой — в последнем — 1000 узлов, 500 узлов и 100 узлов.

14.  **Функция активации**: выберите одну функцию активации, применяемую к каждому слою, значение по умолчанию — Релу.

15.  **Выпадение**: введите число от 0,0 до 1,0, чтобы определить вероятность того, что выходные данные будут удалены в каждом слое во время обучения.

     Выпадение сигнала — это метод регулярного появления, предотвращающий перегонку нейронных сетей. Одно из распространенных решений для этого значения — начать с 0,5, что кажется близким к оптимальному для широкого спектра сетей и задач.

16.  **Нормализация пакетов**. Выберите этот параметр, чтобы использовать нормализацию пакетной службы после каждого скрытого слоя в компоненте Deep.

     Нормализация пакетов — это методика борьбы с внутренней проблемой ковариаций-сдвига при обучении сетей. Как правило, это помогает повысить скорость, производительность и стабильность сетей. 

17.  Запустили конвейер.

## <a name="results"></a>Результаты

После завершения выполнения конвейера, чтобы использовать модель для оценки, подключайтесь к расширению и глубоким [рекомендациям обучения](train-wide-and-deep-recommender.md) , чтобы [оценить широкие и глубокий рекомендации](score-wide-and-deep-recommender.md), чтобы прогнозировать значения для новых входных примеров.

##  <a name="technical-notes"></a>Технические примечания

Широкие & подробное обучение широкими линейными моделями и глубокими нейронными сетями для объединения преимуществ запоминания и обобщения. Широкий компонент принимает набор необработанных функций и преобразований функций для запоминания взаимодействий с функциями. И с меньшим проектированием признаков, глубокий компонент обобщается с незамеченными сочетаниями функций с помощью низкоуровневого сжатия. 

В реализации расширенного & глубокой рекомендацией модуль использует структуру модели по умолчанию. Широкий компонент берет на себя внедрение пользователей, внедрение элементов и преобразование идентификаторов пользователей и идентификаторов элементов в качестве входных данных. Для глубокой части модели внедренный вектор — это описание каждого из функций категории. Вместе с другими числовыми векторами признаков эти векторы затем поступают в нейронную сеть с более глубокой подачей. Общая часть и глубокая часть объединяются путем суммирования итогового журнала вывода, что в итоге приводит к одной общей функции потери для совместного обучения.


## <a name="next-steps"></a>Дальнейшие действия

См. [набор модулей, доступных](module-reference.md) в машинное обучение Azure. 
