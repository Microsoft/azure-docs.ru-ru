---
title: Устранение неполадок в работе Azure Data Lake Analytics сбоев заданий U-SQL из-за платформа .NET Framework обновления 4.7.2
description: Устранение ошибок заданий U-SQL из-за обновления до платформа .NET Framework 4.7.2.
ms.reviewer: jasonh
ms.service: data-lake-analytics
ms.topic: troubleshooting
ms.date: 10/11/2019
ms.openlocfilehash: ab03ea8a88187289f5dce55f8a396a9d51346a3f
ms.sourcegitcommit: 772eb9c6684dd4864e0ba507945a83e48b8c16f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "92217683"
---
# <a name="azure-data-lake-analytics-is-upgrading-to-the-net-framework-v472"></a>Azure Data Lake Analytics выполняется обновление до платформа .NET Framework v 4.7.2

Среда выполнения по умолчанию Azure Data Lake Analytics обновляется с платформа .NET Framework v 4.5.2 до платформа .NET Framework v 4.7.2. Это изменение создает небольшой риск критических изменений, если в коде U-SQL используются пользовательские сборки, и эти пользовательские сборки используют библиотеки .NET.

Это обновление с платформа .NET Framework 4.5.2 до версии 4.7.2 означает, что платформа .NET Framework, развернутые в среде выполнения U-SQL (среда выполнения по умолчанию), теперь всегда будет 4.7.2. Для платформа .NET Framework версий не существует параллельного варианта.

После выполнения этого обновления до платформа .NET Framework 4.7.2 управляемый код системы будет выполняться как версия 4.7.2. пользовательские библиотеки, такие как настраиваемые сборки U-SQL, будут работать в режиме обратной совместимости, подходящем для версии, для которой была создана сборка.

- Если библиотеки DLL сборки созданы для версии 4.5.2, развернутая платформа будет рассматривать их как библиотеки 4.5.2, предоставляя (с некоторыми исключениями) семантику 4.5.2.
- Теперь вы можете использовать пользовательские сборки U-SQL, которые используют функции версии 4.7.2, если вы нацелены на платформа .NET Framework 4.7.2.

Из-за этого обновления до платформа .NET Framework 4.7.2 можно внести критические изменения в задания U-SQL, использующие пользовательские сборки .NET. Мы рекомендуем проверить наличие проблем обратной совместимости, используя приведенную ниже процедуру.

## <a name="how-to-check-for-backwards-compatibility-issues"></a>Проверка на наличие проблем обратной совместимости

Проверьте потенциальные проблемы, связанные с обратной совместимостью, выполнив проверки совместимости .NET для кода .NET в пользовательских сборках U-SQL.

> [!Note]
> Средство не обнаруживает фактические критические изменения. Он только определяет вызванные API-интерфейсы .NET, которые могут вызывать проблемы (для определенных входных данных). Если вы получите оповещение о возникшей ошибке, код может быть по-прежнему подойдет, но вы должны просмотреть дополнительные сведения.

1. Запустите средство проверки обратной совместимости для DLL-библиотек .NET с помощью
   1. Использование расширения Visual Studio в [расширении Visual Studio для анализатора переносимости .NET](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer)
   1. Загрузка и использование автономного средства из [GitHub дотнетапипорт](https://github.com/microsoft/dotnet-apiport). Инструкции по запуску автономного средства находятся на сайте [GitHub дотнетапипорт критические изменения](https://github.com/microsoft/dotnet-apiport/blob/dev/docs/HowTo/BreakingChanges.md)
   1. Для 4.7.2. совместимость, `read isRetargeting == True` выявляет возможные проблемы.
2. Если средство указывает, может ли код влиять на возможную обратную несовместимость (некоторые распространенные примеры несовместимости перечислены ниже), можно дополнительно проверить
   1. Анализ кода и определение, передает ли ваш код значения затронутым API
   1. Выполните проверку времени выполнения. Развертывание среды выполнения не выполняется параллельно в ADLA. Перед обновлением можно выполнить проверку среды выполнения, используя локальный запуск VisualStudio с локальной платформа .NET Framework 4.7.2 с репрезентативным набором данных.
3. Если вы действительно оказываете влияние на обратную несовместимость, выполните необходимые действия для ее исправления (например, для исправления логики данных или кода).

В большинстве случаев не следует повлиять на обратную несовместимость.

## <a name="timeline"></a>Сроки

Вы можете проверить развертывание новой среды выполнения в статье [Устранение неполадок среды выполнения](runtime-troubleshoot.md), а также просмотреть все предыдущие выполненные задания.

### <a name="what-if-i-cant-get-my-code-reviewed-in-time"></a>Что делать, если я не могу просмотреть код вовремя

Вы можете отправить задание относительно старой версии среды выполнения (созданной для 4.5.2), однако из-за отсутствия платформа .NET Framework параллельных возможностей она все равно будет работать только в режиме совместимости 4.5.2. По-прежнему могут возникать некоторые проблемы обратной совместимости из-за такого поведения.

### <a name="what-are-the-most-common-backwards-compatibility-issues-you-may-encounter"></a>Каковы наиболее распространенные проблемы обратной совместимости, которые могут возникнуть

Наиболее распространенная обратная совместимость, которая, вероятно, будет выявлена средством проверки (мы создали этот список, запустив средство проверки на основе собственных внутренних заданий ADLA), на которые повлияли библиотеки (Обратите внимание, что библиотеки можно вызывать только косвенно, поэтому важно предпринять необходимые действия #1, чтобы проверить, влияют ли ваши задания), и возможные действия для их устранения. Примечание. почти во всех случаях для собственных заданий предупреждения выдавали ложные срабатывания из-за узких особенностей наиболее критических изменений.

- Чтобы результирующая задача завершилась, реализация свойства IAsyncResult.CompletedSynchronously должна быть правильной
  - При вызове TaskFactory.FromAsync реализация свойства IAsyncResult.CompletedSynchronously должна быть правильной, чтобы результирующая задача завершилась. То есть свойство должно возвращать значение true, если (и только если) реализация завершилась синхронно. Раньше свойство не проверялось.
  - Затронутые библиотеки: mscorlib, System. Threading. Tasks
  - Предлагаемое действие: Убедитесь, что TaskFactory. FromAsync правильно возвращает значение true

- DataObject.GetData теперь получает данные в кодировке UTF-8
  - Для приложений, предназначенных для NET Framework 4, а также для выполняющихся в .NET Framework 4.5.1 или более ранних версиях, DataObject.GetData получает HTML-данные в виде строки ASCII. В результате символы, не входящие в набор ASCII (символы, коды ASCII которых больше 0x7F), представляются двумя случайными символами. #N # #N#For приложения, предназначенные для платформа .NET Framework 4,5 или более поздней версии и выполняемые на платформа .NET Framework 4.5.2, `DataObject.GetData` извлекает данные в формате HTML в кодировке UTF-8, которая правильно представляет символы, превышающие 0x7F.
  - Затронутые библиотеки: гло
  - Предлагаемое действие. Убедитесь, что извлекаемые данные имеют нужный формат.

- XmlWriter вызывает недействительные суррогатные пары
  - Для приложений с целевой платформой .NET Framework 4.5.2 или предыдущих версий запись недействительной суррогатной пары с помощью обработки резервного исключения не всегда вызывает исключение. Для приложений с целевой платформой .NET Framework 4.6 попытка записи недействительной суррогатной пары вызывает исключение `ArgumentException`.
  - Затронутые библиотеки: System.Xml, System.Xml. Блокировки
  - Предлагаемое действие: Убедитесь, что вы не пишете недопустимую суррогатную пару, которая приведет к исключению аргумента

- HtmlTextWriter неправильно отображает элемент `<br/>`
  - Начиная с .NET Framework 4.6, при вызове `HtmlTextWriter.RenderBeginTag()` и `HtmlTextWriter.RenderEndTag()` с элементом `<BR />` правильно вставляется только один `<BR />` (вместо двух).
  - Затронутые библиотеки: System. Web
  - Предлагаемое действие. Убедитесь, что вы вставляете `<BR />` ожидаемое количество, поэтому случайное поведение не отображается в рабочем задании.

- Был изменен вызов метода CreateDefaultAuthorizationContext с аргументом NULL
  - В .NET Framework 4.6 изменилась реализация AuthorizationContext, возвращаемая вызовом `CreateDefaultAuthorizationContext(IList<IAuthorizationPolicy>)` с нулевым аргументом authorizationPolicies.
  - Затронутые библиотеки: System. IdentityModel
  - Предлагаемое действие: Убедитесь, что вы обрабатываете новое ожидаемое поведение при наличии политики авторизации, имеющей значение null.
  
- RSACng теперь правильно загружает ключи RSA нестандартного размера
  - В версиях .NET Framework до 4.6.2 клиенты с нестандартным размером ключа для сертификатов RSA не могли получить доступ к этим ключам через методы расширения `GetRSAPublicKey()` и `GetRSAPrivateKey()`. `CryptographicException`Исключение с сообщением "запрошенный размер ключа не поддерживается". С платформа .NET Framework 4.6.2 Эта проблема исправлена. Аналогично, `RSA.ImportParameters()` и `RSACng.ImportParameters()` теперь работать с нестандартными размерами ключей без вызова `CryptographicException` .
  - Затронутые библиотеки: mscorlib, System. Core
  - Предлагаемое действие: Убедитесь, что ключи RSA работают должным образом.

- Более строгие проверки двоеточий в пути
  - В .NET Framework 4.6.2 выполнен ряд изменений для поддержки ранее не поддерживаемых путей (по длине и формату). Исправлены проверки надлежащего синтаксиса разделителя диска (двоеточие), в результате появился побочный эффект в виде блокировки некоторых путей универсального кода ресурса (URI) в некоторых API-интерфейсах пути, где раньше это допускалось.
  - Затронутые библиотеки: mscorlib, System. Runtime. Extensions
  - Предлагаемое действие:

- Вызовы к конструкторам ClaimsIdentity
  - Начиная с .NET Framework 4.6.2 конструкторы `T:System.Security.Claims.ClaimsIdentity` с параметром `T:System.Security.Principal.IIdentity` иначе задают свойство `P:System.Security.Claims.ClaimsIdentify.Actor`. Если аргумент `T:System.Security.Principal.IIdentity` является объектом `T:System.Security.Claims.ClaimsIdentity`, а свойство `P:System.Security.Claims.ClaimsIdentify.Actor` этого объекта `T:System.Security.Claims.ClaimsIdentity` не равно `null`, свойство `P:System.Security.Claims.ClaimsIdentify.Actor` присоединяется с помощью метода `M:System.Security.Claims.ClaimsIdentity.Clone`. В 4.6.1 Framework и более ранних версиях `P:System.Security.Claims.ClaimsIdentify.Actor` свойство прикрепляется как существующая ссылка. Из-за этого изменения, начиная с платформа .NET Framework 4.6.2, `P:System.Security.Claims.ClaimsIdentify.Actor` свойство нового `T:System.Security.Claims.ClaimsIdentity` объекта не равно `P:System.Security.Claims.ClaimsIdentify.Actor` свойству `T:System.Security.Principal.IIdentity` аргумента конструктора. В .NET Framework 4.6.1 и более ранних версиях они равны.
  - Затронутые библиотеки: mscorlib
  - Предлагаемое действие: Убедитесь, что ClaimsIdentity работает должным образом в новой среде выполнения

- Сериализация управляющих символов с помощью DataContractJsonSerializer теперь совместима с ECMAScript версии 6 и 8
  - В .NET Framework 4.6.2 и более ранних версиях DataContractJsonSerializer не выполнял сериализацию некоторых специальных управляющих символов, таких как \b, \f и \t, так, как это было совместимо с стандартами ECMAScript версии 6 и V8. Начиная с .NET Framework 4.7 сериализация таких управляющих символов совместима с ECMAScript версий 6 и 8.
  - Затронутые библиотеки: System.Runtime.Serialization.Jsна
  - Предлагаемое действие: обеспечить то же поведение с DataContractJsonSerializer
