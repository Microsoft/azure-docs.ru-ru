---
title: Обработку ошибок и исключений в рабочих процессах
description: Сведения об обработке ошибок и исключений, происходящих в автоматизированных задачах и рабочих процессах, созданных с помощью Azure Logic Apps
services: logic-apps
ms.suite: integration
author: dereklee
ms.author: deli
ms.reviewer: klam, estfan, logicappspm
ms.date: 01/11/2020
ms.topic: article
ms.openlocfilehash: a0c8286b2fb36642723ae28b8bc88e9e49f8a8fb
ms.sourcegitcommit: e559daa1f7115d703bfa1b87da1cf267bf6ae9e8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/17/2021
ms.locfileid: "100577956"
---
# <a name="handle-errors-and-exceptions-in-azure-logic-apps"></a>Обработка ошибок и исключений в Azure Logic Apps

Способ, которым любая архитектура интеграции должным образом обрабатывает время простоя или проблемы, вызванные зависимыми системами, может создать проблему. Чтобы помочь вам создать надежную и устойчивую интеграцию, корректно обрабатывающую проблемы и сбои, Logic Apps предоставляет эффективные возможности обработки ошибок и исключений.

<a name="retry-policies"></a>

## <a name="retry-policies"></a>Политики повтора

Для наиболее простого исключения и обработки ошибок можно использовать *политику повтора* в любом действии или триггере, где это возможно, например, в разделе [действие HTTP](../logic-apps/logic-apps-workflow-actions-triggers.md#http-trigger). Политика повторов указывает, каким образом и повторяет ли действие или триггер запрос, когда истекает время ожидания первоначального запроса или запрос завершается ошибкой, т.е. на запрос дается ответ 408, 429 или 5xx. Если политика повтора не задана, используется политика по умолчанию.

Ниже приведены типы политик повтора.

| Type | Описание |
|------|-------------|
| **Default** | Эта политика отправляет до четырех повторных попыток в *экспоненциально увеличивающихся* интервалах, которые масштабируются с шагом в 7,5 секунд, но ограничены между 5 и 45 секундами. |
| **Экспоненциальный интервал**  | Перед отправкой следующего запроса эта политика ожидает случайного интервала, выбранного из экспоненциально растущего диапазона. |
| **Фиксированный интервал**  | Эта политика ожидает определенный интервал времени перед отправкой следующего запроса. |
| **Нет**  | Повторная отправка запроса не происходит. |
|||

Дополнительные сведения об ограничениях политики повтора см. в статье [Ограничения и настройка Logic Apps](../logic-apps/logic-apps-limits-and-config.md#http-limits).

### <a name="change-retry-policy"></a>Изменение политики повтора

Чтобы выбрать другую политику повтора, выполните следующие действия.

1. Создание приложения логики в Конструкторе приложений логики.

1. Откройте **Параметры** для действия или триггера.

1. Если действие или триггер поддерживает политику повтора, в разделе **Политика повтора**, выберите нужный тип.

Или можно вручную задать политику повтора в разделе `inputs` для действия или триггера, который поддерживает политику повтора. Если не указать политику повтора, действие использует политику по умолчанию.

```json
"<action-name>": {
   "type": "<action-type>",
   "inputs": {
      "<action-specific-inputs>",
      "retryPolicy": {
         "type": "<retry-policy-type>",
         "interval": "<retry-interval>",
         "count": <retry-attempts>,
         "minimumInterval": "<minimum-interval>",
         "maximumInterval": "<maximum-interval>"
      },
      "<other-action-specific-inputs>"
   },
   "runAfter": {}
}
```

*Обязательное*

| Значение | Type | Описание |
|-------|------|-------------|
| <*Повтор — политика — тип*> | Строка | Необходимый тип политики повтора: `default`, `none`, `fixed` или `exponential` |
| <*Интервал повтора*> | Строка | Интервал повторных попыток, значение которого используется в [формате ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations). Минимальный интервал по умолчанию составляет `PT5S`, а максимальный интервал — `PT1D`. При использовании политики экспоненциального интервала можно указать разные минимальное и максимальное значения. |
| <*повторные попытки*> | Целое число | Количество повторных попыток. Значение должно находиться в диапазоне от 1 до 90. |
||||

*Необязательно*

| Значение | Type | Описание |
|-------|------|-------------|
| <*Минимальный интервал*> | Строка | Минимальный интервал политики экспоненциального интервала для случайно выбранного интервала в [ формате ISO 8601 ](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) |
| <*максимальный интервал*> | Строка | Максимальный интервал политики экспоненциального интервала для случайно выбранного интервала в [ формате ISO 8601 ](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) |
||||

Ниже приведены дополнительные сведения о различных типах политик.

<a name="default-retry"></a>

### <a name="default"></a>Значение по умолчанию

Если не будет указана политика повтора, действие использует политику по умолчанию, которая на самом деле представляет собой [политику экспоненциального интервала](#exponential-interval), которая отправляет до четырех повторных попыток с экспоненциально растущим интервалом с шагом в 7,5 секунд. Диапазон составляет от 5 до 45 секунд.

Хотя это явно не определено в действии или триггере, ниже представлена политика по умолчанию на примере действия HTTP.

```json
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "http://myAPIendpoint/api/action",
      "retryPolicy" : {
         "type": "exponential",
         "interval": "PT7S",
         "count": 4,
         "minimumInterval": "PT5S",
         "maximumInterval": "PT1H"
      }
   },
   "runAfter": {}
}
```

### <a name="none"></a>None

Чтобы указать, что действие или триггер не повторяет неудавшиеся запросы, задайте параметру <*retry-policy-type*> значение `none`.

### <a name="fixed-interval"></a>Фиксированный интервал

Чтобы указать, что действие или триггер ждет указанного интервала перед отправкой следующего запроса, задайте параметру <*retry-policy-type*> значение `fixed`.

*Пример*

Эта политика повтора пытается два раза получить последние новости после первого сбоя запроса с 30-секундной задержкой между попытками.

```json
"Get_latest_news": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "https://mynews.example.com/latest",
      "retryPolicy": {
         "type": "fixed",
         "interval": "PT30S",
         "count": 2
      }
   }
}
```

<a name="exponential-interval"></a>

### <a name="exponential-interval"></a>Экспоненциальный интервал

Чтобы указать, что действие или триггер ждет случайного интервала перед отправкой следующего запроса, задайте параметру <*retry-policy-type*> значение `exponential`. Случайный интервал выбирается из экспоненциально растущего диапазона. Минимальный и максимальный интервалы по умолчанию также можно переопределить, указав собственные минимальный и максимальный интервалы.

**Диапазон случайных переменных**

В этой таблице показано, как Logic Apps создает универсальную случайную переменную в указанном диапазоне для каждой попытки повтора, включая число повторных попыток.

| Число повторных попыток | Минимальный интервал | Максимальный интервал |
|--------------|------------------|------------------|
| 1 | Max (0, <*минимум-интервал*>) | min (интервал, <*максимум-интервал*>) |
| 2 | Max (Interval, <*минимум-интервал*>) | min (2 * интервал, <*максимум-интервал*>) |
| 3 | Max (2 * интервал, <*минимум-интервал*>) | min (4 * интервал, <*максимум-интервал*>) |
| 4 | Max (4 * интервал, <*минимум-интервал*>) | min (8 * интервал, <*максимум-интервал*>) |
| .... | .... | .... |
||||

<a name="control-run-after-behavior"></a>

## <a name="catch-and-handle-failures-by-changing-run-after-behavior"></a>Перехват и обработку сбоев путем изменения поведения "запуск после"

При добавлении действий в конструктор приложений логики вы неявно объявляете порядок, который будет использоваться для выполнения этих действий. После завершения выполнения действия это действие помечается состоянием, например,, `Succeeded` `Failed` `Skipped` или `TimedOut` . В определении каждого действия `runAfter` свойство указывает предшествующее действие, которое должно быть завершено, и состояния, разрешенные для этого предшественника, перед выполнением действия-последователя. По умолчанию действие, добавляемое в конструктор, выполняется только после завершения предшественника с `Succeeded` состоянием.

Когда действие вызывает необработанную ошибку или исключение, действие отмечается `Failed` , а все последователи помечаются как `Skipped` . Если такое поведение происходит для действия, которое имеет параллельные ветви, Logic Apps подсистемам соответствует другим веткам для определения их состояния завершения. Например, если ветвь оканчивается `Skipped` действием, состояние завершения этой ветви определяется состоянием предшественника пропущенного действия. После завершения выполнения приложения логики подсистема определяет состояние всего выполнения, оценивая все состояния ветви. Если какая-либо из ветвей завершается сбоем, будет отмечено все выполнение приложения логики `Failed` .

![Примеры, показывающие, как оцениваются состояния выполнения](./media/logic-apps-exception-handling/status-evaluation-for-parallel-branches.png)

Чтобы убедиться в том, что действие все еще может выполняться несмотря на состояние предшественника, [Настройте поведение действия "запуск после"](#customize-run-after) , чтобы обрабатывались неудачные состояния предшественника.

<a name="customize-run-after"></a>

### <a name="customize-run-after-behavior"></a>Настройка поведения "запуск после"

Вы можете настроить поведение действия "запуск после", чтобы действие выполнялось, когда состояние предшественника имеет значение,, `Succeeded` `Failed` `Skipped` `TimedOut` или любое из этих состояний. Например, чтобы отправить сообщение электронной почты после того, `Add_a_row_into_a_table` как действие предшественника «Excel Online» будет помечено `Failed` , вместо этого `Succeeded` Измените поведение «запуск после», выполнив любое из следующих действий.

* В режиме конструктора нажмите кнопку с многоточием (**...**), а затем выберите **настроить выполнение после**.

  ![Настройка поведения "запуск после" для действия](./media/logic-apps-exception-handling/configure-run-after-property-setting.png)

  На фигуре действия отображается состояние по умолчанию, необходимое для действия-предшественника, которое добавляет **строку в таблицу** в этом примере:

  ![Поведение по умолчанию "запустить после" для действия](./media/logic-apps-exception-handling/change-run-after-property-status.png)

  Измените поведение "запуск после" на нужное состояние, которое не **удалось выполнить** в этом примере:

  ![Изменить поведение "запуск после" на "не удалось"](./media/logic-apps-exception-handling/run-after-property-status-set-to-failed.png)

  Чтобы указать, что действие выполняется при условии, что действие-предшественник помечено как `Failed` `Skipped` или `TimedOut` , выберите другие состояния:

  ![Изменить поведение "запуск после", чтобы оно имело другое состояние](./media/logic-apps-exception-handling/run-after-property-multiple-statuses.png)

* В представлении кода в определении JSON действия измените `runAfter` свойство, которое следует за следующим синтаксисом:

  ```json
  "<action-name>": {
     "inputs": {
        "<action-specific-inputs>"
     },
     "runAfter": {
        "<preceding-action>": [
           "Succeeded"
        ]
     },
     "type": "<action-type>"
  }
  ```

  В этом примере измените `runAfter` свойство с `Succeeded` на `Failed` :

  ```json
  "Send_an_email_(V2)": {
     "inputs": {
        "body": {
           "Body": "<p>Failed to&nbsp;add row to &nbsp;@{body('Add_a_row_into_a_table')?['Terms']}</p>",,
           "Subject": "Add row to table failed: @{body('Add_a_row_into_a_table')?['Terms']}",
           "To": "Sophia.Owen@fabrikam.com"
        },
        "host": {
           "connection": {
              "name": "@parameters('$connections')['office365']['connectionId']"
           }
        },
        "method": "post",
        "path": "/v2/Mail"
     },
     "runAfter": {
        "Add_a_row_into_a_table": [
           "Failed"
        ]
     },
     "type": "ApiConnection"
  }
  ```

  Чтобы указать, что действие выполняется при условии, что действие-предшественник помечено как `Failed` `Skipped` или `TimedOut` , добавьте другие состояния:

  ```json
  "runAfter": {
     "Add_a_row_into_a_table": [
        "Failed", "Skipped", "TimedOut"
     ]
  },
  ```

<a name="scopes"></a>

## <a name="evaluate-actions-with-scopes-and-their-results"></a>Оценка действия с помощью областей и их результатов

Аналогично выполнению шагов после выполнения отдельных действий со `runAfter` свойством можно группировать действия внутри [области](../logic-apps/logic-apps-control-flow-run-steps-group-scopes.md). Области позволяют логически группировать действия, получать доступ к общему состоянию области и выполнять действия на основе состояния. После завершения выполнения всех действий в области, она получает собственное состояние.

Чтобы проверить состояние области, можно использовать те же условия, которые используются для проверки состояния выполнения приложения логики, например `Succeeded` , `Failed` и т. д.

По умолчанию при завершении всех действий области состояние области отмечается как `Succeeded` . Если Последнее действие в области `Failed` имеет значение или `Aborted` , то состояние области помечается как `Failed` .

Для перехвата исключений в `Failed` области и выполнения действий, которые обрабатывали эти ошибки, можно использовать `runAfter` свойство для этой `Failed` области. Таким образом, при сбое *каких-либо* действий в области и использовании `runAfter` свойства для этой области можно создать одно действие для перехвата сбоев.

Сведения об ограничениях в областях см. в статье [Ограничения и настройка Logic Apps](../logic-apps/logic-apps-limits-and-config.md).

<a name="get-results-from-failures"></a>

### <a name="get-context-and-results-for-failures"></a>Получение контекста и результатов ошибок

Хотя перехват ошибок в области очень эффективен, вам также может понадобиться контекст, чтобы понять, какие действия завершились сбоем, и узнать возвращенные ошибки и коды состояния.

[`result()`](../logic-apps/workflow-definition-language-functions-reference.md#result)Функция предоставляет контекст для результатов всех действий в области. `result()`Функция принимает один параметр, который является именем области, и возвращает массив, содержащий все результаты действия из этой области. Эти объекты действий включают те же атрибуты, что и `actions()` объект, например время начала действия, время окончания, состояние, входы, идентификаторы корреляции и выходные данные. Чтобы отправить контекст для любых действий, завершившихся сбоем в области, можно легко связать `@result()` выражение со `runAfter` свойством.

Чтобы выполнить действие для каждого действия в области, которая имеет `Failed` результат, и для фильтрации массива результатов по невыполненным действиям, можно связать `@result()` выражение с действием [**Фильтрация массива**](logic-apps-perform-data-operations.md#filter-array-action) и цикл [**по каждому**](../logic-apps/logic-apps-control-flow-loops.md) элементу. Можно взять отфильтрованный массив результатов и выполнить действие для каждой ошибки с помощью `For_each` цикла.

Вот пример с подробным объяснением, которое отправляет HTTP-запрос POST, для которого будут возвращены завершившиеся сбоем действия в области My_Scope.

```json
"Filter_array": {
   "type": "Query",
   "inputs": {
      "from": "@result('My_Scope')",
      "where": "@equals(item()['status'], 'Failed')"
   },
   "runAfter": {
      "My_Scope": [
         "Failed"
      ]
    }
},
"For_each": {
   "type": "foreach",
   "actions": {
      "Log_exception": {
         "type": "Http",
         "inputs": {
            "method": "POST",
            "body": "@item()['outputs']['body']",
            "headers": {
               "x-failed-action-name": "@item()['name']",
               "x-failed-tracking-id": "@item()['clientTrackingId']"
            },
            "uri": "http://requestb.in/"
         },
         "runAfter": {}
      }
   },
   "foreach": "@body('Filter_array')",
   "runAfter": {
      "Filter_array": [
         "Succeeded"
      ]
   }
}
```

Подробно рассмотрим приведенный выше пример.

1. Для получения результатов из всех действий в области My_Scope, действие **Filter_array** использует выражение фильтра `@result('My_Scope')`.

1. Условие для **массива фильтров** — это любой `@result()` элемент, состояние которого равно `Failed` . Это условие фильтрует массив, который имеет все результаты действия от My_Scope до массива только с неудачными результатами.

1. Выполните `For_each` циклическое действие для выходных данных *отфильтрованного массива* . Этот шаг выполняет действие для каждого неудавшегося результата действия, который был ранее отфильтрован.

   Если одно действие в области завершается неудачно, действия в `For_each` цикле выполняются только один раз. Многие завершившиеся сбоем действия приведут к выполнению только одного действия на сбой.

1. Отправка HTTP-запроса POST к `For_each` тексту ответа элемента, который является `@item()['outputs']['body']` выражением.

   Формат элемента `@result()` совпадает с форматом `@actions()` и может быть проанализирован одинаково.

1. В код выше включены два пользовательских заголовка с именем завершившегося сбоем действия (`@item()['name']`) и идентификатором отслеживания клиента выполнения со сбоем `@item()['clientTrackingId']`.

Ниже приведен пример (для справочных целей) отдельного элемента `@result()` с отображением свойств `name`, `body` и `clientTrackingId`, проанализированных в примере выше. За пределами `For_each` действия `@result()` возвращает массив этих объектов.

```json
{
   "name": "Example_Action_That_Failed",
   "inputs": {
      "uri": "https://myfailedaction.azurewebsites.net",
      "method": "POST"
   },
   "outputs": {
      "statusCode": 404,
      "headers": {
         "Date": "Thu, 11 Aug 2016 03:18:18 GMT",
         "Server": "Microsoft-IIS/8.0",
         "X-Powered-By": "ASP.NET",
         "Content-Length": "68",
         "Content-Type": "application/json"
      },
      "body": {
         "code": "ResourceNotFound",
         "message": "/docs/folder-name/resource-name does not exist"
      }
   },
   "startTime": "2016-08-11T03:18:19.7755341Z",
   "endTime": "2016-08-11T03:18:20.2598835Z",
   "trackingId": "bdd82e28-ba2c-4160-a700-e3a8f1a38e22",
   "clientTrackingId": "08587307213861835591296330354",
   "code": "NotFound",
   "status": "Failed"
}
```

Выражения, описанные в этой статье, можно использовать для выполнения различных шаблонов обработки исключений. Вы можете выполнить одно действие обработки исключений вне области, которое принимает весь отфильтрованный массив сбоев, и удалить `For_each` действие. Можно также включить другие полезные свойства из `\@result()` ответа, как описано выше.

## <a name="set-up-azure-monitor-logs"></a>настройка журналов Azure Monitor;

Приведенные выше шаблоны — эффективный способ обработки ошибок и исключений в выполнении. Однако можно также обнаруживать отдельные ошибки и реагировать на них независимо от выполнения. [Azure Monitor](../azure-monitor/overview.md) предоставляет простой способ отправки всех событий рабочего процесса, включая все состояния выполнения и действий, в [log Analytics рабочую область](../azure-monitor/logs/data-platform-logs.md), [учетную запись хранения Azure](../storage/blobs/storage-blobs-overview.md)или [концентраторы событий Azure](../event-hubs/event-hubs-about.md).

Вы можете отслеживать журналы и метрики или публиковать их в любом средстве мониторинга для оценки состояния выполнения. К примеру, можно направлять поток всех событий через Центры событий в [Azure Stream Analytics](https://azure.microsoft.com/services/stream-analytics/). В Stream Analytics можно написать активные запросы для получения сведений об отклонении на основе средних показателей или сбоев из журналов диагностики. Stream Analytics можно использовать для отправки информации в другие источники данных, такие как очереди, разделы, SQL, Azure Cosmos DB или Power BI.

## <a name="next-steps"></a>Дальнейшие шаги

* [Сценарий обработки исключений и ведения журнала ошибок для приложений логики](../logic-apps/logic-apps-scenario-error-and-exception-handling.md)
* [Дополнительные Logic Apps примеры и сценарии](../logic-apps/logic-apps-examples-and-scenarios.md)
