---
title: Отправка коррелированных сообщений по порядку с помощью последовательного сопровождение
description: Отправка связанных сообщений по порядку с помощью последовательного сопровождение шаблона в Azure Logic Apps с помощью служебной шины Azure
services: logic-apps
ms.suite: integration
ms.reviewer: apseth, divswa, logicappspm
ms.topic: conceptual
ms.date: 05/29/2020
ms.openlocfilehash: 8c00d2e4f622bcfad7b2468013336f0d936e318c
ms.sourcegitcommit: 772eb9c6684dd4864e0ba507945a83e48b8c16f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "87048660"
---
# <a name="send-related-messages-in-order-by-using-a-sequential-convoy-in-azure-logic-apps-with-azure-service-bus"></a>Отправка связанных сообщений по порядку с помощью последовательного сопровождение в Azure Logic Apps со служебной шиной Azure

Если необходимо отправить коррелированные сообщения в определенном порядке, можно следовать [ *последовательному* шаблону сопровождение](/azure/architecture/patterns/sequential-convoy) при использовании [Azure Logic Apps](../logic-apps/logic-apps-overview.md) с помощью [соединителя служебной шины Azure](../connectors/connectors-create-api-servicebus.md). Коррелированные сообщения имеют свойство, определяющее связь между этими сообщениями, например идентификатор [сеанса](../service-bus-messaging/message-sessions.md) в служебной шине.

Например, предположим, что у вас есть 10 сообщений для сеанса с именем "сеанс 1", и имеется 5 сообщений для сеанса с именем "Session 2", отправленных в одну и ту же [очередь служебной шины](../service-bus-messaging/service-bus-queues-topics-subscriptions.md). Можно создать приложение логики, которое обрабатывает сообщения из очереди, чтобы все сообщения из сеанса 1 обрабатывались одним запуском триггера, а все сообщения из "сеанс 2" обрабатывались следующим запуском триггера.

![Общий шаблон последовательного сопровождение](./media/send-related-messages-sequential-convoy/sequential-convoy-pattern-general.png)

В этой статье показано, как создать приложение логики, которое реализует этот шаблон с помощью **коррелированной упорядоченной доставки с помощью шаблона сеансов служебной шины** . Этот шаблон определяет рабочий процесс приложения логики, который начинается с соединителя служебной шины **при получении сообщения в триггере очереди (Просмотр блокировки)** , который получает сообщения из [очереди служебной шины](../service-bus-messaging/service-bus-queues-topics-subscriptions.md). Ниже приведены общие действия, выполняемые этим приложением логики.

* Инициализируйте сеанс на основе сообщения, которое триггер считывает из очереди служебной шины.

* Считывает и обрабатывает все сообщения из одного сеанса в очереди во время выполнения текущего рабочего процесса.

Сведения о просмотре JSON этого шаблона см. [в разделе GitHub: service-bus-sessions.json](https://github.com/Azure/logicapps/blob/master/templates/service-bus-sessions.json).

Дополнительные сведения см. в статье [шаблон последовательного сопровождение — шаблоны проектирования облачных архитектур Azure](/azure/architecture/patterns/sequential-convoy).

## <a name="prerequisites"></a>Предварительные требования

* Подписка Azure. Если у вас нет ее, вы можете [зарегистрироваться для получения бесплатной учетной записи Azure](https://azure.microsoft.com/free/).

* Пространство имен служебной шины и [очередь служебной шины](../service-bus-messaging/service-bus-queues-topics-subscriptions.md)— это сущность обмена сообщениями, которая будет использоваться в приложении логики. Эти элементы и приложение логики должны использовать одну и ту же подписку Azure. Убедитесь, что выбран параметр **включить сеансы** при создании очереди. Если эти элементы отсутствуют, Узнайте, [как создать пространство имен служебной шины и очередь](../service-bus-messaging/service-bus-create-namespace-portal.md).

  [!INCLUDE [Warning about creating infinite loops](../../includes/connectors-infinite-loops.md)]

* Основные сведения о создании приложений логики. Если вы не знакомы с Azure Logic Apps, воспользуйтесь кратким руководством, чтобы [создать первый автоматизированный рабочий процесс](../logic-apps/quickstart-create-first-logic-app-workflow.md).

<a name="permissions-connection-string"></a>

## <a name="check-access-to-service-bus-namespace"></a>Проверка доступа к пространству имен служебной шины

Если вы не уверены, имеет ли ваше приложение логики разрешения на доступ к пространству имен служебной шины, подтвердите эти разрешения.

1. Войдите на [портал Azure](https://portal.azure.com). Найдите и выберите *пространство имен* служебной шины.

1. В меню пространство имен в разделе **Параметры** выберите **политики общего доступа**. В разделе **Утверждения** убедитесь, что у вас есть разрешения на **управление** для этого пространства имен.

   ![Управление разрешениями для пространства имен служебной шины](./media/send-related-messages-sequential-convoy/check-service-bus-permissions.png)

1. Теперь получите строку подключения для пространства имен служебной шины. Эту строку можно использовать позже при создании подключения к пространству имен из приложения логики.

   1. В области политики **общего доступа** в разделе **Политика** выберите **RootManageSharedAccessKey**.
   
   1. Нажмите кнопку Копировать рядом с основной строкой подключения. Сохраните строку подключения для дальнейшего использования.

      ![Копирование строки подключения к пространству имен служебной шины](./media/send-related-messages-sequential-convoy/copy-service-bus-connection-string.png)

   > [!TIP]
   > Чтобы проверить, относится ли строка подключения к пространству имен служебной шины или сущности обмена сообщениями, например очереди, найдите в ней параметр `EntityPath`. Если в строке подключения есть такой параметр, значит она относится к определенной сущности и ее нельзя использовать в приложении логики.

## <a name="create-logic-app"></a>Создание приложения логики

В этом разделе вы создадите приложение логики с помощью **коррелированной упорядоченной доставки с помощью шаблона сеансов служебной шины** , который включает триггер и действия для реализации этого шаблона рабочего процесса. Вы также создаете подключение к пространству имен служебной шины и указываете имя очереди служебной шины, которую вы хотите использовать.

1. Создайте пустое приложение логики на [портале Azure](https://portal.azure.com). На домашней странице Azure выберите **создать ресурс**  >  **Интеграция**  >  **приложения логики**.

1. После того как откроется галерея шаблонов, прокрутите разделы видео и Общие триггеры. В разделе **шаблоны** выберите шаблон, **Коррелированная упорядоченная доставка с помощью сеансов служебной шины**.

   ![Выберите шаблон "Коррелированная в заказе доставка с помощью сеансов служебной шины"](./media/send-related-messages-sequential-convoy/select-correlated-in-order-delivery-template.png)

1. Когда появится окно подтверждения, выберите **использовать этот шаблон**.

1. В конструкторе приложений логики в фигуре **служебной шины** выберите **продолжить**, а затем щелкните знак плюса ( **+** ), который отображается в фигуре.

   ![Выберите "продолжить", чтобы подключиться к служебной шине Azure](./media/send-related-messages-sequential-convoy/connect-to-service-bus.png)

1. Теперь создайте подключение к служебной шине, выбрав любой из вариантов:

   * Чтобы использовать строку подключения, скопированную ранее из пространства имен служебной шины, выполните следующие действия.

     1. Выберите **вручную ввести сведения о подключении**.

     1. В качестве **имени подключения** введите имя для подключения. В качестве **строки подключения** вставьте строку подключения к пространству имен и выберите **создать**, например:

        ![Введите имя подключения и строку подключения служебной шины](./media/send-related-messages-sequential-convoy/provide-service-bus-connection-string.png)

        > [!TIP]
        > Если эта строка подключения отсутствует, Узнайте, как [найти и скопировать строку подключения к пространству имен служебной шины](#permissions-connection-string).

   * Чтобы выбрать пространство имен служебной шины из текущей подписки Azure, выполните следующие действия.

     1. В качестве **имени подключения** введите имя для подключения. В качестве **пространства имен служебной шины** выберите пространство имен служебной шины, например:

        ![Введите имя подключения и выберите пространство имен служебной шины.](./media/send-related-messages-sequential-convoy/create-service-bus-connection.png)

     1. Когда появится следующая панель, выберите свою политику служебной шины и щелкните **создать**.

        ![Выберите политика служебной шины, а затем — создать.](./media/send-related-messages-sequential-convoy/create-service-bus-connection-2.png)

1. Когда все будет готово, нажмите кнопку **продолжить**.

   В конструкторе приложений логики теперь отображается **Коррелированная упорядоченная доставка с помощью шаблона сеансов служебной шины** , которая содержит предварительно заполненный рабочий процесс с триггером и действиями, включая две области, которые реализуют обработку ошибок, следующую за `Try-Catch` шаблоном.

Теперь вы можете узнать больше о триггере и действиях в шаблоне или перейти к [предоставлению значений для шаблона приложения логики](#complete-template).

<a name="template-summary"></a>

## <a name="template-summary"></a>Сводка по шаблону

Ниже приведен рабочий процесс верхнего уровня в **коррелированной последовательной доставке с помощью шаблона сеансов служебной шины** , когда сведения свернуты:

![Рабочий процесс шаблона верхнего уровня](./media/send-related-messages-sequential-convoy/template-top-level-flow.png)

| Имя | Описание |
|------|-------------|
| **`When a message is received in a queue (peek-lock)`** | В зависимости от указанного периодичности триггер служебной шины проверяет указанную очередь служебной шины на наличие сообщений. Если сообщение существует в очереди, срабатывает триггер, который создает и запускает экземпляр рабочего процесса. <p><p>Термин *Просмотр-блокировка* означает, что триггер отправляет запрос на получение сообщения из очереди. Если сообщение существует, триггер извлекает и блокирует сообщение, чтобы не происходила другая обработка этого сообщения до тех пор, пока не истечет период блокировки. Для получения дополнительных сведений [инициализируйте сеанс](#initialize-session). |
| **`Init isDone`** | Это [действие **инициализации переменной**](../logic-apps/logic-apps-create-variables-store-values.md#initialize-variable) создает логическую переменную, для которой задано значение `false` , и показывает, что выполняются следующие условия. <p><p>— Больше нет сообщений в сеансе, доступных для чтения. <br>— Блокировка сеанса больше не требуется обновлять, чтобы текущий экземпляр рабочего процесса мог завершиться. <p><p>Дополнительные сведения см. [в разделе Инициализация сеанса](#initialize-session). |
| **`Try`** | Это [действие **области**](../logic-apps/logic-apps-control-flow-run-steps-group-scopes.md) содержит действия, выполняемые для обработки сообщения. Если в области действия возникает проблема `Try` , то последующая `Catch` операция **Scope** обрабатывает эту проблему. Дополнительные сведения см. в разделе ["пробная область"](#try-scope). |
| **`Catch`**| Это [действие **области**](../logic-apps/logic-apps-control-flow-run-steps-group-scopes.md) содержит действия, которые выполняются, если в предыдущей области возникает проблема `Try` . Дополнительные сведения см. в разделе ["Catch" Scope](#catch-scope). |
|||

<a name="try-scope"></a>

### <a name="try-scope"></a>Область "try"

Ниже приведен поток верхнего уровня в `Try` [действии Scope](../logic-apps/logic-apps-control-flow-run-steps-group-scopes.md) , когда сведения свернуты.

![Рабочий процесс действия "try" области](./media/send-related-messages-sequential-convoy/try-scope-action.png)

| Имя | Описание |
|------|-------------|
| **`Send initial message to topic`** | Это действие можно заменить на любое действие, которое должно быть обработано первым сообщением из сеанса в очереди. Идентификатор сеанса указывает сеанс. <p><p>Для этого шаблона действие служебной шины отправляет первое сообщение в раздел служебной шины. Дополнительные сведения см. [в разделе об обработке исходного сообщения](#handle-initial-message). |
| (параллельная ветвь) | Это [действие параллельной ветви](../logic-apps/logic-apps-control-flow-branches.md) создает два пути: <p><p>-Branch #1: продолжить обработку сообщения. Дополнительные сведения см. [в разделе ветвь #1: полное начальное сообщение в очереди](#complete-initial-message). <p><p>-Branch #2: отменяет сообщение, если что-то пошло не так, и выпуски для отправки другим триггером. Дополнительные сведения см. в разделе [Branch #2: отменить начальное сообщение из очереди](#abandon-initial-message). <p><p>Оба пути будут присоединяться позже в **сеансе закрытия в очереди, и действие выполняется** , как описано в следующей строке. |
| **`Close a session in a queue and succeed`** | Это действие служебной шины присоединяет ранее описанные ветви и закрывает сеанс в очереди после того, как происходит одно из следующих событий: <p><p>— Рабочий процесс завершает обработку доступных сообщений в очереди. <br>— Рабочий процесс отменяет начальное сообщение, так как что-то пошло не так. <p><p>Дополнительные сведения см. [в разделе Закрытие сеанса в очереди и выполнение завершено](#close-session-succeed). |
|||

<a name="complete-initial-message"></a>

#### <a name="branch-1-complete-initial-message-in-queue"></a>#1 ответвления: полное начальное сообщение в очереди

| Имя | Описание |
|------|-------------|
| `Complete initial message in queue` | Это действие служебной шины помечает успешно полученное сообщение как завершенное и удаляет сообщение из очереди, чтобы предотвратить повторную обработку. Дополнительные сведения см. [в разделе об обработке исходного сообщения](#handle-initial-message). |
| `While there are more messages for the session in the queue` | Этот [цикл **пока не**](../logic-apps/logic-apps-control-flow-loops.md#until-loop) будет продолжать получать сообщения, пока сообщения существуют или пока не пройдет один час. Дополнительные сведения о действиях в этом цикле см. в разделе [хотя количество сообщений для сеанса в очереди больше](#while-more-messages-for-session). |
| **`Set isDone = true`** | Если сообщения больше не существуют, для этого [действия **Set Variable**](../logic-apps/logic-apps-create-variables-store-values.md#set-variable) присваивается `isDone` значение `true` . |
| **`Renew session lock until cancelled`** | Этот [цикл **until**](../logic-apps/logic-apps-control-flow-loops.md#until-loop) гарантирует, что блокировка сеанса удерживается этим приложением логики, пока сообщения существуют или пока не пройдет один час. Дополнительные сведения о действиях в этом цикле см. в разделе [Обновление блокировки сеанса до отмены](#renew-session-while-messages-exist). |
|||

<a name="abandon-initial-message"></a>

#### <a name="branch-2-abandon-initial-message-from-the-queue"></a>Ветвь #2: отменить начальное сообщение из очереди

Если действие, обрабатывающее первое сообщение, завершается ошибкой, действие служебной шины, не заменяя **исходное сообщение из очереди**, освобождает сообщение для другого экземпляра рабочего процесса, выполняющего выборку и обработку. Дополнительные сведения см. [в разделе об обработке исходного сообщения](#handle-initial-message).

<a name="catch-scope"></a>

### <a name="catch-scope"></a>Область "Catch"

Если действия в `Try` области не выполняются, приложение логики по-прежнему должно закрыть сеанс. `Catch` [Действие Scope](../logic-apps/logic-apps-control-flow-run-steps-group-scopes.md) выполняется `Try` , когда действие Scope приводит к состоянию,, `Failed` `Skipped` или `TimedOut` . Область возвращает сообщение об ошибке, содержащее идентификатор сеанса, в котором возникла проблема, и завершает приложение логики.

Ниже приведен поток верхнего уровня в `Catch` действии Scope, когда сведения свернуты.

![Рабочий процесс действия "Catch"](./media/send-related-messages-sequential-convoy/catch-scope-action.png)

| Имя | Описание |
|------|-------------|
| **`Close a session in a queue and fail`** | Это действие служебной шины закрывает сеанс в очереди, чтобы блокировка сеанса не оставалась открытой. Дополнительные сведения см. [в разделе Закрытие сеанса в очереди и сбой](#close-session-fail). |
| **`Find failure msg from 'Try' block`** | Это [действие **фильтрации массива**](../logic-apps/logic-apps-perform-data-operations.md#filter-array-action) создает массив из входных и выходных данных всех действий в `Try` области на основе указанных критериев. В этом случае это действие возвращает выходные данные действий, которые привели к `Failed` состоянию. Дополнительные сведения см. [в разделе Поиск сообщения о сбое в блоке "try"](#find-failure-message). |
| **`Select error details`** | Это [действие **SELECT**](../logic-apps/logic-apps-perform-data-operations.md#select-action) создает массив, содержащий объекты JSON на основе указанных критериев. Эти объекты JSON строятся на основе значений в массиве, созданном предыдущим действием `Find failure msg from 'Try' block` . В этом случае это действие возвращает массив, содержащий объект JSON, созданный на основе сведений об ошибке, возвращенных предыдущим действием. Дополнительные сведения см. в разделе [Выбор сведений об ошибке](#select-error-details). |
| **`Terminate`** | Это [действие **прекращения**](../logic-apps/logic-apps-workflow-actions-triggers.md#terminate-action) останавливает выполнение рабочего процесса, отменяет все выполняемые действия, пропускает все оставшиеся действия и ВОЗВРАЩАЕТ указанное состояние, идентификатор сеанса и результат ошибки из `Select error details` действия. Дополнительные сведения см. в разделе [Завершение приложения логики](#terminate-logic-app). |
|||

<a name="complete-template"></a>

## <a name="complete-the-template"></a>Завершение работы с шаблоном

Чтобы указать значения триггера и действий в **коррелированной последовательной доставке с помощью шаблона сеансов служебной шины** , выполните следующие действия. Перед сохранением приложения логики необходимо указать все необходимые значения, помеченные звездочкой ( **\*** ).

<a name="initialize-session"></a>

### <a name="initialize-the-session"></a>Инициализация сеанса

* **Если сообщение получено в триггере очереди (Просмотр блокировки)** , укажите эти сведения, чтобы шаблон мог инициализировать сеанс с помощью свойства **Session ID** , например:

  ![Сведения о триггере служебной шины для "когда сообщение получено в очереди (Просмотр-блокировка)"](./media/send-related-messages-sequential-convoy/service-bus-check-message-peek-lock-trigger.png)

  > [!NOTE]
  > Изначально для интервала опроса устанавливается значение 3 минуты, чтобы приложение логики не выполнялось чаще, чем ожидалось, и приводит к непредвиденным затратам на выставление счетов. В идеале установите интервал и частоту 30 секунд, чтобы приложение логики немедленно запустится при поступлении сообщения.

  | Свойство. | Требуется для этого сценария | Значение | Описание |
  |----------|----------------------------|-------|-------------|
  | **Имя очереди** | Да | <*имя очереди*> | Имя ранее созданной очереди служебной шины. В этом примере используется "Fabrikam-Service-Bus-Queue". |
  | **Тип очереди** | Да | **Основная страница** | Основная очередь служебной шины |
  | **Идентификатор сеанса** | Да | **Следующий доступный** | Этот параметр получает сеанс для каждого запуска триггера на основе идентификатора сеанса из сообщения в очереди служебной шины. Сеанс также блокируется, чтобы другие приложения логики или другие клиенты не могли обрабатывать сообщения, связанные с этим сеансом. Последующие действия рабочего процесса обрабатывают все сообщения, связанные с этим сеансом, как описано далее в этой статье. <p><p>Ниже приведены дополнительные сведения о других параметрах **идентификатора сеанса** . <p>- **Нет**. параметр по умолчанию, в результате чего сеансы не используются и не могут использоваться для реализации последовательного шаблона сопровождение. <p>- **Введите пользовательское значение**. Используйте этот параметр, если вам известно, какой идентификатор сеанса вы хотите использовать, и вы всегда хотите запускать триггер для этого идентификатора сеанса. <p>**Примечание**. соединитель служебной шины может сохранять ограниченное количество уникальных сеансов за раз из служебной шины Azure в кэш соединителя. Если число сеансов превышает это ограничение, старые сеансы удаляются из кэша. Дополнительные сведения см. [в статье обмен сообщениями в облаке с помощью Azure Logic Apps и служебной шины Azure](../connectors/connectors-create-api-servicebus.md#connector-reference). |
  | **Интервал** | Да | <*количество интервалов*> | Число единиц времени между повторениями перед проверкой сообщения. |
  | **Частота** | Да | **Second** (секунда), **Minute** (минута), **Hour** (час), **Day** (день), **Week** (неделя) или **Month** (месяц). | Единица времени для повторения, используемое при проверке сообщения. <p>**Совет**. чтобы добавить часовой **пояс** или **время запуска**, выберите эти свойства в списке **Добавить новый параметр** . |
  |||||

  Дополнительные сведения о триггерах см. [в разделе служебная шина — при получении сообщения в очереди (Просмотр-блокировка)](/connectors/servicebus/#when-a-message-is-received-in-a-queue-(peek-lock)). Триггер выводит [ServiceBusMessage](/connectors/servicebus/#servicebusmessage).

После инициализации сеанса рабочий процесс использует действие **инициализации переменной** , чтобы создать логическую переменную, для которой изначально задано значение `false` , и указывает, что выполняются следующие условия. 

* Больше нет сообщений в сеансе, доступных для чтения.

* Блокировка сеанса больше не нуждается в обновлении, поэтому текущий экземпляр рабочего процесса может завершиться.

![Сведения о действии "Инициализация переменной" для "init Done"](./media/send-related-messages-sequential-convoy/init-is-done-variable.png)

Затем в блоке **try** рабочий процесс выполняет действия с первым прочитанным сообщением.

<a name="handle-initial-message"></a>

### <a name="handle-the-initial-message"></a>Обработайте исходное сообщение

Первое действие — это действие служебной шины, которое **отправляет начальное сообщение в раздел**, которое можно заменить любым другим действием, которое должно быть обработано первым сообщением из сеанса в очереди. Идентификатор сеанса указывает сеанс, из которого было создано сообщение.

Действие служебной шины заполнитель отправляет первое сообщение в раздел служебной шины, указанный свойством **Session ID** . Таким образом все сообщения, связанные с конкретным сеансом, отправляются в один и тот же раздел. Все свойства **идентификатора сеанса** для последующих действий в этом шаблоне используют одно и то же значение идентификатора сеанса.

![Сведения о действии служебной шины для команды "отправить исходное сообщение в раздел"](./media/send-related-messages-sequential-convoy/send-initial-message-to-topic-action.png)

1. В действии служебная шина **заполните исходное сообщение в очереди**, укажите имя очереди служебной шины и сохраните все остальные значения свойств по умолчанию в действии.

   ![Сведения о действии служебной шины "полное начальное сообщение в очереди"](./media/send-related-messages-sequential-convoy/complete-initial-message-queue.png)

1. В действии служебная шина отмените **начальное сообщение из очереди**, укажите имя очереди служебной шины и сохраните все остальные значения свойств по умолчанию в действии.

   ![Сведения о действии служебной шины для "отмены исходного сообщения из очереди"](./media/send-related-messages-sequential-convoy/abandon-initial-message-from-queue.png)

Далее вы укажите необходимые сведения для действий, которые следуют за **полным начальным сообщением в действии Queue** . Вы начнете с действий в, **пока для сеанса в цикле очереди больше сообщений** .

<a name="while-more-messages-for-session"></a>

### <a name="while-there-are-more-messages-for-the-session-in-the-queue"></a>Хотя для сеанса в очереди больше сообщений

Этот [цикл **until**](../logic-apps/logic-apps-control-flow-loops.md#until-loop) выполняет эти действия, пока сообщения существуют в очереди или пока не прошло один час. Чтобы изменить предельное время цикла, измените значение свойства **время ожидания** цикла.

* Получение дополнительных сообщений из очереди при наличии сообщений.

* Проверьте количество оставшихся сообщений. Если сообщения по-прежнему существуют, продолжайте обрабатывать сообщения. Если сообщения больше не существуют, Рабочий процесс присваивает `isDone` переменной значение `true` , а затем завершает цикл.

![Цикл Until. Обработка сообщений в очереди](./media/send-related-messages-sequential-convoy/while-more-messages-for-session-in-queue.png)

1. В действии служебная шина **получите дополнительные сообщения из сеанса** и укажите имя очереди служебной шины. В противном случае не заключайте все остальные значения свойств по умолчанию в действии.

   > [!NOTE]
   > По умолчанию максимальное число сообщений равно `175` , но на это ограничение влияет свойство размер сообщения и максимальное значение размера сообщения в служебной шине. Дополнительные сведения см. в разделе [размер сообщения для очереди](../service-bus-messaging/service-bus-quotas.md).

   ![Действие служебной шины — "получить дополнительные сообщения из сеанса"](./media/send-related-messages-sequential-convoy/get-additional-messages-from-session.png)

   Далее рабочий процесс разбивается на следующие параллельные ветви:

   * Если во время проверки наличия дополнительных сообщений возникает ошибка или сбой, задайте `isDone` для переменной значение `true` .

   * Эти **сообщения обрабатываются при** условии, что количество оставшихся сообщений равно нулю. Если значение false и число сообщений существуют, продолжайте обработку. Если задано значение true и сообщения больше не существуют, Рабочий процесс задает `isDone` для переменной значение `true` .

   ![Условие — обрабатывать сообщения, если таковые имеются](./media/send-related-messages-sequential-convoy/process-messages-if-any.png)

   В разделе **If false** цикл **for each** обрабатывает каждое сообщение в порядке "первым поступил — первым обслужен" (FIFO). В **параметрах** цикла параметр **управления параллелизмом** имеет значение `1` , поэтому одновременно обрабатывается только одно сообщение.

   ![Цикл "For Each" — обработка каждого сообщения по одному за раз](./media/send-related-messages-sequential-convoy/for-each-additional-message.png)

1. Для действий служебной шины **заполните сообщение в очереди** и отзовите его **в очереди**, укажите имя очереди служебной шины.

   ![Действия служебной шины — "завершить сообщение в очереди" и "отказаться от сообщения в очереди"](./media/send-related-messages-sequential-convoy/abandon-or-complete-message-in-queue.png)

   После того, как в очереди будет готово **больше сообщений для сеанса** , Рабочий процесс задает `isDone` для переменной значение `true` .

Далее вы укажите необходимые сведения для действий в цикле **продления сеанса до отмены** цикла.

<a name="renew-session-while-messages-exist"></a>

### <a name="renew-session-lock-until-cancelled"></a>Продлить блокировку сеанса до отмены

Этот [цикл **until**](../logic-apps/logic-apps-control-flow-loops.md#until-loop) гарантирует, что блокировка сеанса удерживается этим приложением логики, пока сообщения существуют в очереди или пока не пройдет один час, запустив эти действия. Чтобы изменить предельное время цикла, измените значение свойства **время ожидания** цикла.

* Задержка в течение 25 секунд или на время, меньшее, чем время ожидания блокировки для обрабатываемой очереди. Наименьшая продолжительность блокировки составляет 30 секунд, поэтому значение по умолчанию достаточно. Однако можно оптимизировать количество выполнений цикла, изменив соответствующие значения.

* Проверьте, `isDone` имеет ли переменная значение `true` .

  * Если параметр `isDone` не имеет значение `true` , Рабочий процесс по-прежнему обрабатывает сообщения, поэтому рабочий процесс обновляет блокировку сеанса в очереди и снова проверяет условие цикла.

    Необходимо указать имя очереди служебной шины в действии служебной шины, [**продлить блокировку в сеансе в очереди**](#renew-lock-on-session).

  * Если параметр `isDone` имеет значение `true` , Рабочий процесс не обновляет блокировку сеанса в очереди и выходит из цикла.

  ![Цикл Until — "продлить блокировку сеанса до отмены"](./media/send-related-messages-sequential-convoy/renew-lock-until-session-cancelled.png)

<a name="renew-lock-on-session"></a>

#### <a name="renew-lock-on-the-session-in-a-queue"></a>Продлить блокировку сеанса в очереди

Это действие служебной шины возобновляет блокировку сеанса в очереди, пока рабочий процесс все еще обрабатывает сообщения.

* В действии служебная шина **продлите блокировку сеанса в очереди** и укажите имя очереди служебной шины.

  ![Действие служебной шины — "продлить блокировку на сеанс в очереди"](./media/send-related-messages-sequential-convoy/renew-lock-on-session-in-queue.png)

Далее вы укажите необходимые сведения для действия служебной шины, **закроете сеанс в очереди и завершите** его.

<a name="close-session-succeed"></a>

### <a name="close-a-session-in-a-queue-and-succeed"></a>Закрыть сеанс в очереди и завершить его выполнение

Это действие служебной шины закрывает сеанс в очереди после того, как рабочий процесс заканчивает обработку всех доступных сообщений в очереди, или рабочий процесс отменяет исходное сообщение.

* В действии служебной шины **закройте сеанс в очереди и** укажите имя очереди служебной шины.

  ![Действие служебной шины — "закрыть сеанс в очереди и завершить"](./media/send-related-messages-sequential-convoy/close-session-in-queue-succeed.png)

В следующих разделах описываются действия в `Catch` разделе, которые обрабатывали ошибки и исключения, происходящие в рабочем процессе.

<a name="close-session-fail"></a>

### <a name="close-a-session-in-a-queue-and-fail"></a>Закрытие сеанса в очереди и сбой

Это действие служебной шины всегда выполняется как первое действие в `Catch` области и закрывает сеанс в очереди.

* В действии служебной шины **закройте сеанс в очереди и** укажите имя очереди служебной шины.

  ![Действие служебной шины — "закрыть сеанс в очереди и завершить работу"](./media/send-related-messages-sequential-convoy/close-session-in-queue-fail.png)

Затем рабочий процесс создает массив с входами и выходами из всех действий в `Try` области, чтобы приложение логики могло получить доступ к сведениям об ошибке или сбое.

<a name="find-failure-message"></a>

### <a name="find-failure-msg-from-try-block"></a>Найти сообщение о сбое в блоке "try"

Это [действие **фильтрации массива**](../logic-apps/logic-apps-perform-data-operations.md#filter-array-action) создает массив с входными данными и выходами из всех действий в `Try` области на основе заданных критериев с помощью [ `result()` функции](../logic-apps/workflow-definition-language-functions-reference.md#result). В этом случае это действие возвращает выходные данные действий, имеющих `Failed` состояние, с помощью [ `equals()` функции](../logic-apps/workflow-definition-language-functions-reference.md#equals) и [ `item()` функции](../logic-apps/workflow-definition-language-functions-reference.md#item).

![Действие "Фильтрация массива"-"найти сообщение о сбое" блока "try"](./media/send-related-messages-sequential-convoy/find-failure-message.png)

Вот определение JSON для этого действия:

```json
"Find_failure_msg_from_'Try'_block": {
   "inputs": {
      "from": "@Result('Try')",
      "where": "@equals(item()['status'], 'Failed')"
   },
   "runAfter": {
      "Close_the_session_in_the_queue_and_fail": [
         "Succeeded"
      ]
   },
   "type": "Query"
},
```

Затем рабочий процесс создает массив с объектом JSON, который содержит сведения об ошибке в массиве, возвращенном из `Find failure msg from 'Try' block` действия.

<a name="select-error-details"></a>

### <a name="select-error-details"></a>Выбор сведений об ошибке

Это [действие **SELECT**](../logic-apps/logic-apps-perform-data-operations.md#select-action) создает массив, содержащий объекты JSON на основе входного массива, полученного из предыдущего действия `Find failure msg from 'Try' block` . В частности, это действие возвращает массив, который содержит только указанные свойства для каждого объекта в массиве. В этом случае массив содержит свойства имя действия и результат ошибки.

![Выберите действие-"выбрать сведения об ошибке".](./media/send-related-messages-sequential-convoy/select-error-details.png)

Вот определение JSON для этого действия:

```json
"Select_error_details": {
   "inputs": {
      "from": "@body('Find_failure_msg_from_''Try''_block')[0]['outputs']",
      "select": {
         "action": "@item()['name']",
         "errorResult": "@item()"
      }
   },
   "runAfter": {
      "Find_failure_msg_from_'Try'_block": [
         "Succeeded"
      ]
   },
   "type": "Select"
},
```

Далее рабочий процесс останавливает выполнение приложения логики и возвращает состояние выполнения, а также дополнительные сведения об ошибке или сбое.

<a name="terminate-logic-app"></a>

### <a name="terminate-logic-app-run"></a>Завершение выполнения приложения логики

Это [действие **прерывает**](../logic-apps/logic-apps-workflow-actions-triggers.md#terminate-action) выполнение приложения логики и возвращает в `Failed` качестве состояния для запуска приложения логики вместе с идентификатором сеанса и ошибкой из `Select error details` действия.

![Прекращение действия для прекращения запуска приложения логики](./media/send-related-messages-sequential-convoy/terminate-logic-app-run.png)

Вот определение JSON для этого действия:

```json
"Terminate": {
   "description": "This Failure Termination only runs if the Close Session upon Failure action runs - otherwise the LA will be terminated as Success",
   "inputs": {
      "runError": {
         "code": "",
         "message": "There was an error processing messages for Session ID @{triggerBody()?['SessionId']}. The following error(s) occurred: @{body('Select_error_details')['errorResult']}"
         },
         "runStatus": "Failed"
      },
      "runAfter": {
         "Select_error_details": [
            "Succeeded"
         ]
      },
      "type": "Terminate"
   }
},
```

## <a name="save-and-run-logic-app"></a>Сохранение и запуск приложения логики

После завершения шаблона можно сохранить приложение логики. На панели инструментов конструктора щелкните **Сохранить**.

Чтобы протестировать приложение логики, отправьте сообщения в очередь служебной шины. 

## <a name="next-steps"></a>Дальнейшие действия

* Дополнительные сведения о [триггерах и действиях соединителя служебной шины](/connectors/servicebus/)
