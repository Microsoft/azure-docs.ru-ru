---
title: Справочник по схемам для типов триггеров и действий
description: Справочник по схемам для триггера языка определения рабочего процесса и типов действий в Azure Logic Apps
services: logic-apps
ms.suite: integration
ms.reviewer: jonfan, logicappspm
ms.topic: conceptual
ms.date: 09/22/2020
ms.custom: devx-track-js
ms.openlocfilehash: ea4a4a47e91e88c00ca8a4e886d0372a24482907
ms.sourcegitcommit: a055089dd6195fde2555b27a84ae052b668a18c7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/26/2021
ms.locfileid: "98784314"
---
# <a name="schema-reference-guide-for-trigger-and-action-types-in-azure-logic-apps"></a>Справочник по схемам для типов триггеров и действий в Azure Logic Apps

Эта ссылка описывает общие типы, используемые для идентификации триггеров и действий в базовом определении рабочего процесса приложения логики, которое описывается и проверяется с помощью [языка определения рабочего процесса](../logic-apps/logic-apps-workflow-definition-language.md). Чтобы найти определенные триггеры соединителя и действия, которые можно использовать в приложениях логики, см. список в разделе [Общие сведения о соединителях](/connectors/).

<a name="triggers-overview"></a>

## <a name="triggers-overview"></a>Общие сведения о триггерах

Каждый рабочий процесс включает триггер, который определяет вызовы, создающие экземпляры и запускающие рабочий процесс. Ниже приведены общие категории триггеров.

* *Опрашивающий* триггер проверяет конечную точку службы через равные промежутки времени.

* *Извещающий* триггер создает подписку на конечную точку и предоставляет *URL-адрес обратного вызова*, чтобы конечная точка могла уведомлять триггер, когда происходит указанное событие или стали доступны данные. Затем триггер ожидает ответа конечной точки, прежде чем сработать.

Триггеры имеют следующие основные элементы, хотя некоторые из них являются необязательными.  
  
```json
"<trigger-name>": {
   "type": "<trigger-type>",
   "inputs": { "<trigger-inputs>" },
   "recurrence": { 
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "conditions": [ "<array-with-conditions>" ],
   "runtimeConfiguration": { "<runtime-config-options>" },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
},
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*Имя триггера*> | Строка | Имя триггера | 
| <*тип триггера*> | Строка | Тип триггера, например Http или ApiConnection | 
| <*входные данные триггера*> | Объект JSON | Входные данные, определяющие режим работы триггера | 
| <*единица времени*> | Строка | Единица времени, которая описывает, как часто срабатывает триггер: "секунда", "минута", "час", "день", "неделя" или "месяц" | 
| <*количество единиц времени*> | Целое число | Значение, указывающее, как часто триггер срабатывает на основе частоты, т.е. количество единиц времени, которое необходимо выждать, прежде чем триггер сработает снова <p>Ниже приведены минимальный и максимальный интервалы. <p>— Месяц: 1–16 месяцев; </br>— День: 1–500 дней; </br>— Час: 1–12 000 часов; </br>— Минута: 1–72 000 минут; </br>— Секунда: 1–9 999 999 секунд.<p>Например, если интервал равен 6, а значение частоты — Month, то повтор будет происходить каждые 6 месяцев. | 
|||| 

*Необязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*массив с условиями*> | Array | Массив, содержащий одно или несколько [условий](#trigger-conditions) , которые определяют, следует ли запускать рабочий процесс. Доступно только для триггеров. | 
| <*Runtime-config-параметры*> | Объект JSON | Можно изменить поведение триггера во время выполнения, задав свойства `runtimeConfiguration`. Дополнительные сведения см. в разделе [Настройки конфигурации среды выполнения](#runtime-config-options). | 
| <*splitOn-Expression*> | Строка | Для триггеров, возвращающих массив, можно указать выражение для обработки, которое [разделяет или *выполняет по отдельности*](#split-on-debatch) элементы массива на нескольких экземплярах рабочего процесса. | 
| <*Operation — параметр*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

## <a name="trigger-types-list"></a>Список типов триггеров

Каждый тип триггера имеет свой интерфейс и свои входные данные, которые определяют его поведение. 

### <a name="built-in-triggers"></a>Встроенные триггеры

| Тип триггера | Описание | 
|--------------|-------------| 
| [**HTTP**](#http-trigger) | Проверяет или *опрашивает* любую конечную точку. Эта конечная точка должна соответствовать определенному контракту триггера либо с помощью `202` асинхронной модели, либо путем возвращения массива. | 
| [**HTTPWebhook**](#http-webhook-trigger) | Создает вызываемую конечную точку для приложения логики, но также вызывает указанный URL-адрес для регистрации или отмены регистрации. |
| [**Периодичность**](#recurrence-trigger) | Активируется на основе определенного расписания. Можно задать дату и время в будущем для срабатывания триггера. На основе частоты можно также указать время и дни запуска рабочего процесса. | 
| [**Запрос**](#request-trigger)  | Создает вызываемую конечную точку для приложения логики, также называется "ручным" триггером. Например, ознакомьтесь со статьей [Вызовы, срабатывания триггеров и создание вложенных рабочих процессов в приложениях логики](../logic-apps/logic-apps-http-endpoint.md). | 
||| 

### <a name="managed-api-triggers"></a>Управляемые триггеры API

| Тип триггера | Описание | 
|--------------|-------------| 
| [**ApiConnection**](#apiconnection-trigger) | Проверяет или *опрашивает* конечную точку с помощью [управляемых Майкрософт интерфейсов API](../connectors/apis-list.md). | 
| [**ApiConnectionWebhook**](#apiconnectionwebhook-trigger) | Создает вызываемую конечную точку для приложения логики, вызывая [управляемые Майкрософт интерфейсы API](../connectors/apis-list.md), для подписки или отмены подписки. | 
||| 

## <a name="triggers---detailed-reference"></a>Триггеры. Подробная справочная информация

<a name="apiconnection-trigger"></a>

### <a name="apiconnection-trigger"></a>Триггер APIConnection  

Этот триггер проверяет или *опрашивает* конечную точку с помощью [управляемых Майкрософт интерфейсов API](../connectors/apis-list.md), поэтому параметры для этого триггера могут отличаться в зависимости от конечной точки. Многие разделы в этом определении триггера являются необязательными. Режим работы триггера зависит от того, включены ли разделы.

```json
"<APIConnection_trigger_name>": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<connection-name>']['connectionId']"
         }
      },
      "method": "<method-type>",
      "path": "/<api-operation>",
      "retryPolicy": { "<retry-behavior>" },
      "queries": { "<query-parameters>" }
   },
   "recurrence": { 
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
}
```

*Обязательное*

| Значение | Тип | Описание |
|-------|------|-------------|
| <*APIConnection_trigger_name*> | Строка | Имя триггера |
| <*имя соединения*> | Строка | Имя подключения к управляемому API, который используется рабочим процессом |
| <*тип метода*> | Строка | Метод HTTP для обмена данными с управляемым API: GET, PUT, POST, PATCH или DELETE |
| <*API-операция*> | Строка | Операция API для вызова |
| <*единица времени*> | Строка | Единица времени, которая описывает, как часто срабатывает триггер: "секунда", "минута", "час", "день", "неделя" или "месяц" |
| <*количество единиц времени*> | Целое число | Значение, указывающее, как часто триггер срабатывает на основе частоты, т.е. количество единиц времени, которое необходимо выждать, прежде чем триггер сработает снова <p>Ниже приведены минимальный и максимальный интервалы. <p>— Месяц: 1–16 месяцев; </br>— День: 1–500 дней; </br>— Час: 1–12 000 часов; </br>— Минута: 1–72 000 минут; </br>— Секунда: 1–9 999 999 секунд.<p>Например, если интервал равен 6, а значение частоты — Month, то повтор будет происходить каждые 6 месяцев. |
||||

*Необязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*поведение повторных попыток*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*Параметры запроса*> | Объект JSON | Все параметры запроса для включения с помощью вызова API. Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*Максимальное число запусков*> | Целое число | По умолчанию экземпляры рабочих процессов выполняются одновременно (одновременно или параллельно) до [предельного значения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*Max-запуски — очередь*> | Целое число | Если рабочий процесс уже выполняет максимальное число экземпляров, которое можно изменить в зависимости от `runtimeConfiguration.concurrency.runs` свойства, все новые запуски помещаются в эту очередь вплоть до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*splitOn-Expression*> | Строка | Для триггеров, возвращающих массивы, это выражение ссылается на массив, который необходимо использовать, чтобы вы могли создать и запустить экземпляр рабочего процесса для каждого элемента массива, а не использовали цикл Foreach. <p>Например, следующее выражение представляет элемент массива, возвращенный внутри тела триггера: `@triggerbody()?['value']` |
| <*Operation — параметр*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). |
||||

*Выходные данные*
 
| Элемент | Тип | Описание |
|---------|------|-------------|
| Заголовки | Объект JSON | Заголовки из ответа |
| текст | Объект JSON | Текст из ответа |
| Код состояния | Целое число | Код состояния из ответа |
|||| 

*Пример*

Это определение триггера проверяет электронную почту каждый день в папке "Входящие" для рабочей или учебной учетной записи:

```json
"When_a_new_email_arrives": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "method": "get",
      "path": "/Mail/OnNewEmail",
      "queries": {
          "fetchOnlyWithAttachment": false,
          "folderPath": "Inbox",
          "importance": "Any",
          "includeAttachments": false
      }
   },
   "recurrence": {
      "frequency": "Day",
      "interval": 1
   }
}
```

<a name="apiconnectionwebhook-trigger"></a>

### <a name="apiconnectionwebhook-trigger"></a>Триггер ApiConnectionWebhook

Этот триггер отправляет запрос подписке в конечную точку с помощью [управляемых Майкрософт интерфейсов API](../connectors/apis-list.md), предоставляет *URL-адрес обратного вызова*, на который конечная точка может отправить ответ, и ожидает ответа конечной точки. Дополнительные сведения см. в разделе [Подписка конечной точки](#subscribe-unsubscribe).

```json
"<ApiConnectionWebhook_trigger_name>": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "body": {
          "NotificationUrl": "@{listCallbackUrl()}"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<connection-name>']['connectionId']"
         }
      },
      "retryPolicy": { "<retry-behavior>" },
      "queries": "<query-parameters>"
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-run-queue>
      }
   },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
}
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*имя соединения*> | Строка | Имя подключения к управляемому API, который используется рабочим процессом | 
| <*текст — содержимое*> | Объект JSON | Любое содержимое сообщения для отправки на управляемый API в качестве полезных данных | 
||||

*Необязательно*

| Значение | Тип | Описание |
|-------|------|-------------|
| <*поведение повторных попыток*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). |
| <*Параметры запроса*> | Объект JSON | Все параметры запроса для включения в вызов API <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. |
| <*Максимальное число запусков*> | Целое число | По умолчанию экземпляры рабочих процессов выполняются одновременно (одновременно или параллельно) до [предельного значения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). |
| <*Max-запуски — очередь*> | Целое число | Если рабочий процесс уже выполняет максимальное число экземпляров, которое можно изменить в зависимости от `runtimeConfiguration.concurrency.runs` свойства, все новые запуски помещаются в эту очередь вплоть до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*splitOn-Expression*> | Строка | Для триггеров, возвращающих массивы, это выражение ссылается на массив, который необходимо использовать, чтобы вы могли создать и запустить экземпляр рабочего процесса для каждого элемента массива, а не использовали цикл Foreach. <p>Например, следующее выражение представляет элемент массива, возвращенный внутри тела триггера: `@triggerbody()?['value']` |
| <*Operation — параметр*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

*Пример*

Это определение триггера подписывается на API Office 365 Outlook, предоставляет URL-адрес обратного вызова на конечную точку API и ожидает ответа конечной точки при получении нового электронного письма.

```json
"When_a_new_email_arrives_(webhook)": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "body": {
         "NotificationUrl": "@{listCallbackUrl()}" 
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "path": "/MailSubscription/$subscriptions",
      "queries": {
          "folderPath": "Inbox",
          "hasAttachment": "Any",
          "importance": "Any"
      }
   },
   "splitOn": "@triggerBody()?['value']"
}
```

<a name="http-trigger"></a>

### <a name="http-trigger"></a>Триггер HTTP

Этот триггер отправляет запрос в указанную конечную точку HTTP или HTTPS на основе указанного расписания повторения. Затем триггер проверяет ответ, чтобы определить, выполняется ли рабочий процесс. Дополнительные сведения см. [в разделе вызов конечных точек службы по протоколу HTTP или HTTPS из Azure Logic Apps](../connectors/connectors-native-http.md).

```json
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "<method-type>",
      "uri": "<HTTP-or-HTTPS-endpoint-URL>",
      "headers": { "<header-content>" },
      "queries": "<query-parameters>",
      "body": "<body-content>",
      "authentication": { "<authentication-type-and-property-values>" },
      "retryPolicy": {
         "type": "<retry-behavior>"
      }
   },
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
```

*Обязательное*

| Свойство | Значение | Тип | Описание |
|----------|-------|------|-------------|
| `method` | <*тип метода*> | Строка | Метод, используемый для отправки исходящего запроса: "GET", "Where", "POST", "PATCH" или "DELETE" |
| `uri` | <*HTTP-или-HTTPS-Endpoint-URL*> | Строка | URL-адрес конечной точки HTTP или HTTPS, по которому нужно отправить исходящий запрос. Максимальный размер строки: 2 КБ. <p>Для службы или ресурса Azure этот синтаксис URI включает идентификатор ресурса и путь к ресурсу, к которому требуется получить доступ. |
| `frequency` | <*единица времени*> | Строка | Единица времени, которая описывает, как часто срабатывает триггер: "секунда", "минута", "час", "день", "неделя" или "месяц" |
| `interval` | <*количество единиц времени*> | Целое число | Значение, указывающее, как часто триггер срабатывает на основе частоты, т.е. количество единиц времени, которое необходимо выждать, прежде чем триггер сработает снова <p>Ниже приведены минимальный и максимальный интервалы. <p>— Месяц: 1–16 месяцев; </br>— День: 1–500 дней; </br>— Час: 1–12 000 часов; </br>— Минута: 1–72 000 минут; </br>— Секунда: 1–9 999 999 секунд.<p>Например, если интервал равен 6, а значение частоты — Month, то повтор будет происходить каждые 6 месяцев. |
|||||

*Необязательно*

| Свойство | Значение | Тип | Описание |
|----------|-------|------|-------------|
| `headers` | <*заголовок — содержимое*> | Объект JSON | Все заголовки, которые необходимо включить в запрос <p>Пример задания языка и типа. <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` |
| `queries` | <*Параметры запроса*> | Объект JSON | Любые параметры запроса, которые необходимо использовать в запросе <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к запросу. |
| `body` | <*текст — содержимое*> | Объект JSON | Содержимое сообщения для отправки в качестве полезных данных с запросом |
| `authentication` | <*Проверка подлинности-тип и значение свойства*> | Объект JSON | Модель проверки подлинности, которую запрос использует для проверки подлинности исходящих запросов. Дополнительные сведения см. в разделе [Добавление проверки подлинности в исходящие вызовы](../logic-apps/logic-apps-securing-a-logic-app.md#add-authentication-outbound) далее в этой статье. Помимо планировщика поддерживается свойство `authority`. Если параметр не указан, по умолчанию используется значение `https://management.azure.com/` , но можно использовать другое значение. |
| `retryPolicy` > `type` | <*поведение повторных попыток*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). |
| `runs` | <*Максимальное число запусков*> | Целое число | По умолчанию экземпляры рабочих процессов выполняются одновременно (одновременно или параллельно) до [предельного значения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). |
| `maximumWaitingRuns` | <*Max-запуски — очередь*> | Целое число | Если рабочий процесс уже выполняет максимальное число экземпляров, которое можно изменить в зависимости от `runtimeConfiguration.concurrency.runs` свойства, все новые запуски помещаются в эту очередь вплоть до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). |
| `operationOptions` | <*Operation — параметр*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). |
|||||

*Выходные данные*

| Элемент | Тип | Описание |
|---------|------|-------------|
| `headers` | Объект JSON | Заголовки из ответа |
| `body` | Объект JSON | Текст из ответа |
| `status code` | Целое число | Код состояния из ответа |
||||

*Требования для входящих запросов*

Для работы с приложением логики конечная точка должна соответствовать определенному шаблону или контракту триггера и распознать следующие свойства ответа:

| Свойство | Обязательно | Описание |
|----------|----------|-------------|
| Код состояния | Да | Код состояния "200 OK" инициирует запуск. Другие коды состояния — нет. |
| Заголовок retry-after | Нет | Количество секунд, пока приложение логики не опрашивает конечную точку повторно |
| Заголовок Location | Нет | URL-адрес для вызова во время следующего интервала опроса. Если не указан, используется исходный URL-адрес. |
|||| 

*Пример поведения для различных запросов*

| Код состояния | Повтор через | Поведение | 
|-------------|-------------|----------|
| 200 | {нет} | Выполняется рабочий процесс, затем после определенного количества повторений снова проверяется, не добавились ли данные. | 
| 200 | 10 с | Выполняется рабочий процесс, затем через 10 секунд снова проверяется, не добавились ли данные. |  
| 202 | 60 секунд | Рабочий процесс не запускается. Следующая попытка происходит через одну минуту с учетом определенного повторения. Если определенное повторение составляет менее минуты, то приоритет имеет заголовок retry-after. В противном случае используется определенное повторение. | 
| 400 | {нет} | Недопустимый запрос, рабочий процесс не запускается. Если параметр `retryPolicy` не задан, то используется политика по умолчанию. После достижения количества попыток триггер снова проверяет наличие данных после определенного числа повторений. | 
| 500 | {нет}| Ошибка сервера, рабочий процесс не запускается. Если параметр `retryPolicy` не задан, то используется политика по умолчанию. После достижения количества попыток триггер снова проверяет наличие данных после определенного числа повторений. | 
|||| 

<a name="http-webhook-trigger"></a>

### <a name="httpwebhook-trigger"></a>Триггер httpWebhook  

Этот триггер делает приложение логики вызываемым, создавая конечную точку, которая может зарегистрировать подписку путем вызова URL-адреса указанной конечной точки. При создании этого триггера в рабочем процессе исходящий запрос выполняет вызов для регистрации подписки. Таким образом, триггер может запустить ожидание событий. Когда операция делает этот триггер недопустимым, исходящий запрос автоматически выполняет вызов для отмены подписки. Дополнительные сведения см. в разделе [Подписка конечной точки](#subscribe-unsubscribe).

Можно также указать [ограничения асинхронных операций](#asynchronous-limits) на триггере **HTTPWebhook**. Поведение триггера зависит от разделов, которые используются или пропускаются.

```json
"HTTP_Webhook": {
   "type": "HttpWebhook",
   "inputs": {
      "subscribe": {
         "method": "<method-type>",
         "uri": "<endpoint-subscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" },
         "retryPolicy": { "<retry-behavior>" }
         },
      },
      "unsubscribe": {
         "method": "<method-type>",
         "url": "<endpoint-unsubscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" }
      }
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
```

Некоторые значения, например <*method-type*>, доступны для объектов `"subscribe"` и `"unsubscribe"`.

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*тип метода*> | Строка | Метод HTTP, используемый для запроса подписки: "GET", "PUT", "POST", "PATCH" или "DELETE" | 
| <*Endpoint-Subscribe-URL*> | Строка | URL-адрес конечной точки для отправки запроса на подписку | 
|||| 

*Необязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*тип метода*> | Строка | Метод HTTP, используемый для запроса отмены: GET, PUT, POST, PATCH или DELETE | 
| <*Конечная точка-Отмена подписки — URL-адрес*> | Строка | URL-адрес конечной точки для отправки запроса на отмену | 
| <*текст — содержимое*> | Строка | Любое содержимое сообщения для отправки в запросе на подписку или отмену | 
| <*тип проверки подлинности*> | Объект JSON | Модель проверки подлинности, которую запрос использует для проверки подлинности исходящих запросов. Дополнительные сведения см. в разделе [Добавление проверки подлинности в исходящие вызовы](../logic-apps/logic-apps-securing-a-logic-app.md#add-authentication-outbound) далее в этой статье. |
| <*поведение повторных попыток*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*Максимальное число запусков*> | Целое число | По умолчанию экземпляры рабочих процессов выполняются одновременно (одновременно или параллельно) до [предельного значения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*Max-запуски — очередь*> | Целое число | Если рабочий процесс уже выполняет максимальное число экземпляров, которое можно изменить в зависимости от `runtimeConfiguration.concurrency.runs` свойства, все новые запуски помещаются в эту очередь вплоть до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*Operation — параметр*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

*Выходные данные* 

| Элемент | Тип | Описание |
|---------|------|-------------| 
| Заголовки | Объект JSON | Заголовки из ответа | 
| текст | Объект JSON | Текст из ответа | 
| Код состояния | Целое число | Код состояния из ответа | 
|||| 

*Пример*

Этот триггер создает подписку на указанную конечную точку, предоставляет уникальный URL-адрес обратного вызова и ожидает новых публикаций технологических статей.

```json
"HTTP_Webhook": {
   "type": "HttpWebhook",
   "inputs": {
      "subscribe": {
         "method": "POST",
         "uri": "https://pubsubhubbub.appspot.com/subscribe",
         "body": {
            "hub.callback": "@{listCallbackUrl()}",
            "hub.mode": "subscribe",
            "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
         },
      },
      "unsubscribe": {
         "method": "POST",
         "url": "https://pubsubhubbub.appspot.com/subscribe",
         "body": {
            "hub.callback": "@{workflow().endpoint}@{listCallbackUrl()}",
            "hub.mode": "unsubscribe",
            "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
         }
      }
   }
}
```

<a name="recurrence-trigger"></a>

### <a name="recurrence-trigger"></a>Триггер повторения  

Этот триггер выполняется на основе указанного расписания повторов и предоставляет простой способ создания регулярно запускающегося рабочего процесса.

```json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
      "startTime": "<start-date-time-with-format-YYYY-MM-DDThh:mm:ss>",
      "timeZone": "<time-zone>",
      "schedule": {
         // Applies only when frequency is Day or Week. Separate values with commas.
         "hours": [ <one-or-more-hour-marks> ], 
         // Applies only when frequency is Day or Week. Separate values with commas.
         "minutes": [ <one-or-more-minute-marks> ], 
         // Applies only when frequency is Week. Separate values with commas.
         "weekDays": [ "Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday" ] 
      }
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*единица времени*> | Строка | Единица времени, которая описывает, как часто срабатывает триггер: "секунда", "минута", "час", "день", "неделя" или "месяц" | 
| <*количество единиц времени*> | Целое число | Значение, указывающее, как часто триггер срабатывает на основе частоты, т.е. количество единиц времени, которое необходимо выждать, прежде чем триггер сработает снова <p>Ниже приведены минимальный и максимальный интервалы. <p>— Месяц: 1–16 месяцев; </br>— День: 1–500 дней; </br>— Час: 1–12 000 часов; </br>— Минута: 1–72 000 минут; </br>— Секунда: 1–9 999 999 секунд.<p>Например, если интервал равен 6, а значение частоты — Month, то повтор будет происходить каждые 6 месяцев. | 
|||| 

*Необязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*Начало-Дата-время-с-Format-гггг-мм-DDThh: мм: СС*> | Строка | Дата и время начала в таком формате: <p>ГГГГ-ММ-ДДTчч:мм:сс, если указан часовой пояс, <p>-или- <p>ГГГГ-ММ-ДДTчч:мм:ссZ, если часовой пояс не указан. <p>Например, если требуется указать 18 сентября 2017 г. в 14:00, то используйте 2017-09-18T14:00:00 и укажите часовой пояс, такой как "Стандартное тихоокеанское время", или укажите "2017-09-18T14:00:00Z" без часового пояса. <p>**Примечание.** Время начала не может превышать 49 лет в будущем. оно должно соответствовать [спецификации даты и времени ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) в [формате даты и времени](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)в формате UTC, но без [смещения в формате UTC](https://en.wikipedia.org/wiki/UTC_offset). Если не указать часовой пояс, то необходимо в конце добавить букву Z без пробелов. Эта буква Z ссылается на соответствующее [судовое время](https://en.wikipedia.org/wiki/Nautical_time). <p>В простых расписаниях время начала определяет первый случай выполнения задания, а в сложных расписаниях триггер срабатывает не раньше, чем наступит время начала. Дополнительные сведения о дате и времени начала см. в статье [Начало работы с триггером повторения](../connectors/connectors-native-recurrence.md). | 
| <*Часовой пояс*> | Строка | Применяется только при указании времени начала, так как этот триггер не принимает [смещение от UTC](https://en.wikipedia.org/wiki/UTC_offset). Укажите часовой пояс, который необходимо применить. | 
| <*один-или несколько часов-меток*> | Целое число или массив целых чисел | Если для параметра `frequency` задать значение Day или Week, то можно указать одно или несколько целых чисел от 0 до 23, разделенных запятыми. В эти часы будет запускаться рабочий процесс. <p>Например, если указать 10, 12 и 14, вы получите часовые метки 10:00, 12:00 и 14:00. | 
| <*Метки "один-или несколько минут"*> | Целое число или массив целых чисел | Если для параметра `frequency` задать значение Day или Week, то можно указать одно или несколько целых чисел от 0 до 59, разделенных запятыми. В эти минуты часа будет запускаться рабочий процесс. <p>Например, если указать 30 минут и использовать предыдущий пример для часов, то вы получите 10:30, 12:30 и 14:30. | 
| weekDays | Строка или массив строк | Если для параметра `frequency` задать значение Week, то можно указать один или несколько дней, разделенных запятыми. В эти дни будет запускаться рабочий процесс: Monday (Понедельник), Tuesday (Вторник), Wednesday (Среда), Thursday (Четверг), Friday (Пятница), Saturday (Суббота) и Sunday (Воскресенье). | 
| <*Максимальное число запусков*> | Целое число | По умолчанию экземпляры рабочих процессов выполняются одновременно (одновременно или параллельно) до [предельного значения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*Max-запуски — очередь*> | Целое число | Если рабочий процесс уже выполняет максимальное число экземпляров, которое можно изменить в зависимости от `runtimeConfiguration.concurrency.runs` свойства, все новые запуски помещаются в эту очередь вплоть до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*Operation — параметр*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

*Пример 1*

Этот основной триггер повторения запускается ежедневно:

```json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Day",
      "interval": 1
   }
}
```

*Пример 2*

Вы можете задать дату и время, когда триггер будет срабатывать. Этот триггер повторения будет запущен в соответствии с указанной датой, а затем будет срабатывать ежедневно:

```json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Day",
      "interval": 1,
      "startTime": "2017-09-18T00:00:00Z"
   }
}
```

*Пример 3*

Этот триггер повторения был запущен 9 сентября 2017 года в 14:00 и запускался каждый понедельник в 10:30, 12:30 и 14:30 по тихоокеанскому времени:

``` json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Week",
      "interval": 1,
      "schedule": {
         "hours": [ 10, 12, 14 ],
         "minutes": [ 30 ],
         "weekDays": [ "Monday" ]
      },
      "startTime": "2017-09-07T14:00:00",
      "timeZone": "Pacific Standard Time"
   }
}
```

Дополнительные сведения, а также примеры это триггера см. в статье [Создание и планирование регулярно выполняющихся задач при помощи Azure Logic Apps](../connectors/connectors-native-recurrence.md).

<a name="request-trigger"></a>

### <a name="request-trigger"></a>Триггер запросов

Этот триггер делает приложение логики вызываемым, создавая конечную точку, которая может принимать входящие запросы. Предоставьте схему JSON для этого триггера, которая описывает и проверяет полезные или входные данные, которые триггер получает от входящего запроса. Схема также упрощает свойства триггеров для ссылки на следующие действия в рабочем процессе.

Чтобы вызвать этот триггер, необходимо использовать API `listCallbackUrl`, описанный в [REST API службы рабочих процессов](/rest/api/logic/workflows). Чтобы узнать, как использовать этот триггер в качестве конечной точки HTTP, см. сведения в статье [Вызовы, срабатывания триггеров и создание вложенных рабочих процессов в приложениях логики](../logic-apps/logic-apps-http-endpoint.md).

```json
"manual": {
   "type": "Request",
   "kind": "Http",
   "inputs": {
      "method": "<method-type>",
      "relativePath": "<relative-path-for-accepted-parameter>",
      "schema": {
         "type": "object",
         "properties": { 
            "<property-name>": {
               "type": "<property-type>"
            }
         },
         "required": [ "<required-properties>" ]
      }
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-run-queue>
      },
   },
   "operationOptions": "<operation-option>"
}
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*имя свойства*> | Строка | Имя свойства в схеме JSON, которое описывает полезные данные | 
| <*Тип свойства*> | Строка | Тип свойства | 
|||| 

*Необязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*тип метода*> | Строка | Метод, который входящие запросы должны использовать для вызова приложения логики: GET, PUT, POST, PATCH или DELETE |
| <*относительный путь-для-параметр*> | Строка | Относительный путь для параметра, который принимает URL-адрес конечной точки | 
| <*обязательный параметр — свойства*> | Array | Одно или несколько свойств, требующих значений | 
| <*Максимальное число запусков*> | Целое число | По умолчанию экземпляры рабочих процессов выполняются одновременно (одновременно или параллельно) до [предельного значения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма триггера](#change-trigger-concurrency). | 
| <*Max-запуски — очередь*> | Целое число | Если рабочий процесс уже выполняет максимальное число экземпляров, которое можно изменить в зависимости от `runtimeConfiguration.concurrency.runs` свойства, все новые запуски помещаются в эту очередь вплоть до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | 
| <*Operation — параметр*> | Строка | Поведение по умолчанию можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

*Пример*

Этот триггер указывает, что входящий запрос должен использовать HTTP-метод POST для вызова триггера, а также включать схему, проверяющую входные данные входящего запроса.

```json
"manual": {
   "type": "Request",
   "kind": "Http",
   "inputs": {
      "method": "POST",
      "schema": {
         "type": "object",
         "properties": {
            "customerName": {
               "type": "String"
            },
            "customerAddress": { 
               "type": "Object",
               "properties": {
                  "streetAddress": {
                     "type": "string"
                  },
                  "city": {
                     "type": "string"
                  }
               }
            }
         }
      }
   }
}
```

<a name="trigger-conditions"></a>

## <a name="trigger-conditions"></a>Условия триггера

Для любого триггера (или только для триггера) можно включить массив, содержащий одно или несколько выражений для условий, определяющих, следует ли запускать рабочий процесс. Чтобы добавить `conditions` свойство в триггер в рабочем процессе, откройте приложение логики в редакторе представления кода.

Например, можно указать, что триггер срабатывает, только если веб-сайт возвращает внутреннюю ошибку сервера, ссылаясь на код состояния триггера в свойстве `conditions`.

```json
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Hour",
      "interval": 1
   },
   "conditions": [ {
      "expression": "@equals(triggers().code, 'InternalServerError')"
   } ]
}
```

По умолчанию триггер срабатывает только после получения ответа "200 OK". Если выражение ссылается на код состояния триггера, стандартный режим работы триггера изменяется. Таким образом, если требуется запуск триггера при более чем одном коде состояния, например "200" и "201", необходимо включить в качестве условия следующее выражение.

`@or(equals(triggers().code, 200),equals(triggers().code, 201))` 

<a name="split-on-debatch"></a>

## <a name="trigger-multiple-runs"></a>Множественные запуски триггера

Если триггер возвращает массив для обработки приложением логики, цикл for each может занять слишком много времени для обработки каждого элемента массива. Вместо этого можно использовать свойство **SplitOn** в триггере, чтобы выполнить *индивидуальную обработку* массива. При депакетировании элементы массива разбиваются и запускается новый экземпляр рабочего процесса, который выполняется для каждого элемента массива. Такой подход является эффективным, например, если нужно опросить конечную точку, которая может вернуть несколько новых элементов между интервалами опроса. Максимальное число элементов массива, которое свойство **SplitOn** позволяет обработать в одном приложении логики, см. в статье [Ограничения и настройка Logic Apps](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). 

> [!NOTE]
> Нельзя использовать свойство **SplitOn** с шаблоном синхронного отклика. Любой рабочий процесс, который использует свойство **SplitOn** и содержит действие ответа, выполняется асинхронно и сразу же отправляет ответ `202 ACCEPTED`.
>
> Если включен параллелизм триггеров, [ограничение SplitOn](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) значительно сокращается. Если число элементов превышает это ограничение, функция SplitOn отключается.
 
Если в файле триггера Swagger описаны полезные данные, составляющие массив, **SplitOn** автоматически добавляется в триггер. В противном случае добавьте это свойство в полезные данные ответа, содержащий массив, который нужно обработать индивидуально.

*Пример*

Допустим, что имеется API, который возвращает следующий ответ. 
  
```json
{
   "Status": "Succeeded",
   "Rows": [ 
      { 
         "id": 938109380,
         "name": "customer-name-one"
      },
      {
         "id": 938109381,
         "name": "customer-name-two"
      }
   ]
}
```

Приложению логики требуется только содержимое массива `Rows`, поэтому можно создать триггер, как в следующем примере.

``` json
"HTTP_Debatch": {
   "type": "Http",
    "inputs": {
        "uri": "https://mydomain.com/myAPI",
        "method": "GET"
    },
   "recurrence": {
      "frequency": "Second",
      "interval": 1
    },
    "splitOn": "@triggerBody()?.Rows"
}
```

> [!NOTE]
> Если используется команда `SplitOn`, получить свойства, которые находятся за пределами массива, невозможно. В нашем примере получить свойство `status` в ответе, возвращенном из API, невозможно.
> 
> Чтобы избежать ошибок, если отсутствует свойство `Rows`, в этом примере используется оператор `?`.

Теперь в определении рабочего процесса можно использовать `@triggerBody().name`, чтобы получить значения `name`, которые являются значениями `"customer-name-one"` при первом выполнении и `"customer-name-two"` при втором выполнении. Выходные данные триггера выглядят так:

```json
{
   "body": {
      "id": 938109380,
      "name": "customer-name-one"
   }
}
```

```json
{
   "body": {
      "id": 938109381,
      "name": "customer-name-two"
   }
}
```

<a name="actions-overview"></a>

## <a name="actions-overview"></a>Общие сведения о действиях

Azure Logic Apps предоставляет различные типы действий. Каждый из них имеет различные входные данные, которые определяют уникальный режим работы действия. Действия включают следующие основные элементы, хотя некоторые из них являются необязательными.

```json
"<action-name>": {
   "type": "<action-type>",
   "inputs": { 
      "<input-name>": { "<input-value>" },
      "retryPolicy": "<retry-behavior>" 
   },
   "runAfter": { "<previous-trigger-or-action-status>" },
   "runtimeConfiguration": { "<runtime-config-options>" },
   "operationOptions": "<operation-option>"
},
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------|
| <*действие — имя*> | Строка | Имя действия | 
| <*Тип действия*> | Строка | Тип действия, например Http или ApiConnection| 
| <*имя входа*> | Строка | Имя для входа, определяющее поведение действия | 
| <*входное значение*> | Различные | Входное значение, которое может быть строкой, целым числом, объектом JSON и т. д. | 
| <*Предыдущий триггер-или-Action-Status*> | Объект JSON | Имя и итоговое состояние для триггера или действия, которое должно выполняться немедленно перед запуском текущего действия | 
|||| 

*Необязательно*

| Значение | Тип | Описание | 
|-------|------|-------------|
| <*поведение повторных попыток*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе "Политики повтора". | 
| <*Runtime-config-параметры*> | Объект JSON | Режим работы некоторых действий во время выполнения можно изменить, задав свойство `runtimeConfiguration`. Дополнительные сведения см. в разделе [Настройки конфигурации среды выполнения](#runtime-config-options). | 
| <*Operation — параметр*> | Строка | Режим работы по умолчанию некоторых действий можно изменить, задав свойство `operationOptions`. Дополнительные сведения см. в разделе [Варианты операций](#operation-options). | 
|||| 

## <a name="action-types-list"></a>Список типов действий

Некоторые часто используемые типы действий. 

* [Встроенные типы действий](#built-in-actions), такие как нижеприведенные примеры и многое другое. 

  * [**HTTP**](#http-action) для вызова конечных точек через HTTP или HTTPS

  * [**Ответ**](#response-action) для реагирования на запросы

  * [**Выполнение кода JavaScript**](#run-javascript-code) для выполнения фрагментов кода JavaScript

  * [**Функция**](#function-action) для вызова службы "Функции Azure"

  * Действия обработки данных, такие как [**Соединить**](#join-action), [**Создать**](#compose-action), [**Таблица**](#table-action), [**Выбрать**](#select-action) и другие, которые создают или преобразовывают данные из различных входов

  * [**Рабочий процесс**](#workflow-action) для вызова рабочего процесса другого приложения логики

* [Типы действий управляемых API](#managed-api-actions), такие как [**ApiConnection**](#apiconnection-action) и [**ApiConnectionWebHook**](#apiconnectionwebhook-action), которые вызывают различные соединители и управляемые Майкрософт интерфейсы API, например Служебная шина Azure, Office 365 Outlook, Power BI, хранилище BLOB-объектов Azure, OneDrive, GitHub и т. д.

* [Типы действий рабочего процесса управления](#control-workflow-actions), такие как [**If**](#if-action), [**Foreach**](#foreach-action), [**Switch**](#switch-action), [**Scope**](#scope-action) и [**Until**](#until-action), которые содержат другие действия и помогают организовать выполнение рабочего процесса

<a name="built-in-actions"></a>

### <a name="built-in-actions"></a>Встроенные действия

| Тип действия | Описание | 
|-------------|-------------| 
| [**Создание**](#compose-action) | Создает один выход из входных данных, который может иметь различные типы. | 
| [**Выполнение кода JavaScript**](#run-javascript-code) | Выполнение фрагментов кода JavaScript, соответствующих заданным условиям. Требования к коду и дополнительные сведения см. [в разделе Добавление и выполнение фрагментов кода со встроенным кодом](../logic-apps/logic-apps-add-run-inline-code.md). |
| [**Функция**](#function-action) | Вызывает функцию Azure. | 
| [**HTTP**](#http-action) | Вызывает конечную точку HTTP. | 
| [**К**](#join-action) | Создает строку из всех элементов в массиве и разделяет эти элементы определенным символом разделителя. | 
| [**Анализ JSON**](#parse-json-action) | Создает понятные токены из свойств в содержимом JSON. Затем можно ссылаться на эти свойства, включая токены в приложение логики. | 
| [**Запрос**](#query-action) | Создает массив из элементов другого массива на основании условия или фильтра. | 
| [**Ответ**](#response-action) | Создает ответ на входящий вызов или запрос. | 
| [**Выберите пункт**](#select-action) | Создает массив объектов JSON, преобразуя элементы другого массива на основе указанной карты. | 
| [**Таблица**](#table-action) | Создает таблицу CSV или HTML из массива. | 
| [**Завершение**](#terminate-action) | Останавливает активное выполнение рабочего процесса. | 
| [**Ожидание**](#wait-action) | Приостанавливает рабочий процесс на заданный срок или до указанной даты и времени. | 
| [**Рабочий процесс**](#workflow-action) | Создает вложенный рабочий процесс внутри другого рабочего процесса. | 
||| 

<a name="managed-api-actions"></a>

### <a name="managed-api-actions"></a>Действия управляемых API

| Тип действия | Описание | 
|-------------|-------------|  
| [**ApiConnection**](#apiconnection-action) | Вызывает конечную точку HTTP, используя [управляемый Майкрософт интерфейс API](../connectors/apis-list.md). | 
| [**ApiConnectionWebhook**](#apiconnectionwebhook-action) | Работает как веб-перехватчик HTTP, но использует [интерфейс API, управляемый Майкрософт](../connectors/apis-list.md). | 
||| 

<a name="control-workflow-actions"></a>

### <a name="control-workflow-actions"></a>Действия рабочего процесса управления

Эти действия позволяют управлять выполнением рабочего процесса и включают в себя другие действия. За пределами действия рабочего процесса управления можно непосредственно ссылаться на действия внутри него. Например, если имеется действие `Http` внутри области, можно ссылаться на выражение `@body('Http')` из любой точки в рабочем процессе. В то же время действия, которые существуют внутри действия рабочего процесса управления, могут "привязываться" только к другим действиям, которые находятся в той же структуре рабочего процесса управления.

| Тип действия | Описание | 
|-------------|-------------| 
| [**Используют**](#foreach-action) | Выполняет те же действия в цикле для каждого элемента массива. | 
| [**Наличии**](#if-action) | Выполняет действия в зависимости от того, имеет ли заданное условие значение true или false. | 
| [**Область**](#scope-action) | Выполняет действия из набора действий на основе состояния группы. | 
| [**Коммутатор**](#switch-action) | Выполняет действия, организованные в случаях, когда значения из выражений, объектов или токенов соответствуют значениям, указанным для каждого случая. | 
| [**Вплот**](#until-action) | Выполняет действия в цикле до тех пор, пока указанное условие не будет иметь значение true. | 
|||  

## <a name="actions---detailed-reference"></a>Действия. Подробная справочная информация

<a name="apiconnection-action"></a>

### <a name="apiconnection-action"></a>Действие APIConnection

Это действие отправляет HTTP-запрос для [управляемого Microsoft интерфейса API](../connectors/apis-list.md) и требует сведения об API и параметрах, а также ссылку на действительное соединение. 

``` json
"<action-name>": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<api-name>']['connectionId']"
         },
         "<other-action-specific-input-properties>"        
      },
      "method": "<method-type>",
      "path": "/<api-operation>",
      "retryPolicy": "<retry-behavior>",
      "queries": { "<query-parameters>" },
      "<other-action-specific-properties>"
    },
    "runAfter": {}
}
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*действие — имя*> | Строка | Имя действия, предоставляемого соединителем | 
| <*Имя API*> | Строка | Имя управляемого Майкрософт интерфейса API, используемого для подключения | 
| <*тип метода*> | Строка | Метод HTTP для вызова API: GET, PUT, POST, PATCH или DELETE | 
| <*API-операция*> | Строка | Операция API для вызова | 
|||| 

*Необязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*другие действия, связанные с вводом-свойством*> | Объект JSON | Все входные свойства, которые применяются к указанному действию | 
| <*поведение повторных попыток*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*Параметры запроса*> | Объект JSON | Все параметры запроса для включения с помощью вызова API. <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*другие свойства, относящиеся к действию*> | Объект JSON | Все другие свойства, которые применяются к указанному действию | 
|||| 

*Пример*

Это определение описывает действие **Отправить по электронной почте** для соединителя Outlook Office 365, который является управляемым Майкрософт интерфейсом API. 

```json
"Send_an_email": {
   "type": "ApiConnection",
   "inputs": {
      "body": {
         "Body": "Thank you for your membership!",
         "Subject": "Hello and welcome!",
         "To": "Sophie.Owen@contoso.com"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "method": "POST",
      "path": "/Mail"
    },
    "runAfter": {}
}
```

<a name="apiconnection-webhook-action"></a>

### <a name="apiconnectionwebhook-action"></a>Действие APIConnectionWebhook

Это действие отправляет запрос на подписку через HTTP в конечную точку с помощью [управляемого Майкрософт интерфейсом API](../connectors/apis-list.md), предоставляет *URL-адрес обратного вызова*, на который конечная точка может отправить ответ, и ожидает ответа конечной точки. Дополнительные сведения см. в разделе [Подписка конечной точки](#subscribe-unsubscribe).

```json
"<action-name>": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "subscribe": {
         "method": "<method-type>",
         "uri": "<api-subscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" },
         "retryPolicy": "<retry-behavior>",
         "queries": { "<query-parameters>" },
         "<other-action-specific-input-properties>"
      },
      "unsubscribe": {
         "method": "<method-type>",
         "uri": "<api-unsubscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" },
         "<other-action-specific-properties>"
      },
   },
   "runAfter": {}
}
```

Некоторые значения, например <*method-type*>, доступны для объектов `"subscribe"` и `"unsubscribe"`.

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*действие — имя*> | Строка | Имя действия, предоставляемого соединителем | 
| <*тип метода*> | Строка | Метод HTTP для подписки или отмены подписки на конечную точку: GET, PUT, POST, PATCH или DELETE | 
| <*API-Subscribe-URL*> | Строка | Универсальный код ресурса (URI), используемый для подписки на API | 
|||| 

*Необязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*API — Отмена подписки — URL-адрес*> | Строка | Универсальный код ресурса (URI), используемый для отмены подписки на API | 
| <*заголовок — содержимое*> | Объект JSON | Все заголовки для отправки в запрос <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` |
| <*текст — содержимое*> | Объект JSON | Любое содержимое сообщения для отправки в запросе | 
| <*тип проверки подлинности*> | Объект JSON | Модель проверки подлинности, которую запрос использует для проверки подлинности исходящих запросов. Дополнительные сведения см. в разделе [Добавление проверки подлинности в исходящие вызовы](../logic-apps/logic-apps-securing-a-logic-app.md#add-authentication-outbound) далее в этой статье. |
| <*поведение повторных попыток*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). | 
| <*Параметры запроса*> | Объект JSON | Все параметры запроса для включения в вызов API <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*другие действия, связанные с вводом-свойством*> | Объект JSON | Все входные свойства, которые применяются к указанному действию | 
| <*другие свойства, относящиеся к действию*> | Объект JSON | Все другие свойства, которые применяются к указанному действию | 
|||| 

Также можно указать ограничения для действий **ApiConnectionWebhook** так же, как [ограничения асинхронных операций HTTP](#asynchronous-limits).

<a name="compose-action"></a>

### <a name="compose-action"></a>Действие compose

Это действие создает один вывод из нескольких входных данных, включая выражения. Оба входа и выхода могут иметь любой тип, поддерживаемый Azure Logic Apps, например массивы, объекты JSON, язык XML и двоичные объекты. Затем можно использовать выходные данные действия в других действиях. 

```json
"Compose": {
   "type": "Compose",
   "inputs": "<inputs-to-compose>",
   "runAfter": {}
},
```

*Обязательное* 

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*входные данные для создания*> | Любой | Входные данные для создания единых выходных данных | 
|||| 

*Пример 1*

<!-- markdownlint-disable MD038 -->
Это определение действия объединяет `abcdefg ` с конечным пространством и значением `1234`.
<!-- markdownlint-enable MD038 -->

```json
"Compose": {
   "type": "Compose",
   "inputs": "abcdefg 1234",
   "runAfter": {}
},
```

Результат, который создает это действие.

`abcdefg 1234`

*Пример 2*

Это определение действия объединяет строковую переменную, содержащую `abcdefg` и целочисленную переменную, которая содержит `1234`.

```json
"Compose": {
   "type": "Compose",
   "inputs": "@{variables('myString')}@{variables('myInteger')}",
   "runAfter": {}
},
```

Результат, который создает это действие.

`"abcdefg1234"`

<a name="run-javascript-code"></a>

### <a name="execute-javascript-code-action"></a>Действие "выполнить код JavaScript"

Это действие выполняет фрагмент кода JavaScript и возвращает результаты через `Result` маркер, на который могут ссылаться последующие действия.

```json
"Execute_JavaScript_Code": {
   "type": "JavaScriptCode",
   "inputs": {
      "code": "<JavaScript-code-snippet>",
      "explicitDependencies": {
         "actions": [ <previous-actions> ],
         "includeTrigger": true
      }
   },
   "runAfter": {}
}
```

*Обязательное*

| Значение | Тип | Описание |
|-------|------|-------------|
| <*JavaScript-Code-фрагмент кода*> | Различается | Код JavaScript, который требуется выполнить. Требования к коду и дополнительные сведения см. [в разделе Добавление и выполнение фрагментов кода со встроенным кодом](../logic-apps/logic-apps-add-run-inline-code.md). <p>В `code` атрибуте фрагмент кода может использовать в `workflowContext` качестве входных данных объект, предназначенный только для чтения. Этот объект содержит вложенные свойства, которые предоставляют коду доступ к результатам триггера и предыдущих действий в рабочем процессе. Дополнительные сведения об `workflowContext` объекте см. в разделе [эталонный триггер и результаты действия в коде](../logic-apps/logic-apps-add-run-inline-code.md#workflowcontext). |
||||

*Обязательный в некоторых случаях*

`explicitDependencies`Атрибут указывает, что необходимо явно включить результаты из триггера, предыдущих действий или и того, и другого как зависимости для фрагмента кода. Дополнительные сведения о добавлении этих зависимостей см. в разделе [Добавление параметров для встроенного кода](../logic-apps/logic-apps-add-run-inline-code.md#add-parameters). 

Для `includeTrigger` атрибута можно указать `true` `false` значения или.

| Значение | Тип | Описание |
|-------|------|-------------|
| <*предыдущие действия*> | Массив строк | Массив с указанными именами действий. Используйте имена действий, которые отображаются в определении рабочего процесса, где имена действий используют символы подчеркивания (_), а не пробелы (""). |
||||

*Пример 1*

Это действие запускает код, который получает имя приложения логики и возвращает в результате текст "Hello World FROM \<logic-app-name> ". В этом примере код ссылается на имя рабочего процесса, обращаясь к `workflowContext.workflow.name` свойству через объект, который доступен только для чтения `workflowContext` . Дополнительные сведения об использовании `workflowContext` объекта см. в разделе [ссылочный триггер и результаты действий в коде](../logic-apps/logic-apps-add-run-inline-code.md#workflowcontext).

```json
"Execute_JavaScript_Code": {
   "type": "JavaScriptCode",
   "inputs": {
      "code": "var text = \"Hello world from \" + workflowContext.workflow.name;\r\n\r\nreturn text;"
   },
   "runAfter": {}
}
```

*Пример 2*

Это действие запускает код в приложении логики, которое активируется при поступлении нового электронного письма в рабочую или учебную учетную запись. Приложение логики также использует действие отправить утверждение по электронной почте, которое пересылает содержимое из полученного электронного письма вместе с запросом на утверждение.

Код извлекает адреса электронной почты из свойства триггера `Body` и возвращает адреса вместе со `SelectedOption` значением свойства из действия утверждения. Действие явным образом включает действие отправить утверждение по электронной почте в качестве зависимости в `explicitDependencies`  >  `actions` атрибуте.

```json
"Execute_JavaScript_Code": {
   "type": "JavaScriptCode",
   "inputs": {
      "code": "var re = /(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/g;\r\n\r\nvar email = workflowContext.trigger.outputs.body.Body;\r\n\r\nvar reply = workflowContext.actions.Send_approval_email_.outputs.body.SelectedOption;\r\n\r\nreturn email.match(re) + \" - \" + reply;\r\n;",
      "explicitDependencies": {
         "actions": [
            "Send_approval_email_"
         ]
      }
   },
   "runAfter": {}
}
```



<a name="function-action"></a>

### <a name="function-action"></a>Действие функции

Это действие вызывает ранее созданный объект [Функция Azure](../azure-functions/functions-get-started.md).

```json
"<Azure-function-name>": {
   "type": "Function",
   "inputs": {
     "function": {
        "id": "<Azure-function-ID>"
      },
      "method": "<method-type>",
      "headers": { "<header-content>" },
      "body": { "<body-content>" },
      "queries": { "<query-parameters>" } 
   },
   "runAfter": {}
}
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------|  
| <*Идентификатор функции Azure*> | Строка | Идентификатор ресурса для функции Azure, которую требуется вызвать. Формат для этого значения:<p>"/subscriptions/<*Azure-subscription-ID*>/resourceGroups/<*Azure-resource-group*>/providers/Microsoft.Web/sites/<*Azure-function-app-name*>/functions/<*Azure-function-name*>" | 
| <*тип метода*> | Строка | Метод HTTP, используемый для вызова функции: GET, PUT, POST, PATCH или DELETE <p>Если метод не указан, то по умолчанию используется метод POST. | 
||||

*Необязательно*

| Значение | Тип | Описание | 
|-------|------|-------------|  
| <*заголовок — содержимое*> | Объект JSON | Все заголовки для отправки с вызовом <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` |
| <*текст — содержимое*> | Объект JSON | Любое содержимое сообщения для отправки в запросе | 
| <*Параметры запроса*> | Объект JSON | Все параметры запроса для включения в вызов API <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. | 
| <*другие действия, связанные с вводом-свойством*> | Объект JSON | Все входные свойства, которые применяются к указанному действию | 
| <*другие свойства, относящиеся к действию*> | Объект JSON | Все другие свойства, которые применяются к указанному действию | 
||||

При сохранении приложения логики модуль Logic Apps выполняет эти проверки указанной функции.

* У рабочего процесса должен быть доступ к функции.

* Рабочий процесс может использовать только стандартный триггер HTTP или универсальный триггер веб-перехватчика в формате JSON. 

  Модуль Logic Apps получает и кэширует URL-адрес триггера, используемый в среде выполнения. Тем не менее, если какая-либо операция делает недействительным кэшированный URL-адрес, то в среде выполнения действие **Функция** заканчивается сбоем. Чтобы устранить эту проблему, повторно сохраните приложение логики, чтобы оно снова загрузило URL-адрес триггера.

* Функция не может иметь какой-либо определенный маршрут.

* Можно использовать только авторизацию с помощью функции и анонимную авторизацию. 

*Пример*

Это определение действия вызывает ранее созданную функцию GetProductID.

```json
"GetProductID": {
   "type": "Function",
   "inputs": {
     "function": {
        "id": "/subscriptions/<XXXXXXXXXXXXXXXXXXXX>/resourceGroups/myLogicAppResourceGroup/providers/Microsoft.Web/sites/InventoryChecker/functions/GetProductID"
      },
      "method": "POST",
      "headers": { 
          "x-ms-date": "@utcnow()"
       },
      "body": { 
          "Product_ID": "@variables('ProductID')"
      }
   },
   "runAfter": {}
}
```

<a name="http-action"></a>

### <a name="http-action"></a>Действие HTTP

Это действие отправляет запрос в указанную конечную точку HTTP или HTTPS и проверяет ответ, чтобы определить, выполняется ли рабочий процесс. Дополнительные сведения см. [в разделе вызов конечных точек службы по протоколу HTTP или HTTPS из Azure Logic Apps](../connectors/connectors-native-http.md).

```json
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "<method-type>",
      "uri": "<HTTP-or-HTTPS-endpoint-URL>",
      "headers": { "<header-content>" },
      "queries": { "<query-parameters>" },
      "body": "<body-content>",
      "authentication": { "<authentication-type-and-property-values>" },
      "retryPolicy": {
         "type": "<retry-behavior>"
      },
   },
   "runAfter": {}
}
```

*Обязательное*

| Свойство | Значение | Тип | Описание |
|----------|-------|------|-------------|
| `method` | <*тип метода*> | Строка | Метод, используемый для отправки исходящего запроса: "GET", "Where", "POST", "PATCH" или "DELETE" |
| `uri` | <*HTTP-или-HTTPS-Endpoint-URL*> | Строка | URL-адрес конечной точки HTTP или HTTPS, по которому нужно отправить исходящий запрос. Максимальный размер строки: 2 КБ. <p>Для службы или ресурса Azure этот синтаксис URI включает идентификатор ресурса и путь к ресурсу, к которому требуется получить доступ. |
|||||

*Необязательно*

| Свойство | Значение | Тип | Описание |
|----------|-------|------|-------------|
| `headers` | <*заголовок — содержимое*> | Объект JSON | Все заголовки, которые необходимо включить в запрос <p>Пример задания языка и типа. <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` |
| `queries` | <*Параметры запроса*> | Объект JSON | Любые параметры запроса, которые необходимо использовать в запросе <p>Например, объект `"queries": { "api-version": "2018-01-01" }` добавляет `?api-version=2018-01-01` к вызову. |
| `body` | <*текст — содержимое*> | Объект JSON | Содержимое сообщения для отправки в качестве полезных данных с запросом |
| `authentication` | <*Проверка подлинности-тип и значение свойства*> | Объект JSON | Модель проверки подлинности, которую запрос использует для проверки подлинности исходящих запросов. Дополнительные сведения см. в разделе [Добавление проверки подлинности в исходящие вызовы](../logic-apps/logic-apps-securing-a-logic-app.md#add-authentication-outbound) далее в этой статье. Помимо планировщика поддерживается свойство `authority`. Если параметр не указан, по умолчанию используется значение `https://management.azure.com/` , но можно использовать другое значение. |
| `retryPolicy` > `type` | <*поведение повторных попыток*> | Объект JSON | Настраивает режим повтора для прерывистых сбоев, которые имеют код состояния 408, 429 и 5XX, и для любых исключений при подключении. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md#retry-policies). |
| <*другие действия, связанные с вводом-свойством*> | <*входные данные-свойство*> | Объект JSON | Все входные свойства, которые применяются к указанному действию |
| <*другие свойства, относящиеся к действию*> | <*свойство-значение*> | Объект JSON | Все другие свойства, которые применяются к указанному действию |
|||||

*Пример*

Это определение действия получает последние новости, отправив запрос на указанную конечную точку.

```json
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "https://mynews.example.com/latest"
   }
}
```

<a name="join-action"></a>

### <a name="join-action"></a>Действие "Соединить"

Это действие создает строку из всех элементов в массиве и разделяет эти элементы определенным символом разделителя. 

```json
"Join": {
   "type": "Join",
   "inputs": {
      "from": <array>,
      "joinWith": "<delimiter>"
   },
   "runAfter": {}
}
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*array*> | Array | Массив или выражение, которое предоставляет исходные элементы. Если задано выражение, заключите его в двойные кавычки. | 
| <*delimiter*> | Единая строка символов | Символ, разделяющий каждый элемент в строке | 
|||| 

*Пример*

Предположим, что у вас есть ранее созданная переменная myIntegerArray, содержащая этот массив целых чисел. 

`[1,2,3,4]` 

Это определение действия получает значения из переменной с помощью функции `variables()` в выражении и создает эту строку с теми значениями, которые разделяются запятыми: `"1,2,3,4"`.

```json
"Join": {
   "type": "Join",
   "inputs": {
      "from": "@variables('myIntegerArray')",
      "joinWith": ","
   },
   "runAfter": {}
}
```

<a name="parse-json-action"></a>

### <a name="parse-json-action"></a>Действие "Анализ JSON"

Это действие создает удобные пользовательские поля или *токены* из свойств в содержимом JSON. Затем можно получить доступ к этим свойствам в своем приложении логики, используя вместо этого токены. Например, если необходимо использовать выходные данные JSON таких служб как Служебная шина Azure и Azure Cosmos DB, можно включить это действие в своем приложении логики, чтобы иметь возможность легче ссылаться на выходные данные.

```json
"Parse_JSON": {
   "type": "ParseJson",
   "inputs": {
      "content": "<JSON-source>",
         "schema": { "<JSON-schema>" }
      },
      "runAfter": {}
},
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*JSON — источник*> | Объект JSON | Содержимое JSON, которое необходимо анализировать | 
| <*JSON — схема*> | Объект JSON | Схема JSON, описывающая основное содержимое JSON, которое использует действие для анализа исходного содержимого JSON. <p>**Совет**. В Конструкторе Logic Apps можно указать схему или предоставить пример полезных данных, чтобы действие могло создать схему. | 
|||| 

*Пример*

Это определение действия создает эти токены, которые можно использовать в рабочем процессе, но только в действиях, выполняемых после действия " **анализ JSON** ":

`FirstName`, `LastName` и `Email`.

```json
"Parse_JSON": {
   "type": "ParseJson",
   "inputs": {
      "content": {
         "Member": {
            "Email": "Sophie.Owen@contoso.com",
            "FirstName": "Sophie",
            "LastName": "Owen"
         }
      },
      "schema": {
         "type": "object",
         "properties": {
            "Member": {
               "type": "object",
               "properties": {
                  "Email": {
                     "type": "string"
                  },
                  "FirstName": {
                     "type": "string"
                  },
                  "LastName": {
                     "type": "string"
                  }
               }
            }
         }
      }
   },
   "runAfter": { }
},
```

В этом примере свойство content указывает содержимое JSON для анализа. Также можно предоставить это содержимое JSON как пример полезных данных для создания схемы.

```json
"content": {
   "Member": { 
      "FirstName": "Sophie",
      "LastName": "Owen",
      "Email": "Sophie.Owen@contoso.com"
   }
},
```

Свойство schema указывает схему JSON, используемую для описания содержимого JSON.

```json
"schema": {
   "type": "object",
   "properties": {
      "Member": {
         "type": "object",
         "properties": {
            "FirstName": {
               "type": "string"
            },
            "LastName": {
               "type": "string"
            },
            "Email": {
               "type": "string"
            }
         }
      }
   }
}
```

<a name="query-action"></a>

### <a name="query-action"></a>Действие запроса

Это действие создает массив из элементов другого массива на основании указанного условия или фильтра.

```json
"Filter_array": {
   "type": "Query",
   "inputs": {
      "from": <array>,
      "where": "<condition-or-filter>"
   },
   "runAfter": {}
}
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*array*> | Array | Массив или выражение, которое предоставляет исходные элементы. Если задано выражение, заключите его в двойные кавычки. |
| <*условие или фильтр*> | Строка | Условие, используемое для фильтрации элементов в массиве источника <p>**Примечание**. Если нет значений, соответствующих условию, действие создает пустой массив. |
|||| 

*Пример*

Это определение действия создает массив, содержащий значения, превышающие указанное значение, которое равно двум.

```json
"Filter_array": {
   "type": "Query",
   "inputs": {
      "from": [ 1, 3, 0, 5, 4, 2 ],
      "where": "@greater(item(), 2)"
   }
}
```

<a name="response-action"></a>

### <a name="response-action"></a>Действие ответа  

Это действие создает полезные данные для ответа на запрос HTTP. 

```json
"Response" {
    "type": "Response",
    "kind": "http",
    "inputs": {
        "statusCode": 200,
        "headers": { <response-headers> },
        "body": { <response-body> }
    },
    "runAfter": {}
},
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*Response-Status — код*> | Целое число | Код состояния HTTP, отправленный на входящий запрос. Код по умолчанию является "200 OK", но это может быть любой допустимый код состояния, который начинается с 2xx, 4xx или 5xx, но не с 3xxx. | 
|||| 

*Необязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*заголовки ответов*> | Объект JSON | Один или несколько заголовков для включения в ответ | 
| <*текст ответа*> | Различные | Текст ответа, который может быть строкой, объектом JSON или даже двоичным содержимым из предыдущего действия | 
|||| 

*Пример*

Это определение действия создает ответ на HTTP-запрос с заданным кодом статуса, текстом сообщения и заголовком сообщения.

```json
"Response": {
   "type": "Response",
   "inputs": {
      "statusCode": 200,
      "body": {
         "ProductID": 0,
         "Description": "Organic Apples"
      },
      "headers": {
         "x-ms-date": "@utcnow()",
         "content-type": "application/json"
      }
   },
   "runAfter": {}
}
```

*Ограничения*

В отличии от других, действие **Ответ** имеет специальные ограничения. 

* Рабочий процесс может использовать действие **Ответ** только тогда, когда он начинается с триггера запроса HTTP, это значит, что рабочий процесс должен запускаться HTTP-запросом.

* Рабочий процесс может использовать действие **Ответ** в любом месте, *кроме* как внутри циклов **Foreach**, **Until**, включая последовательные циклы и параллельные ветви. 

* Исходный запрос получает ответ рабочего процесса только в том случае, если все действия, необходимые для действия **ответа** , завершаются в течение [предельного времени ожидания HTTP](../logic-apps/logic-apps-limits-and-config.md#http-limits).

  Однако, если рабочий процесс вызывает другое приложение логики в качестве вложенного рабочего процесса, родительский рабочий процесс ожидает завершения вложенного рабочего процесса, независимо от того, сколько времени прошло до его завершения.

* Когда рабочий процесс использует действие **Ответ** и синхронный шаблон ответа, он не может использовать команду **splitOn** в определении триггера, потому что эта команда создает несколько запусков. Проверьте этот случай, когда используется метод PUT, и если значение равно true, вернется ответ "Недопустимый запрос".

  В противном случае, если рабочий процесс использует команду **splitOn** и действие **Ответ**, рабочий процесс выполняется асинхронно и немедленно возвращает ответ "202 ACCEPTED".

* Когда выполнение рабочего процесса достигает действия **Ответ**, но входящий запрос уже получил ответ, действие **Ответ** помечается как Failed (Сбой) из-за конфликта. И в результате выполнения приложения логики также отмечается состояние Failed (Сбой).

<a name="select-action"></a>

### <a name="select-action"></a>Выбор действия

Это действие создает массив с объектами JSON путем преобразования элементов из другого массива на основе указанного сопоставления. Выходной и исходный массив всегда имеет одинаковое количество элементов. Несмотря на то что невозможно изменить количество объектов в выходном массиве, можно добавлять или удалять свойства и их значения в этих объектах. Свойство `select` указывает по меньшей мере одну пару "ключ — значение", определяющую сопоставление для преобразования элементов в исходном массиве. Пара "ключ — значение" представляет свойство и его значение во всех объектах выходного массива.

```json
"Select": {
   "type": "Select",
   "inputs": {
      "from": <array>,
      "select": { 
          "<key-name>": "<expression>",
          "<key-name>": "<expression>"        
      }
   },
   "runAfter": {}
},
```

*Обязательное* 

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*array*> | Array | Массив или выражение, которое предоставляет исходные элементы. Убедитесь, что выражение заключено в двойные кавычки. <p>**Примечание**. Если исходный массив пуст, это действие создает пустой массив. | 
| <*имя ключа*> | Строка | Имя свойства, присвоенное результату *выражения* <> <p>Чтобы добавить новое свойство во всех объектах в выходном массиве, предоставьте <*key-name*> для этого свойства и объект <*expression*> для значения свойства. <p>Чтобы удалить свойство из всех объектов в массиве, опустите <*key-name*> для этого свойства. | 
| <*expression*> | Строка | Выражение, которое преобразует элемент в исходный массив и присваивает результат <ому *имени ключа*> | 
|||| 

Действие **Выбрать** создает массив как вывод, поэтому любое действие, которое хочет использовать этот вывод, должно либо принимать массив, либо необходимо преобразовать массив в тип, который принимает действие пользователя. Например, чтобы преобразовать выходной массив в строку, передайте массив в действие **Создать**, а затем ссылайтесь на результат действия **Создать** в других действиях.

*Пример*

Это определение действия создает массив объектов JSON из массива целых чисел. Действие повторяется с исходным массивом, получает каждое целочисленное значение с помощью выражения `@item()` и присваивает каждому значению свойство "`number`" в каждом объекте JSON.

```json
"Select": {
   "type": "Select",
   "inputs": {
      "from": [ 1, 2, 3 ],
      "select": { 
         "number": "@item()" 
      }
   },
   "runAfter": {}
},
```

Массив, который создает это действие.

`[ { "number": 1 }, { "number": 2 }, { "number": 3 } ]`

Чтобы использовать этот массив выходных данных в других действиях, передайте этот результат в действие **Создать**.

```json
"Compose": {
   "type": "Compose",
   "inputs": "@body('Select')",
   "runAfter": {
      "Select": [ "Succeeded" ]
   }
},
```

Затем можно использовать вывод из действия **Создать** в других действиях, например **Office 365 Outlook: отправить по электронной почте**.

```json
"Send_an_email": {
   "type": "ApiConnection",
   "inputs": {
      "body": {
         "Body": "@{outputs('Compose')}",
         "Subject": "Output array from Select and Compose actions",
         "To": "<your-email@domain>"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "method": "post",
      "path": "/Mail"
   },
   "runAfter": {
      "Compose": [ "Succeeded" ]
   }
},
```

<a name="table-action"></a>

### <a name="table-action"></a>Действие таблицы

Это действие создает таблицу CSV или HTML из массива. Для массивов с объектами JSON это действие автоматически создает заголовки столбцов с именами свойств объектов. Для массивов с другими типами данных необходимо указать заголовки столбцов и значений. Например, этот массив содержит свойства ID и Product_Name, которые могут использовать это действие для заголовков столбцов.

`[ {"ID": 0, "Product_Name": "Apples"}, {"ID": 1, "Product_Name": "Oranges"} ]` 

```json
"Create_<CSV | HTML>_table": {
   "type": "Table",
   "inputs": {
      "format": "<CSV | HTML>",
      "from": <array>,
      "columns": [ 
         {
            "header": "<column-name>",
            "value": "<column-value>"
         },
         {
            "header": "<column-name>",
            "value": "<column-value>"
         } 
      ]
   },
   "runAfter": {}
}
```

*Обязательное* 

| Значение | Тип | Описание | 
|-------|------|-------------| 
| \<CSV *or* HTML>| Строка | Формат таблицы, которую необходимо создать | 
| <*array*> | Array | Массив или выражение, которое предоставляет исходные элементы для таблицы <p>**Примечание**. Если исходный массив пуст, это действие создает пустую таблицу. | 
|||| 

*Необязательно*

Чтобы задать или настроить заголовки столбцов и значения, используйте массив `columns`. Когда пары `header-value` имеют одинаковое имя заголовка, их значения отображаются в том же столбце под этим заголовком. В противном случае каждый уникальный заголовок определяет уникальный столбец.

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*имя столбца*> | Строка | Имя заголовка столбца | 
| <*значение столбца*> | Любой | Значение в столбце | 
|||| 

*Пример 1*

Предположим, что имеется ранее созданная переменная myItemArray, содержащая в данный момент этот массив.

`[ {"ID": 0, "Product_Name": "Apples"}, {"ID": 1, "Product_Name": "Oranges"} ]`

Это определение действия создает таблицу CSV из переменной myItemArray. Выражение, использующее свойство `from`, возвращает массив из myItemArray с помощью функции `variables()`.

```json
"Create_CSV_table": {
   "type": "Table",
   "inputs": {
      "format": "CSV",
      "from": "@variables('myItemArray')"
   },
   "runAfter": {}
}
```

Таблица CSV, которая создает это действие. 

```
ID,Product_Name 
0,Apples 
1,Oranges 
```

*Пример 2*

Это определение действия создает таблицу HTML из переменной myItemArray. Выражение, использующее свойство `from`, возвращает массив из myItemArray с помощью функции `variables()`.

```json
"Create_HTML_table": {
   "type": "Table",
   "inputs": {
      "format": "HTML",
      "from": "@variables('myItemArray')"
   },
   "runAfter": {}
}
```

Таблица HTML, которая создает это действие. 

<table><thead><tr><th>ID</th><th>Product_name</th></tr></thead><tbody><tr><td>0</td><td>Яблоки</td></tr><tr><td>1</td><td>Апельсины</td></tr></tbody></table>

*Пример 3*

Это определение действия создает таблицу HTML из переменной myItemArray. Однако этот пример переопределяет имена заголовков столбцов по умолчанию с помощью Stock_ID и Description и добавляет слово Organic к значениям в столбце Description.

```json
"Create_HTML_table": {
   "type": "Table",
   "inputs": {
      "format": "HTML",
      "from": "@variables('myItemArray')",
      "columns": [ 
         {
            "header": "Stock_ID",
            "value": "@item().ID"
         },
         {
            "header": "Description",
            "value": "@concat('Organic ', item().Product_Name)"
         }
      ]
    },
   "runAfter": {}
},
```

Таблица HTML, которая создает это действие. 

<table><thead><tr><th>Stock_ID</th><th>Описание</th></tr></thead><tbody><tr><td>0</td><td>Органические яблоки</td></tr><tr><td>1</td><td>Органические апельсины</td></tr></tbody></table>

<a name="terminate-action"></a>

### <a name="terminate-action"></a>Действие terminate

Это действие останавливает выполнение экземпляра рабочего процесса, отменяет все выполняемые действия, пропускает все оставшиеся действия и возвращает указанное состояние. Например, можно использовать действие **Завершить**, когда приложение логики должно полностью выйти из состояния ошибки. Это действие не влияет на уже выполненные действия и не может указываться в циклах **Foreach** и **Until**, включая последовательные циклы.

```json
"Terminate": {
   "type": "Terminate",
   "inputs": {
       "runStatus": "<status>",
       "runError": {
            "code": "<error-code-or-name>",
            "message": "<error-message>"
       }
   },
   "runAfter": {}
}
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*состояние*> | Строка | Состояние для возврата запуска: Failed (Сбой), Cancelled (Отменено) или Succeeded (Успешно) |
|||| 

*Необязательно*

Свойства для объекта runStatus применяются только в том случае, если свойству runStatus присвоено состояние Failed (Сбой).

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*ошибка-код или имя*> | Строка | Код или имя ошибки |
| <*Error — сообщение*> | Строка | Сообщение или текст, описывающий ошибку и любые действия, которые пользователь приложения может предпринять | 
|||| 

*Пример*

Это определение действия останавливает выполнение рабочего процесса, устанавливает статус запуска как Failed (Сбой) и возвращает состояние, код ошибки и сообщение об ошибке.

```json
"Terminate": {
    "type": "Terminate",
    "inputs": {
        "runStatus": "Failed",
        "runError": {
            "code": "Unexpected response",
            "message": "The service received an unexpected response. Please try again."
        }
   },
   "runAfter": {}
}
```

<a name="wait-action"></a>

### <a name="wait-action"></a>Действие wait

Это действие приостанавливает выполнение рабочего процесса на указанный период времени или до указанного времени, но не для обоих.

*Указанный интервал*

```json
"Delay": {
   "type": "Wait",
   "inputs": {
      "interval": {
         "count": <number-of-units>,
         "unit": "<interval>"
      }
   },
   "runAfter": {}
},
```

*Указанное время*

```json
"Delay_until": {
   "type": "Wait",
   "inputs": {
      "until": {
         "timestamp": "<date-time-stamp>"
      }
   },
   "runAfter": {}
},
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*количество единиц*> | Целое число | Число единиц ожидания для действия **Задержка** | 
| <*interval*> | Строка | Для действия **Задержка** период ожидания составляет: "секунда", "минута", "час", "день", "неделя", "месяц" | 
| <*Метка даты и времени*> | Строка | Дата и время возобновления исполнения для действия **Задержка до**. Для этого значения необходимо использовать [дату и время в формате UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). | 
|||| 

*Пример 1*

Это определение действия приостанавливает рабочий процесс на 15 минут.

```json
"Delay": {
   "type": "Wait",
   "inputs": {
      "interval": {
         "count": 15,
         "unit": "Minute"
      }
   },
   "runAfter": {}
},
```

*Пример 2*

Это определение действия приостанавливает рабочий процесс до указанного времени.

```json
"Delay_until": {
   "type": "Wait",
   "inputs": {
      "until": {
         "timestamp": "2017-10-01T00:00:00Z"
      }
   },
   "runAfter": {}
},
```

<a name="workflow-action"></a>

### <a name="workflow-action"></a>Действие workflow

Это действие вызывает другое ранее созданное приложение логики, это значит, что можно включать и повторно использовать другие рабочие процессы приложений логики. Также можно использовать выходы из дочернего или *вложенного* приложения логики в действиях, следующих за вложенным приложением логики, при условии, что дочернее приложение логики возвращает ответ.

Модуль Logic Apps проверяет доступ к триггеру, который необходимо вызвать, поэтому убедитесь, что вы можете получить доступ к этому триггеру. Кроме того, вложенное приложение логики должно соответствовать следующим критериям.

* Триггер делает вложенное приложение логики вызываемым, наподобие триггеров [Запрос](#request-trigger) или [HTTP](#http-trigger)

* Та же подписка Azure, что и родительское приложение логики

* Чтобы использовать выходы из вложенного приложения логики в родительском приложении логики, вложенное приложение логики должно иметь действие [Ответ](#response-action)

```json
"<nested-logic-app-name>": {
   "type": "Workflow",
   "inputs": {
      "body": { "<body-content" },
      "headers": { "<header-content>" },
      "host": {
         "triggerName": "<trigger-name>",
         "workflow": {
            "id": "/subscriptions/<Azure-subscription-ID>/resourceGroups/<Azure-resource-group>/providers/Microsoft.Logic/<nested-logic-app-name>"
         }
      }
   },
   "runAfter": {}
}
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*Nested-Logic-App-Name*> | Строка | Имя приложения логики, которое требуется вызвать | 
| <*Имя триггера*> | Строка | Имя триггера вложенного приложения логики, которое необходимо вызвать | 
| <*Идентификатор подписки Azure*> | Строка | Идентификатор подписки Azure вложенного приложения логики |
| <*Azure-resource-group*> | Строка | Группа ресурсов Azure вложенного приложения логики |
| <*Nested-Logic-App-Name*> | Строка | Имя приложения логики, которое требуется вызвать |
||||

*Необязательно*

| Значение | Тип | Описание | 
|-------|------|-------------|  
| <*заголовок — содержимое*> | Объект JSON | Все заголовки для отправки с вызовом | 
| <*текст — содержимое*> | Объект JSON | Любое содержимое сообщения для отправки с вызовом | 
||||

*Выходные данные*

Выходные данные этого действия различаются в зависимости от действия "Ответ" вложенного приложения логики. Если вложенное приложение логики не включает действие "Ответ", выходные данные будут пустыми.

*Пример*

После успешного завершения действия Start_search это определение действия рабочего процесса вызывает другое приложение логики с именем Get_product_information, которое передается в заданные входы.

```json
"actions": {
   "Start_search": { <action-definition> },
   "Get_product_information": {
      "type": "Workflow",
      "inputs": {
         "body": {
            "ProductID": "24601",
         },
         "host": {
            "id": "/subscriptions/XXXXXXXXXXXXXXXXXXXXXXXXXX/resourceGroups/InventoryManager-RG/providers/Microsoft.Logic/Get_product_information",
            "triggerName": "Find_product"
         },
         "headers": {
            "content-type": "application/json"
         }
      },
      "runAfter": { 
         "Start_search": [ "Succeeded" ]
      }
   }
},
```

## <a name="control-workflow-action-details"></a>Сведения о действиях рабочего процесса управления

<a name="foreach-action"></a>

### <a name="foreach-action"></a>Действие foreach

Это циклическое действие выполняет итерацию по массиву и действия с каждым элементом массива. По умолчанию цикл Foreach выполняется в параллельном режиме, вплоть до максимального числа циклов. Это максимальное значение см. в разделе [ограничения и конфигурация](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Узнайте [, как создать циклы for each](../logic-apps/logic-apps-control-flow-loops.md#foreach-loop).

```json
"For_each": {
   "type": "Foreach",
   "actions": { 
      "<action-1>": { "<action-definition-1>" },
      "<action-2>": { "<action-definition-2>" }
   },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": <count>
      }
    },
    "operationOptions": "<operation-option>"
}
```

*Обязательное* 

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*действие 1... \n*> | Строка | Имена действий, выполняемых над каждым элементом массива | 
| <*действие — определение-1... \n*> | Объект JSON | Определения действий, которые выполняются | 
| <*выражение for each*> | Строка | Выражение, которое ссылается на каждый элемент в указанном массиве | 
|||| 

*Необязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*count*> | Целое число | По умолчанию итерации цикла for each выполняются одновременно (одновременно или параллельно) вплоть до [ограничения по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение, задав новое значение <*count*>, см. раздел [Изменение параллелизма цикла Foreach](#change-for-each-concurrency). | 
| <*Operation — параметр*> | Строка | Чтобы запустить цикл Foreach последовательно, а не параллельно, задайте <*operation-option*> для `Sequential` или <*count*> для `1`, но не для обоих. Дополнительные сведения см. в разделе [Последовательный запуск циклов Foreach](#sequential-for-each). | 
|||| 

*Пример*

Этот цикл Foreach отправляет электронное письмо для каждого элемента массива, содержащего вложения из входящего письма. Цикл отправляет электронное письмо, включая вложение, пользователю, который рассматривает вложение.

```json
"For_each": {
   "type": "Foreach",
   "actions": {
      "Send_an_email": {
         "type": "ApiConnection",
         "inputs": {
            "body": {
               "Body": "@base64ToString(items('For_each')?['Content'])",
               "Subject": "Review attachment",
               "To": "Sophie.Owen@contoso.com"
                },
            "host": {
               "connection": {
                  "id": "@parameters('$connections')['office365']['connectionId']"
               }
            },
            "method": "post",
            "path": "/Mail"
         },
         "runAfter": {}
      }
   },
   "foreach": "@triggerBody()?['Attachments']",
   "runAfter": {}
}
```

Чтобы указать только массив, который передается в качестве выходных данных из триггера, это выражение получает массив <*array-name*> из текста триггера. Чтобы избежать ошибок при отсутствии массива, в этом выражении используется оператор `?`.

`@triggerBody()?['<array-name>']` 

<a name="if-action"></a>

### <a name="if-action"></a>Действие If

Это действие, которое является *условным оператором*, оценивает выражение, которое представляет условие и запускает другую ветвь, основанную на том, является ли условие истинным или ложным. Если условие истинное, ему будет присвоено состояние Succeeded (Успешно). Дополнительные сведения см. в разделе [Создание условных операторов, которые управляют действиями в рабочих процессах Azure Logic Apps](../logic-apps/logic-apps-control-flow-conditional-statement.md).

``` json
"Condition": {
   "type": "If",
   "expression": { "<condition>" },
   "actions": {
      "<action-1>": { "<action-definition>" }
   },
   "else": {
      "actions": {
        "<action-2>": { "<action-definition" }
      }
   },
   "runAfter": {}
}
```

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*выполняет*> | Объект JSON | Условие, которое может быть выражением, для оценки | 
| <*действие 1*> | Объект JSON | Действие выполнится когда <*condition*> будет истинное | 
| <*действие — определение*> | Объект JSON | Определение действия | 
| <*действие — 2*> | Объект JSON | Действие выполнится когда <*condition*> будет ложным | 
|||| 

Действия в объектах `actions` или `else` получают следующие статусы.

* "Succeeded", если они запускаются и выполняются успешно;
* "Failed", если они запускаются, но завершаются ошибкой;
* "Skipped", если не запускается соответствующая ветвь.

*Пример*

Это условие указывает, что когда целочисленная переменная имеет значение больше нуля, рабочий процесс проверяет веб-сайт. Если переменная равна нулю или меньше, рабочий процесс проверяет другой веб-сайт.

```json
"Condition": {
   "type": "If",
   "expression": {
      "and": [ {
         "greater": [ "@variables('myIntegerVariable')", 0 ] 
      } ]
   },
   "actions": { 
      "HTTP - Check this website": {
         "type": "Http",
         "inputs": {
         "method": "GET",
            "uri": "http://this-url"
         },
         "runAfter": {}
      }
   },
   "else": {
      "actions": {
         "HTTP - Check this other website": {
            "type": "Http",
            "inputs": {
               "method": "GET",
               "uri": "http://this-other-url"
            },
            "runAfter": {}
         }
      }
   },
   "runAfter": {}
}
```  

#### <a name="how-conditions-use-expressions"></a>Использование выражений условиями

Ниже приведены некоторые примеры, показывающие, как можно использовать выражения в условиях.
  
| JSON | Result | 
|------|--------| 
| expression: @parameters('<*hasSpecialAction*>') | Только для логических выражений условие передается для любого истинного значения. <p>Чтобы преобразовать другие типы в логический, используйте следующие функции: `empty()` или `equals()`. | 
| expression: @greater(actions('<*action*>').output.value, parameters('<*threshold*>')) | Для сравнения функций действие выполняется только тогда, когда результат <*action*> больше значения <*threshold*>. | 
| expression: @or(greater(actions('<*action*>').output.value, parameters('<*threshold*>')), less(actions('<*same-action*>').output.value, 100)) | Для логических функций и создания вложенных логических выражений действие выполняется, когда результат <*action*> больше значения <*threshold*> или меньше 100. | 
| expression: @equals(length(actions('<*action*>').outputs.errors), 0)) | Можно использовать функции массива для проверки того, имеет ли массив какие-либо элементы. Действие выполняется, если массив `errors` пустой. | 
||| 

<a name="scope-action"></a>

### <a name="scope-action"></a>Действие scope

Логические группы этого действия в *областях*, которые получают свое состояние после завершения действий в той области. Затем можно использовать статус области, чтобы определить, выполняются ли другие действия. Дополнительные сведения см. в разделе [Создание областей, которые выполняют действия рабочего процесса на основе состояния группы в Azure Logic Apps](../logic-apps/logic-apps-control-flow-run-steps-group-scopes.md).

```json
"Scope": {
   "type": "Scope",
   "actions": {
      "<inner-action-1>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      },
      "<inner-action-2>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      }
   }
}
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------|  
| <*Inner-действие-1... \n*> | Объект JSON | Одно или несколько действий, которые выполняются в области |
| <*действие — входные данные*> | Объект JSON | Входные данные для каждого действия |
|||| 

<a name="switch-action"></a>

### <a name="switch-action"></a>Действие switch

Это действие, также известное как *оператор switch*, организует другие действия по *случаях* и присваивает значение каждому случаю, за исключением случая по умолчанию, если он существует. Когда выполняется рабочий процесс, действие **Переключить** сравнивает значение из выражения, объекта или токена со значениями, указанными для каждого случая. Если действие **Переключить** находит соответствующий вариант, рабочий процесс выполняет действия только для этого варианта. Каждый раз, когда действие **Переключить** запускается, существует только один подходящий случай или совпадений нет. Если совпадений не существует, действие **Переключить** выполняется по умолчанию. Дополнительные сведения см. в разделе [Создание операторов switch, которые запускают действия рабочего процесса на основе определенных значений в Azure Logic Apps](../logic-apps/logic-apps-control-flow-switch-statement.md).

``` json
"Switch": {
   "type": "Switch",
   "expression": "<expression-object-or-token>",
   "cases": {
      "Case": {
         "actions": {
           "<action-name>": { "<action-definition>" }
         },
         "case": "<matching-value>"
      },
      "Case_2": {
         "actions": {
           "<action-name>": { "<action-definition>" }
         },
         "case": "<matching-value>"
      }
   },
   "default": {
      "actions": {
         "<default-action-name>": { "<default-action-definition>" }
      }
   },
   "runAfter": {}
}
```

*Обязательное*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*выражение-Object-или-Token*> | Различается | Выражение, объект JSON или маркер безопасности для оценки | 
| <*действие — имя*> | Строка | Имя действия для запуска в случае соответствия | 
| <*действие — определение*> | Объект JSON | Определение действия для запуска в случае соответствия | 
| <*Сопоставление-значение*> | Различается | Значение для сравнения с результатом вычисления | 
|||| 

*Необязательно*

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*Default — Action-Name*> | Строка | Имя действия по умолчанию для запуска, если не существует подходящего случая | 
| <*Default — определение действия*> | Объект JSON | Определение действия по умолчанию для запуска, если не существует подходящего случая | 
|||| 

*Пример*

Это определение действия оценивает, выбирает ли пользователь в ответ на письмо с запросом вариант "Утвердить" или "Отклонить". Исходя из этого выбора, действие **Переключить** запускает действия для случая сопоставления, который должен отправить другое электронное сообщение ответчику, но с разными формулировками в каждом случае. 

``` json
"Switch": {
   "type": "Switch",
   "expression": "@body('Send_approval_email')?['SelectedOption']",
   "cases": {
      "Case": {
         "actions": {
            "Send_an_email": { 
               "type": "ApiConnection",
               "inputs": {
                  "Body": "Thank you for your approval.",
                  "Subject": "Response received", 
                  "To": "Sophie.Owen@contoso.com"
               },
               "host": {
                  "connection": {
                     "name": "@parameters('$connections')['office365']['connectionId']"
                  }
               },
               "method": "post",
               "path": "/Mail"
            },
            "runAfter": {}
         },
         "case": "Approve"
      },
      "Case_2": {
         "actions": {
            "Send_an_email_2": { 
               "type": "ApiConnection",
               "inputs": {
                  "Body": "Thank you for your response.",
                  "Subject": "Response received", 
                  "To": "Sophie.Owen@contoso.com"
               },
               "host": {
                  "connection": {
                     "name": "@parameters('$connections')['office365']['connectionId']"
                  }
               },
               "method": "post",
               "path": "/Mail"
            },
            "runAfter": {}     
         },
         "case": "Reject"
      }
   },
   "default": {
      "actions": { 
         "Send_an_email_3": { 
            "type": "ApiConnection",
            "inputs": {
               "Body": "Please respond with either 'Approve' or 'Reject'.",
               "Subject": "Please respond", 
               "To": "Sophie.Owen@contoso.com"
            },
            "host": {
               "connection": {
                  "name": "@parameters('$connections')['office365']['connectionId']"
               }
            },
            "method": "post",
            "path": "/Mail"
         },
         "runAfter": {} 
      }
   },
   "runAfter": {
      "Send_approval_email": [ 
         "Succeeded"
      ]
   }
}
```

<a name="until-action"></a>

### <a name="until-action"></a>Действие Until

Это действие цикла содержит действия, которые выполняются, пока указанное условие имеет истинное значение. После завершения работы всех других действий на последнем этапе цикл проверяет условие. Можно включить несколько действий в объект `"actions"`, и действие должно определить как минимум одно ограничение. Дополнительные сведения см. в разделе [Цикл until](../logic-apps/logic-apps-control-flow-loops.md#until-loop). 

```json
 "Until": {
   "type": "Until",
   "actions": {
      "<action-name>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      },
      "<action-name>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      }
   },
   "expression": "<condition>",
   "limit": {
      "count": <loop-count>,
      "timeout": "<loop-timeout>"
   },
   "runAfter": {}
}
```

| Значение | Тип | Описание | 
|-------|------|-------------| 
| <*действие — имя*> | Строка | Имя действия, которое необходимо выполнить внутри цикла | 
| <*Тип действия*> | Строка | Тип действия, которое необходимо запустить | 
| <*действие — входные данные*> | Различные | Входные данные для выполнения действия | 
| <*выполняет*> | Строка | Условие или выражение для оценки после всех действий в завершении цикла | 
| <*Счетчик циклов*> | Целое число | Предел максимального количества циклов, которое может выполнить действие. Дополнительные сведения о предельном и максимальном предельном значениях по умолчанию см. в разделе [ограничения и настройка для Azure Logic Apps](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). | 
| <*время ожидания цикла*> | Строка | Предел времени работы цикла, в течение которого цикл может работать. Значение `timeout` по умолчанию равно `PT1H`, которое требует [формат ISO 8601](https://en.wikipedia.org/wiki/ISO_8601). |
|||| 

> [!NOTE]
> Если выражение зависит от выходных данных любого действия в цикле Until, убедитесь, что учитывается любой сбой, полученный в результате этого действия.

*Пример*

Это определение действия цикла отправляет HTTP-запрос по указанному URL-адресу до тех пор, пока не будет выполнено одно из этих условий.

* Запрос возвращает ответ с состоянием кода "200 OK".
* Цикл выполнялся 60 раз.
* Цикл был выполнен в течение одного часа.

```json
 "Run_until_loop_succeeds_or_expires": {
    "type": "Until",
    "actions": {
        "HTTP": {
            "type": "Http",
            "inputs": {
                "method": "GET",
                "uri": "http://myurl"
            },
            "runAfter": {}
        }
    },
    "expression": "@equals(outputs('HTTP')['statusCode'], 200)",
    "limit": {
        "count": 60,
        "timeout": "PT1H"
    },
    "runAfter": {}
}
```

<a name="subscribe-unsubscribe"></a>

## <a name="webhooks-and-subscriptions"></a>Веб-перехватчики и подписки

Триггеры и действия на основе веб-перехватчика не регулярно проверяют конечные точки, но ждут конкретных событий или данных на этих конечных точках. Эти триггеры и действия *подписываются* на конечные точки, предоставляя *URL-адрес обратного вызова*, куда конечная точка может отправлять ответы.

Вызов `subscribe` выполняется при любом изменении рабочего процесса, например когда происходит обновление учетных данных или изменяются входные параметры для триггера или действия. Этот вызов использует те же параметры, что и стандартные действия HTTP. 

Вызов `unsubscribe` выполняется автоматически, когда при выполнении операции триггер или действие становится недопустимым, например:

* удаление или отключение триггера; 
* удаление или отключение рабочего процесса; 
* удаление или отключение подписки. 

Для поддержки этих вызовов выражение `@listCallbackUrl()` возвращает уникальный "URL-адрес обратного вызова" для этого триггера или действия. Этот URL-адрес представляет собой уникальный идентификатор для конечных точек, использующих REST API службы. Параметры этой функции совпадают с параметрами триггера веб-перехватчика или действия.

<a name="asynchronous-limits"></a>

## <a name="change-asynchronous-duration"></a>Изменение асинхронной длительности

Для триггеров и действий можно ограничить длительность для асинхронного шаблона определенным интервалом времени, добавив свойство `limit.timeout`. Таким образом, если действие не закончилось, когда интервал истекает, статус действия помечается `Cancelled` с кодом `ActionTimedOut`. Свойство `timeout` использует [формат ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations).

``` json
"<trigger-or-action-name>": {
   "type": "Workflow | Webhook | Http | ApiConnectionWebhook | ApiConnection",
   "inputs": {},
   "limit": {
      "timeout": "PT10S"
   },
   "runAfter": {}
}
```

<a name="runtime-config-options"></a>

## <a name="runtime-configuration-settings"></a>Параметры конфигурации среды выполнения

Можно изменить поведение среды выполнения по умолчанию для триггеров и действий, добавив эти `runtimeConfiguration` свойства в определение триггера или действия.

| Свойство | Тип | Описание | Триггер или действие | 
|----------|------|-------------|-------------------| 
| `runtimeConfiguration.concurrency.runs` | Целое число | Измените [*ограничение по умолчанию*](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) на количество экземпляров рабочих процессов, которые могут выполняться одновременно (параллельно или одновременно). Изменение этого значения может помочь ограничить количество запросов, получаемых серверными системами. <p>Параметр свойства `runs`, равный `1`, работает так же, как параметр свойства `operationOptions`, равный `SingleInstance`. Можно установить любое свойство, но не оба сразу. <p>Дополнительные сведения об изменении предела по умолчанию см. в раздел об [изменении параллелизма триггера](#change-trigger-concurrency) или о [последовательном запуске экземпляров](#sequential-trigger). | Все триггеры | 
| `runtimeConfiguration.concurrency.maximumWaitingRuns` | Целое число | Измените [*ограничение по умолчанию*](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) на количество экземпляров рабочих процессов, которые должны ожидать выполнения, если приложение логики уже использует максимальное количество параллельных экземпляров. <p>Чтобы изменить предел по умолчанию, см. раздел [Изменение предела ожидающих запусков](#change-waiting-runs). | Все триггеры | 
| `runtimeConfiguration.concurrency.repetitions` | Целое число | Измените [*ограничение по умолчанию*](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) на количество итераций цикла "For Each", которые могут выполняться одновременно (одновременно или параллельно). <p>Параметр свойства `repetitions`, равный `1`, работает так же, как параметр свойства `operationOptions`, равный `SingleInstance`. Можно установить любое свойство, но не оба сразу. <p>Дополнительные сведения об изменении предела по умолчанию см. в разделе [Изменение параллелизма цикла Foreach](#change-for-each-concurrency) или [Последовательный запуск циклов Foreach](#sequential-for-each). | Действие: <p>[Используют](#foreach-action) | 
| `runtimeConfiguration.paginationPolicy.minimumItemCount` | Целое число | Для определенных действий, которые поддерживают и имеют включенную разбивку на страницы, это значение указывает *минимальное* число получаемых результатов. <p>Сведения о включении разбивки на страницы см. в разделе [получение небольшого объема данных, элементов или результатов с помощью разбивки на страницы](../logic-apps/logic-apps-exceed-default-page-size-with-pagination.md) | Действие: различные |
| `runtimeConfiguration.secureData.properties` | Array | Во многих триггерах и действиях эти параметры скрывают входные и выходные данные, а также и то, и другое из журнала выполнения приложения логики. <p>Дополнительные сведения о защите этих данных см. в разделе [Скрытие входов и выходов из журнала выполнения](../logic-apps/logic-apps-securing-a-logic-app.md#secure-data-code-view). | Большинство триггеров и действий |
| `runtimeConfiguration.staticResult` | Объект JSON | Для действий, которые поддерживают и имеют включенный [статический параметр результата](../logic-apps/test-logic-apps-mock-data-static-results.md) , `staticResult` объект имеет следующие атрибуты: <p>- `name`, который ссылается на имя статического определения результата текущего действия, которое отображается внутри `staticResults` атрибута в атрибуте рабочего процесса приложения логики `definition` . Дополнительные сведения см. в разделе [статические результаты — Справочник по схеме для языка определения рабочего процесса](../logic-apps/logic-apps-workflow-definition-language.md#static-results). <p> - `staticResultOptions`, который указывает, являются ли статические результаты `Enabled` текущим действием. <p>Сведения о включении статических результатов см. в статье [тестирование приложений логики с помощью макетных данных путем настройки статических результатов](../logic-apps/test-logic-apps-mock-data-static-results.md) . | Действие: различные |
||||| 

<a name="operation-options"></a>

## <a name="operation-options"></a>Варианты операций

Можно изменить поведение по умолчанию для триггеров и действий со свойством `operationOptions` в триггере или определении действия.

| Параметр операции | Тип | Описание | Триггер или действие | 
|------------------|------|-------------|-------------------| 
| `DisableAsyncPattern` | Строка | Запускайте действия на основе HTTP синхронно, а не асинхронно. <p><p>Чтобы задать этот параметр, см. в разделе [Синхронное выполнение действия](#disable-asynchronous-pattern). | Действия: <p>[ApiConnection](#apiconnection-action), <br>[Http](#http-action), <br>[Ответ](#response-action) | 
| `IncludeAuthorizationHeadersInOutputs` | Строка | Для приложений логики, которые [обеспечивают Azure Active Directory открытой аутентификации (Azure AD OAuth)](../logic-apps/logic-apps-securing-a-logic-app.md#enable-oauth) для авторизации доступа для входящих вызовов к конечной точке триггера на основе запроса, включите `Authorization` заголовок маркера доступа OAuth в выходные данные триггера. Дополнительные сведения см. [в разделе Включение заголовка Authorization в выходные данные триггера запроса](../logic-apps/logic-apps-securing-a-logic-app.md#include-auth-header). | Триггеры: <p>[Запрос](#request-trigger), <br>[HTTP Webhook](#http-webhook-trigger) | 
| `Sequential` | Строка | Запускайте итерации цикла Foreach по одной, а не одновременно параллельно. <p>Этот параметр работает так же, как параметр свойства `runtimeConfiguration.concurrency.repetitions`, равный `1`. Можно установить любое свойство, но не оба сразу. <p><p>Дополнительные сведения о задании этого параметра см. в разделе [Последовательный запуск циклов Foreach](#sequential-for-each).| Действие: <p>[Используют](#foreach-action) | 
| `SingleInstance` | Строка | Запустите триггер для каждого экземпляра приложения логики последовательно и дождитесь завершения предыдущего активного запуска, прежде чем запускать следующий экземпляр приложения логики. <p><p>Этот параметр работает так же, как параметр свойства `runtimeConfiguration.concurrency.runs`, равный `1`. Можно установить любое свойство, но не оба сразу. <p>Чтобы задать этот параметр, см. раздел [Последовательная активизация экземпляров](#sequential-trigger). | Все триггеры | 
||||

<a name="change-trigger-concurrency"></a>

### <a name="change-trigger-concurrency"></a>Изменение параллелизма триггера

По умолчанию экземпляры рабочего процесса приложения логики выполняются одновременно (параллельно или одновременно). Это означает, что каждый экземпляр триггера срабатывает до завершения выполнения ранее запущенного экземпляра рабочего процесса. Однако количество одновременно выполняемых экземпляров [ограничено по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Когда количество одновременно выполняемых экземпляров рабочего процесса достигает этого предела, все остальные экземпляры должны ожидать выполнения. Это ограничение помогает контролировать количество запросов, которые получают серверные системы.

При включении управления параллелизмом триггеров экземпляры запускаются параллельно с [ограничением по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Чтобы изменить это ограничение параллелизма по умолчанию, можно использовать редактор представления кода или конструктор Logic Apps, так как изменение параметра параллелизма с помощью конструктора добавляет или обновляет `runtimeConfiguration.concurrency.runs` свойство в базовом определении триггера и наоборот. Это свойство управляет максимальным числом новых экземпляров рабочих процессов, которые могут выполняться параллельно.

Ниже приведены некоторые рекомендации по включению параллелизма в триггере.

* Если параметр Concurrency включен, [ограничение SplitOn](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits) значительно сокращается для [депакетирования массивов](#split-on-debatch). Если число элементов превышает это ограничение, функция SplitOn отключается.

* Невозможно отключить параллелизм после включения управления параллелизмом.

* При включении параллелизма долго выполняющийся экземпляр приложения логики может привести к тому, что новые экземпляры приложения логики будут входить в состояние ожидания. Это состояние предотвращает создание новых экземпляров Azure Logic Apps и происходит даже в том случае, если количество параллельных запусков меньше указанного максимального числа параллельных запусков.

  * Чтобы прервать это состояние, отмените *Запуск* самых ранних экземпляров.

    1. В меню приложения логики выберите **Обзор**.

    1. В разделе **журнал запусков** выберите самый ранний экземпляр, который все еще выполняется, например:

       ![Выберите самый ранний выполняющийся экземпляр](./media/logic-apps-workflow-actions-triggers/waiting-runs.png)

       > [!TIP]
       > Чтобы просмотреть только те экземпляры, которые еще работают, откройте список **все** и выберите пункт **выполняется**.

    1. В разделе **Запуск приложения логики** выберите **Отменить выполнение**.

       ![Найти самый ранний выполняющийся экземпляр](./media/logic-apps-workflow-actions-triggers/cancel-run.png)

  * Чтобы обойти эту возможность, добавьте время ожидания для любого действия, которое может содержать эти запуски. Если вы работаете в редакторе кода, см. раздел [изменение асинхронной длительности](#asynchronous-limits). В противном случае, если вы используете конструктор, выполните следующие действия.

    1. В приложении логики в действии, в котором нужно добавить время ожидания, в правом верхнем углу нажмите кнопку с многоточием (**...**), а затем выберите **Параметры**.

       ![Открытие параметров действия](./media/logic-apps-workflow-actions-triggers/action-settings.png)

    1. В разделе **время ожидания** укажите длительность времени ожидания в [формате ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations).

       ![Укажите длительность ожидания](./media/logic-apps-workflow-actions-triggers/timeout.png)

* Для последовательного запуска приложения логики задайте для параллелизма триггера значение `1` либо с помощью редактора представления кода, либо конструктора. Убедитесь, что для свойства триггера не задано значение `operationOptions` `SingleInstance` в редакторе представления кода. В противном случае возникнет ошибка проверки. Дополнительные сведения см. в разделе [Последовательная активизация экземпляров](#sequential-trigger).

#### <a name="edit-in-code-view"></a>Изменение в представлении кода 

В базовом определении триггера добавьте `runtimeConfiguration.concurrency.runs` свойство, которое может иметь значение в диапазоне от `1` до `50` .

Ниже приведен пример, который ограничивает параллельные выполнения до 10 экземпляров.

```json
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": 10
      }
   }
}
```

Дополнительные сведения см. в разделе [Настройки конфигурации среды выполнения](#runtime-config-options).

#### <a name="edit-in-logic-apps-designer"></a>Изменение в Конструкторе Logic Apps

1. В правом верхнем углу окна триггера нажмите кнопку с многоточием (**...**), а затем выберите **Параметры**.

1. В разделе **Управление параллелизмом** установите для параметра **Ограничение** значение **Вкл.** 

1. Перетащите ползунок **Степень параллелизма** к необходимому значению. Чтобы выполнять приложение логики в последовательном режиме, перетащите ползунок до значения **1**.

<a name="change-for-each-concurrency"></a>

### <a name="change-for-each-concurrency"></a>Изменение параллелизма цикла Foreach

По умолчанию все итерации цикла "For Each" выполняются одновременно (одновременно или параллельно). Это означает, что каждая итерация начнет выполняться до завершения предыдущей итерации. Однако количество параллельно выполняемых итераций [ограничено по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Если количество параллельно выполняющихся итераций достигает этого предела, все остальные итерации должны ожидать выполнения.

Чтобы изменить предел по умолчанию, можно использовать либо редактор просмотра кода, либо Конструктор Logic Apps, поскольку изменение параметра параллелизма с помощью конструктора добавляет или обновляет свойство `runtimeConfiguration.concurrency.repetitions` в базовом определении действия Foreach и наоборот. Это свойство определяет максимальное число итераций, которые могут выполняться параллельно.

> [!NOTE] 
> Если вы установите действие Foreach для запуска последовательно с помощью конструктора или редактора представления кода, не устанавливайте свойство `operationOptions` действия равное `Sequential` в редакторе представления кода. В противном случае возникнет ошибка проверки. Дополнительные сведения см. в разделе [Последовательный запуск циклов Foreach](#sequential-for-each).

#### <a name="edit-in-code-view"></a>Изменение в представлении кода 

В базовом определении "For Each" добавьте или обновите `runtimeConfiguration.concurrency.repetitions` свойство, которое может иметь значение в диапазоне от `1` и `50` .

Ниже приведен пример, который ограничивает параллельные выполнения до 10 итераций.

```json
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": 10
      }
   }
}
```

Дополнительные сведения см. в разделе [Настройки конфигурации среды выполнения](#runtime-config-options).

#### <a name="edit-in-logic-apps-designer"></a>Изменение в Конструкторе Logic Apps

1. В области **для каждого** действия в правом верхнем углу нажмите кнопку с многоточием (**...**), а затем выберите **Параметры**.

1. В разделе **Управление параллелизмом** для параметра **Управление параллелизмом** задайте значение **Вкл.**

1. Перетащите ползунок **Степень параллелизма** к необходимому значению. Чтобы выполнять приложение логики в последовательном режиме, перетащите ползунок до значения **1**.

<a name="change-waiting-runs"></a>

### <a name="change-waiting-runs-limit"></a>Изменение предела ожидающих запусков

По умолчанию экземпляры рабочего процесса приложения логики выполняются одновременно (параллельно или одновременно). Это означает, что каждый экземпляр триггера срабатывает до завершения выполнения ранее запущенного экземпляра рабочего процесса. Однако количество одновременно выполняемых экземпляров [ограничено по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Когда количество одновременно выполняемых экземпляров рабочего процесса достигает этого предела, все остальные экземпляры должны ожидать выполнения.

Количество ожидающих запусков также [ограничено по умолчанию](../logic-apps/logic-apps-limits-and-config.md#looping-debatching-limits). Когда количество ожидающих запусков достигает этого предела, подсистема Logic Apps больше не принимает новые запуски. Триггеры запроса и веб-перехватчика возвращают 429 ошибку, а повторяющиеся триггеры начинают пропускать попытки опроса.

Можно не только [изменить ограничение по умолчанию для параллелизма триггеров](#change-trigger-concurrency), но также можно изменить ограничение по умолчанию для ожидающих выполнения. В базовом определении триггера добавьте `runtimeConfiguration.concurrency.maximumWaitingRuns` свойство, которое может иметь значение в диапазоне от `1` до `100` .

```json
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "maximumWaitingRuns": 50
      }
   }
}
```

Дополнительные сведения см. в разделе [Настройки конфигурации среды выполнения](#runtime-config-options).

<a name="sequential-trigger"></a>

### <a name="trigger-instances-sequentially"></a>Последовательная активация экземпляров

Чтобы запустить каждый экземпляр рабочего процесса приложения логики только после того, как предыдущий экземпляр завершит работу, настройте триггер для выполнения последовательно. Вы можете использовать либо редактор просмотра кода, либо конструктор Logic Apps, поскольку изменение параметра параллелизма с помощью конструктора также добавляет или обновляет свойство `runtimeConfiguration.concurrency.runs` в базовом определении триггера и наоборот.

> [!NOTE] 
> Если вы настроите триггер для последовательного запуска с помощью конструктора или редактора представления кода, не устанавливайте свойство `operationOptions` триггера равное `Sequential` в редакторе представления кода. В противном случае возникнет ошибка проверки. 

#### <a name="edit-in-code-view"></a>Изменение в представлении кода

В определении триггера задайте одно из этих свойств, но не оба. 

Задайте для свойства `runtimeConfiguration.concurrency.runs` значение `1`.

```json
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": 1
      }
   }
}
```

*-или-*

Задайте для свойства `operationOptions` значение `SingleInstance`.

```json
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "operationOptions": "SingleInstance"
}
```

Дополнительные сведения см. в разделе [Параметры конфигурации среды выполнения](#runtime-config-options) и [Параметры операций](#operation-options).

#### <a name="edit-in-logic-apps-designer"></a>Изменение в Конструкторе Logic Apps

1. В правом верхнем углу окна триггера нажмите кнопку с многоточием (**...**), а затем выберите **Параметры**.

1. В разделе **Управление параллелизмом** установите для параметра **Ограничение** значение **Вкл.** 

1. Перетащите ползунок **Степень параллелизма** на номер `1`. 

<a name="sequential-for-each"></a>

### <a name="run-for-each-loops-sequentially"></a>Последовательный запуск циклов Foreach

Чтобы запустить итерацию цикла Foreach только после завершения предыдущей итерации, настройте последовательное выполнение каждого действия. Вы можете использовать либо редактор просмотра кода, либо конструктор Logic Apps, поскольку изменение действия параллелизма с помощью конструктора также добавляет или обновляет свойство `runtimeConfiguration.concurrency.repetitions` в базовом определении действия и наоборот.

> [!NOTE] 
> Если вы настроите последовательное выполнение действия Foreach для запуска с помощью конструктора или редактора представления кода, не устанавливайте свойство `operationOptions` действия равным `Sequential` в редакторе представления кода. В противном случае возникнет ошибка проверки. 

#### <a name="edit-in-code-view"></a>Изменение в представлении кода

В определении действия задайте один из этих свойств, но не оба. 

Задайте для свойства `runtimeConfiguration.concurrency.repetitions` значение `1`.

```json
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": 1
      }
   }
}
```

*-или-*

Задайте для свойства `operationOptions` значение `Sequential`.

```json
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "operationOptions": "Sequential"
}
```

Дополнительные сведения см. в разделе [Параметры конфигурации среды выполнения](#runtime-config-options) и [Параметры операций](#operation-options).

#### <a name="edit-in-logic-apps-designer"></a>Изменение в Конструкторе Logic Apps

1. В правом верхнем углу **для каждого** действия нажмите кнопку с многоточием (**...**), а затем выберите **Параметры**.

1. В разделе **Управление параллелизмом** для параметра **Управление параллелизмом** задайте значение **Вкл.**

1. Перетащите ползунок **Степень параллелизма** на номер `1`.

<a name="disable-asynchronous-pattern"></a>

### <a name="run-actions-in-a-synchronous-operation-pattern"></a>Выполнение действий в шаблоне синхронной операции

По умолчанию действия HTTP Action и APIConnection в Azure Logic Apps соответствуют стандартному [*шаблону асинхронной операции*](/azure/architecture/patterns/async-request-reply), а действие ответа соответствует *шаблону синхронной операции*. Асинхронная модель указывает, что после того, как действие вызывает или отправляет запрос в указанную конечную точку, службу, систему или API, получатель немедленно возвращает ответ ["202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.3) Accepted" (принято). Этот код подтверждает, что получатель принял запрос, но еще не завершил обработку. Ответ может включать `location` заголовок, указывающий URL-адрес и идентификатор обновления, который вызывающий может использовать для постоянного опроса или проверки состояния асинхронного запроса до тех пор, пока получатель не прекратит обработку и не вернет сообщение об успешном завершении ["200 ОК"](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.1) или другой ответ, отличный от 202. Дополнительные сведения см. в разделе [асинхронная интеграция микрослужб применяет автономность микрослужбы](/azure/architecture/microservices/design/interservice-communication#synchronous-versus-asynchronous-messaging).

* В конструкторе приложений логики параметр действия HTTP, действия APIConnection и действие ответ имеют значение **асинхронного шаблона** . Если этот параметр включен, вызывающий объект не ждет завершения обработки и может перейти к следующему действию, но будет продолжать проверять состояние до тех пор, пока обработка не будет остановлена. Если этот параметр отключен, вызывающий объект ожидает завершения обработки перед переходом к следующему действию. Чтобы найти этот параметр, выполните следующие действия.

  1. В строке заголовка действия HTTP нажмите кнопку с многоточием (**...**), открывающую параметры действия.

  1. Найдите параметр **асинхронного шаблона** .

     ![Параметр "асинхронная модель"](./media/logic-apps-workflow-actions-triggers/asynchronous-pattern-setting.png)

* В определении базового нотация объектов JavaScript (JSON) действия HTTP действия и APIConnection неявно соответствуют шаблону асинхронной операции.

В некоторых случаях может потребоваться, чтобы действие следовало следовать синхронному шаблону. Например, при использовании действия HTTP может потребоваться:

* [Избегайте истечения времени ожидания HTTP для долго выполняющихся задач](../connectors/connectors-native-http.md#avoid-http-timeouts)
* [Отключить проверку заголовков расположения](../connectors/connectors-native-http.md#disable-location-header-check)

В этих случаях можно выполнить синхронное выполнение действия с помощью следующих параметров:

* Замените версию опроса этого действия на версию веб-перехватчика, если она доступна.

* Отключите асинхронное поведение действия, выполнив любой из следующих настроек.

  * В конструкторе приложений логики [Отключите параметр **асинхронного шаблона**](#turn-off-asynchronous-pattern-setting).

  * В базовом определении JSON действия [добавьте `"DisableAsyncPattern"` параметр operation](#add-disable-async-pattern-option).

<a name="turn-off-asynchronous-pattern-setting"></a>

#### <a name="turn-off-asynchronous-pattern-setting"></a>Отключить **асинхронный параметр шаблона**

1. В конструкторе приложений логики в строке заголовка действия нажмите кнопку с многоточием (**...**), открывающую параметры действия.

1. Найдите параметр **асинхронный шаблон** , установите параметр в значение **выкл** ., если он включен, и нажмите кнопку **Готово**.

   ![Отключить параметр "асинхронный шаблон"](./media/logic-apps-workflow-actions-triggers/disable-asynchronous-pattern-setting.png)

<a name="add-disable-async-pattern-option"></a>

#### <a name="disable-asynchronous-pattern-in-actions-json-definition"></a>Отключение асинхронного шаблона в определении JSON действия

В базовом определении JSON действия добавьте и задайте [свойство "оператионоптионс"](#operation-options) в разделе `"DisableAsyncPattern"` действия `"inputs"` , например:

```json
"<some-long-running-action>": {
   "type": "Http",
   "inputs": { "<action-inputs>" },
   "operationOptions": "DisableAsyncPattern",
   "runAfter": {}
}
```

<a name="authenticate-triggers-actions"></a>

## <a name="authenticate-triggers-and-actions"></a>Проверка подлинности триггеров и действий

Конечные точки HTTP и HTTPS поддерживают различные виды проверки подлинности. В зависимости от триггера или действия, которые используются для выполнения исходящих вызовов или запросов на доступ к этим конечным точкам, можно выбрать из разных диапазонов типов проверки подлинности. Дополнительные сведения см. в разделе [Добавление проверки подлинности в исходящие вызовы](../logic-apps/logic-apps-securing-a-logic-app.md#add-authentication-outbound) далее в этой статье.

## <a name="next-steps"></a>Дальнейшие действия

* См. дополнительные сведения о [языке определения рабочего процесса](../logic-apps/logic-apps-workflow-definition-language.md)