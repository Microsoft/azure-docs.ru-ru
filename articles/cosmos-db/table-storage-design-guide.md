---
title: Разработка таблиц Azure Cosmos DB для обеспечения масштабирования и производительности
description: Руководство по проектированию Хранилища таблиц Azure. Масштабируемые и производительные таблицы в Azure Cosmos DB и Хранилище таблиц Azure
ms.service: cosmos-db
ms.subservice: cosmosdb-table
ms.topic: how-to
ms.date: 06/19/2020
author: sakash279
ms.author: akshanka
ms.custom: seodec18, devx-track-csharp
ms.openlocfilehash: 603c891e53e5712d489fcef8415e3db55328c9ad
ms.sourcegitcommit: 867cb1b7a1f3a1f0b427282c648d411d0ca4f81f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "99988448"
---
# <a name="azure-table-storage-table-design-guide-scalable-and-performant-tables"></a>Руководство по проектированию Хранилища таблиц Azure. Масштабируемые и производительные таблицы
[!INCLUDE[appliesto-table-api](includes/appliesto-table-api.md)]

[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

При проектировании масштабируемых и производительных таблиц необходимо учитывать ряд факторов, включая затраты. Если вы ранее разрабатывали схемы для реляционных баз данных, вам будет удобнее ознакомиться с этими вопросами. Хотя между хранилищем таблиц Azure и реляционными моделями есть некоторые сходства, также есть много важных различий. Как правило, эти различия приводят к созданию разных вариантов, которые могут показаться пользователям, знакомым с реляционными базами данных, алогичными или неверными, но если разработка выполняется для хранилища NoSQL типа "ключ — значение", например хранилища таблиц, эти различия будут иметь смысл.

Хранилище таблиц предназначено для поддержки масштабирования облачных приложений, содержащих миллиарды сущностей ("строк" в терминологии реляционных баз данных) данных, или для наборов данных, которые должны поддерживать значительные объемы транзакций. Поэтому необходимо по-новому взглянуть на способы хранения данных и понять, как работает Хранилище таблиц. Решение, в котором используется правильно спроектированное хранилище данных NoSQL, имеет все перспективы для значительного масштабирования (при более низких затратах), по сравнению с решением на основе реляционной базы данных. Данное руководство поможет решить эти задачи.  

## <a name="about-azure-table-storage"></a>Сведения о Хранилище таблиц Azure
В этом разделе представлены некоторые ключевые функции Хранилища таблиц, имеющие особое значение в процессе разработки производительных и масштабируемых компонентов. Если вы работаете со службой хранилища Microsoft Azure и хранилищем таблиц впервые, прежде чем прочесть оставшуюся часть этой статьи, ознакомьтесь со следующими ресурсами: [Общие сведения о службе хранилища Microsoft Azure](../storage/common/storage-introduction.md) и [Приступая к работе с Хранилищем таблиц Azure с помощью .NET](./tutorial-develop-table-dotnet.md). Несмотря на то, что основной акцент в руководстве сделан на Хранилище таблиц, здесь будут рассматриваться некоторые вопросы, имеющие отношение к Хранилищу очередей Azure и хранилищу больших двоичных объектов Azure и их использовании в решении вместе с Хранилищем таблиц.  

Хранилище таблиц использует табличный формат для хранения данных. Согласно стандартной терминологии каждая строка таблицы представляет сущность, а различные свойства этой сущности хранятся в столбцах. Каждая сущность имеет уникально идентифицирующую ее пару ключей и столбец метки времени, который Хранилище таблиц использует для отслеживания времени последнего обновления сущности. Метка времени добавляется автоматически, ее нельзя вручную перезаписать произвольным значением. Хранилище таблиц применяет метку времени последнего изменения (LMT) для управления оптимистическим параллелизмом.  

> [!NOTE]
> Операции REST API Хранилища таблиц также возвращают значение `ETag`, являющееся производным от отметки времени последнего изменения (LMT). В этом документе термины "ETag" и "LMT" взаимозаменяемые, поскольку они относятся к одним и тем же базовым данным.  
> 
> 

В следующем примере показана простая схема таблицы для хранения сущностей сотрудников и отделов. Подобную структуру имеет большинство таблиц, приведенных далее в этом руководстве.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Отметка времени</th>
<th></th>
</tr>
<tr>
<td>Маркетинг</td>
<td>00001</td>
<td>2014-08-22T00:50:32Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td>Don</td>
<td>Hall</td>
<td>34</td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Маркетинг</td>
<td>00002</td>
<td>2014-08-22T00:50:34Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td>Июнь</td>
<td>Cao</td>
<td>47</td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Маркетинг</td>
<td>отдел;</td>
<td>2014-08-22T00:50:30Z</td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>Маркетинг</td>
<td>153</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>Sales</td>
<td>00010</td>
<td>2014-08-22T00:50:44Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td>Ken</td>
<td>Kwok</td>
<td>23</td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


Пока эта схема выглядит примерно так же, как таблица в реляционной базе данных. Основными отличиями являются обязательные столбцы и возможность хранения нескольких типов сущностей в одной таблице. Кроме того, все определенные пользователями свойства, например **FirstName** или **Age**, имеют такой тип данных, как целое или строка, аналогично столбцам в реляционной базе данных. В отличие от традиционных реляционных баз данных Хранилище таблиц имеет бессхемную конструкцию. Это значит, что свойства могут относиться к разным типам. Для хранения сложных типов данных в одном свойстве необходимо использовать сериализованный формат, например JSON или XML. Дополнительные сведения см. в статье [Общие сведения о модели данных Хранилища таблиц](/rest/api/storageservices/Understanding-the-Table-Service-Data-Model).

Основой для разработки эффективной таблицы является выбор свойств `PartitionKey` и `RowKey`. Каждая сущность, хранящаяся в таблице, должна иметь уникальное сочетание значений `PartitionKey` и `RowKey`. Как и в случае с ключами в таблице реляционной базы данных, значения `PartitionKey` и `RowKey` индексируются для создания кластеризованного индекса, позволяющего выполнять быстрый поиск. Однако Хранилище таблиц не создает дополнительных индексов, поэтому это единственные два индексированных свойства (некоторые закономерности, описанные ниже, показывают, как можно обойти это очевидное ограничение).  

Таблица состоит из одного или нескольких разделов. Большая часть принимаемых решений по разработке будет связана с выбором подходящих свойств `PartitionKey` и `RowKey` для оптимизации решения. В решение может входить только одна таблица, в которой все сущности упорядочены по разделам. Однако обычно решение состоит из нескольких таблиц. Таблицы помогают логически упорядочивать сущности, а также помогают управлять доступом к данным с помощью списков управления доступом. Можно удалить всю таблицу с помощью одной операции хранилища.  

### <a name="table-partitions"></a>Разделы таблицы
Имя учетной записи, имя таблицы и свойство `PartitionKey`, вместе взятые, определяют раздел в службе хранилища, где Хранилище таблиц хранит сущность. Поскольку разделы являются частью схемы адресации для сущностей, они определяют область действия транзакций (см. раздел [Транзакции группы сущностей](#entity-group-transactions) далее в этой статье) и формируют основу варианта масштабирования Хранилища таблиц. Дополнительные сведения о разделах таблицы см. в статье [Контрольный список для обеспечения масштабируемости и производительности для Хранилища таблиц](../storage/tables/storage-performance-checklist.md).  

В Хранилище таблиц отдельный узел обслуживает один или несколько полных разделов, а масштабирование службы осуществляется за счет динамического распределения нагрузки разделов между узлами. Если узел находится под нагрузкой, Хранилище таблиц может разделить диапазон разделов, обслуживаемых этим узлом, на разные узлы. По мере убывания трафика Хранилище таблиц может объединить диапазоны разделов из неиспользуемых узлов обратно в один узел.  

Дополнительные сведения о внутренних подробностях Хранилища таблиц, в особенности о том, как оно управляет разделами, см. в документе [Служба хранилища Microsoft Azure: высокодоступная служба облачного хранения со строгой согласованностью](/archive/blogs/windowsazurestorage/sosp-paper-windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency).  

### <a name="entity-group-transactions"></a>Транзакции группы сущностей
В Хранилище таблиц транзакции группы сущностей (EGT) являются единственным встроенным механизмом для выполнения атомарных обновлений в нескольких сущностях. Транзакции группы сущностей называются *пакетными транзакциями*. Эти транзакции поддерживаются только для сущностей, хранящихся в одном разделе (имеющих общий ключ раздела в данной таблице), поэтому каждый раз, когда в нескольких сущностях требуется провести атомарные транзакции, необходимо убедиться, что эти сущности находятся в одном разделе. Именно этот момент часто является основанием для хранения нескольких типов сущностей в одной таблице (и разделе) и отказа от использования нескольких таблиц для разных типов сущностей. Одна транзакция группы сущностей может работать с максимум 100 сущностей.  При отправке сразу нескольких транзакций группы сущностей для обработки важно убедиться в том, что эти транзакции не работают с сущностями, которые являются общими между такими транзакциями, в противном случае обработка может быть отложена.

Кроме того, применение транзакций группы сущностей приводит к необходимости сопоставить преимущества и недостатки и сделать компромиссный выбор при разработке. Использование дополнительных разделов будет способствовать повышению масштабируемости приложения, так как Azure предоставляет множество вариантов для балансировки нагрузки запросов между узлами. Однако это может ограничить возможности приложения по выполнению атомарных транзакций и обеспечению высокого уровня согласованности данных. Кроме того, следует принять во внимание наличие определенных целевых показателей масштабируемости на уровне раздела, которые могут ограничивать ожидаемую пропускную способность для транзакций на одном узле.

Дополнительные сведения о целевых показателях масштабируемости для учетных записей хранения Azure см. в статье [Целевые показатели масштабируемости и производительности для стандартных учетных записей хранения](../storage/common/scalability-targets-standard-account.md). Дополнительные сведения о целевых показателях масштабируемости для Хранилища таблиц см. в статье [Целевые показатели масштабируемости и производительности для Хранилища таблиц](../storage/tables/scalability-targets.md). В последующих разделах данного руководства рассматриваются различные стратегии разработки, упрощающие управление подобными компромиссными решениями, а также описываются оптимальные варианты выбора ключа раздела с учетом конкретных требований клиентского приложения.  

### <a name="capacity-considerations"></a>Рекомендации по емкости
В следующей таблице перечислены некоторые ключевые значения, которые следует учитывать при разработке решения для Хранилища таблиц.  

| Общая емкость учетной записи хранения Azure | 500 TБ |
| --- | --- |
| Количество таблиц в учетной записи хранения Azure |Ограничено только емкостью учетной записи хранения. |
| Количество разделов в таблице |Ограничено только емкостью учетной записи хранения. |
| Количество сущностей в разделе |Ограничено только емкостью учетной записи хранения. |
| Размер отдельной сущности |До 1 МБ с максимум 255 свойствами (включая свойства `PartitionKey`, `RowKey` и `Timestamp`). |
| Размер `PartitionKey` |Строка размером до 1 КБ. |
| Размер `RowKey` |Строка размером до 1 КБ. |
| Размер транзакции группы сущностей |Транзакция может содержать не более 100 сущностей, а объем полезных данных не должен превышать 4 МБ. Транзакция группы сущностей может обновлять сущность только один раз. |

Дополнительные сведения см. в статье [Общие сведения о модели данных Хранилища таблиц](/rest/api/storageservices/Understanding-the-Table-Service-Data-Model).  

### <a name="cost-considerations"></a>Рекомендации по стоимости
Хранилище таблиц является относительно недорогой системой хранения данных. Однако в рамках оценки любого решения, в котором развернуто Хранилище таблиц, необходимо провести расчет затрат как на использование емкостей, так и на количество транзакций. Однако во многих сценариях хранение денормализованных или повторяющихся данных для повышения производительности или масштабируемости решения является вполне правомерным подходом. Дополнительные сведения о ценах см. на [странице цен на службу хранилища Azure](https://azure.microsoft.com/pricing/details/storage/).  

## <a name="guidelines-for-table-design"></a>Рекомендации по разработке таблиц
В них приведены некоторые ключевые рекомендации, которые следует учитывать при разработке таблиц. В данном пошаговом руководстве эти сведения рассматриваются более подробно. Эти рекомендации отличаются от тех, которым необходимо следовать при разработке для реляционных баз данных.  

Разработка Хранилища таблиц для эффективного *чтения* данных из него:

* **Разрабатывайте решения с учетом выполнения запросов в приложениях с большим количеством операций чтения.** При разработке таблиц сначала необходимо сосредоточиться на запросах (особенно на чувствительных к задержкам), которые будут выполняться, а затем уделить внимание вариантам обновления сущностей. Это позволит создать эффективное и высокопроизводительное решение.  
* **Укажите в запросах как `PartitionKey`, так и `RowKey`.** *Точечные запросы*, подобные таким, — самые эффективные запросы Хранилища таблиц.  
* **Рассмотрите возможность хранения повторяющихся копий сущностей.** Хранилище таблиц является недорогим в использовании, поэтому в целях создания более эффективных запросов рекомендуется сохранять одни и те же сущности несколько раз (с разными ключами).  
* **Рассмотрите возможность денормализации данных.** Хранилище таблиц не требует больших затрат, поэтому рассмотрите возможность денормализации данных. Например, храните сущности сводки, чтобы запросы к объединенным данным обращались только к одной сущности.  
* **Используйте значения составного ключа.** Доступны только следующие ключи: `PartitionKey` и `RowKey`. Например, значения составного ключа можно использовать для включения альтернативных путей доступа с ключами к сущностям.  
* **Используйте проекции в запросах.** С помощью запросов, выбирающих только необходимые поля, можно сократить объем данных, передаваемых по сети.  

Разработка Хранилища таблиц для эффективной *записи* данных в него:  

* **Не создавайте разделы с высокой нагрузкой.** Выбирайте ключи, которые позволяют распределять запросы по нескольким разделам в любой момент времени.  
* **Избегайте пиковых нагрузок по трафику.** Распределите трафик по разумному периоду времени и избегайте пиковых нагрузок по трафику.
* **Для каждого типа сущности не требуется создавать отдельную таблицу.** Чтобы выполнять атомарные транзакции с типами сущностей, эти несколько типов сущностей можно хранить в одном разделе одной таблицы.
* **Рассмотрите требуемую максимальную пропускную способность.** Необходимо иметь в виду целевые показатели масштабируемости для Хранилища таблиц и обеспечить их соблюдение.  

В данном руководстве приведены примеры, которые демонстрируют практическую реализацию всех этих принципов.  

## <a name="design-for-querying"></a>Разработка для запросов
Хранилище таблиц может быть связано с большим количеством операций чтения, записи или сочетания этих двух видов нагрузки. В этом разделе рассматривается разработка для эффективной поддержки операций чтения. Как правило, схема, поддерживающая операции чтения, также эффективна для операций записи. Однако при разработке с учетом поддержки операций записи необходимо учитывать дополнительные моменты. Они обсуждаются в следующем разделе [Разработка для изменения данных](#design-for-data-modification).

Хорошей отправной точкой является вопрос о том, какие запросы потребуется выполнить приложению для получения необходимых данных.  

> [!NOTE]
> Для Хранилища таблиц очень важно правильно заранее спроектировать решение, поскольку его последующие изменения связаны с реализацией трудных и дорогостоящих процессов. Например, чтобы устранить проблемы с производительностью в реляционной базе данных, можно просто добавить индексы в существующую базу данных. Но этот вариант неприемлем для Хранилища таблиц.  

### <a name="how-your-choice-of-partitionkey-and-rowkey-affects-query-performance"></a>Влияние выбора `PartitionKey` и `RowKey` на производительность запросов
В следующих примерах предполагается, что сущности сотрудников хранятся в Хранилище таблиц согласно приведенной далее структуре (для большей ясности во многих примерах свойство `Timestamp` опущено).  

| Имя столбца | Тип данных |
| --- | --- |
| `PartitionKey` (отдел) |Строка |
| `RowKey` (код сотрудника) |Строка |
| `FirstName` |Строка |
| `LastName` |Строка |
| `Age` |Целое число |
| `EmailAddress` |Строка |

Ниже приведены некоторые общие рекомендации по разработке запросов к Хранилищу таблиц. Синтаксис фильтра, используемый в следующих примерах, взят из REST API Хранилища таблиц. Дополнительные сведения см. в статье [Запрос сущностей](/rest/api/storageservices/Query-Entities).  

* *Точечный запрос* представляет собой самый эффективный вариант поиска и рекомендуется к использованию при крупномасштабном поиске или поиске, требующем минимальной задержки. Для эффективного поиска отдельных сущностей в таком запросе можно использовать индексы и указать оба значения, `PartitionKey` и `RowKey`. Например: `$filter=(PartitionKey eq 'Sales') and (RowKey eq '2')`.  
* Второй наилучший вариант — *запрос в диапазоне*. Он использует `PartitionKey` и фильтрует диапазон значений `RowKey`, чтобы вернуть несколько сущностей. Значение `PartitionKey` определяет конкретный раздел, а значения `RowKey` определяют подмножество сущностей в этом разделе. Например: `$filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'`.  
* Третий наилучший вариант — *сканирование раздел*. Он использует `PartitionKey` и фильтрует еще одно свойство, не являющееся ключевым, и может возвращать несколько сущностей. Значение `PartitionKey` определяет конкретный раздел и значения свойств, выбранные для подмножества сущностей в этом разделе. Например: `$filter=PartitionKey eq 'Sales' and LastName eq 'Smith'`.  
* Тип поиска *Сканирование таблицы* не использует свойство `PartitionKey` и является неэффективным, так как поиск совпадающих сущностей выполняется по всем разделам таблицы. Сканирование таблицы будет осуществляться независимо от того, использует фильтр свойство `RowKey` или нет. Например: `$filter=LastName eq 'Jones'`.  
* Запросы хранилища таблиц Azure, возвращающие несколько сущностей, сортируются в порядке `PartitionKey` и `RowKey`. Чтобы избежать повторной сортировки сущностей в клиенте, выберите свойство `RowKey`, которое определяет самый распространенный порядок сортировки. Результаты запросов, возвращаемые API таблиц Azure в Azure Cosmos DB, не сортируются по ключу раздела или ключу строки. Дополнительные сведения см. в ответе на вопрос [Чем API таблиц отличается от хранилища таблиц Azure?](table-api-faq.md#table-api-vs-table-storage).

Использование логического оператора "**or**"для указания фильтра на основе `RowKey` приведет к запуску просмотра раздела и не будет обрабатываться как запрос диапазона. Поэтому избегайте запросов, использующих такие фильтры, как `$filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')`.  

Примеры кода на стороне клиента с использованием клиентской библиотеки хранилища для выполнения запросов см. в следующих разделах.  

* [Выполнение точечного запроса с помощью клиентской библиотеки хранилища](#run-a-point-query-by-using-the-storage-client-library)
* [Извлечение нескольких сущностей с помощью LINQ](#retrieve-multiple-entities-by-using-linq)
* [Проекция на стороне сервера](#server-side-projection)  

Примеры кода на стороне клиента, который может обрабатывать несколько типов сущностей, хранящихся в одной таблице, см. в следующем разделе:  

* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)  

### <a name="choose-an-appropriate-partitionkey"></a>Выбор соответствующего свойства `PartitionKey`
Выбранное свойство `PartitionKey` должно сбалансировать необходимость использования транзакций группы сущностей (для обеспечения согласованности) и требование к распределению сущностей по нескольким разделам (для построения масштабируемого решения).  

С одной стороны, все сущности можно хранить в одном разделе. Однако это может ограничить масштабируемость вашего решения и не позволит Хранилищу таблиц получать запросы на балансировку нагрузки. С другой стороны, в одном разделе можно хранить только одну сущность. За счет этого обеспечивается высокая масштабируемость, и Хранилище таблиц может выполнять запросы балансировки нагрузки, но не позволяет использовать транзакции группы сущностей.  

Идеальное свойство `PartitionKey` позволяет применять эффективные запросы и обеспечивает достаточно разделов, чтобы гарантировать масштабируемость решения. Вы поймете, что сущности имеют соответствующее свойство, которое распределяет их по необходимому количеству разделов.

> [!NOTE]
> Например, в системе, где хранятся сведения о пользователях или сотрудниках, идентификатор пользователя (`UserID`) может быть выражен подходящим значением `PartitionKey`. Использовать определенный идентификатор пользователя (`UserID`) в качестве ключа раздела могут сразу несколько сущностей. Каждая сущность, хранящая данные о пользователе, сгруппирована в один раздел. Доступ к этим сущностям можно получить с помощью EGT, сохраняя при этом высокую масштабируемость.
> 
> 

При выборе свойства `PartitionKey` необходимо учесть ряд дополнительных аспектов, которые имеют отношение к операциям вставки, обновления и удаления сущностей. Дополнительные сведения см. в разделе [Разработка для изменения данных](#design-for-data-modification).  

### <a name="optimize-queries-for-table-storage"></a>Оптимизация запросов к Хранилищу таблиц
Хранилище таблиц автоматически индексирует сущности с помощью значений `PartitionKey` и `RowKey` в одном кластеризованном индексе. Именно по этой причине точечные запросы являются наиболее эффективными. Однако не существует индексов, отличных от кластеризованного индекса, использующего значения `PartitionKey` и `RowKey`.

Многие разработки должны соответствовать требованиям по включению поиска сущностей на основании нескольких условий. Например, поиск сущностей сотрудников на основе адреса электронной почты, кода сотрудника или фамилии. Следующие шаблоны в разделе [Шаблоны для разработки таблиц](#table-design-patterns) призваны обеспечить соответствие этим типам требований. Шаблоны также учитывают тот факт, что хранилище таблиц не предоставляет вторичные индексы.  

* [Шаблон вторичного индекса внутри раздела](#intra-partition-secondary-index-pattern). Хранение нескольких копий каждой сущности с использованием разных значений `RowKey` (в одном и том же разделе). Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки с использованием разных значений `RowKey`.  
* [Шаблон вторичного индекса в разных разделах](#inter-partition-secondary-index-pattern). Хранение нескольких копий каждой сущности с использованием разных значений `RowKey` в разных разделах или в разных таблицах. Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки с использованием разных значений `RowKey`.  
* [Шаблон сущностей индекса](#index-entities-pattern). Поддерживайте сущности индексов для выполнения эффективных операций поиска, возвращающих списки сущностей.  

### <a name="sort-data-in-table-storage"></a>Сортировка данных в Хранилище таблиц

Хранилище таблиц возвращает результаты запроса, отсортированные в порядке возрастания по `PartitionKey`, а затем по `RowKey`.

> [!NOTE]
> Результаты запросов, возвращаемые API таблиц Azure в Azure Cosmos DB, не сортируются по ключу раздела или ключу строки. Дополнительные сведения см. в ответе на вопрос [Чем API таблиц отличается от хранилища таблиц Azure?](table-api-faq.md#table-api-vs-table-storage).

Ключи в Хранилище таблиц являются строковыми значениями. Чтобы правильно отсортировать числовые значения, их необходимо преобразовать в значения фиксированной длины и заполнить нулями. Например, если значение кода сотрудника, используемое в качестве `RowKey`, является целочисленным значением, то код сотрудника **123** необходимо преобразовать в **00000123**. 

Многие приложения предъявляют требования к использованию данных, отсортированных в разных порядках. Например, сотрудники могут быть отсортированы по имена или по дате присоединения. Следующие шаблоны в разделе [Шаблоны для разработки таблиц](#table-design-patterns) предназначены для выбора альтернативных порядков сортировки для сущностей.  

* [Шаблон вторичного индекса внутри раздела](#intra-partition-secondary-index-pattern). Хранение нескольких копий каждой сущности с использованием разных значений `RowKey` (в одном и том же разделе). Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки с использованием разных значений `RowKey`.  
* [Шаблон вторичного индекса в разных разделах](#inter-partition-secondary-index-pattern). Хранение нескольких копий каждой сущности с использованием разных значений `RowKey` в разных разделах в разных таблицах. Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки с использованием разных значений `RowKey`.
* [Шаблон для заключительного фрагмента журнала](#log-tail-pattern). Извлечение *n* сущностей, недавно добавленных в раздел, с помощью значения `RowKey`, выполняющего сортировку по дате и времени в обратном порядке.  

## <a name="design-for-data-modification"></a>Разработка для изменения данных
В этом разделе рассматриваются вопросы разработки для оптимизации операций вставки, обновления и удаления. В некоторых случаях необходимо оценить компромисс между схемами, оптимизированными для выполнения запросов, и схемами, оптимизированными для изменения данных. Такая оценка аналогична той, которая выполняется в отношении схем для реляционных баз данных (несмотря на то, что методы управления компромиссами между схемами в реляционной базе данных различаются). В разделе [Шаблоны для разработки таблиц](#table-design-patterns) описаны шаблоны разработки для Хранилища таблиц и рассматриваются некоторые компромиссные варианты. На практике вы увидите, что многие модели, оптимизированные для выполнения запросов к сущностям, также хорошо подходят для изменения сущностей.  

### <a name="optimize-the-performance-of-insert-update-and-delete-operations"></a>Оптимизация производительности операций вставки, обновления и удаления
Чтобы обновить или удалить сущность, ее необходимо определить с помощью значений `PartitionKey` и `RowKey`. В этом отношении выбор `PartitionKey` и `RowKey` для изменения сущностей должен соответствовать выбранным критериям для поддержки точечных запросов. Необходимо, чтобы сущности определялись как можно эффективнее. Следует исключить неэффективное сканирование раздела или таблицы для поиска сущности с целью обнаружения значений `PartitionKey` и `RowKey`, необходимых для ее обновления или удаления.  

Следующие шаблоны в разделе [Шаблоны для разработки таблиц](#table-design-patterns) позволяют оптимизировать производительность операций вставки, обновления и удаления.  

* [Шаблон для удаления больших объемов сущностей](#high-volume-delete-pattern). Включение операции удаления больших объемов сущностей за счет сохранения всех сущностей для одновременного удаления в отдельной таблице. Удаление сущностей происходит при удалении таблицы.  
* [Шаблон для рядов данных](#data-series-pattern). Чтобы сократить количество выполняемых запросов, храните ряды данных в одной сущности.  
* [Шаблон для масштабных сущностей](#wide-entities-pattern). Чтобы сохранить сущности, имеющие более 252 свойств, используйте несколько физических сущностей.  
* [Шаблон для сущностей больших размеров](#large-entities-pattern). Для хранения больших по объему значений свойств используйте хранилище больших двоичных объектов.  

### <a name="ensure-consistency-in-your-stored-entities"></a>Обеспечение согласованности хранимых сущностей
Другим фактором, который влияет на выбор ключей для оптимизации изменения данных, является обеспечение согласованности с помощью атомарных операций. Транзакции группы сущностей можно использовать только для работы с сущностями, хранящимися в одном разделе.  

Следующие шаблоны в разделе [Шаблоны для разработки таблиц](#table-design-patterns) предназначены для управления согласованностью.  

* [Шаблон вторичного индекса внутри раздела](#intra-partition-secondary-index-pattern). Хранение нескольких копий каждой сущности с использованием разных значений `RowKey` (в одном и том же разделе). Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки с использованием разных значений `RowKey`.  
* [Шаблон вторичного индекса в разных разделах](#inter-partition-secondary-index-pattern). Хранение нескольких копий каждой сущности с использованием разных значений `RowKey` в разных разделах или в разных таблицах. Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки с использованием разных значений `RowKey`.  
* [Шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern). Обеспечьте согласованное поведение в рамках границ раздела или границ системы хранения с помощью запросов Azure.
* [Шаблон сущностей индекса](#index-entities-pattern). Поддерживайте сущности индексов для выполнения эффективных операций поиска, возвращающих списки сущностей.  
* [Шаблон денормализации](#denormalization-pattern). Объединение связанных данных в одной сущности для извлечения необходимых данных с помощью одного точечного запроса.  
* [Шаблон для рядов данных](#data-series-pattern). Чтобы сократить количество выполняемых запросов, храните ряды данных в одной сущности.  

Дополнительные сведения см. в разделе [Транзакции группы сущностей](#entity-group-transactions) далее в этой статье.  

### <a name="ensure-your-design-for-efficient-modifications-facilitates-efficient-queries"></a>Использование эффективных запросов в разработке для эффективных изменений
Во многих случаях разработка эффективных запросов способствует эффективным изменениям. Однако в каждом конкретном случае всегда следует проверять, так ли это. Некоторые шаблоны в разделе [Шаблоны для разработки таблиц](#table-design-patterns) позволяют явным образом сопоставить выгоды и недостатки процессов создания запросов и изменения сущностей. Вместе с этим всегда необходимо учитывать количество операций каждого типа.  

Следующие шаблоны в разделе [Шаблоны для разработки](#table-design-patterns) таблиц предназначены для определения компромиссных вариантов между разработкой для эффективных запросов и разработкой для эффективного изменения данных.  

* [Шаблон составного ключа](#compound-key-pattern). Используйте составные значения `RowKey`, чтобы клиент мог выполнять поиск связанных данных с помощью одного точечного запроса.  
* [Шаблон для заключительного фрагмента журнала](#log-tail-pattern). Извлечение *n* сущностей, недавно добавленных в раздел, с помощью значения `RowKey`, выполняющего сортировку по дате и времени в обратном порядке.  

## <a name="encrypt-table-data"></a>Шифрование данных таблиц
Клиентская библиотека хранилища Azure для .NET поддерживает шифрование строковых свойств для операций вставки и замены. Зашифрованные строки хранятся в службе в виде двоичных свойств. Они преобразуются обратно в строки после расшифровки.    

Что касается таблиц, то в дополнение к политике шифрования пользователи должны указать свойства, которые необходимо зашифровать. Либо укажите атрибут `EncryptProperty` (для сущностей POCO, которые являются производными от `TableEntity`), либо укажите сопоставитель шифрования в параметрах запроса. Сопоставитель шифрования — это делегат, который получает ключ секции, ключ строки и имя свойства, а затем возвращает логическое значение, которое указывает, следует ли это свойство шифровать. Во время шифрования клиентская библиотека использует эти сведения, чтобы решить, следует ли шифровать свойство перед отправкой. Делегат также обеспечивает возможность логики в отношении того, как шифруются свойства. (Например, если значение равно X, то шифровать свойство А; в противном случае шифровать свойства А и В.) Не нужно предоставлять эти сведения при чтении или выполнении запросов к сущностям.

В настоящий момент слияние не поддерживается. Поскольку подмножество свойств могло уже быть зашифровано с помощью другого ключа, простое слияние новых свойств и обновление метаданных приведет к потере данных. Для слияния требуется либо сначала прочитать данные существующей сущности в службе, либо использовать новый ключ для каждого свойства, однако оба способа не подходят из-за низкой эффективности.     

Дополнительные сведения о шифровании данных таблицы см. в статье [Шифрование на стороне клиента и Azure Key Vault для службы хранилища Microsoft Azure](../storage/common/storage-client-side-encryption.md).  

## <a name="model-relationships"></a>Моделирование отношений
Построение модели предметной области является одним из ключевых этапов при разработке комплексных систем. Как правило, процесс моделирования используется для определения сущностей и отношений между ними. Это позволяет понять направление бизнес-деятельности и представить структуру системы. В этом разделе рассматривается процедура преобразования некоторых распространенных типов отношений, присутствующих в моделях предметной области, в схемы для Хранилища таблиц. Процесс сопоставления логической модели данных с физической моделью данных на базе NoSQL отличается от аналогичного процесса, используемого при разработке реляционной базы данных. Структура реляционных баз данных обычно предполагает процесс нормализации данных, оптимизированный с целью минимизировать избыточность. Такой подход также предполагает возможность декларативного запроса, который абстрагирует реализацию способа работы базы данных.  

### <a name="one-to-many-relationships"></a>Отношения «один-ко-многим»
Отношения "один-ко-многим" между бизнес-объектами являются распространенными. Например, в одном отделе работает много сотрудников. Существует несколько способов реализации отношений "один ко многим" в Хранилище таблиц, каждый со своими преимуществами и недостатками, которые могут иметь определенное значение в конкретном сценарии.  

Рассмотрим пример крупной многонациональной корпорации с десятками тысяч отделов и сущностей сотрудников. Каждый отдел включает много сотрудников, и каждый сотрудник связан с одним конкретным отделом. Первый подход заключается в хранении отдельных сущностей отделов и сотрудников, как показано ниже.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE01.png" alt-text="Рисунок: сущность отдела и сущность сотрудника":::

В этом примере демонстрируется явное отношение "один ко многим" между типами на основе значения `PartitionKey`. В каждом отделе может работать много сотрудников.  

В этом примере также показана сущность отдела и связанные сущности сотрудников в одном разделе. Для разных типов сущностей можно выбрать использование разных разделов, таблиц или даже учетных записей хранилища.  

В качестве альтернативного подхода выступает денормализация данных и хранение только сущностей сотрудников с денормализованными данными отдела, как показано в следующем примере. В данном случае денормализованный подход может оказаться не лучшим вариантом, если присутствуют требования к возможности изменения сведений о руководителе отдела, поскольку для этого придется обновлять каждого сотрудника отдела.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE02.png" alt-text="Изображение сущности Employee, показывающее, как денормализовать данные и хранить только сущности сотрудников с денормализованными данными о подразделении.":::

Дополнительные сведения см. в разделе [Шаблон денормализации](#denormalization-pattern).  

В следующей таблице приводятся преимущества и недостатки каждого из подходов для хранения сущностей сотрудников и отделов, связанных отношением "один ко многим". Следует также учитывать периодичность выполнения различных операций. Может оказаться приемлемым наличие схемы, которая включает ресурсоемкую операцию, если эта операция выполняется редко.  

<table>
<tr>
<th>Подход</th>
<th>Плюсы</th>
<th>Минусы</th>
</tr>
<tr>
<td>Отдельные типы сущностей, один раздел, одна таблица</td>
<td>
<ul>
<li>Сущность отдела можно обновить с помощью одной операции.</li>
<li>Если требуется изменять сущность отдела при каждом обновлении, вставке или удалении сущности сотрудника, в целях обеспечения согласованности можно использовать транзакции группы сущностей. Например, в случае поддержки осведомленности о количестве сотрудников в каждом отделе.</li>
</ul>
</td>
<td>
<ul>
<li>Для некоторых действий на стороне клиента может потребоваться получить сущность как сотрудника, так и отдела.</li>
<li>Операции хранения выполняются в одном разделе. При значительных объемах транзакций это может привести к формированию активной области.</li>
<li>Транзакции группы сущностей нельзя использовать для перемещения сотрудника в другой отдел.</li>
</ul>
</td>
</tr>
<tr>
<td>Отдельные типы сущностей, разные разделы или таблицы или учетные записи хранения</td>
<td>
<ul>
<li>Сущность отдела или сущность сотрудника можно обновить с помощью одной операции.</li>
<li>При значительных объемах транзакций это может помочь распределить нагрузку по нескольким разделам.</li>
</ul>
</td>
<td>
<ul>
<li>Для некоторых действий на стороне клиента может потребоваться получить сущность как сотрудника, так и отдела.</li>
<li>Транзакции группы сущностей нельзя использовать для обеспечения согласованности при обновлении, вставке или удалении сотрудника или обновлении отдела. Например, для обновления количества сотрудников в сущности отдела.</li>
<li>Транзакции группы сущностей нельзя использовать для перемещения сотрудника в другой отдел.</li>
</ul>
</td>
</tr>
<tr>
<td>Денормализация в один тип сущности</td>
<td>
<ul>
<li>Все необходимые данные можно извлечь с помощью одного запроса.</li>
</ul>
</td>
<td>
<ul>
<li>Если требуется обновить сведения об отделе (будет необходимо обновить всех сотрудников в отделе), обеспечение согласованности может оказаться ресурсоемким процессом.</li>
</ul>
</td>
</tr>
</table>

Выбор подходящего варианта и определение наиболее значимых преимуществ и недостатков зависит от конкретных сценариев в приложении. Например, как часто изменяются сущности отдела? Требуются ли для всех запросов сотрудников дополнительные сведения о отделе? Насколько вы близки к ограничениям масштабируемости в разделах или вашей учетной записи хранения?  

### <a name="one-to-one-relationships"></a>Отношения «один-к-одному»
В модель предметной области могут входить отношения между сущностями "один к одному". Чтобы реализовать отношение "один к одному" в Хранилище таблиц, необходимо выбрать способ привязки двух связанных сущностей, если потребуется извлечь их обе. Эта связь может быть либо неявной (на основе соглашения в значениях ключа), либо явной с сохранением связи в форме значений `PartitionKey` и `RowKey` в каждой сущности. Сведения о необходимости хранения связанных сущностей в одном разделе см. в разделе [Отношения "один-ко-многим"](#one-to-many-relationships).  

Есть также ряд аспектов, которые могут привести к реализации отношений "один к одному" в Хранилище таблиц.  

* Обработка сущностей большого размера (дополнительные сведения см. в статье [Шаблон для сущностей больших размеров](#large-entities-pattern)).  
* Внедрение средств управления доступом (см. раздел [Управление доступом с помощью подписей общего доступа](#control-access-with-shared-access-signatures)).  

### <a name="join-in-the-client"></a>Присоединение клиента
Несмотря на то, что в Хранилище таблиц существует возможность моделирования отношений, не следует забывать две основные причины использования Хранилища таблиц — масштабируемость и производительность. Если вы считаете, что моделируете много отношений, которые приводят к ухудшению производительности и масштабируемости решения, стоит подумать о необходимости ввода всех взаимосвязей между данными в структуру таблицы. Необходимые операции присоединения, выполненные клиентским приложением, позволят упростить структуру и улучшить масштабируемость и производительность решения.  

Например, данные, которые содержатся в небольших таблицах и меняются нечасто, можно извлекать по мере необходимости и кэшировать на стороне клиента. Это позволит избежать повторяющихся циклические операций по извлечению одних и тех же данных. В примерах, которые мы рассматривали в этом разделе, набор отделов небольшой организации, скорее всего, будет небольшим и редко подверженным изменениям. Это позволяет получить хороший кандидат для данных, которые клиентское приложение может скачать один раз и кэшировать как данные подстановки.  

### <a name="inheritance-relationships"></a>Отношения наследования
Если клиентское приложение использует набор классов, которые являются частью наследственной связи для представления бизнес-сущностей, эти сущности можно сохранить в Хранилище таблиц. Например, в клиентском приложении может быть определен следующий набор классов, где класс `Person` является абстрактным.

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE03.png" alt-text="Схема отношений наследования":::

Экземпляры двух конкретных классов в Хранилище таблиц можно сохранить с помощью одной таблицы `Person`. Используйте сущности, которые выглядят следующим образом:  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE04.png" alt-text="Рисунок: сущности клиента и сущности сотрудника":::

Дополнительные сведения о работе с несколькими типами сущностей в одной таблице в клиентском коде см. в разделе [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types) далее в этом руководстве. Там приводятся примеры определения типа сущности в клиентском коде.  

## <a name="table-design-patterns"></a>Шаблоны для разработки таблиц
В предыдущих разделах вы узнали, как оптимизировать структуру таблицы как для извлечения данных сущностей с помощью запросов, так и для выполнения операций по вставке, обновлению и удалению данных сущностей. В этом разделе приводится описание некоторых шаблонов, которые подходят для использования с Хранилищем таблиц. Кроме того, вы увидите практическое решение ряда проблем и сможете выбрать компромиссный вариант. На следующей схеме показаны связи между различными шаблонами.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE05.png" alt-text="Схема шаблонов для разработки таблицы":::

На схеме шаблонов представлены некоторые связи между шаблонами (синий цвет) и антишаблонами (оранжевый цвет), которые приведены в этом руководстве. Безусловно, существует множество других стоящих внимания шаблонов. Например, один из основных сценариев для Хранилища таблиц — использование [шаблона материализованного представления](/previous-versions/msp-n-p/dn589782(v=pandp.10)) из шаблона [Разделение ответственности команд и запросов](/previous-versions/msp-n-p/jj554200(v=pandp.10)).  

### <a name="intra-partition-secondary-index-pattern"></a>Шаблон вторичного индекса внутри раздела
Хранение нескольких копий каждой сущности с использованием разных значений `RowKey` (в одном и том же разделе). Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки с использованием разных значений `RowKey`. Транзакции группы сущностей обеспечивают согласованность обновлений копий.  

#### <a name="context-and-problem"></a>Контекст и проблема
Хранилище таблиц автоматически индексирует сущности с помощью значений `PartitionKey` и `RowKey`. Это позволяет клиентскому приложению эффективно извлекать сущности с использованием этих значений. Например, используя приведенную ниже структуру таблицы, клиентское приложение может выполнить точечный запрос для извлечения отдельной сущности сотрудника с указанием названия отдела и кода сотрудника (значения `PartitionKey` и `RowKey`). Клиент также может извлекать сущности, отсортированные по идентификатору сотрудника в каждом отделе.

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE06.png" alt-text="Рисунок сущности Employee, в которой клиентское приложение может использовать запрос к точке для получения отдельной сущности Employee, используя название отдела и идентификатор сотрудника (значения PartitionKey и RowKey).":::

Чтобы найти сущность сотрудника на основе другого свойства (например, адрес электронной почты), необходимо использовать менее эффективную функцию просмотра раздела. Это связано с тем, что Хранилище таблиц не поддерживает вторичные индексы. Кроме того, невозможно запросить список сотрудников, отсортированный в порядке, отличном от `RowKey`.  

#### <a name="solution"></a>Решение
Чтобы решить проблему отсутствия вторичных индексов, можно сохранить несколько копий каждой сущности с каждой копией, используя другое значение `RowKey`. При сохранении сущностей с приведенными ниже структурами можно эффективно извлекать сущности сотрудников на основе адреса электронной почты или кода сотрудника. Значения префиксов `RowKey`, `empid_` и `email_` позволяют выполнять запросы на одного сотрудника или ряд сотрудников с помощью диапазона адресов электронной почты или кодов сотрудников.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE07.png" alt-text="Рисунок: сущность сотрудника с различными значениями RowKey":::

Следующие два условия фильтрации (одно для поиска по коду сотрудника и второе для поиска по адресу электронной почты сотрудника) задают точечные запросы.  

* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')  
* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')  

Если требуется запросить диапазон сущностей сотрудников, можно указать диапазон, отсортированный по кодам сотрудников или по их адресам электронной почты, выполнив запрос на сущности с соответствующим префиксом в свойстве `RowKey`.  

* Чтобы найти всех сотрудников отдела продаж с кодом в диапазоне от 000100 до 000199, используйте следующее условие фильтрации: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199').  
* Чтобы найти всех сотрудников отдела продаж с адресом электронной почты, начинающимся с буквы "a", используйте следующее условие фильтрации: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b').  
  
Синтаксис фильтра, используемый в предыдущих примерах, взят из REST API Хранилища таблиц. Дополнительные сведения см. в статье [Запрос сущностей](/rest/api/storageservices/Query-Entities).  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Хранилище таблиц является относительно недорогим в использовании, поэтому накладные расходы на хранение повторяющихся данных не являются предметом первостепенной важности. Однако затраты на разработку всегда следует оценивать с учетом требований к планируемому хранилищу и добавлять повторяющиеся сущности только в целях поддержки запросов, которые будет выполнять клиентское приложение.  
* Поскольку сущности вторичного индекса хранятся в одном разделе с исходными сущностями, следует убедиться в том, что целевые показатели масштабируемости для отдельного раздела не превышены.  
* Чтобы обеспечить согласованность повторяющихся сущностей, можно воспользоваться транзакциями группы сущностей (EGT) для автоматического обновления двух копий сущности. Это означает, что все копии сущности необходимо хранить в одном разделе. Дополнительные сведения см. в разделе [Транзакции группы сущностей](#entity-group-transactions).  
* Значение свойства `RowKey` должно быть уникальным для каждой сущности. Рекомендуется использовать значения составного ключа.  
* Заполнение числовых значений в свойстве `RowKey` (например, для кода сотрудника 000223) позволяет правильно выполнять операции сортировки и фильтрации на основе верхних и нижних границ.  
* Дублировать все свойства сущности не требуется. Например, если для запросов, которые ищут сущности по адресу электронной почты в `RowKey`, не требуется возраст сотрудника, то эти сущности могут иметь следующую структуру.

  :::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE08.png" alt-text="Рисунок: сущность сотрудника":::

* Рекомендуется сохранить повторяющиеся данные и убедиться в том, что все необходимые данные можно получить с помощью одного запроса, а не использовать один запрос для поиска сущности, а другой — для поиска необходимых данных.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон в следующих случаях:

- Клиентское приложение должно получать сущности с помощью различных ключей.
- Клиенту необходимо получить сущности в различных порядках сортировки.
- Каждую сущность можно найти с помощью различных уникальных значений.

При выполнении поисков сущностей с использованием различных значений `RowKey` следует убедиться, что целевые показатели масштабируемости раздела не превышены.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон вторичного индекса в разных разделах;](#inter-partition-secondary-index-pattern)
* [Шаблон составного ключа;](#compound-key-pattern)
* [Транзакции группы сущностей](#entity-group-transactions)
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a>Шаблон вторичного индекса в разных разделах
Хранение нескольких копий каждой сущности с использованием разных значений `RowKey` в разных разделах или в разных таблицах. Это обеспечивает быстрый и эффективный поиск, а также альтернативные порядки сортировки с использованием разных значений `RowKey`.  

#### <a name="context-and-problem"></a>Контекст и проблема
Хранилище таблиц автоматически индексирует сущности с помощью значений `PartitionKey` и `RowKey`. Это позволяет клиентскому приложению эффективно извлекать сущности с использованием этих значений. Например, используя приведенную ниже структуру таблицы, клиентское приложение может выполнить точечный запрос для извлечения отдельной сущности сотрудника с указанием названия отдела и кода сотрудника (значения `PartitionKey` и `RowKey`). Клиент также может извлекать сущности, отсортированные по идентификатору сотрудника в каждом отделе.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE09.png" alt-text="График структуры сущностей сотрудников, которая, при использовании, клиентское приложение может использовать запрос к точке для получения отдельной сущности Employee, используя название отдела и идентификатор сотрудника (значения PartitionKey и RowKey)."::: 8

Чтобы найти сущность сотрудника на основе другого свойства (например, адрес электронной почты), необходимо использовать менее эффективную функцию просмотра раздела. Это связано с тем, что Хранилище таблиц не поддерживает вторичные индексы. Кроме того, невозможно запросить список сотрудников, отсортированный в порядке, отличном от `RowKey`.  

Вы планируете выполнять множество операций с этими сущностями и хотите свести к минимуму риск ограничения клиента со стороны Хранилища таблиц.  

#### <a name="solution"></a>Решение
Чтобы решить проблему отсутствия вторичных индексов, можно сохранить несколько копий каждой сущности с каждой копией, используя другие значения `PartitionKey` и `RowKey`. При сохранении сущностей с приведенными ниже структурами можно эффективно извлекать сущности сотрудников на основе адреса электронной почты или кода сотрудника. Значения префиксов `PartitionKey`, `empid_` и `email_` позволяют определить нужный индекс, который будет использоваться для запроса.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE10.png" alt-text="Рисунок: сущность сотрудника с первичным индексом и сущность сотрудника со вторичным индексом":::

Следующие два условия фильтрации (одно для поиска по коду сотрудника и второе для поиска по адресу электронной почты сотрудника) задают точечные запросы.  

* $filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')
* $filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')  

Если требуется запросить диапазон сущностей сотрудников, можно указать диапазон, отсортированный по кодам сотрудников или по их адресам электронной почты, выполнив запрос на сущности с соответствующим префиксом в свойстве `RowKey`.  

* Чтобы найти всех сотрудников отдела продаж с кодом сотрудника в диапазоне от **000100** до **000199**, отсортированных по коду сотрудника, используйте следующее условие: $filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199').  
* Чтобы найти всех сотрудников отдела продаж с адресом электронной почты, который начинается с "a", и сортировкой по коду сотрудника, используйте следующее условие: $filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b').  

Обратите внимание, что синтаксис фильтра, используемый в предыдущих примерах, взят из REST API Хранилища таблиц. Дополнительные сведения см. в статье [Запрос сущностей](/rest/api/storageservices/Query-Entities).  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Чтобы обеспечить согласованность копий сущностей, можно использовать [шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern) для сущностей основного и вторичного индексов.  
* Хранилище таблиц является относительно недорогим в использовании, поэтому накладные расходы на хранение повторяющихся данных не являются предметом первостепенной важности. Однако затраты на разработку всегда следует оценивать с учетом требований к планируемому хранилищу и добавлять повторяющиеся сущности только в целях поддержки запросов, которые будет выполнять клиентское приложение.  
* Значение свойства `RowKey` должно быть уникальным для каждой сущности. Рекомендуется использовать значения составного ключа.  
* Заполнение числовых значений в свойстве `RowKey` (например, для кода сотрудника 000223) позволяет правильно выполнять операции сортировки и фильтрации на основе верхних и нижних границ.  
* Дублировать все свойства сущности не требуется. Например, если для запросов, которые ищут сущности по адресу электронной почты в `RowKey`, не требуется возраст сотрудника, то эти сущности могут иметь следующую структуру.
  
  :::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE11.png" alt-text="Рисунок: сущность сотрудника со вторичным индексом":::

* Повторяющиеся данные рекомендуется сохранить и убедиться, что все необходимые данные можно извлечь с помощью одного запроса, вместо того, чтобы выполнять один запрос для поиска сущности с помощью вторичного индекса, а другой — для поиска необходимых данных в первичном индексе.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон в следующих случаях:

- Клиентское приложение должно получать сущности с помощью различных ключей.
- Клиенту необходимо получить сущности в различных порядках сортировки.
- Каждую сущность можно найти с помощью различных уникальных значений.

Используйте этот шаблон, если при поиске сущностей с помощью различных значений `RowKey` нужно избежать превышения показателей ограничения масштабирования раздела.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  
* [Шаблон вторичного индекса внутри раздела;](#intra-partition-secondary-index-pattern)  
* [Шаблон составного ключа;](#compound-key-pattern)  
* [Транзакции группы сущностей](#entity-group-transactions)  
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a>Шаблон для согласованных транзакций
Обеспечьте согласованное поведение в рамках границ раздела или границ системы хранения с помощью запросов Azure.  

#### <a name="context-and-problem"></a>Контекст и проблема
Транзакции группы сущностей приводят к выполнению атомарных транзакций в нескольких сущностях, использующих один общий ключ раздела. Из соображений производительности и масштабируемости может потребоваться сохранить сущности согласно требованиям к согласованности в отдельных разделах или отдельной системе хранения. В этом случае использовать транзакции группы сущностей для обеспечения согласованности нельзя. Например, может существовать требование к обеспечению согласованности между следующими элементами.  

* Сущности, хранящиеся в двух разных секциях одной таблицы, в разных таблицах или в разных учетных записях хранения.  
* Сущность, хранящаяся в Хранилище таблиц, и большой двоичный объект, хранящийся в хранилище BLOB-объектов.  
* Сущность, хранящаяся в Хранилище таблиц, и файл в файловой системе.  
* Сущность, хранящаяся в Хранилище таблиц, но индексируемая с помощью Когнитивного поиска Azure.  

#### <a name="solution"></a>Решение
Используя очереди Azure, можно реализовать решение, обеспечивающее согласованность между двумя и более разделами или системами хранения.

Чтобы продемонстрировать этот подход, предположим, что существует требование к архивации сущностей бывших сотрудников. К сущностям бывших сотрудников редко выполняются запросы, поэтому они должны быть исключены из любых действий, связанных с текущими сотрудниками. Чтобы реализовать это требование, действующие сотрудники сохраняются в таблице **Current**, а бывшие сотрудники — в таблице **Archive**. Для архивации сотрудника необходимо удалить сущность из таблицы **Current** и добавить сущность в таблицу **Archive**.

Но для выполнения этих двух операций нельзя использовать транзакции группы сущностей. Чтобы избежать риска отображения сущности в обеих таблицах или ни в одной из них в случае сбоя, операция архивации должна быть согласованной. Этапы этой операции приведены на следующей схеме.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE12.png" alt-text="Схема решения для итоговой согласованности":::

Клиент инициирует операцию архивации, помещая сообщение в очередь Azure (в этом примере выполняется архивация сотрудника № 456). Рабочая роль опрашивает очередь на наличие новых сообщений. При обнаружении такого сообщения она читает сообщение и оставляет в очереди скрытую копию. Затем рабочая роль извлекает копию сущности из таблицы **Current**, вставляет копию в таблицу **Archive** и после этого удаляет исходную сущность из таблицы **Current**. Если предыдущие действия выполнены без ошибок, рабочая роль удаляет скрытое сообщения из очереди.  

В этом примере на шаге 4 на схеме происходит вставка сотрудника в таблицу **Archive**. Сотрудника можно добавить в большой двоичный объект в хранилище BLOB-объектов или в файл в файловой системе.  

#### <a name="recover-from-failures"></a>Восстановление после сбоев
Важно отметить, что, если рабочей роли требуется перезапустить операцию архивации, операции на шагах 4–5 должны быть *идемпотентными*. Если используется Хранилище таблиц, на шаге 4 необходимо выполнить операцию "Вставить или заменить". На шаге 5 в клиентской библиотеке необходимо выполнить операцию "Удалить, если существует". Если используется другая система хранения данных, необходимо выполнить соответствующую идемпотентную операцию.  

Если рабочая роль никогда не выполняет действие на шаге 6 на схеме, по истечении времени ожидания сообщение повторно появится в очереди, чтобы рабочая роль могла обработать его еще раз. Рабочая роль может проверить, сколько раз было прочтено сообщение в очереди, и при необходимости пометит его как "подозрительное" и требующее изучения, отправив в отдельную очередь. Дополнительные сведения о чтении сообщений в очередях и проверке количества сообщений, выведенных из очереди, см. в статье [Получение сообщений](/rest/api/storageservices/Get-Messages).  

Некоторые ошибки в Хранилище таблиц и Хранилище очередей являются временными, поэтому клиентское приложение должно содержать логику повтора, подходящую для их обработки.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Это решение не поддерживает изоляцию транзакций. Например, клиент мог считывать таблицы **Current** и **Archive**, когда рабочая роль находилась между шагами 4–5 на схеме, и заметить несогласованное представление данных. В конечном счете данные будут согласованы.  
* Необходимо убедиться, что для обеспечения окончательной согласованности шаги 4–5 являются идемпотентными.  
* Для масштабирования решения можно использовать несколько очередей и экземпляров рабочих ролей.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, чтобы обеспечить согласованность между сущностями, которые существуют в различных разделах или таблицах. Этот шаблон можно расширить и обеспечить согласованность операций в Хранилище таблиц и хранилище BLOB-объектов, а также в других источниках данных, не входящих в службу хранилища Azure, таких как база данных или файловая система.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Транзакции группы сущностей](#entity-group-transactions)  
* [Объединение или замена.](#merge-or-replace)  

> [!NOTE]
> Если изоляция транзакции имеет важное значение для решения, измените таблицы для использования транзакций группы сущностей.  
> 
> 

### <a name="index-entities-pattern"></a>Шаблон сущностей индекса
Поддерживайте сущности индексов для выполнения эффективных операций поиска, возвращающих списки сущностей.  

#### <a name="context-and-problem"></a>Контекст и проблема
Хранилище таблиц автоматически индексирует сущности с помощью значений `PartitionKey` и `RowKey`. Это позволяет клиентскому приложению эффективно извлекать сущность с помощью точечного запроса. Например, используя приведенную ниже структуру таблицы, клиентское приложение может эффективно извлечь отдельную сущность сотрудника с указанием названия отдела и кода сотрудника (значения `PartitionKey` и `RowKey`).  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE13.png" alt-text="График структуры сущностей сотрудников, в которой клиентское приложение может эффективно извлекать отдельные сущности сотрудников с помощью имени отдела и идентификатора сотрудника (PartitionKey и RowKey).":::

Если наряду с этим необходимо извлекать список сущностей сотрудников на основе значения другого неуникального свойства, например фамилий, для поиска совпадений следует использовать менее эффективную функцию просмотра раздела, а не индекс для прямого поиска. Это связано с тем, что Хранилище таблиц не поддерживает вторичные индексы.  

#### <a name="solution"></a>Решение
Чтобы включить поиск по фамилии с помощью структуры сущности, приведенной выше, необходимо создать и поддерживать списки кодов сотрудников. Чтобы извлечь сущности сотрудников с определенной фамилией, например Jones, сначала найдите список кодов для сотрудников с фамилией Jones, а затем извлеките сущности этих сотрудников. Существует три основных варианта хранения списков кодов сотрудников.  

* Использование хранилища BLOB-объектов.  
* Создание сущностей индексов в одном разделе с сущностями сотрудников.  
* Создание сущностей индексов в отдельном разделе или таблице.  

Вариант 1. Использование хранилища BLOB-объектов  

В этом случае вы создаете большой двоичный объект для каждой уникальной фамилии, а затем в каждом таком объекте сохраняете список значений `PartitionKey` (отдел) и `RowKey` (код сотрудника) для сотрудников с этой фамилией. При добавлении или удалении сотрудника следует убедиться, что содержимое соответствующего большого двоичного объекта согласовано с сущностями сотрудников.  

Вариант 2. Создание сущностей индексов в одном разделе с сущностями сотрудников  

Используйте сущности индексов, хранящие следующие данные.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE14.png" alt-text="Рисунок: сущность сотрудника со строкой, содержащей список идентификаторов сотрудников с одинаковыми фамилиями":::

Свойство `EmployeeIDs` содержит список кодов сотрудников, фамилии которых хранятся в свойстве `RowKey`.  

Ниже описан процесс, которого следует придерживаться при добавлении нового сотрудника. В этом примере мы добавляем сотрудника с кодом 000152 и фамилией Jones в отдел продаж.  

1. Извлеките сущность индекса с помощью значения `PartitionKey` "Sales" и значения `RowKey` "Jones". Сохраните ETag это сущности для использования на шаге 2.  
2. Создайте транзакцию группы сущностей (то есть пакетную операцию), которая вставляет новую сущность сотрудника (значение `PartitionKey` "Sales" и значение `RowKey` "000152") и обновляет сущность индекса (значение `PartitionKey` "Sales" и значение `RowKey` "Jones"). Транзакция группы сущностей делает это путем добавления нового кода сотрудника в список в поле EmployeeIDs. Дополнительные сведения см. в разделе [Транзакции группы сущностей](#entity-group-transactions).  
3. Если транзакция группы сущностей не может быть выполнена из-за ошибки оптимистичного параллелизма (другой пользователь изменил сущность индекса), необходимо вернуться к шагу 1.  

Если используется второй вариант, можно использовать аналогичный подход для удаления сотрудника. Изменить фамилию сотрудника немного сложнее, поскольку потребуется выполнить транзакцию группы сущностей для обновления трех сущностей: сущности сотрудника, сущности индекса для прежней фамилии и сущности индекса для новой фамилии. Перед внесением любых изменений необходимо извлекать каждую сущность для последующего получения значений ETag, которые затем можно использовать для выполнения обновлений с помощью оптимистичного параллелизма.  

Далее приводится процедура поиска всех сотрудников отдела с нужной фамилией. В этом примере осуществляется поиск всех сотрудников с фамилией Jones в отделе продаж.  

1. Извлеките сущность индекса с помощью значения `PartitionKey` "Sales" и значения `RowKey` "Jones".  
2. Выполните анализ списка кодов сотрудников в поле `EmployeeIDs`.  
3. Чтобы получить дополнительные сведения о каждом из этих сотрудников (например, адрес электронной почты), извлеките каждую сущность сотрудника с помощью значения `PartitionKey` "Sales" и значений `RowKey` из списка сотрудников, полученного на шаге 2.  

Способ 3. Создание сущностей индексов в отдельном разделе или таблице.  

Для этого варианта используйте сущности индексов, хранящих следующие данные.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE15.png" alt-text="Снимок экрана, на котором показана сущность индекса сотрудника, содержащая список идентификаторов сотрудников для сотрудников с последним именем, хранящимся в RowKey и PartitionKey.":::

`EmployeeDetails`Свойство содержит список идентификаторов сотрудников и пар названий отделов для сотрудников с фамилией, хранящимся в `RowKey` .

Использовать транзакции группы сущностей для обеспечения согласованности нельзя, поскольку сущности индексов находятся в разделе, отличном от раздела с сущностями сотрудников. Убедитесь, что сущности индексов согласованы с сущностями сотрудников.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* В этом решении требуется как минимум два запроса для извлечения совпадающих сущностей: один для запроса сущностей индексов с целью получения списка значений `RowKey`, а другой — для извлечения каждой сущности в списке.  
* Ввиду того что размер отдельной сущности не превышает 1 МБ, в вариантах 2 и 3 решения предполагается, что размер списка кодов сотрудников с любой заданной фамилией никогда не будет больше 1 МБ. Если размер списка кодов сотрудников, вероятнее всего, превышает 1 МБ, следует использовать вариант 1 и сохранить данные индекса в хранилище BLOB-объектов.  
* Если выбран вариант 2 (с использованием транзакций группы сущностей для обработки операций добавления и удаления сотрудников и изменения фамилии сотрудника), то необходимо оценить отношение объема транзакций к ограничениям масштабируемости в определенном разделе. В этом случае следует рассмотреть согласованное решение (вариант 1 или вариант 3). В них используются очереди для обработки запросов на обновление, а также они позволяют хранить сущности индекса в другом разделе, отдельно от сущностей.  
* Вариант 2 в этом решении предполагает, что вы хотите выполнить поиск по фамилии в отделе. Например, вы хотите получить список сотрудников с фамилией Jones в отделе продаж. Чтобы получить возможность поиска всех сотрудников с фамилией Jones в масштабах организации, выберите вариант 1 или 3.
* Можно реализовать решение на основе очереди, которое обеспечивает итоговую согласованность. Дополнительные сведения см. в разделе [Шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern).  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон для поиска набора сущностей с общим значением свойства, например всех сотрудников с фамилией Jones.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  
* [Транзакции группы сущностей](#entity-group-transactions)  
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a>Шаблон денормализации
Объедините связанные данных в одной сущности для извлечения необходимых данных с помощью одного запроса точки.  

#### <a name="context-and-problem"></a>Контекст и проблема
В реляционной базе данных нормализация данных обычно выполняется для удаления дубликатов, возникающих при извлечении запросами данных из нескольких таблиц. Если нормализация данных осуществляется в таблицах Azure, для извлечения связанных данных требуется сделать несколько переходов от клиента к серверу и обратно. Например, при использовании следующей структуры таблицы требуется два перехода для получения сведений об отделе. Один переход служит для извлечения сущности отдела, включающей код руководителя, а второй переход служит для извлечения сведений о руководителе в сущности сотрудника.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE16.png" alt-text="Рисунок: сущность отдела и сущность сотрудника":::

#### <a name="solution"></a>Решение
Вместо хранения данных в двух отдельных сущностях денормализуйте данные и сохраните копию со сведениями о руководителе в сущности отдела. Пример:  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE17.png" alt-text="Рисунок: денормализованная и объединенная сущность отдела":::

Теперь, когда сущности отделов хранятся с этими свойствами, все сведения об отделе можно получать с помощью точечного запроса.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Двойное хранение некоторых данных связано с определенными издержками. Повышение производительности, возникающее в результате меньшего количества запросов к Хранилищу таблиц, обычно приводит к увеличению затрат на хранение. Кроме того, такие затраты частично нивелируются сокращением числа транзакций, которые требуются для получения сведений о подразделении.  
* Необходимо поддерживать согласованность двух сущностей, в которых хранятся сведения о руководителях. Для решения проблемы согласованности можно использовать транзакции группы сущностей для обновления нескольких сущностей в одной атомарной транзакции. В этом случае сущность отдела и сущность сотрудника для руководителя отдела хранятся в одном разделе.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимость поиска связанных данных возникает довольно часто. Этот шаблон уменьшает количество запросов, которые необходимо выполнить клиенту для извлечения требуемых данных.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Транзакции группы сущностей](#entity-group-transactions)  
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a>Шаблон составного ключа
Используйте составные значения `RowKey`, чтобы клиент мог выполнять поиск связанных данных с помощью одного точечного запроса.  

#### <a name="context-and-problem"></a>Контекст и проблема
В реляционной базе данных считается естественным использовать присоединения в запросах с целью возврата связанных частей данных в клиент в одном запросе. Например, с помощью идентификатора сотрудника можно выполнить поиск списка связанных сущностей, которые содержат данные о производительности этого сотрудника.  

Предположим, что сущности сотрудников хранятся в Хранилище таблиц с использованием следующей структуры.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE18.png" alt-text="Рисунок структуры сущностей сотрудников, который следует использовать для хранения сущностей Employee в хранилище таблиц.":::

Необходимо также сохранить исторические данные, связанные с производительностью и оценкой продуктивности по каждому году, отработанному сотрудников в организации. Кроме того, эти данные должны быть доступны по каждому году. Одним из вариантов является создание другой таблицы, в которой хранятся сущности со следующей структурой.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE19.png" alt-text="Рисунок: сущность оценки сотрудника":::

В этом случае вы можете дублировать некоторые сведения (например, имя и фамилию) в новую сущность, чтобы затем извлекать данные с помощью одного запроса. Однако вы не можете поддерживать высокий уровень согласованности, поскольку использование транзакций группы сущностей для обновления двух сущностей не допускается.  

#### <a name="solution"></a>Решение
Сохраните новый тип сущности в исходную таблицу с помощью сущностей со следующей структурой.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE20.png" alt-text="Рисунок: сущность сотрудника с составным ключом":::

Обратите внимание, что `RowKey` теперь является составным ключом, состоящим из кода сотрудника и года его оценки. Это позволяет получить данные о производительности и оценке сотрудника с помощью одного запроса для одной сущности.  

В следующем примере показан процесс извлечения всех отчетных данных по конкретному сотруднику (например, сотрудник 000123 из отдела продаж).  

$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Необходимо использовать соответствующий символ-разделитель, упрощающий анализ значения `RowKey`. Например, **000123_2012**.  
* Эта сущность сохраняется в одном разделе с другими сущностями, которые содержат связанные данные по тому же сотруднику. Это значит, что поддержка высокого уровня согласованности осуществляется с помощью транзакций группы сущностей.
* Чтобы определить допустимость использования этого шаблона, рекомендуется принять во внимание частоту выполнения запросов к данным. Если вы будете обращаться к отчетным данным редко, а к основным данным сотрудника часто, их следует сохранить как отдельные сущности.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимо сохранить одну или несколько связанных часто запрашиваемых сущностей.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Транзакции группы сущностей](#entity-group-transactions)  
* [Работа с разными типами сущностей](#work-with-heterogeneous-entity-types)  
* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a>Шаблон для заключительного фрагмента журнала
Извлечение *n* сущностей, недавно добавленных в раздел, с помощью значения `RowKey`, выполняющего сортировку по дате и времени в обратном порядке.  

> [!NOTE]
> Результаты запросов, возвращаемые API таблиц Azure в Azure Cosmos DB, не сортируются по ключу раздела или ключу строки. Поэтому этот шаблон подходит для Хранилища таблиц, но не подходит для Azure Cosmos DB. Дополнительные сведения см. в ответе на вопрос [Чем API таблиц отличается от Хранилища таблиц Azure?](table-api-faq.md#table-api-vs-table-storage).

#### <a name="context-and-problem"></a>Контекст и проблема
Общее требование заключается в необходимости иметь возможность извлекать последние созданные сущности. Например, десять последних заявок на возмещение сотрудникам. Табличные запросы поддерживают операцию запроса `$top` для возврата первых *n* сущностей из набора. Эквивалентной операции запроса для возврата последних *n* сущностей в наборе не существует.  

#### <a name="solution"></a>Решение
Сохраните сущности с помощью свойства `RowKey`, которое естественным образом сортирует даты и время в обратном порядке. В этом случае самая последняя запись всегда будет отображаться первой.  

Например, чтобы извлечь десять самых последних заявок на возмещение расходов, отправленных сотрудниками, можно использовать обратное значение тика, являющееся производным от текущей даты и времени. В следующем примере кода C# показан один из способов создания подходящего значения "обратных тиков" для свойства `RowKey`, которое выполняет сортировку с самого последнего значения и до самого первого.  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

Чтобы вернуться к исходному значению даты и времени, воспользуйтесь следующим кодом.  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

Табличный запрос выглядит следующим образом.  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Чтобы обеспечить надлежащую сортировку, необходимо заполнить начало значения обратного тика нулями.  
* Необходимо соблюдать целевые показатели масштабирования на уровне раздела. Не создавайте разделы с высокой нагрузкой!  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Этот шаблон используется в случаях, если необходимо получить доступ к сущностям в обратном порядке даты и времени или если требуется доступ к последним добавленным сущностям.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Анти-шаблон, предусматривающий добавление в начало или конец;](#prepend-append-anti-pattern)  
* [Извлечение сущностей](#retrieve-entities)  

### <a name="high-volume-delete-pattern"></a>Шаблон для удаления больших объемов сущностей
Включение операции удаления больших объемов сущностей за счет сохранения всех сущностей для одновременного удаления в отдельной таблице. Удаление сущностей происходит при удалении таблицы.  

#### <a name="context-and-problem"></a>Контекст и проблема
Многие приложения удаляют старые данные, которые больше не требуются для клиентского приложения. Кроме того, данные могут удаляться при архивации приложения на другой носитель. Такие данные обычно можно определить по дате. Например, существует требование для удаления записей всех запросов на вход, которые были созданы более 60 дней назад.  

Один из возможных вариантов заключается в использовании даты и времени запроса на вход в свойстве `RowKey`.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE21.png" alt-text="Рисунок: сущности попытки входа":::

Такой подход позволяет избежать формирования активных областей в разделах, так как приложение сможет вставлять и удалять сущности входа для каждого пользователя в отдельном разделе. Однако при наличии большого количества сущностей такой подход может быть дорогостоящим и длительным. Во-первых, необходимо выполнить сканирование таблицы, чтобы найти все удаляемые сущности, а затем удалить каждую старую сущность. Количество переходов к серверу, необходимых для удаления старых сущностей, можно сократить путем пакетной вставки нескольких запросов на удаление в EGT.  

#### <a name="solution"></a>Решение
Используйте отдельную таблицу для каждого дня, когда предпринимаются попытки входа в систему. Можно воспользоваться приведенной выше структурой сущности, чтобы избежать формирования активных областей во время вставки сущностей. Процедура удаления старых сущностей теперь заключается в ежедневном удалении одной таблицы (выполнение одной операции хранения), поскольку находить и удалять сотни и тысячи отдельных сущностей входа больше не требуется.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Ваша схема поддерживает другие способы использования данных приложением, например поиск конкретных сущностей, установка связи с другими данными или создание сводных данных?  
* Ваш проект предотвращает формирование активных областей в случае вставки новых сущностей?  
* Повторное использование того же имени таблицы после его удаления связано с определенной задержкой. Рекомендуется всегда использовать уникальные имена таблиц.  
* Первое использование новой таблицы предполагает ограничение ресурсов, поскольку Хранилище таблиц изучает шаблоны доступа и распределяет разделы по узлам. Рекомендуется определить периодичность создания новых таблиц.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон при наличии большого количества сущностей для одновременного удаления.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Транзакции группы сущностей](#entity-group-transactions)
* [Изменение сущностей](#modify-entities)  

### <a name="data-series-pattern"></a>Шаблон для рядов данных
Чтобы сократить количество выполняемых запросов, храните ряды данных в одной сущности.  

#### <a name="context-and-problem"></a>Контекст и проблема
Возьмем распространенный сценарий, когда приложение сохраняет ряды данных, которые требуется извлечь все сразу. Например, приложение может записывать количество сообщений, ежечасно отправляемых каждым сотрудником, а затем использовать эти сведения для отображения количества сообщений, отправленных каждым пользователем за предыдущие 24 часа. Для хранения 24 сущностей для каждого сотрудника можно разработать одну структуру.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE22.png" alt-text="Рисунок: сущность статистики сообщений":::

В ней можно без труда находить и обновлять сущности для каждого сотрудника каждый раз, когда приложению требуется обновить значение количества сообщений. Однако чтобы извлечь данные для построения графика активности за предыдущие 24 часа, потребуется извлечь 24 сущности.  

#### <a name="solution"></a>Решение
Используйте следующую структуру с отдельным свойством для хранения количества сообщений за каждый час.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE23.png" alt-text="Рисунок: сущность статистики сообщений с разделенными свойствами":::

В этом случае вы сможете обновлять количество сообщений по сотруднику за определенный час с помощью операции объединения. Теперь с помощью запроса к одной сущности можно извлечь все сведения, необходимые для построения графика.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Если ряды данных не могут полностью поместиться в одну сущность (сущности могут содержать до 252 свойств), используйте альтернативное хранилище данных, например BLOB-объект.  
* Если сущность обновляется несколькими клиентами одновременно, используйте **ETag** для реализации оптимистичного параллелизма. Большое количество клиентов может привести к высокому уровню конкуренции.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимо обновить и получить ряды данных, связанных с отдельной сущностью.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон для сущностей больших размеров](#large-entities-pattern)  
* [Объединение или замена.](#merge-or-replace)  
* [Шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern) (при сохранении рядов данных в BLOB-объект)  

### <a name="wide-entities-pattern"></a>Шаблон для масштабных сущностей
Чтобы сохранить сущности, имеющие более 252 свойств, используйте несколько физических сущностей.  

#### <a name="context-and-problem"></a>Контекст и проблема
Отдельные сущности могут иметь не более 252 свойств (за исключением обязательных свойств системы), а общий объем хранимых данных не должен превышать 1 МБ. В реляционной базе вопрос с ограничениями по размеру строки обычно решается путем добавления новой таблицы и установки отношения "один к одному".  

#### <a name="solution"></a>Решение
С помощью Хранилища таблиц можно сохранить несколько сущностей, которые будут представлять один крупный бизнес-объект с более чем 252 свойствами. Например, чтобы сохранить количество мгновенных сообщений, отправленных каждым сотрудником за последние 365 дней, можно использовать следующую структуру с двумя сущностями, имеющими разные схемы.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE24.png" alt-text="Рисунок: сущность статистики сообщений с Rowkey 01 и сущность состояния сообщений с Rowkey 02":::

Если необходимо внести изменение, требующее обновления обеих сущностей для обеспечения их синхронизации, воспользуйтесь транзакциями группы сущностей. В противном случае можно выполнить одну операцию объединения, которая позволит обновить количество сообщений за определенный день. Чтобы получить все данные для отдельного сотрудника, необходимо извлечь обе сущности. Это можно сделать с помощью двух эффективных запросов, которые используют как значение `PartitionKey`, так и значение `RowKey`.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующий момент.  

* Извлечение логической сущности целиком связано с выполнением как минимум двух операций с хранилищем: одна для извлечения каждой физической сущности.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если требуется сохранить сущности, размер или количество свойств которых превышает ограничения для отдельной сущности в Хранилище таблиц.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Транзакции группы сущностей](#entity-group-transactions)
* [Объединение или замена.](#merge-or-replace)

### <a name="large-entities-pattern"></a>Шаблон для сущностей больших размеров
Для хранения больших по объему значений свойств используйте хранилище больших двоичных объектов.  

#### <a name="context-and-problem"></a>Контекст и проблема
В отдельной сущности нельзя сохранить данные, общий объем которых превышает 1 МБ. Если в одном или нескольких свойствах хранятся значения, из-за которых общий размер сущности превышает указанное значение, эту сущность нельзя сохранить в Хранилище таблиц.  

#### <a name="solution"></a>Решение
Если размер сущности превышает 1 МБ из-за того, что одно или несколько свойств содержат большой объем данных, эти данные можно сохранить в хранилище BLOB-объектов, а затем сохранить адрес большого двоичного объекта в свойстве в сущности. Например, фотографию сотрудника можно сохранить в хранилище больших двоичных объектов, а ссылку на фотографию — в свойстве `Photo` сущности сотрудника.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE25.png" alt-text="Рисунок: сущность сотрудника со строкой для фотографии, указывающей на хранилище BLOB-объектов":::

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Чтобы обеспечить согласованность между сущностью в Хранилище таблиц и данными в хранилище BLOB-объектов, используйте [шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern).
* Для извлечения полной сущности требуется как минимум две транзакции хранилища: одна для извлечения сущности и одна для извлечения данных большого двоичного объекта.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимо сохранить сущности, размер которых превышает ограничения для отдельной сущности в Хранилище таблиц.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  
* [Шаблон для масштабных сущностей.](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a>Анти-шаблон, предусматривающий добавление в начало или конец
При наличии большого количества операций вставки повысьте уровень масштабируемости путем распределения вставляемых компонентов по нескольким разделам.  

#### <a name="context-and-problem"></a>Контекст и проблема
Как правило, добавление сущностей в начало или конец хранящихся сущностей приводит к тому, что приложение будет добавлять новые сущности к первому или последнему разделу в последовательности разделов. В этом случае все операции вставки в определенный момент времени выполняются в одном разделе, создавая активную область. Это не позволяет Хранилищу таблиц сбалансировать операции вставки в несколько узлов и может привести к тому, что приложение достигнет целевых показателей масштабируемости для раздела. Например, рассмотрим случай приложения, которое регистрирует доступ сотрудников к сети и ресурсам. Структура сущности, подобная приведенной ниже, может привести к тому, что раздел текущего часа станет активной областью, если объем транзакций достигает целевого показателя масштабируемости для отдельного раздела:  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE26.png" alt-text="Рисунок структуры сущности, которая может привести к тому, что Секция текущего часа станет активной областью, если объем транзакций достигает целевой цели масштабируемости для отдельной секции.":::

#### <a name="solution"></a>Решение
Следующая альтернативная структура сущности предотвращает формирование активной области в любом разделе во время регистрации событий приложением.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE27.png" alt-text="Рисунок: сущность сотрудника со свойством RowKey, объединяющим год, месяц, день, время и идентификатор события":::

Обратите внимание, что в этом примере `PartitionKey` и `RowKey` являются составными ключами. Свойство `PartitionKey` использует идентификаторы отдела и сотрудника для распределения операции ведения журнала по нескольким разделам.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Альтернативная структура ключа, которая предотвращает создание разделов с высокой нагрузкой во время выполнения операций вставки, поддерживает запросы, выполняемые клиентским приложением?  
* Ожидаемый объем транзакций означает вероятность достижения целевых показателей масштабируемости для отдельного раздела и возможность регулирования Хранилищем таблиц?  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Если объем транзакций может привести к ограничению при доступе к разделу с высокой нагрузкой, не используйте антишаблон, предусматривающий добавление в начало или конец.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Шаблон для заключительного фрагмента журнала;](#log-tail-pattern)  
* [Изменение сущностей](#modify-entities)  

### <a name="log-data-anti-pattern"></a>Анти-шаблон для данных журнала
Как правило, данные журнала следует хранить не в Хранилище таблиц, а в хранилище BLOB-объектов.  

#### <a name="context-and-problem"></a>Контекст и проблема
Распространенным вариантом использования данных журнала является получение выбранных записей журнала для определенного диапазона дат и времени. Например, необходимо найти все ошибки и критические сообщения, которые приложение зарегистрировало в период между 15:04 и 15:06 в определенную дату. Вы не хотите использовать дату и время сообщения журнала, чтобы определить раздел, в котором сохраняются сущности журнала. Это приводит к тому, что в любой момент времени все сущности журнала будут совместно использовать одно и то же значение `PartitionKey` (см. [Антишаблон, предусматривающий добавление в начало или конец](#prepend-append-anti-pattern)). Например, следующая схема сущности для сообщения журнала приводит к созданию раздела с высокой нагрузкой, так как приложение записывает все сообщения журнала в раздел для текущей даты и часа.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE28.png" alt-text="Рисунок, показывающий схему сущности для сообщения журнала, приводит к постановке в горячую секцию.":::

В этом примере `RowKey` содержит дату и время сообщения журнала, чтобы сообщения журнала были отсортированы в порядке даты и времени. `RowKey` также содержит идентификатор сообщения, в случае, если несколько сообщений журнала имеют одинаковые дату и время.  

Другим вариантом является использование свойства `PartitionKey` для записи сообщений в несколько разделов. Например, если источник сообщения журнала позволяет распределять сообщения по нескольким разделам, можно использовать следующую схему сущности.  

:::image type="content" source="./media/storage-table-design-guide/storage-table-design-IMAGE29.png" alt-text="Рисунок: сущность сообщения журнала":::

Однако здесь возникает проблема, которая заключается в том, что для извлечения всех сообщений журнала за определенный период времени необходимо выполнить поиск в каждом разделе таблицы.

#### <a name="solution"></a>Решение
В предыдущем разделе была отмечена проблема использования Хранилища таблиц для хранения записей журнала и предлагались две неудовлетворительные схемы. Результатом одного решения было формирование активной области с риском снижения производительности записи сообщений журнала. Другое решение приводило к ухудшению производительности запросов в связи с требованием просматривать каждый раздел в таблице для получения сообщений журнала за определенный промежуток времени. Хранилище больших двоичных объектов предлагает наилучшее решение в такой ситуации. Оно связано с преимуществами хранения данных журнала в службе аналитики хранилища Azure.  

Описанные в этом разделе способы хранения данных журнала службой аналитики хранилища в хранилище больших двоичных объектов иллюстрируют подход к хранению данных, запрашиваемых по диапазону.  

Служба аналитики хранилища сохраняет сообщения журнала в формате с разделителями в нескольких больших двоичных объектах. Формат с разделителями упрощает анализ данных в сообщениях журнала.  

Служба аналитики хранилища использует соглашение об именовании больших двоичных объектов, позволяющее находить большой двоичный объект (или большие двоичные объекты), которые содержат искомые сообщения журнала. Например, большой двоичный объект с именем "queue/2014/07/31/1800/000001.log" содержит сообщения журнала, относящиеся к службе очередей, за час, начиная с 18:00 31 июля 2014 г. «000001» означает первый файл журнала за этот период. Служба аналитики хранилища также записывает метки времени первого и последнего сообщений журнала, хранящихся в файле в составе метаданных большого двоичного объекта. API для хранилища BLOB-объектов позволяет размещать большие двоичные объекты в контейнере на основе префикса имени. Чтобы разместить все большие двоичные объекты, содержащие данные журнала очереди за час, начиная с 18:00, можно использовать префикс "queue/2014/07/31/1800".  

Служба аналитики хранилища помещает сообщения журнала во внутренний буфер, а затем периодически обновляет соответствующий большой двоичный объект или создает новый с последним пакетом записей журнала. Это способствует сокращению количества операций записи, которые должны быть выполнены в хранилище BLOB-объектов.  

Если в своем приложении вы реализуете аналогичное решение, подумайте, как управлять компромиссом между надежностью, затратами и масштабируемостью. Иными словами, оцените результат записи всех записей журнала в хранилище BLOB-объектов по сравнению с буферизацией обновлений в приложении и их записи в хранилище BLOB-объектов в пакетах.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При выборе способа хранения данных журнала, необходимо учитывать следующие моменты.  

* При создании схемы таблицы без потенциальных разделов с высокой нагрузкой может оказаться, что доступ к данным журнала осуществляется неэффективно.  
* Для обработки данные журнала клиенту часто требуется загружать много записей.  
* Несмотря на то, что данные журнала часто носят структурированный характер, наилучшим решением может быть хранилище больших двоичных объектов.  

### <a name="implementation-considerations"></a>Рекомендации по реализации
В этом разделе рассматриваются некоторые вопросы, которые необходимо иметь в виду при реализации моделей, описанных в предыдущих разделах. В большей части этого раздела приводятся примеры на языке C#, в которых используется клиентская библиотека хранилища(версия 4.3.0 на момент написания данного руководства).  

### <a name="retrieve-entities"></a>Извлечение сущностей
Как упоминалось в разделе [Разработка для запросов](#design-for-querying), самый эффективный запрос — точечный. Однако в некоторых случаях может потребоваться извлечь несколько сущностей. В этом разделе описывается ряд общих методов извлечения сущностей с помощью клиентской библиотеки хранилища.  

#### <a name="run-a-point-query-by-using-the-storage-client-library"></a>Выполнение точечного запроса с помощью клиентской библиотеки хранилища
Самый простой способ выполнить точечный запрос — использовать табличную операцию **Retrieve**. Как показано в следующем фрагменте кода C#, эта операция извлекает сущность со значением `PartitionKey` "Sales" и значением `RowKey` "212":  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

Обратите внимание на то, что извлекаемая сущность будет иметь тип `EmployeeEntity`.  

#### <a name="retrieve-multiple-entities-by-using-linq"></a>Извлечение нескольких сущностей с помощью LINQ
Для извлечения нескольких сущностей можно использовать LINQ с клиентской библиотекой хранилища, указав при этом запрос с предложением **where**. Чтобы исключить сканирование таблицы, в предложение where необходимо всегда включать значение `PartitionKey` и, если возможно, значение `RowKey`, которые позволят избежать просмотров таблиц и разделов. Служба таблиц поддерживает ограниченный набор операторов сравнения ("больше", "больше или равно", "меньше", "меньше или равно", "равно", "не равно"), которые могут использоваться в предложении where. Следующий фрагмент кода C# предназначен для поиска всех сотрудников, фамилии которых начинаются с буквы B (при условии, что фамилия хранится в свойстве `RowKey`), в отделе продаж (при условии, что название отдела хранится в свойстве `PartitionKey`).  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

Обратите внимание на то, каким образом в запросе указываются свойства `RowKey` и `PartitionKey` для обеспечения максимального быстродействия.  

В следующем примере кода показана эквивалентная функциональность с использованием плавного API (дополнительные сведения о плавных API см. в разделе [Советы и рекомендации по разработке текучих API](https://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)).  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> В образце объединено несколько методов `CombineFilters` для включения трех условий фильтрации.  
> 
> 

#### <a name="retrieve-large-numbers-of-entities-from-a-query"></a>Извлечение большого количества сущностей из запроса
Оптимальный запрос возвращает отдельные сущности на основе значений `PartitionKey` и `RowKey`. Однако в некоторых ситуациях может существовать требование о возвращении нескольких сущностей из одного или даже нескольких разделов. В таких случаях следует полностью протестировать производительность приложения.  

Запрос к Хранилищу таблиц может возвращать максимум 1000 сущностей одновременно, а время его выполнения не превышает 5 секунд. Хранилище таблиц возвращает маркер продолжения, чтобы клиентское приложение запрашивало следующий набор сущностей, если выполняется одно из следующих условий.

- Результирующий набор содержит более 1000 сущностей.
- Запрос не завершился в течение пяти секунд.
- Запрос пересекает границу раздела. 

Дополнительные сведения о принципе действия маркеров продолжения см. в статье [Время ожидания запроса и разбивка на страницы](/rest/api/storageservices/Query-Timeout-and-Pagination).  

Клиентская библиотека хранилища может автоматически обрабатывать маркеры продолжения при возвращении сущностей из Хранилища таблиц. В следующем примере кода C# клиентская библиотека хранилища автоматически обрабатывает маркеры продолжения в случае их возвращения Хранилищем таблиц в ответе.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

Следующий код C# обрабатывает маркеры продолжения явным образом.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

Явное использование маркеров продолжения позволяет управлять извлечением следующего сегмента данных. Например, если клиентское приложение позволяет пользователям пролистывать сущности, хранящиеся в таблице, пользователь может принять решение не пролистывать все сущности, извлеченные запросом. Приложение будет использовать маркер продолжения только для получения следующего сегмента, когда пользователь завершил разбивку по страницам всех сущностей в текущем сегменте. Такой подход имеет несколько преимуществ.  

* Можно ограничивать объем данных, извлекаемых из Хранилища таблиц и перемещаемых по сети.  
* В .NET можно выполнять асинхронный ввод-вывод.  
* Можно сериализовать маркер продолжения в постоянное хранилище, чтобы пользователь мог продолжить свои действия в случае сбоя приложения.  

> [!NOTE]
> Маркер продолжения обычно возвращает сегмент, содержащий 1000 сущностей и меньше. Это также происходит, если ограничить количество записей, возвращаемых запросом, с помощью **Take**, чтобы вернуть первые n сущностей, соответствующих условиям поиска. Хранилище таблиц может возвращать сегмент, содержащий менее n сущностей, а также маркер продолжения, позволяющий получить оставшиеся сущности.  
> 
> 

Следующий код C# демонстрирует процесс изменения количества возвращаемых сущностей в сегменте.  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a>Проекция на стороне сервера
Одна сущность может иметь до 255 свойств и быть размером не более 1 МБ. При выполнении запроса к таблице и извлечении сущностей может потребоваться только часть свойств, а передача данных будет осуществляться только при необходимости (для сокращения времени задержки и снижения затрат). Проекции на стороне сервера можно использовать для передачи только необходимых свойств. В следующем примере извлекается только свойство `Email` (вместе с `PartitionKey`, `RowKey`, `Timestamp` и `ETag`) из сущностей, выбранных запросом.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

Обратите внимание на доступность значения `RowKey`, несмотря на то, что оно не включено в список возвращаемых свойств.  

### <a name="modify-entities"></a>изменение сущностей.
Клиентская библиотека хранилища позволяет изменять сущности, хранящиеся в Хранилище таблиц, путем вставки, удаления и обновления сущностей. С помощью транзакций группы сущностей можно выполнять пакетные операции вставки, обновления и удаления, сокращая тем самым количество круговых переходов и повышая производительность решения.  

Исключения, создаваемые в тот момент, когда клиентская библиотека хранилища выполняет транзакцию группы сущностей, обычно содержат индекс сущности, которая вызвала сбой обработки всего пакета. Это может оказаться полезным при отладке кода, использующего транзакции группы сущностей.  

Следует также учитывать влияние разработки на то, каким образом клиентское приложение обрабатывает операций параллелизма и обновления.  

#### <a name="managing-concurrency"></a>Управление параллелизмом
По умолчанию Хранилище таблиц реализует проверки оптимистичного параллелизма на уровне отдельных сущностей для операций Insert, Merge и Delete, несмотря на то, что клиент может принудительно заставить Хранилище таблиц обойти эти проверки. Дополнительные сведения см. в статье [Управление параллелизмом в службе хранилища Microsoft Azure](../storage/blobs/concurrency-manage.md).  

#### <a name="merge-or-replace"></a>Объединение или замена.
Метод `Replace` класса `TableOperation` всегда заменяет полную сущность в Хранилище таблиц. Если это свойство не включено в запрос, но существует в хранимой сущности, запрос удалит это свойство из хранимой сущности. Каждое свойство требуется в включать в запрос до тех пор, пока оно явным образом не будет удалено из хранимой сущности.  

Метод `Merge` класса `TableOperation` можно использовать для сокращения объема данных, отправляемых в Хранилище таблиц при необходимости обновления сущности. Метод `Merge` заменяет все свойства в хранимой сущности значениями свойств из сущности, входящей в запрос. Этот метод оставляет без изменений все свойства в хранимой сущности, которые не включаются в запрос. Это полезно при наличии сущностей больших размеров и если нужно обновить незначительное количество свойств в запросе.  

> [!NOTE]
> Методы `*Replace` и `Merge` завершаются ошибкой, если сущность не существует. В качестве альтернативы рекомендуется рассмотреть методы `InsertOrReplace` и `InsertOrMerge`, которые в случае отсутствия сущности создают таковую.  
> 
> 

### <a name="work-with-heterogeneous-entity-types"></a>Работа с разными типами сущностей
Хранилище таблиц является хранилищем *без схемы*. Это значит, что в одной таблице могут храниться сущности нескольких типов, что обеспечивает исключительную гибкость разработки. В следующем примере показана таблица, в которой хранятся сущности сотрудников и отделов.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Отметка времени</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

Каждая сущность по-прежнему должна иметь значения `PartitionKey`, `RowKey` и `Timestamp`, однако она может иметь любой набор свойств. Кроме того, тип сущности будет указан только после выбора места для хранения этих сведений. Существует два варианта определения типа сущности.  

* Добавьте тип сущности в начало свойства `RowKey` (или, возможно, свойства `PartitionKey`). Например, `EMPLOYEE_000123` или `DEPARTMENT_SALES` как значения `RowKey`.  
* Используйте отдельное свойство для записи типа сущности, как показано в таблице ниже.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Отметка времени</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td>Сотрудник</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td>Сотрудник</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>отдел;</td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Возраст</th>
<th>Email</th>
</tr>
<tr>
<td>Сотрудник</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

Первый вариант (добавление типа сущности в начало свойства `RowKey`) полезен, если существует вероятность, что две сущности разных типов имеют одинаковое значение ключа. Кроме того, он позволяет объединять сущности одного типа в раздел.  

Методики, описанные в этом разделе, особенно важны для обсуждения [отношений наследования](#inheritance-relationships).  

> [!NOTE]
> Чтобы клиентские приложения могли формировать объекты POCO и работать с различными версиями, рекомендуется включить номер версии в значение типа сущности.  
> 
> 

В оставшейся части этого раздела описываются некоторые функции клиентской библиотеки хранилища, которые упрощают работу с несколькими типами сущностей в одной таблице.  

#### <a name="retrieve-heterogeneous-entity-types"></a>Извлечение разных типов сущностей
Если вы используете клиентскую библиотеку хранилища, вам доступны три варианта работы с несколькими типами сущностей.  

Если известно, какой тип сущности хранится с конкретными значениями `RowKey` и `PartitionKey`, то можно указать тип сущности при ее получении. Это было показано в двух предыдущих примерах, в которых извлекаются сущности типа `EmployeeEntity`: [Выполнение запроса точки с помощью клиентской библиотеки хранилища](#run-a-point-query-by-using-the-storage-client-library) и [Извлечение нескольких сущностей с помощью LINQ](#retrieve-multiple-entities-by-using-linq).  

Второй вариант — использовать тип `DynamicTableEntity` (контейнер свойств) вместо конкретного типа сущности POCO. Этот вариант также может повысить производительность, поскольку нет необходимости выполнять сериализацию и десериализовать сущность в типы .NET. В следующем примере кода C# показано извлечение нескольких сущностей различных типов из таблицы и возврат всех сущностей в качестве экземпляров `DynamicTableEntity`. После этого в примере используется свойство `EntityType` для определения типа каждой сущности.  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

Чтобы извлечь другие свойства, необходимо использовать метод `TryGetValue` в свойстве `Properties` класса `DynamicTableEntity`.  

Третьим вариантом является объединение с использованием типа `DynamicTableEntity` и экземпляра `EntityResolver`. Он позволяет выполнять разрешение в несколько типов POCO в рамках одного запроса. В этом примере делегат `EntityResolver` использует свойство `EntityType`, чтобы отличать два типа сущности, возвращаемых запросом. Метод `Resolve` использует делегат `resolver` для разрешения экземпляров `DynamicTableEntity` в экземпляры `TableEntity`.  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modify-heterogeneous-entity-types"></a>Изменение разных типов сущностей
Чтобы удалить тип сущности, его не нужно знать. Однако при вставке тип сущности всегда известен. Чтобы обновить сущность, не зная ее тип и не используя класс сущности POCO, можно воспользоваться типом `DynamicTableEntity`. Следующий пример кода извлекает одну сущность и проверяет свойство `EmployeeCount` перед его обновлением.  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="control-access-with-shared-access-signatures"></a>Управление доступом с помощью подписанных URL-адресов
Маркеры подписи общего доступа (SAS) позволяют клиентским приложениям напрямую изменять (и выполнять запросы) сущности таблицы без прохождения проверки подлинности в Хранилище таблиц. Существует три основных преимущества использования SAS в приложении.  

* Не нужно распространять ключ учетной записи хранения на небезопасной платформе (например, на мобильном устройстве), чтобы предоставить устройству права на доступ и изменение сущностей в Хранилище таблиц.  
* Можно разгрузить некоторую работу, которую выполняют веб-роль и рабочая роль при управлении сущностями. Можно разгрузить клиентские устройства, такие как компьютеры и мобильные устройства конечных пользователей.  
* Клиенту можно назначить ограниченный ресурсами и временем набор разрешений (например, доступ только для чтения к определенным ресурсам).  

Дополнительные сведения об использовании маркеров SAS с Хранилищем таблиц см. в статье [Использование подписанных URL-адресов (SAS)](../storage/common/storage-sas-overview.md).  

Тем не менее необходимо по-прежнему создавать маркеры SAS, которые предоставляют клиентскому приложению доступ к сущностям в Хранилище таблиц. Это можно сделать в среде, которая имеет безопасный доступ к ключам учетной записи хранения. Как правило, для создания маркеров SAS их доставки в клиентские приложения, которым требуется доступ к сущностям, используются веб-роли или рабочие роли. Поскольку процесс создания маркеров SAS и их доставки клиентов по-прежнему связан с издержками, рекомендуется рассмотреть оптимальные варианты сокращения расходов в сценариях с большим количеством операций.  

Можно создать маркер SAS, который предоставляет доступ к подмножеству сущностей в таблице. По умолчанию создается маркер SAS для всей таблицы. Но можно также указать, чтобы маркер SAS предоставлял доступ либо к диапазону значений `PartitionKey`, либо к диапазону значений `PartitionKey` и `RowKey`. Маркеры SAS можно создать для отдельных пользователей системы таким образом, чтобы маркер SAS предоставлял пользователю доступ только к его собственным сущностям в Хранилище таблиц.  

### <a name="asynchronous-and-parallel-operations"></a>Асинхронные и параллельные операции
Чтобы улучшить производительность и время отклика клиента в случае распределения запросов по нескольким разделам, рекомендуется обратить внимание на асинхронные и параллельные запросы.
Например, в вашем распоряжении может быть два или несколько экземпляров рабочих ролей с параллельным доступом к таблицам. Отдельные рабочие роли могут отвечать за определенные наборы разделов или же просто несколько экземпляров рабочих ролей могут получать доступ ко всем разделам в таблице.  

Повысить производительность в экземпляре клиента можно путем асинхронного выполнения операций хранения. Клиентская библиотека хранилища упрощает написание асинхронных запросов и изменений. Например, можно начать с синхронного метода, который извлекает все сущности в разделе, как показано в следующем коде C#.  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

Этот код можно легко изменить, чтобы запрос выполнялся в асинхронном режиме, как показано ниже.  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

В данном примере асинхронного режима присутствуют следующие отличия от синхронной версии.  

* Теперь подпись метода содержит модификатор `async` и возвращает экземпляр `Task`.  
* Вместо вызова метода `ExecuteSegmented` для получения результатов метод теперь вызывает метод `ExecuteSegmentedAsync`. Метод использует модификатор `await` для асинхронного получения результатов.  

Клиентское приложение может вызывать этот метод несколько раз с разными значениями параметра `department`, а каждый запрос будет выполняться в отдельном потоке.  

Асинхронная версия метода `Execute` в классе `TableQuery` отсутствует, поскольку интерфейс `IEnumerable` не поддерживает асинхронное перечисление.  

Можно вставлять, обновлять и удалять сущности в асинхронном режиме. В следующем примере кода C# показан простой синхронный метод вставки или замены сущности сотрудника.  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

Этот код можно легко изменить, чтобы обновление выполнялось в асинхронном режиме, как показано ниже.  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

В данном примере асинхронного режима присутствуют следующие отличия от синхронной версии.  

* Теперь подпись метода содержит модификатор `async` и возвращает экземпляр `Task`.  
* Вместо вызова метода `Execute` для обновления сущности метод теперь вызывает метод `ExecuteAsync`. Метод использует модификатор `await` для асинхронного получения результатов.  

Клиентское приложение может вызывать несколько подобных асинхронных методов, а каждый вызов метода выполняется в отдельном потоке.