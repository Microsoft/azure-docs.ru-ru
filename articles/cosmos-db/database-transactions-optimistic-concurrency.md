---
title: Транзакции базы данных и оптимистическая блокировка в Azure Cosmos DB
description: Эта статья содержит сведения о транзакциях базы данных и оптимистической блокировке в Azure Cosmos DB
author: markjbrown
ms.author: mjbrown
ms.service: cosmos-db
ms.subservice: cosmosdb-sql
ms.topic: conceptual
ms.date: 12/04/2019
ms.reviewer: sngun
ms.openlocfilehash: 96652b2a1eb35668bd8a810b309ab31cec5afdb7
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "97967265"
---
# <a name="transactions-and-optimistic-concurrency-control"></a>Управление транзакциями и оптимистической блокировкой
[!INCLUDE[appliesto-sql-api](includes/appliesto-sql-api.md)]

Транзакции базы данных обеспечивают безопасную и предсказуемую модель программирования для работы с одновременными изменениями данных. Традиционные реляционные базы данных, например SQL Server, позволяют писать бизнес-логику с помощью хранимых процедур и/или триггеров, отправляйте их на сервер для выполнения непосредственно в ядре СУБД. В традиционных реляционных базах данных необходимо иметь дело с двумя различными языками программирования (без транзакций), такими как JavaScript, Python, C#, Java и т. д., а также с языком программирования транзакций (например, T-SQL), который изначально исполняется базой данных.

Ядро СУБД Azure Cosmos DB поддерживает транзакции с полной совместимостью с ACID (атомарность, согласованность, изоляция, устойчивость) и изоляцией моментального снимка. Все операции базы данных в области действия [логической секции](partitioning-overview.md) контейнера являются транзакционно выполняемыми в ядре СУБД, размещенном в реплике секции. К ним относятся операции записи (обновление одного или нескольких элементов в логическом разделе) и операции чтения. В следующей таблице показаны различные операции и типы транзакций.

| **Операция**  | **Тип операции** | **Транзакция для одного или нескольких элементов** |
|---------|---------|---------|
| INSERT (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| INSERT (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| REPLACE (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| REPLACE (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| UPSERT (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| UPSERT (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| DELETE (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| DELETE (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| Выполнение хранимой процедуры | Запись и чтение | Транзакции для нескольких элементов |
| Выполнение процедуры слияния, инициируемое системой | запись | Транзакции для нескольких элементов |
| Удаление элементов, у которых истек срок жизни (TTL), инициируемое системой | запись | Транзакции для нескольких элементов |
| Чтение | Чтение | Транзакция для одного элемента |
| Канал изменений | Чтение | Транзакции для нескольких элементов |
| Чтение с разбивкой на страницы | Чтение | Транзакции для нескольких элементов |
| Запрос с разбивкой на страницы | Чтение | Транзакции для нескольких элементов |
| Выполнение определяемой пользователем функции в составе запроса с разбивкой на страницы | Чтение | Транзакции для нескольких элементов |

## <a name="multi-item-transactions"></a>Транзакции для нескольких элементов

Azure Cosmos DB позволяет создавать [хранимые процедуры, триггеры pre и POST, пользовательские функции (UDF)](stored-procedures-triggers-udfs.md) и процедуры MERGE в JavaScript. Ядро СУБД Azure Cosmos DB имеет встроенную поддержку выполнения JavaScript. Вы можете зарегистрировать в контейнере хранимые процедуры, предшествующие и последующие триггеры, определяемые пользователем функции и процедуры слияния, чтобы позднее выполнять их транзакционно в ядре СУБД Azure Cosmos. Создание логики приложения на JavaScript допускает естественное выражение потока управления, области видимости переменных, присвоения, а также интеграцию примитивов обработки исключений с транзакциями базы данных непосредственно на JavaScript.

Хранимые процедуры, триггеры, определяемые пользователем функции и процедуры слияния на JavaScript помещаются в контекстные транзакции ACID с изоляцией моментального снимка для всех элементов в логическом разделе. Если при выполнении такой транзакции код JavaScript создает исключение, то вся транзакция прерывается и откатывается к прежнему состоянию. Полученная модель программирования является простой, но эффективной. Разработчики JavaScript получают надежную модель программирования, сохраняя привычные языковые конструкции и библиотечные примитивы.

Возможность выполнить код JavaScript непосредственно в ядре СУБД повышает производительность операций над элементами контейнера в базе данных и обеспечивает поддержку транзакций. Кроме того, встроенная поддержка JSON и JavaScript в ядре СУБД Azure Cosmos устраняет несоответствия между системами типов в приложении и базе данных.

## <a name="optimistic-concurrency-control"></a>Управление оптимистическим параллелизмом

Оптимистическая блокировка позволяет предотвратить потери операций обновления и удаления. Для конфликтующих одновременных операций применяется обычная пессимистическая блокировка ядра СУБД, размещенного в том же логическом разделе, что и обрабатываемый элемент. Когда две параллельные операции пытаются обновить элемент в логическом разделе до последней версии, одна из них будет успешной, а вторая завершится ошибкой. Но если одна или обе из таких операций ранее считали старое значение обновляемого элемента, база данных не может проверить актуальность считанных значений для любой из конфликтующих операций. К счастью, эту ситуацию можно обнаружить с помощью **управления оптимистичным параллелизмом (OCC)** , прежде чем позволить двум операциям ввести границу транзакции в ядре СУБД. Оптимистическая блокировка защищает от случайной перезаписи данные, внесенные другими пользователями. Она также не позволит другим процессам случайно перезаписать ваши изменения.

Для одновременных обновлений элемента Azure Cosmos DB применяет оптимистическую блокировку на уровне протокола связи. Для учетных записей Azure Cosmos, настроенных для **операций записи в один регион**, Azure Cosmos DB гарантирует, что клиентская версия обновляемого (или удаляемого) элемента будет совпадать с версией элемента в контейнере Azure Cosmos. Это гарантирует, что операции записи защищены от случайного перезаписи другими записями других и наоборот. В среде с несколькими пользователями оптимистическая блокировка не позволит вам случайно удалить или изменить элемент с неправильной версией. Таким образом, элементы защищаются от неизвестных проблем «потерянное обновление» или «потеря удаления».

В учетной записи Azure Cosmos, настроенной для **записи в несколько регионов**, данные можно зафиксировать отдельно в дополнительных регионах, если они `_etag` совпадают с данными в локальном регионе. После того как новые данные зафиксированы локально в дополнительном регионе, они объединяются в центре или основном регионе. Если политика разрешения конфликтов выполняет слияние новых данных с центральным регионом, эти данные будут реплицироваться глобально с новым `_etag` . Если политика разрешения конфликтов отклоняет новые данные, дополнительный регион будет восстановлен до исходных данных и `_etag` .

Для каждого элемента в контейнере Azure Cosmos определено системное свойство `_etag`. Значение `_etag` создается и обновляется на сервере автоматически при каждом обновлении элемента. `_etag` можно использовать с `if-match` заголовком запроса, предоставляемым клиентом, чтобы позволить серверу решить, можно ли условно обновить элемент. Значение `if-match` заголовка совпадает со значением объекта `_etag` на сервере. Затем элемент обновляется. Если значение `if-match` заголовка запроса больше не является актуальным, сервер отклоняет операцию с ответом на сообщение "HTTP 412 предусловие". Затем клиент может повторно получить элемент для получения текущей версии элемента на сервере или переопределить версию элемента на сервере со своим собственным `_etag` значением элемента. Кроме того, `_etag` можно использовать с `if-none-match` заголовком для определения необходимости повторной выборки ресурса.

`_etag`Значение элемента изменяется каждый раз при обновлении элемента. Для операций Replace Item `if-match` должен быть явно выражен как часть параметров запроса. Пример такого кода можно найти на [GitHub](https://github.com/Azure/azure-cosmos-dotnet-v3/blob/master/Microsoft.Azure.Cosmos.Samples/Usage/ItemManagement/Program.cs#L676-L772). `_etag` значения неявно проверяются для всех записанных элементов, затронутых хранимой процедурой. При обнаружении любого конфликта хранимая процедура выполняет откат транзакции и создает исключение. Такой метод гарантирует, что операции записи хранимой процедуры применяются атомарным образом, то есть "все или ничего". Приложение получает сигнал о необходимости повторно применить обновления и повторить исходный запрос клиента.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о транзакциях базы данных и оптимистической блокировке вы можете получить в следующих статьях.

- [Работа с базами данных, контейнерами и элементами Azure Cosmos](account-databases-containers-items.md)
- [Уровни согласованности](consistency-levels.md)
- [Типы конфликтов и политики их разрешения](conflict-resolution-policies.md)
- [Использование Трансактионалбатч](transactional-batch.md)
- [Хранимые процедуры, триггеры и определяемые пользователем функции](stored-procedures-triggers-udfs.md)
