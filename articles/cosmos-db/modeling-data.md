---
title: Моделирование данных в Azure Cosmos DB
titleSuffix: Azure Cosmos DB
description: Сведения о моделировании данных в базах данных NoSQL и различиях между моделированием данных в реляционной базе данных и базе данных документов.
author: markjbrown
ms.author: mjbrown
ms.service: cosmos-db
ms.subservice: cosmosdb-sql
ms.topic: conceptual
ms.date: 07/23/2019
ms.openlocfilehash: a141177846def9c94216684c1083d0d336eeda1e
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "93333262"
---
# <a name="data-modeling-in-azure-cosmos-db"></a>Моделирование данных в Azure Cosmos DB
[!INCLUDE[appliesto-sql-api](includes/appliesto-sql-api.md)]

Несмотря на то, что базы данных без схемы, такие как Azure Cosmos DB, упрощают хранение и запрос неструктурированных и частичных данных, следует потратить некоторое время на обдумывание модели данных, чтобы получить максимальную часть службы с точки зрения производительности и масштабируемости, а также наименьших затрат.

Как данные будут храниться? Как приложение будет получать данные и выполнять запросы по ним? Приложение слишком интенсивно читается или слишком интенсивно записывается?

После прочтения этой статьи вы сможете ответить на следующие вопросы:

* Что такое моделирование данных и почему оно так важно?
* Как моделирование данных в Azure Cosmos DB отличается от модели реляционной базы данных?
* Как выразить связи данных в нереляционной базе данных?
* Когда следует внедрять данные, а когда — связывать?

## <a name="embedding-data"></a>Внедрение данных

При запуске моделирования данных в Azure Cosmos DB пытаться рассматривать сущности как **автономные элементы** , представленные в виде документов JSON.

Для сравнения, давайте сначала посмотрим, как можно моделировать данные в реляционной базе данных. В следующем примере показано, как можно сохранить в реляционной базе данных человека.

:::image type="content" source="./media/sql-api-modeling-data/relational-data-model.png" alt-text="Модель реляционной базы данных" border="false":::

При работе с реляционными базами данных стратегия заключается в нормализации всех данных. Нормализация данных обычно подразумевает получение сущности, например человека, и разбиение их на отдельные компоненты. В приведенном выше примере у пользователя может быть несколько записей контактных данных, а также несколько записей адресов. Контактные данные можно дополнительно разделить, извлекая общие поля, такие как тип. То же самое касается адреса, каждая запись может иметь тип *Home* или *Business*.

Руководящий принцип при нормализации данных заключается в том, чтобы **избегать хранения избыточных данных** в каждой записи и использовать только ссылки на эти данные. В этом примере для чтения человека со всеми его контактными данными и адресами необходимо использовать объединения для эффективного создания (или денормализации) данных во время выполнения.

```sql
SELECT p.FirstName, p.LastName, a.City, cd.Detail
FROM Person p
JOIN ContactDetail cd ON cd.PersonId = p.Id
JOIN ContactDetailType cdt ON cdt.Id = cd.TypeId
JOIN Address a ON a.PersonId = p.Id
```

Чтобы обновить сведения о контактах и адреса для отдельного человека, требуется выполнить операции записи для множества отдельных таблиц.

Теперь давайте посмотрим, как мы будем моделировать те же данные, что и автономная сущность в Azure Cosmos DB.

```json
{
    "id": "1",
    "firstName": "Thomas",
    "lastName": "Andersen",
    "addresses": [
        {
            "line1": "100 Some Street",
            "line2": "Unit 1",
            "city": "Seattle",
            "state": "WA",
            "zip": 98012
        }
    ],
    "contactDetails": [
        {"email": "thomas@andersen.com"},
        {"phone": "+1 555 555-5555", "extension": 5555}
    ]
}
```

Используя описанный выше подход, мы **денормализовани** запись о лице, **внедрив** всю информацию, относящуюся к этому человеку, например контактные данные и адреса, в *один документ JSON* .
Кроме того, отсутствие привязки к фиксированной схеме повышает гибкость работы, например, мы можем использовать сведения о контактах в самых разных формах.

Получение полной записи о лице из базы данных теперь представляет собой **одну операцию чтения** для одного контейнера и для одного элемента. Обновление записи о лице с контактными данными и адресами также является **одной операцией записи** для одного элемента.

Благодаря денормализации данных ваше приложение может использовать меньше запросов и обновлений для выполнения распространенных операций.

### <a name="when-to-embed"></a>Когда следует использовать внедрение

В общем случае модели внедренных данных следует использовать в следующих ситуациях:

* Между сущностями **существуют связи.**
* между сущностями существуют связи **один к нескольким** ;
* имеются внедренные данные, которые **редко изменяются**;
* Существуют внедренные данные, которые не будут увеличиваться **без привязки**.
* Существуют внедренные данные, которые **часто запрашиваются вместе**.

> [!NOTE]
> Обычно модели денормализованных данных обеспечивают повышенную производительность при **чтении** .

### <a name="when-not-to-embed"></a>Когда внедрение использовать не следует

Хотя правило «Thumb» в Azure Cosmos DBе состоит в денормализации всего содержимого и внедрении всех данных в один элемент, это может привести к возникновению некоторых ситуаций, которые следует избегать.

Рассмотрим этот фрагмент кода JSON.

```json
{
    "id": "1",
    "name": "What's new in the coolest Cloud",
    "summary": "A blog post by someone real famous",
    "comments": [
        {"id": 1, "author": "anon", "comment": "something useful, I'm sure"},
        {"id": 2, "author": "bob", "comment": "wisdom from the interwebs"},
        …
        {"id": 100001, "author": "jane", "comment": "and on we go ..."},
        …
        {"id": 1000000001, "author": "angry", "comment": "blah angry blah angry"},
        …
        {"id": ∞ + 1, "author": "bored", "comment": "oh man, will this ever end?"},
    ]
}
```

Так могла бы выглядеть сущность публикации с внедренными комментариями, если бы мы моделировали обычный блог или систему CMS. Проблема с данным примером заключается в том, что массив комментариев является **неограниченным**, то есть не существует (фактического) предела для количества комментариев, которое может иметь отдельная публикация. Это может стать проблемой, так как размер элемента может увеличиваться бесконечно большим.

По мере увеличения размера элемента может снизиться возможность передачи данных по сети, а также чтения и обновления элемента в масштабе.

В этом случае лучше рассмотреть следующую модель данных.

```json
Post item:
{
    "id": "1",
    "name": "What's new in the coolest Cloud",
    "summary": "A blog post by someone real famous",
    "recentComments": [
        {"id": 1, "author": "anon", "comment": "something useful, I'm sure"},
        {"id": 2, "author": "bob", "comment": "wisdom from the interwebs"},
        {"id": 3, "author": "jane", "comment": "....."}
    ]
}

Comment items:
{
    "postId": "1"
    "comments": [
        {"id": 4, "author": "anon", "comment": "more goodness"},
        {"id": 5, "author": "bob", "comment": "tails from the field"},
        ...
        {"id": 99, "author": "angry", "comment": "blah angry blah angry"}
    ]
},
{
    "postId": "1"
    "comments": [
        {"id": 100, "author": "anon", "comment": "yet more"},
        ...
        {"id": 199, "author": "bored", "comment": "will this ever end?"}
    ]
}
```

Эта модель содержит три последних комментария, внедренных в контейнер POST, который является массивом с фиксированным набором атрибутов. Другие комментарии группируются в пакетах 100 комментариев и хранятся в виде отдельных элементов. Размер пакета был выбран равным 100, поскольку наше условное приложение позволяет пользователю отправить 100 комментариев за один раз.  

Другой случай, когда внедрение данных не является хорошей идеей, заключается в том, что внедренные данные часто используются в разных элементах и будут часто меняться.

Рассмотрим этот фрагмент кода JSON.

```json
{
    "id": "1",
    "firstName": "Thomas",
    "lastName": "Andersen",
    "holdings": [
        {
            "numberHeld": 100,
            "stock": { "symbol": "zaza", "open": 1, "high": 2, "low": 0.5 }
        },
        {
            "numberHeld": 50,
            "stock": { "symbol": "xcxc", "open": 89, "high": 93.24, "low": 88.87 }
        }
    ]
}
```

Этот код может представлять биржевой портфель человека. Мы решили внедрить информацию об акциях в каждый документ портфеля. В среде, где связанные данные регулярно изменяются, например, в приложении биржевых торгов, внедрение часто изменяемых данных означает, что вы постоянно обновляете каждый документ портфеля при выполнении торговой операции с каждой акцией.

В течение дня акции *zaza* могут покупать и продавать сотни раз, и *zaza* могут входить в портфели тысяч пользователей. В случае использования описанной выше модели данных нам пришлось бы обновлять многие тысячи документов портфелей каждый день, что затруднило бы масштабирование системы.

## <a name="referencing-data"></a>Использование ссылок на данные

Внедрение данных прекрасно работает во многих случаях, но существуют ситуации, когда денормализация данных приведет к большему числу проблем, чем стоит. Что же нам делать теперь?

Связи между сущностями можно задавать не только в реляционных базах данных. В базе данных документов можно получить сведения в одном документе, относящемся к данным в других документах. Не рекомендуется создавать системы, которые лучше подходят для реляционной базы данных в Azure Cosmos DB или в любой другой базе данных документов, но простые связи прекрасно подходят и могут быть полезными.

В приведенном ниже коде JSON мы решили использовать использованный ранее пример биржевого портфеля, однако здесь мы не внедряем элемент акции в портфеле, а ссылаемся на него. Если элемент акции часто изменяется в течение дня, то обновлять требуется единственный документ акции.

```json
Person document:
{
    "id": "1",
    "firstName": "Thomas",
    "lastName": "Andersen",
    "holdings": [
        { "numberHeld":  100, "stockId": 1},
        { "numberHeld":  50, "stockId": 2}
    ]
}

Stock documents:
{
    "id": "1",
    "symbol": "zaza",
    "open": 1,
    "high": 2,
    "low": 0.5,
    "vol": 11970000,
    "mkt-cap": 42000000,
    "pe": 5.89
},
{
    "id": "2",
    "symbol": "xcxc",
    "open": 89,
    "high": 93.24,
    "low": 88.87,
    "vol": 2970200,
    "mkt-cap": 1005000,
    "pe": 75.82
}
```

Недостаток такого подхода проявляется, когда приложению нужно отобразить информацию о каждой имеющейся акции в портфеле человека; в этом случае потребуется выполнить множество обращений к базе данных, чтобы загрузить информацию для каждого документа акции. Здесь мы приняли решение повысить эффективность операций записи, которые часто выполняются в течение дня, однако это затруднило выполнение операций чтения, которые оказывают меньшее влияние на производительность всей данной системы.

> [!NOTE]
> Модели нормализованных данных **могут потребовать больше круговых путей** к серверу.

### <a name="what-about-foreign-keys"></a>Сведения о внешнем ключе

Поскольку в настоящий момент концепция ограничения, основанная на внешнем ключе или чем-либо другом, отсутствует, все связи между документами представляют собой "слабые звенья" и не проверяются базой данных. Если вы хотите убедиться, что данные, на которые ссылается документ, действительно существуют, это нужно сделать в приложении либо с помощью триггеров на стороне сервера или хранимых процедур в Azure Cosmos DB.

### <a name="when-to-reference"></a>Когда следует использовать ссылки

В общем случае модели нормализованных данных следует использовать в следующих ситуациях:

* Осуществляется представление связей **один ко многим** .
* Осуществляется представление связей **многие ко многим** .
* Связанные данные **часто изменяются**.
* Данные, на которые указывает ссылка, могут быть **неограниченными**.

> [!NOTE]
> Обычно нормализация обеспечивает повышенную производительность при **записи** .

### <a name="where-do-i-put-the-relationship"></a>Куда следует поместить связь

Рост связи поможет определить, в каком документе следует сохранить ссылку.

Давайте рассмотрим следующий код JSON, моделирующий издателей и книги.

```json
Publisher document:
{
    "id": "mspress",
    "name": "Microsoft Press",
    "books": [ 1, 2, 3, ..., 100, ..., 1000]
}

Book documents:
{"id": "1", "name": "Azure Cosmos DB 101" }
{"id": "2", "name": "Azure Cosmos DB for RDBMS Users" }
{"id": "3", "name": "Taking over the world one JSON doc at a time" }
...
{"id": "100", "name": "Learn about Azure Cosmos DB" }
...
{"id": "1000", "name": "Deep Dive into Azure Cosmos DB" }
```

Если на издателя приходится небольшое число книг, а рост ограничен, то может оказаться удобным хранить ссылку на книгу в документе издателя. Однако если число книг на издателя не имеет ограничений, эта модель данных приведет к изменяемым и разрастающимся массивам, как в приведенном выше примере с документом издателя.

Небольшая доработка помогает получить модель, которая все еще представляет те же данные, однако избавляется от крупных изменяемых коллекций.

```json
Publisher document:
{
    "id": "mspress",
    "name": "Microsoft Press"
}

Book documents:
{"id": "1","name": "Azure Cosmos DB 101", "pub-id": "mspress"}
{"id": "2","name": "Azure Cosmos DB for RDBMS Users", "pub-id": "mspress"}
{"id": "3","name": "Taking over the world one JSON doc at a time"}
...
{"id": "100","name": "Learn about Azure Cosmos DB", "pub-id": "mspress"}
...
{"id": "1000","name": "Deep Dive into Azure Cosmos DB", "pub-id": "mspress"}
```

В приведенном выше примере мы помещали неограниченную коллекцию в документ издателя. Вместо этого мы просто воспользуемся ссылкой на издателя в каждом документе книги.

### <a name="how-do-i-model-manymany-relationships"></a>Как моделировать связи "многие ко многим"

В реляционной базе данных связи *многие ко многим* часто моделируются с помощью таблиц JOIN, которые просто соединяют вместе записи из других таблиц.


:::image type="content" source="./media/sql-api-modeling-data/join-table.png" alt-text="Объединенные таблицы" border="false":::

У вас может возникнуть желание реплицировать это с помощью документов и создать модель данных, аналогичную приведенной ниже.

```json
Author documents:
{"id": "a1", "name": "Thomas Andersen" }
{"id": "a2", "name": "William Wakefield" }

Book documents:
{"id": "b1", "name": "Azure Cosmos DB 101" }
{"id": "b2", "name": "Azure Cosmos DB for RDBMS Users" }
{"id": "b3", "name": "Taking over the world one JSON doc at a time" }
{"id": "b4", "name": "Learn about Azure Cosmos DB" }
{"id": "b5", "name": "Deep Dive into Azure Cosmos DB" }

Joining documents:
{"authorId": "a1", "bookId": "b1" }
{"authorId": "a2", "bookId": "b1" }
{"authorId": "a1", "bookId": "b2" }
{"authorId": "a1", "bookId": "b3" }
```

Такой подход будет работать. Однако при загрузке автора вместе с его книгами или книги вместе с ее автором всегда потребуется отправлять два дополнительных запроса в базу данных. Один запрос отправляется в документ присоединения, а другой — для получения самого присоединяемого документа.

Если эта таблица JOIN всего лишь соединяет два элемента данных, почему бы просто не отказаться от нее?
Давайте рассмотрим следующее.

```json
Author documents:
{"id": "a1", "name": "Thomas Andersen", "books": ["b1", "b2", "b3"]}
{"id": "a2", "name": "William Wakefield", "books": ["b1", "b4"]}

Book documents:
{"id": "b1", "name": "Azure Cosmos DB 101", "authors": ["a1", "a2"]}
{"id": "b2", "name": "Azure Cosmos DB for RDBMS Users", "authors": ["a1"]}
{"id": "b3", "name": "Learn about Azure Cosmos DB", "authors": ["a1"]}
{"id": "b4", "name": "Deep Dive into Azure Cosmos DB", "authors": ["a2"]}
```

Теперь, если у меня есть автор, я сразу же знал, какие книги были написаны, и наоборот, если у меня был загружен документ книги, я бы знал идентификаторы авторов. Это позволяет отказаться от промежуточного запроса к таблице JOIN и сократить количество круговых путей для вашего приложения.

## <a name="hybrid-data-models"></a>Гибридные модели данных

Мы рассмотрели внедрение данных (или денормализацию) и использование ссылок на данные (или нормализацию), а также преимущества и недостатки этих подходов.

Однако далеко не всегда следует придерживаться лишь одного из подходов, можно попробовать совместить их.

Учитывая применяемые в приложении схемы использования и рабочие нагрузки, в некоторых случаях совмещение внедрения и ссылок может иметь смысл и позволяет упростить логическую схему приложения, сократить число круговых путей к серверу и при этом сохранить высокий уровень производительности.

Давайте рассмотрим следующий код JSON.

```json
Author documents:
{
    "id": "a1",
    "firstName": "Thomas",
    "lastName": "Andersen",
    "countOfBooks": 3,
    "books": ["b1", "b2", "b3"],
    "images": [
        {"thumbnail": "https://....png"}
        {"profile": "https://....png"}
        {"large": "https://....png"}
    ]
},
{
    "id": "a2",
    "firstName": "William",
    "lastName": "Wakefield",
    "countOfBooks": 1,
    "books": ["b1"],
    "images": [
        {"thumbnail": "https://....png"}
    ]
}

Book documents:
{
    "id": "b1",
    "name": "Azure Cosmos DB 101",
    "authors": [
        {"id": "a1", "name": "Thomas Andersen", "thumbnailUrl": "https://....png"},
        {"id": "a2", "name": "William Wakefield", "thumbnailUrl": "https://....png"}
    ]
},
{
    "id": "b2",
    "name": "Azure Cosmos DB for RDBMS Users",
    "authors": [
        {"id": "a1", "name": "Thomas Andersen", "thumbnailUrl": "https://....png"},
    ]
}
```

Здесь мы в большей степени придерживались модели внедрения, где данные из других сущностей внедряются в документ верхнего уровня, однако для остальных данных используются ссылки.

Если взглянуть на документ книги, можно заметить несколько интересных полей в массиве авторов. Поле `id` , которое используется для ссылки на авторский документ, является стандартным методом в нормализованной модели, но у нас также есть `name` и `thumbnailUrl` . Мы могли бы задержать `id` приложение и оставить в нем дополнительную информацию, необходимую в соответствующем документе автора, с помощью "Link", но поскольку наше приложение отображает имя автора и изображение эскиза с каждой книгой, мы можем сохранить круговой путь к серверу на каждую книгу в списке, выполнив нормализацию данных автора. 

Конечно, если имя автора изменилось или хотели бы обновить свою фотографию, нам пришлось бы перейти и обновить каждую книгу, опубликованную ранее, но для нашего приложения, исходя из предположения, что авторы не меняют имена часто, это приемлемое решение проекта.  

В этом примере имеются **предварительно вычисленные статистические** значения для сохранения дорогостоящей обработки операции чтения. В данном примере некоторые данные, внедренные в документ автора, вычисляются во время выполнения. Каждый раз при публикации новой книги создается документ книги, **и** для поля countOfBooks задается вычисленное значение, зависящее от числа существующих для данного автора документов книги. Такая оптимизация хорошо подходит для систем с большим количеством операций чтения, где можно выполнять вычисления в операциях записи для повышения производительности операций чтения.

Использование модели с предварительно вычисленными значениями в полях стало возможным благодаря тому, что Azure Cosmos DB поддерживает **транзакции с несколькими документами**. Многие хранилища NoSQL не позволяют выполнять транзакции между документами, что вынуждает слепо следовать правилу "всегда внедряйте все, что можно". В Azure Cosmos DB вы можете использовать триггеры на стороне сервера или хранимые процедуры, которые вставляют книги и обновляют авторов в рамках транзакции ACID. Теперь вам не **обязательно** внедрять все в один документ просто для того, чтобы обеспечить согласованность данных.

## <a name="distinguishing-between-different-document-types"></a>Различия между различными типами документов

В некоторых случаях может потребоваться смешивать различные типы документов в одной коллекции. Обычно это происходит, когда требуется, чтобы несколько связанных документов находились в одном [разделе](partitioning-overview.md). Например, можно разместить книги и обзоры книг в одной и той же коллекции и секционировать их по `bookId` . В такой ситуации обычно требуется добавить в документы поле, определяющее их тип, чтобы отличать их.

```json
Book documents:
{
    "id": "b1",
    "name": "Azure Cosmos DB 101",
    "bookId": "b1",
    "type": "book"
}

Review documents:
{
    "id": "r1",
    "content": "This book is awesome",
    "bookId": "b1",
    "type": "review"
},
{
    "id": "r2",
    "content": "Best book ever!",
    "bookId": "b1",
    "type": "review"
}
```

## <a name="next-steps"></a>Дальнейшие действия

Основная идея этой статьи заключается в том, что моделирование данных без фиксированных схем не теряет своей актуальности.

Как не существует единственного способа представить элемент данных на экране, нет такого способа и для моделирования данных. Необходимо разобраться в принципах работы приложения, его механизмах формирования, использования и обработки данных. После этого с помощью представленных здесь рекомендаций вы можете приступить к созданию модели, которая оптимально соответствует основным потребностям вашего приложения. Благодаря отсутствию схемы в базе данных вы можете оперативно вносить изменения в приложения и легко корректировать модель данных соответствующим образом.

Дополнительные сведения об Azure Cosmos DB см. на странице [документации](https://azure.microsoft.com/documentation/services/cosmos-db/) по этой службе.

Чтобы понять, как сегментировать данные по нескольким разделам, ознакомьтесь со статьей [Секционирование, ключи секции и масштабирование в DocumentDB](partitioning-overview.md).

Чтобы научиться моделировать и секционировать данные на Azure Cosmos DB с помощью практического примера, ознакомьтесь с [ разделом моделирование данных и секционирование — Real-World пример](how-to-model-partition-example.md).
