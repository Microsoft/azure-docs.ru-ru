---
title: Моделирование и секционирование данных на Azure Cosmos DB с помощью реального примера
description: Сведения о моделировании и секционировании на примере реального использования Azure Cosmos DB Core API
author: ThomasWeiss
ms.service: cosmos-db
ms.subservice: cosmosdb-sql
ms.topic: how-to
ms.date: 05/23/2019
ms.author: thweiss
ms.custom: devx-track-js
ms.openlocfilehash: d2f35ae7a6110acb2ca89bdaeb487eddabf84923
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "98185824"
---
# <a name="how-to-model-and-partition-data-on-azure-cosmos-db-using-a-real-world-example"></a>Процесс моделирования и секционирования данных в Azure Cosmos DB на примере реального использования
[!INCLUDE[appliesto-sql-api](includes/appliesto-sql-api.md)]

Эта статья основана на нескольких Azure Cosmos DB таких концепциях, как [моделирование данных](modeling-data.md), [секционирование](partitioning-overview.md)и [подготовленная пропускная способность](request-units.md) , чтобы продемонстрировать, как выполнять реальные упражнения по проектированию данных.

Если вы регулярно работаете с реляционными базами данных, у вас уже есть представление о моделях данных и определенный набор приемов по их созданию. Azure Cosmos DB имеет ряд уникальных преимуществ и специфичных ограничений. Поэтому многие традиционные рекомендации в этой среде плохо применимы и приводят к созданию неоптимальных решений. В этой статье наглядно демонстрируется полный процесс моделирования данных в Azure Cosmos DB на примере реального использования — от моделирования элементов до размещения сущностей и секционирования контейнеров.

[Скачайте или просмотрите созданный сообществом исходный код](https://github.com/jwidmer/AzureCosmosDbBlogExample) , иллюстрирующий основные понятия из этой статьи. Этот пример кода был создан участником сообщества, а группа Azure Cosmos DB не поддерживает его обслуживание.

## <a name="the-scenario"></a>Сценарий

В этом упражнении мы рассмотрим платформу для ведения блогов, на которой *пользователи* могут публиковать *записи*. Также они могут добавлять к этим записям *отметки "Нравится"* и текстовые *комментарии*.

> [!TIP]
> Несколько слов, которые здесь выделены *курсивом*, определяют характер сущностей и концепций, с которыми будет работать наша модель.

Давайте добавим к спецификации несколько конкретных требований:

- на титульной странице должен отображаться веб-канал недавно созданных записей;
- нужна возможность получить все записи определенного пользователя, все комментарии и (или) отметки "Нравится" по определенной записи;
- вместе с записью должны возвращаться имя пользователя автора этой записи, а также количество комментариев и отметок "Нравится";
- вместе с комментариями и отметками "Нравится" должны возвращаться имена пользователей, которые их создали;
- при отображении списков записей должна демонстрироваться только усеченная версия содержимого.

## <a name="identify-the-main-access-patterns"></a>Описание основных схем доступа

Сначала определим структуру для начальной спецификации, обозначив шаблоны доступа для нашего решения. При разработке модели данных для Azure Cosmos DB важно понять, какие операции будет обслуживать эта модель, чтобы повысить эффективность обработки этих запросов.

Чтобы упростить общий процесс, мы разделяем возможные операции на команды и запросы, используя термины из концепции [CQRS](https://en.wikipedia.org/wiki/Command%E2%80%93query_separation#Command_query_responsibility_segregation). Командами считаются операции записи (то есть с целью обновления информационной системы), а запросами — обращения только для чтения.

Вот список операций, которые можно будет выполнять на нашей платформе:

- **[C1]** Создание или изменение пользователя
- **[Q1]** Получение пользователя
- **[C2]**  — создание или изменение записи;
- **[Q2]**  — получение записи;
- **[Q3]** Выводить список записей пользователя в краткой форме
- **[C3]** Создание комментария
- **[Q4]** Список комментариев записи
- **[C4]**  — добавление к записи отметки "Нравится";
- **[Q5]**  — список отметок "Нравится" для записи;
- **[Q6]**  — список *x* самых свежих записей в краткой форме (веб-канал).

На этом этапе мы не будем думать о том, что будет содержать каждая сущность (пользователь, POST и т. д.). Как правило, этот шаг обычно выполняется в первую очередь при проектировании на основе реляционного хранилища, поскольку нам нужно выяснить, как эти сущности будут переноситься с точки зрения таблиц, столбцов, внешних ключей и т. д. Это гораздо меньше проблем с базой данных документов, которая не применяет схему при записи.

Поэтому схему доступа на раннем этапе нужно определять только для того, чтобы создать набор тестов на основе этого списка операций. При каждом очередном изменении модели данных мы будем выполнять каждую из этих операций, контролируя их производительность и масштабируемость. Мы вычисляем единицы запросов, потребляемые в каждой модели, и оптимизируют их. Все эти модели используют политику индексирования по умолчанию, и ее можно переопределить путем индексирования конкретных свойств, что может дополнительно улучшить потребление и задержку единиц запросов.

## <a name="v1-a-first-version"></a>V1: первая версия

Первыми объектами у нас будут два контейнера: `users` и `posts`.

### <a name="users-container"></a>Контейнер users

В этом контейнере хранятся только элементы с данными о пользователях:

```json
{
    "id": "<user-id>",
    "username": "<username>"
}
```

Для него мы выполним секционирование по `id`. То есть каждая логическая секция в этом контейнере будет содержать только один элемент.

### <a name="posts-container"></a>Контейнер posts

В этом контейнере размещаются записи, комментарии и отметки "Нравится":

```json
{
    "id": "<post-id>",
    "type": "post",
    "postId": "<post-id>",
    "userId": "<post-author-id>",
    "title": "<post-title>",
    "content": "<post-content>",
    "creationDate": "<post-creation-date>"
}

{
    "id": "<comment-id>",
    "type": "comment",
    "postId": "<post-id>",
    "userId": "<comment-author-id>",
    "content": "<comment-content>",
    "creationDate": "<comment-creation-date>"
}

{
    "id": "<like-id>",
    "type": "like",
    "postId": "<post-id>",
    "userId": "<liker-id>",
    "creationDate": "<like-creation-date>"
}
```

Для него мы выполним секционирование по `postId`, то есть каждая логическая секция в этом контейнере будет содержать одну запись, все комментарии и все отметки "Нравится" к ней.

Обратите внимание, что мы добавили свойство `type` в элементы, которые хранятся в этом контейнере, чтобы различать описанные выше три вида сущностей.

Кроме того, мы решили использовать ссылки на связанные данные вместо внедрения данных (сравнение этих концепций вы найдете [в этом разделе](modeling-data.md)), руководствуясь следующими факторами:

- верхний предел для количества созданных пользователем записей е предусмотрен;
- записи могут иметь произвольную длину;
- верхний предел для количества комментариев и (или) отметок "Нравится" для одной записи не предусмотрен;
- требуется возможность добавить к записи комментарий или отметку "Нравится", не обновляя саму запись.

## <a name="how-well-does-our-model-perform"></a>Насколько хорошо работает эта модель?

Пришло время оценить производительность и масштабируемость нашей первой версии. Для каждой из ранее определенных операций мы оценим задержку и количество потребляемых единиц запроса. Это измерение выполняется по фиктивному набору данных 100 000 пользователей, содержащему от 5 до 50 записей от каждого пользователя, а также не более 25 комментариев и 100 отметок "Нравится" для каждой записи.

### <a name="c1-createedit-a-user"></a>[C1] — создание или изменение пользователя

Этот запрос реализуется довольно просто: достаточно создать или обновить элемент в контейнере `users`. Такие запросы хорошо распределяются по всем секциям благодаря ключу секции `id`.

:::image type="content" source="./media/how-to-model-partition-example/V1-C1.png" alt-text="Запись одного элемента в контейнер users" border="false":::

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 7 мс | 5,71 ЕЗ | ✅ |

### <a name="q1-retrieve-a-user"></a>[Q1] — получение сведений о пользователе

Получение сведений о пользователе выполняется путем чтения соответствующего элемента из контейнера `users`.

:::image type="content" source="./media/how-to-model-partition-example/V1-Q1.png" alt-text="Получение одного элемента из контейнера users" border="false":::

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 2 мс | 1 ЕЗ | ✅ |

### <a name="c2-createedit-a-post"></a>[C2] — создание или изменение записи

Аналогично операции **[C1]**, выполняется путем записи в контейнер `posts`.

:::image type="content" source="./media/how-to-model-partition-example/V1-C2.png" alt-text="Запись одного элемента в контейнер posts" border="false":::

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 9 мс | 8,76 ЕЗ | ✅ |

### <a name="q2-retrieve-a-post"></a>[Q2] — получение записи

Сначала нужно извлечь соответствующий документ из контейнера `posts`. Но этого недостаточно, ведь согласно спецификации требуется предоставить имя пользователя автора записи, а также количество комментариев и отметок "Нравится" для этой записи. Для этого мы выполним еще три запроса SQL.

:::image type="content" source="./media/how-to-model-partition-example/V1-Q2.png" alt-text="Получение записи и дополнительных статистических данных" border="false":::

В каждом из дополнительных запросов применяется фильтр по ключу секционирования соответствующего контейнера. Это позволяет добиться максимальной производительности и масштабируемости. Но в итоге мы выполняем четыре операции для возврата одной записи. Это поведение мы улучшим в следующей итерации.

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 9 мс | 19,54 ЕЗ | ⚠ |

### <a name="q3-list-a-users-posts-in-short-form"></a>[Q3] — список записей пользователя в краткой форме

Сначала нам нужно извлечь требуемые записи с помощью запроса SQL, который возвращает записи по определенному пользователю. Также мы должны выполнить дополнительные запросы для получения имени пользователя автора, количества комментариев и отметок "Нравится".

:::image type="content" source="./media/how-to-model-partition-example/V1-Q3.png" alt-text="Получение всех записей пользователя и статистическая обработка дополнительных данных" border="false":::

Представленная реализация имеет несколько недостатков:

- сбор данных о количестве комментариев и отметок "Нравится" выполняется отдельно для каждой записи, которая получена в результатах первого запроса;
- основной запрос не использует фильтр по ключу раздела в контейнере `posts`, что приводит к размножению запросов и сканированию по всем разделам в контейнере.

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 130 мс | 619,41 ЕЗ | ⚠ |

### <a name="c3-create-a-comment"></a>[C3] — создание комментария

Комментарий создается путем сохранения соответствующего элемента в контейнер `posts`.

:::image type="content" source="./media/how-to-model-partition-example/V1-C2.png" alt-text="Запись одного элемента в контейнер posts" border="false":::

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 7 мс | 8,57 ЕЗ | ✅ |

### <a name="q4-list-a-posts-comments"></a>[Q4] — список комментариев к записи

Мы начинаем обработку с запроса, который позволяет извлечь все комментарии к нужной записи. Затем снова нужно получить имена пользователей отдельно для каждого комментария.

:::image type="content" source="./media/how-to-model-partition-example/V1-Q4.png" alt-text="Получение всех комментариев к записи и статистическая обработка дополнительных данных" border="false":::

Основной запрос позволяет отфильтровать данные контейнера по ключу секции, но раздельный сбор имен пользователей снижает общую производительность. Мы улучшим это поведение позже.

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 23 мс | 27,72 ЕЗ | ⚠ |

### <a name="c4-like-a-post"></a>[C4] — добавление к записи отметки "Нравится"

Так же, как и при выполнении операции **[C3]**, мы создаем нужные элемент в контейнере `posts`.

:::image type="content" source="./media/how-to-model-partition-example/V1-C2.png" alt-text="Запись одного элемента в контейнер posts" border="false":::

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 6 мс | 7,05 ЕЗ | ✅ |

### <a name="q5-list-a-posts-likes"></a>[Q5] — список отметок "Нравится" для записи

Так же, как и при выполнении операции **[Q4]**, мы запрашиваем отметки "Нравится" для нужной записи, а затем получаем для них имена пользователей.

:::image type="content" source="./media/how-to-model-partition-example/V1-Q5.png" alt-text="Получение всех отметок &quot;Нравится&quot; к записи и статистическая обработка дополнительных данных" border="false":::

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 59 мс | 58,92 ЕЗ | ⚠ |

### <a name="q6-list-the-x-most-recent-posts-created-in-short-form-feed"></a>[Q6] — список "x" самых свежих записей в краткой форме (веб-канал)

Мы запрашиваем последние записи из контейнера `posts`, отсортировав его по убыванию даты создания, а затем собираем имена пользователей и количество комментариев и отметок "Нравится" для каждой из записей.

:::image type="content" source="./media/how-to-model-partition-example/V1-Q6.png" alt-text="Получение самых свежих записей и статистическая обработка дополнительных данных" border="false":::

Опять же, наш первоначальный запрос не фильтрует ключ секции `posts` контейнера, который запускает дорогостоящее развертывание. Это еще хуже, так как мы нацелены на гораздо больший результирующий набор и отсортовать результаты с помощью `ORDER BY` предложения, которое делает его более дорогостоящим в плане единиц запросов.

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 306 мс | 2063,54 ЕЗ | ⚠ |

## <a name="reflecting-on-the-performance-of-v1"></a>Факторы, влияющие на производительность версии 1

Изучая проблемы с производительностью, которые мы обнаружили в предыдущем разделе, можно выделить два основных класса проблем:

- некоторые операции требуют выполнить несколько запросов для сбора всех нужных данных;
- некоторые запросы не используют ключ секции для фильтрации контейнеров, в результате чего создаются размноженные запросы с плохой масштабируемостью.

Давайте займемся устранением каждой из этих проблем, начиная с первой из них.

## <a name="v2-introducing-denormalization-to-optimize-read-queries"></a>V2. Введение в денормализацию для оптимизации запросов чтения

Дополнительные запросы в некоторых случаях создаются из-за того, что результаты первоначального запроса содержат не все данные, которые нам нужны. При работе с хранилищем нереляционных данных, таким как Azure Cosmos DB, подобные проблемы обычно решаются путем денормализации данных по всему набору данных.

В нашем примере мы изменим элементы записей, чтобы они содержали имя пользователя, число комментариев и отметок "Нравится":

```json
{
    "id": "<post-id>",
    "type": "post",
    "postId": "<post-id>",
    "userId": "<post-author-id>",
    "userUsername": "<post-author-username>",
    "title": "<post-title>",
    "content": "<post-content>",
    "commentCount": <count-of-comments>,
    "likeCount": <count-of-likes>,
    "creationDate": "<post-creation-date>"
}
```

Мы также изменим элементы комментариев и отметок "Нравится",чтобы они содержали имя пользователя, создавшего их:

```json
{
    "id": "<comment-id>",
    "type": "comment",
    "postId": "<post-id>",
    "userId": "<comment-author-id>",
    "userUsername": "<comment-author-username>",
    "content": "<comment-content>",
    "creationDate": "<comment-creation-date>"
}

{
    "id": "<like-id>",
    "type": "like",
    "postId": "<post-id>",
    "userId": "<liker-id>",
    "userUsername": "<liker-username>",
    "creationDate": "<like-creation-date>"
}
```

### <a name="denormalizing-comment-and-like-counts"></a>Денормализация счетчиков комментариев и отметок "Нравится"

Теперь нам нужно, чтобы при каждом добавлении комментария или отметки "Нравится" увеличивались значения `commentCount` или `likeCount` для соответствующей записи. Так как контейнер `posts` секционируется по `postId`, новый элемент (комментарий или отметка "Нравится") располагается в той же логической секции, что и соответствующая запись. Это позволяет нам использовать [хранимую процедуру](stored-procedures-triggers-udfs.md) для выполнения нужной операции.

Теперь, когда создается комментарий (операция **[C3]**), мы не просто добавляем новый элемент в контейнер `posts`, но и вызываем следующую хранимую процедуру в этом контейнере:

```javascript
function createComment(postId, comment) {
  var collection = getContext().getCollection();

  collection.readDocument(
    `${collection.getAltLink()}/docs/${postId}`,
    function (err, post) {
      if (err) throw err;

      post.commentCount++;
      collection.replaceDocument(
        post._self,
        post,
        function (err) {
          if (err) throw err;

          comment.postId = postId;
          collection.createDocument(
            collection.getSelfLink(),
            comment
          );
        }
      );
    })
}
```

Эта хранимая процедура принимает в качестве параметров идентификатор записи и текст нового комментария. Она предназначена для выполнения следующих действий:

- извлечение записи;
- увеличение значения `commentCount`;
- сохранение новых данных записи;
- добавление нового комментария.

Поскольку хранимые процедуры выполняются как атомарные транзакции, значение `commentCount` и фактическое количество комментариев всегда будут синхронизироваться.

Разумеется, мы применим аналогичную хранимую процедуру и для добавления новых отметок "Нравится", чтобы увеличивать значение `likeCount`.

### <a name="denormalizing-usernames"></a>Денормализация имен пользователей

Для имен пользователей нужен другой подход, так как они располагаются не только в разных секциях, но и в другом контейнере. Для денормализации данных в нескольких секциях и контейнерах можно использовать [веб-канал изменений](change-feed.md) исходного контейнера.

В нашем примере мы настроим канал изменений контейнера `users` таким образом, чтобы он реагировал на каждое изменение имен пользователей. Все эти изменения мы будем распространять с помощью другой хранимой процедуры из контейнера `posts`:

:::image type="content" source="./media/how-to-model-partition-example/denormalization-1.png" alt-text="Денормализация имен пользователей в контейнере posts" border="false":::

```javascript
function updateUsernames(userId, username) {
  var collection = getContext().getCollection();
  
  collection.queryDocuments(
    collection.getSelfLink(),
    `SELECT * FROM p WHERE p.userId = '${userId}'`,
    function (err, results) {
      if (err) throw err;

      for (var i in results) {
        var doc = results[i];
        doc.userUsername = username;

        collection.upsertDocument(
          collection.getSelfLink(),
          doc);
      }
    });
}
```

Эта хранимая процедура принимает в качестве параметров идентификатор пользователя и его новое имя пользователя. Она предназначена для выполнения следующих задач:

- Извлечение всех элементов, соответствующих условию `userId` (это могут быть записи, комментарии и отметки "Нравится").
- Для каждого из этих элементов:
  - заменяется параметр `userUsername`;
  - сохраняются новые данные элемента.

> [!IMPORTANT]
> Эта операция сопряжена со значительными затратами, так как хранимую процедуру придется выполнить в каждом разделе контейнера `posts`. Но мы полагаем, что большинство пользователей выбирают подходящее имя пользователя сразу при регистрации и никогда не изменяют его, а значит, такое обновление будет выполняться очень редко.

## <a name="what-are-the-performance-gains-of-v2"></a>Какие преимущества для производительности обеспечила версия 2?

### <a name="q2-retrieve-a-post"></a>[Q2] — получение записи

Теперь, когда мы настроили денормализацию, для обработки этого запроса достаточно получить один элемент.

:::image type="content" source="./media/how-to-model-partition-example/V2-Q2.png" alt-text="Получение одного элемента из контейнера posts" border="false":::

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 2 мс | 1 ЕЗ | ✅ |

### <a name="q4-list-a-posts-comments"></a>[Q4] — список комментариев к записи

Здесь мы также избавились от затрат на дополнительные запросы имен пользователей и оставили лишь один запрос с фильтрацией по ключу секции.

:::image type="content" source="./media/how-to-model-partition-example/V2-Q4.png" alt-text="Получение всех комментариев для записи" border="false":::

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 4 мс | 7,72 ЕЗ | ✅ |

### <a name="q5-list-a-posts-likes"></a>[Q5] — список отметок "Нравится" для записи

Аналогичный результат достигнут и для перечисления отметок "Нравится".

:::image type="content" source="./media/how-to-model-partition-example/V2-Q5.png" alt-text="Получение всех отметок &quot;Нравится&quot; для записи" border="false":::

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 4 мс | 8,92 ЕЗ | ✅ |

## <a name="v3-making-sure-all-requests-are-scalable"></a>V3: обеспечение масштабируемости всех запросов

Изучая достигнутые показатели производительности, мы видим две еще не полностью оптимизированных операции: **[Q3]** и **[Q6]**. Эти операции связаны с запросами, которые используют фильтрацию контейнеров по ключу секции.

### <a name="q3-list-a-users-posts-in-short-form"></a>[Q3] — список записей пользователя в краткой форме

В этот запрос в версии 2 уже были внесены улучшения, позволяющие избежать дополнительных запросов.

:::image type="content" source="./media/how-to-model-partition-example/V2-Q3.png" alt-text="Схема, на которой показан запрос для отображения записей пользователя в краткой форме." border="false":::

Но сохранившийся запрос по-прежнему не выполняет фильтрацию контейнера `posts` по ключу раздела.

К этой ситуации можно подойти достаточно простым способом.

1. Операция *должна* применять фильтр по `userId`, ведь мы хотим получить все записи конкретного пользователя.
1. Она работает неэффективно, так как применяется к контейнеру `posts`, который не секционирован по параметру `userId`.
1. Совершено очевидно, что эту проблему с производительностью можно решить, выполняя запрос к контейнеру, который *уже* секционирован по параметру `userId`.
1. И он у нас есть: это контейнер `users`!

Поэтому мы добавим второй уровень денормализации, дублируя все записи в контейнере `users`. Это даст нам, по сути, полную копию всех записей с секционированием по другим измерениям, что позволит более эффективно извлекать их по `userId`.

Контейнер `users` теперь содержит два вида элементов:

```json
{
    "id": "<user-id>",
    "type": "user",
    "userId": "<user-id>",
    "username": "<username>"
}

{
    "id": "<post-id>",
    "type": "post",
    "postId": "<post-id>",
    "userId": "<post-author-id>",
    "userUsername": "<post-author-username>",
    "title": "<post-title>",
    "content": "<post-content>",
    "commentCount": <count-of-comments>,
    "likeCount": <count-of-likes>,
    "creationDate": "<post-creation-date>"
}
```

Обратите внимание на следующее.

- Мы добавили поле `type` в элементе user, чтобы отличать записи от пользователей.
- Мы также добавили к элементу user поле `userId`, которое дублирует поле `id`. Оно нам нужно, так как контейнер `users` теперь секционируется по `userId` (а не по `id`, как ранее).

Чтобы выполнить эту денормализацию, мы снова применяем канал изменений. Теперь мы настроим реагирование по каналу изменений в контейнере `posts`, чтобы переносить в контейнер `users` все новые или измененные записи. Кроме того, так как список записей не нужно возвращать с полным содержимым, мы можем усекать их при обработке.

:::image type="content" source="./media/how-to-model-partition-example/denormalization-2.png" alt-text="Денормализация с переносом записей в контейнер users" border="false":::

Теперь наш запрос можно направить к контейнеру `users` и использовать фильтрацию по ключу секции этого контейнера.

:::image type="content" source="./media/how-to-model-partition-example/V3-Q3.png" alt-text="Получение всех записей пользователя" border="false":::

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 4 мс | 6,46 ЕЗ | ✅ |

### <a name="q6-list-the-x-most-recent-posts-created-in-short-form-feed"></a>[Q6] — список "x" самых свежих записей в краткой форме (веб-канал)

Ситуация здесь похожа на описанную выше: даже после удаления запросов, ставших ненужными после добавленной в версии 2 денормализации, оставшийся запрос не использует фильтрацию по ключу секции контейнера:

:::image type="content" source="./media/how-to-model-partition-example/V2-Q6.png" alt-text="Схема, на которой показан запрос для перечисления самых последних записей, созданных в краткой форме." border="false":::

Применяя тот же подход, производительность и масштабируемость этого запроса можно увеличить, ограничив область его действия одной секцией. Это вполне достижимо, так как возвращать нужно ограниченный набор элементов. Чтобы заполнить домашнюю страницу нашей платформы блогов достаточно лишь получить 100 самых последних записей, не перебирая весь набор данных.

Чтобы оптимизировать этот последний запрос, мы добавляем в архитектуру третий контейнер, полностью посвященный обслуживанию этого запроса. Добавим также денормализацию запросов в этот новый контейнер `feed`:

```json
{
    "id": "<post-id>",
    "type": "post",
    "postId": "<post-id>",
    "userId": "<post-author-id>",
    "userUsername": "<post-author-username>",
    "title": "<post-title>",
    "content": "<post-content>",
    "commentCount": <count-of-comments>,
    "likeCount": <count-of-likes>,
    "creationDate": "<post-creation-date>"
}
```

Этот контейнер секционируется по полю `type`, которое для наших элементов всегда имеет значение `post`. Это гарантирует, что все элементы в контейнере будут размещаться в одной секции.

Для достижения такой денормализации нужно лишь подключить конвейер канала изменений, который мы создали ранее, для передачи записей в новый контейнер. Здесь важно помнить один важный момент — нам нужно хранить только 100 самых последних записей, иначе размер контейнера может превысить максимальный размер секции. Для этого мы вызываем [триггер после операции](stored-procedures-triggers-udfs.md#triggers) при каждом добавлении документа в контейнер:

:::image type="content" source="./media/how-to-model-partition-example/denormalization-3.png" alt-text="Денормализация с переносом записей в контейнер веб-канала" border="false":::

Усечь коллекцию можно с помощью такого запроса:

```javascript
function truncateFeed() {
  const maxDocs = 100;
  var context = getContext();
  var collection = context.getCollection();

  collection.queryDocuments(
    collection.getSelfLink(),
    "SELECT VALUE COUNT(1) FROM f",
    function (err, results) {
      if (err) throw err;

      processCountResults(results);
    });

  function processCountResults(results) {
    // + 1 because the query didn't count the newly inserted doc
    if ((results[0] + 1) > maxDocs) {
      var docsToRemove = results[0] + 1 - maxDocs;
      collection.queryDocuments(
        collection.getSelfLink(),
        `SELECT TOP ${docsToRemove} * FROM f ORDER BY f.creationDate`,
        function (err, results) {
          if (err) throw err;

          processDocsToRemove(results, 0);
        });
    }
  }

  function processDocsToRemove(results, index) {
    var doc = results[index];
    if (doc) {
      collection.deleteDocument(
        doc._self,
        function (err) {
          if (err) throw err;

          processDocsToRemove(results, index + 1);
        });
    }
  }
}
```

И, наконец, мы переадресуем существующий запрос в новый контейнер `feed`:

:::image type="content" source="./media/how-to-model-partition-example/V3-Q6.png" alt-text="Извлечение самых последних записей" border="false":::

| **Задержка** | **Стоимость в ЕЗ** | **Производительность** |
| --- | --- | --- |
| 9 мс | 16,97 ЕЗ | ✅ |

## <a name="conclusion"></a>Заключение

Давайте подытожим улучшения общей производительности и масштабируемости, которые мы добавляли в разных версиях архитектуры.

| | V1 | V2 | V3 |
| --- | --- | --- | --- |
| **Тогда** | 7 мс / 5,71 ЕЗ | 7 мс / 5,71 ЕЗ | 7 мс / 5,71 ЕЗ |
| **Q1** | 2 мс / 1 ЕЗ | 2 мс / 1 ЕЗ | 2 мс / 1 ЕЗ |
| **'** | 9 мс / 8,76 ЕЗ | 9 мс / 8,76 ЕЗ | 9 мс / 8,76 ЕЗ |
| **Q2** | 9 мс / 19,54 ЕЗ | 2 мс / 1 ЕЗ | 2 мс / 1 ЕЗ |
| **Q3** | 130 мс / 619,41 ЕЗ | 28 мс / 201,54 ЕЗ | 4 мс / 6,46 ЕЗ |
| **Режим** | 7 мс / 8,57 ЕЗ | 7 мс / 15,27 ЕЗ | 7 мс / 15,27 ЕЗ |
| **Q4** | 23 мс / 27,72 ЕЗ | 4 мс / 7,72 ЕЗ | 4 мс / 7,72 ЕЗ |
| **C4** | 6 мс / 7,05 ЕЗ | 7 мс / 14,67 ЕЗ | 7 мс / 14,67 ЕЗ |
| **Вопрос 5** | 59 мс / 58,92 ЕЗ | 4 мс / 8,92 ЕЗ | 4 мс / 8,92 ЕЗ |
| **Вопрос 6** | 306 мс / 2063,54 ЕЗ | 83 мс / 532,33 ЕЗ | 9 мс / 16,97 ЕЗ |

### <a name="we-have-optimized-a-read-heavy-scenario"></a>Мы оптимизировали сценарий с интенсивной нагрузкой на чтение.

Вы могли заметить, что наши действия оптимизируют производительность операций чтения (запросов) в ущерб эффективности операций записи (команд). При операциях записи теперь часто запускаются действия денормализации через каналы изменений, что повышает затраты на их вычисление и длительность выполнения.

Это оправдано тем, что на платформе ведения блогов (как и многие другие социальные сети) выполняется много операций чтения. Количество обслуживаемых операций чтения обычно на несколько порядков выше, чем количество операций записи. Увеличение ресурсоемкости для операций записи позволяет снизить стоимость и повысить эффективность операций чтения.

Давайте рассмотрим пример самый существенный из представленных здесь приемов оптимизации. Операция **[Q6]** теперь требует только 17 ЕЗ вместо 2000 и более. Это достигается путем денормализации записей, повышающей затраты на сохранение каждой записи примерно на 10 ЕЗ. Так как запросы канала обновлений обслуживаются многократно чаще, чем создание или обновление записей, затраты на денормализацию можно считать несущественными по сравнению с увеличением эффективности.

### <a name="denormalization-can-be-applied-incrementally"></a>Денормализацию можно применять последовательно

Улучшения масштабируемости, которые мы рассматривали в этой статье, включают денормализацию и дублирование данных по всему набору данных. Важно отметить, что вы не обязаны применить все приемы оптимизации к первому дню работы. Запросы с фильтрацией по ключам секций дают более высокий эффект при больших масштабах, но запросы к нескольким секциям вполне допустимы, если они выполняются редко или по небольшому набору данных. Если вы создаете прототип или планируете работу с небольшой и контролируемой базой пользователей, можно отложить эти улучшения на будущее. При этом важно организовать [мониторинг](use-metrics.md) производительности модели, чтобы правильно определить момент для оптимизации.

В канале изменений, который мы используем для распространения обновлений в другие контейнеры, постоянно сохраняются все обновления. Это позволяет получить все обновления, реализованные с момента создания контейнера, и применить денормализованные представления в одной операции "наверстывания", даже если в системе накопился большой объем данных.

## <a name="next-steps"></a>Дальнейшие действия

Изучив эту вводную статью о моделировании и секционировании данных, вы можете перейти к следующим статьям с дополнительными сведениями о рассмотренных здесь понятиях:

- [Работа с базами данных, контейнерами и элементами](account-databases-containers-items.md)
- [Partitioning in Azure Cosmos DB](partitioning-overview.md) (Секционирование в Azure Cosmos DB)
- [Веб-канал изменений в Azure Cosmos DB](change-feed.md)
