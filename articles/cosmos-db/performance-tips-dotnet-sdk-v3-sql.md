---
title: Azure Cosmos DB советы по повышению производительности для пакета SDK для .NET v3
description: Узнайте о параметрах конфигурации клиента, которые помогут улучшить Azure Cosmos DB производительности пакета SDK для .NET v3.
author: j82w
ms.service: cosmos-db
ms.subservice: cosmosdb-sql
ms.topic: how-to
ms.date: 10/13/2020
ms.author: jawilley
ms.custom: devx-track-dotnet, contperf-fy21q2
ms.openlocfilehash: 06fb087744ff4ecd96bee7a26e4a796e87866322
ms.sourcegitcommit: ba676927b1a8acd7c30708144e201f63ce89021d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/07/2021
ms.locfileid: "102433681"
---
# <a name="performance-tips-for-azure-cosmos-db-and-net"></a>Советы по повышению производительности для .NET в Azure Cosmos DB
[!INCLUDE[appliesto-sql-api](includes/appliesto-sql-api.md)]

> [!div class="op_single_selector"]
> * [Пакет SDK версии 3 для .NET](performance-tips-dotnet-sdk-v3-sql.md)
> * [Пакет SDK для .NET версии 2](performance-tips.md)
> * [Пакет SDK для Java версии 4](performance-tips-java-sdk-v4-sql.md)
> * [Пакет SDK для Async Java версии 2](performance-tips-async-java.md)
> * [Пакет SDK для Sync Java версии 2](performance-tips-java.md)

Azure Cosmos DB — это быстрая, гибкая распределенная база данных, которая легко масштабируется с гарантированной задержкой и уровнями пропускной способности. Вам не нужно вносить существенные изменения в архитектуру или писать сложный код для масштабирования базы данных с Azure Cosmos DB. Для увеличения или уменьшения масштаба достаточно выполнить один вызов API. Дополнительные сведения см. в разделе [предоставление пропускной способности контейнера](how-to-provision-container-throughput.md) или [предоставление пропускной способности базы данных](how-to-provision-database-throughput.md). 

Поскольку доступ к Azure Cosmos DB осуществляется через сетевые вызовы, можно выполнять оптимизацию на стороне клиента для достижения пиковой производительности при использовании [пакета SDK для SQL .NET](sql-api-sdk-dotnet-standard.md).

Если вы пытаетесь повысить производительность базы данных, рассмотрите параметры, приведенные в следующих разделах.

## <a name="hosting-recommendations"></a>Рекомендации по размещению

**Для рабочих нагрузок с большим количеством запросов используйте Windows 64-bit, а не Windows 32-разрядная обработка узлов**

Для повышения производительности рекомендуется использовать Windows 64-разрядную обработку узлов. Пакет SDK для SQL содержит собственный файл ServiceInterop.dll для локального анализа и оптимизации запросов. ServiceInterop.dll поддерживается только на платформе Windows x64. 

Для Linux и других неподдерживаемых платформ, в которых ServiceInterop.dll недоступна, к шлюзу создается дополнительный сетевой вызов для получения оптимизированного запроса. 

Четыре типа приложений, перечисленные здесь, по умолчанию используют 32-разрядную обработку узла. Чтобы изменить обработку узла до 64-разрядной обработки для типа приложения, выполните следующие действия.

- **Для исполняемых приложений**: в окне **Свойства проекта** на панели **Сборка** задайте для параметра [Целевая платформа](/visualstudio/ide/how-to-configure-projects-to-target-platforms?preserve-view=true&view=vs-2019) значение **x64**.

- **Для тестовых проектов на основе VSTest**: в меню **тест** Visual **Studio выберите пункт**  >  **Параметры** тестирования, а затем задайте для параметра **архитектура процессора по умолчанию** значение **x64**.

- **Для локально развернутых веб-приложений ASP.NET**: выберите **инструменты**  >  **Параметры**  >  **проекты и решения**  >  **веб-проекты**, а затем выберите **использовать 64-разрядную версию IIS Express для веб-сайтов и проектов**.

- **Для веб-приложений ASP.NET, развернутых в Azure**: в портал Azure в окне **параметры приложения** выберите **64-разрядную** платформу.

> [!NOTE] 
> По умолчанию для новых проектов Visual Studio задан **любой ЦП**. Рекомендуется задать для проекта версию **x64** , чтобы не переключиться на **x86**. Проект, для которого задан **любой ЦП** , может легко переключиться на **x86** , если добавляется зависимость только для x86.<br/>
> Файл ServiceInterop.dll должен находиться в папке, из которой выполняется библиотека DLL пакета SDK. Это должно быть проблемой только в том случае, если вы вручную копируете библиотеки DLL или используете пользовательские системы сборки или развертывания.
    
**Включить сбор мусора на стороне сервера**

Уменьшение частоты сборки мусора может помочь в некоторых случаях. В .NET задайте для [gcServer](/dotnet/core/run-time-config/garbage-collector#flavors-of-garbage-collection) значение `true` .

**Масштабирование рабочей нагрузки клиента**

При тестировании на высоких уровнях пропускной способности или скорости, превышающей 50 000 единиц запросов в секунду, клиентское приложение может стать узким местом рабочей нагрузки. Это связано с тем, что компьютер может закончится при использовании ЦП или использования сети. Если вы достигли этой точки, то можете повысить производительность Azure Cosmos DB, развернув клиентские приложения на нескольких серверах.

> [!NOTE] 
> Высокая загрузка ЦП может привести к увеличению задержки и исключениям времени ожидания запроса.

## <a name="networking"></a>Сеть
<a id="direct-connection"></a>

**Политика подключения: использование режима прямого подключения**

Пакет SDK для .NET v3 по умолчанию имеет прямой режим соединения. Режим соединения настраивается при создании `CosmosClient` экземпляра в `CosmosClientOptions` .  Дополнительные сведения о различных вариантах подключения см. в статье [режимы подключения](sql-sdk-connection-modes.md) .

```csharp
string connectionString = "<your-account-connection-string>";
CosmosClient client = new CosmosClient(connectionString,
new CosmosClientOptions
{
    ConnectionMode = ConnectionMode.Gateway // ConnectionMode.Direct is the default
});
```

**Временная нехватка портов**

Если вы видите большой объем подключения или интенсивное использование портов на экземплярах, сначала убедитесь, что экземпляры клиента являются одноэлементными. Иными словами, экземпляры клиента должны быть уникальными в течение всего времени существования приложения.

При запуске по протоколу TCP клиент оптимизирует задержку, используя долгосрочные соединения. Это отличается от протокола HTTPS, который прерывает подключения после двух минут бездействия.

В сценариях, где имеется разреженный доступ, и если при сравнении с доступом к режиму шлюза вы заметили большее число подключений, вы можете:

* Настройте свойство [космосклиентоптионс. портреусемоде](/dotnet/api/microsoft.azure.cosmos.cosmosclientoptions.portreusemode) в значение `PrivatePortPool` (действующее с версиями платформы 4.6.1 и более поздних версий и .net Core версии 2,0 и более поздних). Это свойство позволяет пакету SDK использовать небольшой пул временных портов для различных конечных точек назначения Azure Cosmos DB.
* Задайте для свойства [космосклиентоптионс. IdleConnectionTimeout](/dotnet/api/microsoft.azure.cosmos.cosmosclientoptions.idletcpconnectiontimeout) значение больше или равное 10 минутам. Рекомендуемые значения — от 20 минут до 24 часов.

<a id="same-region"></a>

**Для повышения производительности выровнять клиенты в одном регионе Azure**

По возможности разместите приложения, вызывающие Azure Cosmos DB, в том же регионе, что и база данных Azure Cosmos DB. Ниже приведено приблизительное сравнение: вызовы Azure Cosmos DB в пределах одного региона завершаются в течение 1 миллисекунды (МС) до 2 мс, но задержка между Западом и Восточная регионом США составляет более 50 мс. Эта задержка может отличаться от запроса к запросу в зависимости от маршрута, выполняемого запросом по мере его передачи от клиента к границе центра обработки данных Azure. 

Вы можете получить наименьшую возможную задержку, убедившись, что вызывающее приложение находится в том же регионе Azure, что и подготовленная Azure Cosmos DBная конечная точка. Список доступных регионов см. на странице с [регионами Azure](https://azure.microsoft.com/regions/#services).

:::image type="content" source="./media/performance-tips/same-region.png" alt-text="Выровнять клиенты в одном регионе." border="false":::

   <a id="increase-threads"></a>

**Увеличение числа потоков и задач**

Поскольку вызовы Azure Cosmos DB выполняются по сети, может потребоваться изменить степень параллелизма запросов, чтобы клиентское приложение тратило минимальное время ожидания между запросами. Например, если вы используете [библиотеку параллельных задач](/dotnet/standard/parallel-programming/task-parallel-library-tpl).NET, создайте в порядке сотни задач, считывающих или записывающих Azure Cosmos DB.

**Включить ускоренную сеть**
 
Чтобы сократить задержку и нагрузку на ЦП, рекомендуется включить ускоренную сеть на клиентских виртуальных машинах. Дополнительные сведения см. в статьях [Создание виртуальной машины Windows с ускоренной сетью](../virtual-network/create-vm-accelerated-networking-powershell.md) или [Создание виртуальной машины Linux с ускоренной сетью](../virtual-network/create-vm-accelerated-networking-cli.md).

## <a name="sdk-usage"></a>Использование пакета SDK

**Установка последней версии пакета SDK**

Пакеты SDK для Azure Cosmos DB постоянно улучшаются, чтобы обеспечивать самую высокую производительность. Чтобы определить самый последний пакет SDK и просмотреть улучшения, см. раздел [Azure Cosmos DB SDK](sql-api-sdk-dotnet-standard.md).

**Использование API-интерфейсов потока**

[Пакет SDK для .NET v3](https://github.com/Azure/azure-cosmos-dotnet-v3) содержит API-интерфейсы потока, которые могут получать и возвращать данные без сериализации. 

Приложения среднего уровня, которые не используют ответы непосредственно из пакета SDK, но ретранслировать их на другие уровни приложений, могут воспользоваться преимуществами API-интерфейсов потока. Примеры обработки потоков см. в разделе примеры [управления элементами](https://github.com/Azure/azure-cosmos-dotnet-v3/blob/master/Microsoft.Azure.Cosmos.Samples/Usage/ItemManagement) .

**Используйте один и тот же клиент Azure Cosmos DB в течение всего жизненного цикла приложения.**

Каждый `CosmosClient` экземпляр является потокобезопасным и выполняет эффективное управление подключениями и кэширование адресов, когда оно работает в режиме Direct. Чтобы обеспечить эффективное управление подключениями и повысить производительность клиента пакета SDK, рекомендуется использовать один экземпляр в `AppDomain` течение всего времени существования приложения.

При работе с функциями Azure экземпляры также должны следовать существующим [рекомендациям](../azure-functions/manage-connections.md#static-clients) и поддерживать один экземпляр.

<a id="max-connection"></a>

**Отключить ответ содержимого при операциях записи**

Для рабочих нагрузок, имеющих большое количество полезных данных, установите `EnableContentResponseOnWrite` для параметра запроса значение `false` . Служба больше не будет возвращать созданный или обновленный ресурс пакету SDK. Как правило, так как приложение имеет создаваемый объект, служба не должна ее возвращать. Значения заголовков по-прежнему доступны, например плата за запрос. Отключение реагирования на содержимое может помочь повысить производительность, поскольку пакету SDK больше не требуется выделять память или сериализовать текст ответа. Это также сокращает использование пропускной способности сети для дальнейшей помощи в производительности.  

```csharp
ItemRequestOptions requestOptions = new ItemRequestOptions() { EnableContentResponseOnWrite = false };
ItemResponse<Book> itemResponse = await this.container.CreateItemAsync<Book>(book, new PartitionKey(book.pk), requestOptions);
// Resource will be null
itemResponse.Resource
```

**Включение групповой поддержки для оптимизации пропускной способности вместо задержки**

Включите *этот* параметр для сценариев, когда рабочей нагрузке требуется большой объем пропускной способности, а задержка не так важна. Дополнительные сведения о включении функции "несущее множество" и о том, какие сценарии следует использовать для, см. в разделе [Введение в сбор](https://devblogs.microsoft.com/cosmosdb/introducing-bulk-support-in-the-net-sdk)данных.

**Увеличение System.Net MaxConnections на узле при использовании режима шлюза**

При использовании режима шлюза запросы Azure Cosmos DB выполняются по протоколу HTTPS/RESTFUL. К ним применяются ограничения на количество подключений по умолчанию для каждого имени узла или IP-адреса. Может потребоваться задать `MaxConnections` более высокое значение (от 100 до 1 000), чтобы клиентская библиотека могла использовать несколько одновременных подключений к Azure Cosmos DB. В пакете SDK для .NET 1.8.0 и более поздних версиях значение по умолчанию для [ServicePointManager. DefaultConnectionLimit](/dotnet/api/system.net.servicepointmanager.defaultconnectionlimit) равно 50. Чтобы изменить значение, можно задать [`Documents.Client.ConnectionPolicy.MaxConnectionLimit`](/dotnet/api/microsoft.azure.documents.client.connectionpolicy.maxconnectionlimit) более высокое значение.

**Настройка параллельных запросов для секционированных коллекций**

Пакет SDK для SQL .NET поддерживает параллельные запросы, которые позволяют параллельно запрашивать секционированный контейнер. Дополнительные сведения см. в [примерах кода](https://github.com/Azure/azure-cosmos-dotnet-v3/blob/master/Microsoft.Azure.Cosmos.Samples/Usage/Queries/Program.cs) для работы с пакетами SDK. Параллельные запросы предназначены для обеспечения более высокой задержки и пропускной способности запросов, чем их последовательный аналог. 

Параллельные запросы предоставляют два параметра, которые можно настроить в соответствии с вашими требованиями. 

- **Максконкурренци**: управляет максимальным числом секций, к которым можно обращаться параллельно.

   Параллельный запрос работает путем параллельного запроса нескольких секций. Но данные из отдельных секций извлекаться последовательно по отношению к запросу. Параметр `MaxConcurrency` в [пакете SDK v3](https://github.com/Azure/azure-cosmos-dotnet-v3) , равный количеству секций, имеет лучший шанс достижения наиболее возможного запроса, при условии, что все остальные системные условия остаются прежними. Если число секций неизвестно, можно задать высокое значение степени параллелизма. В качестве степени параллелизма система выберет минимальное значение (число секций, предоставленных пользователем входных данных).

    Параллельные запросы обеспечивают наибольшее преимущество, если данные равномерно распределяются по всем секциям по отношению к запросу. Если секционированная коллекция секционирована таким образом, что все или большинство данных, возвращаемых запросом, Concentrated в нескольких секциях (в худшем случае это одна секция), эти секции приводят к снижению производительности запроса.
   
- **MaxBufferedItemCount**: управляет количеством предварительно выбранных результатов.

   Параллельный запрос предназначен для предварительного получения результатов, пока текущий пакет результатов обрабатывается клиентом. Такая предварительная выборка помогает повысить общую задержку запроса. `MaxBufferedItemCount`Параметр ограничивает количество предварительно выбранных результатов. Задайте `MaxBufferedItemCount` ожидаемое число возвращаемых результатов (или большее число), чтобы запрос получал максимальную пользу от предварительной выборки.

   Предварительная выборка работает так же, как независимо от степени параллелизма, и существует один буфер для данных из всех секций.  

**Реализация интервала задержки для RetryAfter**

Во время тестирования производительности следует увеличить нагрузку до тех пор, пока не будет отрегулировано небольшое количество запросов. Если запросы регулируемы, клиентское приложение должно отменить регулирование для указанного сервером интервала повторных попыток. В связи с этим переходом гарантируется минимальное количество времени, затрачиваемого на ожидание между повторными попытками. 

Дополнительные сведения см. в разделе [RetryAfter](/dotnet/api/microsoft.azure.cosmos.cosmosexception.retryafter#Microsoft_Azure_Cosmos_CosmosException_RetryAfter).
    
Существует механизм записи дополнительных диагностических сведений и устранения проблем задержки, как показано в следующем примере. Можно зарегистрировать строку диагностики для запросов с более высокой задержкой чтения. Захваченная строка диагностики поможет понять, сколько раз была получена ошибка *429* для данного запроса.

```csharp
ItemResponse<Book> readItemResponse = await this.cosmosContainer.ReadItemAsync<Book>("ItemId", new PartitionKey("PartitionKeyValue"));
readItemResponse.Diagnostics.ToString(); 
```

**Увеличение числа потоков и задач**

См. раздел [увеличение числа потоков и задач](#increase-threads) в разделе "Сетевые подключения" этой статьи.

## <a name="indexing-policy"></a>Политика индексации
 
**Увеличение скорости выполнения операций записи посредством исключения неиспользуемых путей из индексирования**

Политика индексирования Azure Cosmos DB также позволяет указать, какие пути документов следует включить в индексирование или исключить из него с помощью путей индексирования (IndexingPolicy. IncludedPaths и IndexingPolicy. ExcludedPaths). 

Индексирование только нужных путей может повысить производительность операций записи, сократить расходы на ЕДИНИЦу при операциях записи и сократить объем хранилища индексов для сценариев, в которых эти шаблоны запросов известны заранее. Это обусловлено тем, что стоимость индексирования напрямую соотносится с количеством уникальных путей. Например, в следующем коде показано, как исключить весь раздел документов (поддерево) из индексирования с помощью подстановочного знака "*":

```csharp
var containerProperties = new ContainerProperties(id: "excludedPathCollection", partitionKeyPath: "/pk" );
containerProperties.IndexingPolicy.IncludedPaths.Add(new IncludedPath { Path = "/*" });
containerProperties.IndexingPolicy.ExcludedPaths.Add(new ExcludedPath { Path = "/nonIndexedContent/*");
Container container = await this.cosmosDatabase.CreateContainerAsync(containerProperties);
```

Дополнительные сведения см. в статье [Политики индексации Azure Cosmos DB](index-policy.md).

## <a name="throughput"></a>Пропускная способность
<a id="measure-rus"></a>

**Измерение и настройка для более низкого использования единиц запросов/с**

Azure Cosmos DB предлагает обширный набор операций с базами данных. Эти операции включают в себя реляционные и иерархические запросы с файлами универсального формата диска (UDF), хранимыми процедурами и триггерами, которые работают с документами в коллекции баз данных. 

Затраты, связанные с каждой из этих операций, зависят от ЦП, операций ввода-вывода и объема памяти, необходимых для выполнения операции. Вместо того, чтобы думать об аппаратных ресурсах и управлении ими, можно представить единицу запроса как единую меру для ресурсов, необходимых для выполнения различных операций с базами данных и обслуживания запросов приложений.

Пропускная способность подготавливается на основе числа [единиц запросов](request-units.md) , заданных для каждого контейнера. Потребление единиц запросов оценивается как количество единиц на секунду. Приложения, превышающие подготовленную частоту единиц запросов для контейнера, будут ограничены до тех пор, пока скорость не станет ниже подготовленного уровня для контейнера. Если приложению требуется более высокий уровень пропускной способности, можно увеличить пропускную способность, выполнив подготовку дополнительных единиц запросов.

Сложность запроса влияет на количество единиц запроса, потребляемых операцией. Количество предикатов, характер предикатов, число файлов UDF и размер исходного набора данных влияют на стоимость операций запроса.

Чтобы измерить издержки любой операции (создания, обновления или удаления), просмотрите заголовок [x-MS-Request-расход](/rest/api/cosmos-db/common-cosmosdb-rest-response-headers) (или эквивалентное `RequestCharge` свойство в `ResourceResponse\<T>` или `FeedResponse\<T>` в пакете SDK для .NET), чтобы определить количество единиц запросов, потребляемых операциями:

```csharp
// Measure the performance (Request Units) of writes
ItemResponse<Book> response = await container.CreateItemAsync<Book>(myBook, new PartitionKey(myBook.PkValue));
Console.WriteLine("Insert of item consumed {0} request units", response.RequestCharge);
// Measure the performance (Request Units) of queries
FeedIterator<Book> queryable = container.GetItemQueryIterator<ToDoActivity>(queryString);
while (queryable.HasMoreResults)
    {
        FeedResponse<Book> queryResponse = await queryable.ExecuteNextAsync<Book>();
        Console.WriteLine("Query batch consumed {0} request units", queryResponse.RequestCharge);
    }
```             

Плата за запрос, возвращаемая в этом заголовке, является долей подготовленной пропускной способности (то есть 2 000 единиц запросов в секунду). Например, если предыдущий запрос возвращает документы 1 000 1-KB, стоимость операции будет 1 000. Таким образом, в течение одной секунды сервер учитывает только два таких запроса до того, как частота запросов будет превышена. Дополнительные сведения см. в разделе [единицы запроса](request-units.md) и [Калькулятор единиц запросов](https://www.documentdb.com/capacityplanner).
<a id="429"></a>

**Обработка ограничения скорости / слишком высокая частота запросов**

Когда клиент пытается превысить зарезервированную пропускную способность для учетной записи, на сервере нет снижения производительности и не будет использоваться пропускная способность, превышающая зарезервированный уровень. Сервер завершает запрос с помощью ошибкой requestratetoolarge (код состояния HTTP 429). Он возвращает заголовок [x-MS-Retry-After-MS](/rest/api/cosmos-db/common-cosmosdb-rest-response-headers) , который указывает время ожидания (в миллисекундах), по истечении которого пользователь должен выполнить запрос еще раз.

```xml
    HTTP Status 429,
    Status Line: RequestRateTooLarge
    x-ms-retry-after-ms :100
```

Пакеты SDK перехватят этот ответ, обработают заголовок retry-after, указанный сервером, и отправят запрос повторно. Если к вашей учетной записи параллельно имеет доступ только один клиент, следующая попытка будет успешной.

При наличии более чем одного клиента, постоянно работающего над частотой запросов, количество повторных попыток по умолчанию, которое в настоящее время установлено на 9, может оказаться недостаточным. В этом случае клиент выдает приложению исключение Космосексцептион с кодом состояния 429. 

Можно изменить число повторных попыток по умолчанию, задав `RetryOptions` для `CosmosClientOptions` экземпляра. По умолчанию Космосексцептион с кодом состояния 429 возвращается после совокупного времени ожидания 30 секунд, если запрос будет продолжать работать выше скорости запросов. Эта ошибка возвращается, даже если текущее число повторных попыток меньше максимального, независимо от того, является ли текущее значение значением по умолчанию 9 или значением, определенным пользователем.

Автоматическое поведение повторных попыток помогает повысить устойчивость и удобство использования для большинства приложений. Но это может не быть лучшим поведением при выполнении тестов производительности, особенно при измерении задержки. Если настройка производительности повлияла на регулирование сервера и стала причиной автоматической отправки запросов пакетом SDK, это может стать причиной появления пиков задержек на стороне клиента. Чтобы избежать всплесков задержки во время экспериментов производительности, следует измерять плату, возвращаемую каждой операцией, и обеспечить работу запросов ниже зарезервированной частоты запросов. 

Дополнительные сведения см. в разделе [единицы запроса](request-units.md).

**Для более высокой пропускной способности разрабатывать небольшие документы**

Плата за запрос (т. е. затраты на обработку запросов) указанной операции напрямую соотносится с размером документа. Операции с большими документами изменяют больше операций с малыми документами.

## <a name="next-steps"></a>Дальнейшие действия
Пример приложения, который используется для оценки Azure Cosmos DB для высокопроизводительных сценариев на нескольких клиентских компьютерах, см. в статье [Тестирование производительности и масштабирования с помощью Azure Cosmos DB](performance-testing.md).

Дополнительные сведения о создании приложения с высокой масштабируемостью и производительностью см. в статье [Partitioning and scaling in Azure Cosmos DB](partitioning-overview.md) (Секционирование и масштабирование в Azure Cosmos DB).