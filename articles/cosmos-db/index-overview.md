---
title: Индексирование в Azure Cosmos DB
description: Узнайте, как работает индексирование в Azure Cosmos DB, различные типы индексов, такие как диапазоны, пространственные, составные индексы, поддерживаются.
author: timsander1
ms.service: cosmos-db
ms.subservice: cosmosdb-sql
ms.topic: conceptual
ms.date: 05/21/2020
ms.author: tisande
ms.openlocfilehash: b7349a08b93810dcc3befd6058302d6c4573ab8d
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "98019335"
---
# <a name="indexing-in-azure-cosmos-db---overview"></a>Индексирование в Azure Cosmos DB — обзор
[!INCLUDE[appliesto-sql-api](includes/appliesto-sql-api.md)]

Azure Cosmos DB — это база данных без использования схем, которая позволяет выполнять итерацию приложения, не отвлекаясь на управление схемами или индексами. По умолчанию Azure Cosmos DB автоматически индексирует каждое свойство всех элементов в [контейнере](account-databases-containers-items.md#azure-cosmos-containers). Разработчикам не нужно определять схемы или настраивать вторичные индексы.

В статье описан способы индексирования данных в Azure Cosmos DB и использования индексов для повышения производительности запросов. Мы рекомендуем ознакомиться с ней перед изучением процедуры настройки [политик индексирования](index-policy.md).

## <a name="from-items-to-trees"></a>От элементов к деревьям

Каждый раз, когда элемент сохраняется в контейнере, его содержимое проецируется как документ JSON, а затем преобразуется в представление в виде дерева. Это означает, что каждое свойство этого элемента представлено в виде узла дерева. Псевдоузел корня создается как родительский элемент для всех свойств элемента первого уровня. Листовые узлы содержат фактические скалярные значения, перенесенные элементом.

Рассмотрим этот элемент в качестве примера:

```json
    {
        "locations": [
            { "country": "Germany", "city": "Berlin" },
            { "country": "France", "city": "Paris" }
        ],
        "headquarters": { "country": "Belgium", "employees": 250 },
        "exports": [
            { "city": "Moscow" },
            { "city": "Athens" }
        ]
    }
```

Он будет представлен в виде следующего дерева:

:::image type="content" source="./media/index-overview/item-as-tree.png" alt-text="Предыдущий элемент, представленный в виде дерева" border="false":::

Обратите внимание, как массивы кодируются в дереве: каждая запись в массиве получает промежуточный узел с меткой индекса этой записи в массиве (0, 1 и т. д.).

## <a name="from-trees-to-property-paths"></a>От деревьев к путям к свойствам

Причина, по которой Azure Cosmos DB преобразует элементы в деревья, заключается в том, что это позволяет ссылаться на свойства по путям в этих деревьях. Чтобы получить путь к свойству, мы можем перемещаться по дереву с корневого узла к этому свойстве и объединять метки каждого пройденного узла.

Ниже приведены пути для каждого свойства из примера элемента, описанного выше.

- /Locations/0/Country: "Германия"
- /Locations/0/City: "Берлин"
- /Locations/1/Country: "Франция"
- /Locations/1/City: "Париж"
- /хеадкуартерс/Каунтри: "Бельгия"
- /хеадкуартерс/емплойис: 250
- /EXPORTS/0/City: Москва
- /EXPORTS/1/City: «Афины»

При записи элемента Azure Cosmos DB эффективно индексирует путь каждого свойства и соответствующее ему значение.

## <a name="types-of-indexes"></a><a id="index-types"></a>Типы индексов

В настоящее время Azure Cosmos DB поддерживает три типа индексов. Эти типы индексов можно настроить при определении политики индексирования.

### <a name="range-index"></a>Индекс диапазона

Индекс **диапазона** основан на упорядоченной древовидной структуре. Тип индекса Range используется для:

- Запросы на равенство:

    ```sql
   SELECT * FROM container c WHERE c.property = 'value'
   ```

   ```sql
   SELECT * FROM c WHERE c.property IN ("value1", "value2", "value3")
   ```

   совпадение для элемента массива
   ```sql
    SELECT * FROM c WHERE ARRAY_CONTAINS(c.tags, "tag1")
    ```

- Запросы к диапазону:

   ```sql
   SELECT * FROM container c WHERE c.property > 'value'
   ```
  (для `>`, `<`, `>=`, `<=`, `!=`)

- Проверка наличия свойства:

   ```sql
   SELECT * FROM c WHERE IS_DEFINED(c.property)
   ```

- Строковые системные функции:

   ```sql
   SELECT * FROM c WHERE CONTAINS(c.property, "value")
   ```

   ```sql
   SELECT * FROM c WHERE STRINGEQUALS(c.property, "value")
   ```

- Запросы `ORDER BY`:

   ```sql
   SELECT * FROM container c ORDER BY c.property
   ```

- Запросы `JOIN`:

   ```sql
   SELECT child FROM container c JOIN child IN c.properties WHERE child = 'value'
   ```

Индексы диапазона можно использовать для скалярных значений (строка или число). Политика индексирования по умолчанию, задаваемая для только что созданных контейнеров, применяет диапазонные индексы для любых строк или чисел. Сведения о настройке индексов диапазонов см. в разделе [примеры политики индексации диапазонов](how-to-manage-indexing-policy.md#range-index)

### <a name="spatial-index"></a>Пространственный индекс

**Пространственные** индексы позволяют выполнять эффективные запросы к геопространственным объектам, таким как точки, линии и многоугольники. В этих запросах используются ключевые слова ST_DISTANCE, ST_WITHIN и ST_INTERSECTS. Ниже приведены некоторые примеры использования типа пространственного индекса.

- Геопространственные запросы расстояний:

   ```sql
   SELECT * FROM container c WHERE ST_DISTANCE(c.property, { "type": "Point", "coordinates": [0.0, 10.0] }) < 40
   ```

- Геопространственные запросы включения:

   ```sql
   SELECT * FROM container c WHERE ST_WITHIN(c.property, {"type": "Point", "coordinates": [0.0, 10.0] })
   ```

- Геопространственные запросы пересечения:

   ```sql
   SELECT * FROM c WHERE ST_INTERSECTS(c.property, { 'type':'Polygon', 'coordinates': [[ [31.8, -5], [32, -5], [31.8, -5] ]]  })  
   ```

Пространственные индексы можно использовать для правильно отформатированных объектов [GeoJSON](./sql-query-geospatial-intro.md). В настоящее время поддерживаются Points, LineStrings, Polygons и MultiPolygons. Чтобы использовать этот тип индекса, задайте с помощью `"kind": "Range"` свойства при настройке политики индексирования. Сведения о настройке пространственных индексов см. в разделе [примеры политики пространственного индексирования](how-to-manage-indexing-policy.md#spatial-index)

### <a name="composite-indexes"></a>Составные индексы

**Составные индексы** увеличивают эффективность выполнения операций над несколькими полями. Тип составного индекса используется для:

- Запросы `ORDER BY` к нескольким свойствам:

```sql
 SELECT * FROM container c ORDER BY c.property1, c.property2
```

- Запросы с фильтром и `ORDER BY`. Эти запросы могут использовать составной индекс, если свойство фильтра добавлено в предложение `ORDER BY`.

```sql
 SELECT * FROM container c WHERE c.property1 = 'value' ORDER BY c.property1, c.property2
```

- Запросы с фильтром для двух или более свойств, в которых по крайней мере одно свойство является фильтром проверки на равенство

```sql
 SELECT * FROM container c WHERE c.property1 = 'value' AND c.property2 > 'value'
```

До тех пор, пока один предикат фильтра использует один из типов индексов, обработчик запросов оценивает это перед продолжением проверки остальной части. Например, вас есть SQL-запрос `SELECT * FROM c WHERE c.firstName = "Andrew" and CONTAINS(c.lastName, "Liu")`

* Приведенный выше запрос сначала фильтрует записи со значением firstName = "Andrew", используя индекс. Затем он передает все записи firstName = "Andrew" через последующий конвейер для вычисления предиката CONTAINS.

* Вы можете ускорить запросы и избежать полной проверки при использовании функций, которые не используют индекс (например, CONTAINS), добавив дополнительные предикаты фильтра, которые используют этот индекс. Порядок предложений фильтра не важен. Обработчик запросов позволяет определить, какие предикаты являются более избирательными, и выполнить запрос соответствующим образом.

Дополнительные сведения о настройке составных индексов см. в разделе [примеры политики составного индексирования](how-to-manage-indexing-policy.md#composite-index)

## <a name="querying-with-indexes"></a>Выполнение запросов с использованием индексов

Пути, извлеченные при индексировании данных, упрощают поиск индекса при обработке запроса. Сопоставляя предложение `WHERE` запроса со списком индексированных путей, можно очень быстро выявить элементы, которые соответствуют предикату запроса.

Например, рассмотрим следующий запрос: `SELECT location FROM location IN company.locations WHERE location.country = 'France'`. Предикат запроса (фильтрация по элементам, где любое расположение имеет значение "France" в качестве страны или региона) соответствует пути, выделенному красным цветом:

:::image type="content" source="./media/index-overview/matching-path.png" alt-text="Сопоставление определенного пути в дереве" border="false":::

> [!NOTE]
> Предложение `ORDER BY`, которое упорядочивается по одному свойству, *всегда* требует индекс диапазона, и если у пути, на который оно ссылается, его нет, оно завершится ошибкой. Аналогичным образом запросу `ORDER BY`, который упорядочивается по нескольким свойствам, *всегда* требуется составной индекс.

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения об индексировании вы найдете в следующих статьях.

- [Политика индексирования](index-policy.md)
- [Управление политикой индексирования](how-to-manage-indexing-policy.md)