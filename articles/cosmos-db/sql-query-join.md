---
title: Запросы SQL JOIN для Azure Cosmos DB
description: Сведения о СОЕДИНЕНии нескольких таблиц в Azure Cosmos DB для запроса данных
author: timsander1
ms.service: cosmos-db
ms.subservice: cosmosdb-sql
ms.topic: conceptual
ms.date: 01/07/2021
ms.author: tisande
ms.openlocfilehash: cb7b2e62a9fabeeca675edb8e6aa356213e0999e
ms.sourcegitcommit: 42a4d0e8fa84609bec0f6c241abe1c20036b9575
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "98011413"
---
# <a name="joins-in-azure-cosmos-db"></a>Объединения в Azure Cosmos DB
[!INCLUDE[appliesto-sql-api](includes/appliesto-sql-api.md)]

В реляционной базе данных объединение между таблицами является логическим кокомпонентом для проектирования нормализованных схем. В отличие от этого, API SQL использует денормализованную модель данных элементов без схемы, которая является логическим эквивалентом *самосоединения*.

Объединения приводят к полному перекрестному произведению наборов, участвующих в соединении. Результатом других типов соединений является набор кортежей элементов того же типа, где каждое значение в кортеже связано с набором с псевдонимом, участвующим в соединении. Доступ к этому набору можно получить, создав ссылку на этот псевдоним в остальных предложениях.

## <a name="syntax"></a>Синтаксис

Язык поддерживает синтаксис `<from_source1> JOIN <from_source2> JOIN ... JOIN <from_sourceN>` . Этот запрос возвращает набор кортежей со `N` значениями. Каждый кортеж будет со значениями, полученными путем итерации всех псевдонимов контейнера среди их наборов. 

Рассмотрим следующее выражение FROM: `<from_source1> JOIN <from_source2> JOIN ... JOIN <from_sourceN>`.  
  
 Разрешите каждому источнику определить `input_alias1, input_alias2, …, input_aliasN`. Это предложение FROM возвращает набор N-кортежей (кортежей, у которых число значений равно N). Каждый кортеж будет со значениями, полученными путем итерации всех псевдонимов контейнера среди их наборов.  
  
**Пример 1** — 2 источника  
  
- Определите аргумент `<from_source1>` на уровне контейнера. Он должен представлять набор {A, Б, В}.  
  
- Определите аргумент `<from_source2>` на уровне документа и добавьте ссылку на input_alias1. Он должен представлять следующие наборы:  
  
    {1, 2} для `input_alias1 = A,`;  
  
    {3} для `input_alias1 = B,`;  
  
    {4, 5} для `input_alias1 = C,`.  
  
- В результате выполнения предложения FROM `<from_source1> JOIN <from_source2>` вернутся следующие кортежи:  
  
    (`input_alias1, input_alias2`):  
  
    `(A, 1), (A, 2), (B, 3), (C, 4), (C, 5)`  
  
**Пример 2** — 3 источника  
  
- Определите аргумент `<from_source1>` на уровне контейнера. Он должен представлять набор {A, Б, В}.  
  
- Определите аргумент `<from_source2>` на уровне документа и добавьте ссылку на `input_alias1`. Он должен представлять следующие наборы:  
  
    {1, 2} для `input_alias1 = A,`;  
  
    {3} для `input_alias1 = B,`;  
  
    {4, 5} для `input_alias1 = C,`.  
  
- Определите аргумент `<from_source3>` на уровне документа и добавьте ссылку на `input_alias2`. Он должен представлять следующие наборы:  
  
    {100, 200} для `input_alias2 = 1,`;  
  
    {300} для `input_alias2 = 3,`;  
  
- В результате выполнения предложения FROM `<from_source1> JOIN <from_source2> JOIN <from_source3>` вернутся следующие кортежи:  
  
    (input_alias1, input_alias2, input_alias3):  
  
    (A, 1, 100), (A, 1, 200), (B, 3, 300)  
  
  > [!NOTE]
  > Другие значения `input_alias1`, например `input_alias2`, для которых `<from_source3>` не вернул значения, не имеют кортежей.  
  
**Пример 3** — 3 источника  
  
- Определите аргумент <from_source1> на уровне контейнера. Он должен представлять набор {A, Б, В}.  
  
- Определите аргумент `<from_source1>` на уровне контейнера. Он должен представлять набор {A, Б, В}.  
  
- Определите аргумент <from_source2> на уровне документа и добавьте ссылку на input_alias1. Он должен представлять следующие наборы:  
  
    {1, 2} для `input_alias1 = A,`;  
  
    {3} для `input_alias1 = B,`;  
  
    {4, 5} для `input_alias1 = C,`.  
  
- Определите аргумент `<from_source3>` в области `input_alias1`. Он должен представлять следующие наборы:  
  
    {100, 200} для `input_alias2 = A,`;  
  
    {300} для `input_alias2 = C,`;  
  
- В результате выполнения предложения FROM `<from_source1> JOIN <from_source2> JOIN <from_source3>` вернутся следующие кортежи:  
  
    (`input_alias1, input_alias2, input_alias3`):  
  
    (A, 1, 100), (A, 1, 200), (A, 2, 100), (A, 2, 200),  (C, 4, 300) ,  (C, 5, 300)  
  
  > [!NOTE]
  > В результате этого соединения образовалось векторное произведение между `<from_source2>` и `<from_source3>`. Это связано с тем, что оба этих аргумента относятся к аргументу `<from_source1>`.  Это привело к созданию 4 (2 x 2) кортежей со значением A, 0 кортежей (1 x 0) со значением B и 2 (2x1) кортежей со значением C.  
  
## <a name="examples"></a>Примеры

Ниже приведены примеры, иллюстрирующие работу соединений. Перед выполнением этих примеров загрузите [данные семейства](sql-query-getting-started.md#upload-sample-data)примеров. В следующем примере результат пуст, так как перекрестное произведение каждого элемента из источника и пустого набора пусто:

```sql
    SELECT f.id
    FROM Families f
    JOIN f.NonExistent
```

Результат:

```json
    [{
    }]
```

В следующем примере соединение является перекрестным произведением между двумя объектами JSON, корнем элемента `id` и `children` подкорнем. Тот факт, что `children` является массивом, не эффективен в соединении, так как он работает с одним корнем, который является `children` массивом. Результат содержит только два результата, поскольку перекрестное произведение каждого элемента с массивом дает только один элемент.

```sql
    SELECT f.id
    FROM Families f
    JOIN f.children
```

Вы получите такие результаты:

```json
    [
      {
        "id": "AndersenFamily"
      },
      {
        "id": "WakefieldFamily"
      }
    ]
```

Следующий пример является более традиционным присоединением:

```sql
    SELECT f.id
    FROM Families f
    JOIN c IN f.children
```

Вы получите такие результаты:

```json
    [
      {
        "id": "AndersenFamily"
      },
      {
        "id": "WakefieldFamily"
      },
      {
        "id": "WakefieldFamily"
      }
    ]
```

Источник FROM предложения JOIN является итератором. Таким образом, последовательность в предыдущем примере:  

1. Разверните каждый дочерний элемент `c` в массиве.
2. Примените перекрестное произведение с корнем элемента `f` с каждым дочерним элементом `c` , сведенным к первому шагу.
3. Наконец, следует проецировать только свойство корневого объекта `f` `id` .

Первый элемент, `AndersenFamily` , содержит только один `children` элемент, поэтому результирующий набор содержит только один объект. Второй элемент, `WakefieldFamily` ,, содержит два `children` , поэтому перекрестный продукт создает два объекта, по одному для каждого `children` элемента. Корневые поля в обоих этих элементах будут такими же, как и ожидаемые при векторном произведении.

Реальная служебная программа предложения JOIN заключается в формировании кортежей из перекрестного произведения в фигуре, которая в противном случае усложняется для проекта. Приведенный ниже пример фильтрует по сочетанию кортежа, который позволяет пользователю выбрать условие, которое соответствует всем кортежам в целом.

```sql
    SELECT 
        f.id AS familyName,
        c.givenName AS childGivenName,
        c.firstName AS childFirstName,
        p.givenName AS petName
    FROM Families f
    JOIN c IN f.children
    JOIN p IN c.pets
```

Вы получите такие результаты:

```json
    [
      {
        "familyName": "AndersenFamily",
        "childFirstName": "Henriette Thaulow",
        "petName": "Fluffy"
      },
      {
        "familyName": "WakefieldFamily",
        "childGivenName": "Jesse",
        "petName": "Goofy"
      }, 
      {
       "familyName": "WakefieldFamily",
       "childGivenName": "Jesse",
       "petName": "Shadow"
      }
    ]
```

Следующее расширение предыдущего примера выполняет двойное соединение. Перекрестное произведение можно просмотреть в виде следующего псевдо-кода:

```
    for-each(Family f in Families)
    {
        for-each(Child c in f.children)
        {
            for-each(Pet p in c.pets)
            {
                return (Tuple(f.id AS familyName,
                  c.givenName AS childGivenName,
                  c.firstName AS childFirstName,
                  p.givenName AS petName));
            }
        }
    }
```

`AndersenFamily` имеет одного дочернего элемента с одним Pet, поэтому перекрестный продукт получает одну строку (1 \* 1 1 \* ) из этого семейства. `WakefieldFamily` имеет два дочерних элемента, только один из которых имеет pets, но этот дочерний элемент имеет два pets. Перекрестное произведение для этого семейства дает 1 \* 1 \* 2 = 2 строки.

В следующем примере имеется дополнительный фильтр для `pet` , исключающий все кортежи, в которых нет имени Pet `Shadow` . Можно создавать кортежи из массивов, фильтровать по любому элементу кортежа и проецировать любое сочетание элементов.

```sql
    SELECT 
        f.id AS familyName,
        c.givenName AS childGivenName,
        c.firstName AS childFirstName,
        p.givenName AS petName
    FROM Families f
    JOIN c IN f.children
    JOIN p IN c.pets
    WHERE p.givenName = "Shadow"
```

Вы получите такие результаты:

```json
    [
      {
       "familyName": "WakefieldFamily",
       "childGivenName": "Jesse",
       "petName": "Shadow"
      }
    ]
```

Если в запросе есть соединение и фильтры, можно переписать часть запроса в качестве [вложенного запроса](sql-query-subquery.md#optimize-join-expressions) для повышения производительности.

## <a name="next-steps"></a>Дальнейшие действия

- [Начало работы](sql-query-getting-started.md)
- [Примеры .NET для Azure Cosmos DB](https://github.com/Azure/azure-cosmosdb-dotnet)
- [Вложенные запросы](sql-query-subquery.md)