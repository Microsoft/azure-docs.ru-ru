---
title: Политики индексирования в Azure Cosmos DB
description: Узнайте, как настроить и изменить политику индексирования по умолчанию для автоматического индексирования и повышения производительности в Azure Cosmos DB.
author: timsander1
ms.service: cosmos-db
ms.subservice: cosmosdb-sql
ms.topic: conceptual
ms.date: 02/02/2021
ms.author: tisande
ms.openlocfilehash: 58ee3bcd0ba14359ea9adaa131b8280b81008b57
ms.sourcegitcommit: ea822acf5b7141d26a3776d7ed59630bf7ac9532
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/03/2021
ms.locfileid: "99526778"
---
# <a name="indexing-policies-in-azure-cosmos-db"></a>Indexing policy in Azure Cosmos DB (Политики индексации в Azure Cosmos DB)
[!INCLUDE[appliesto-sql-api](includes/appliesto-sql-api.md)]

В Azure Cosmos DB каждый контейнер имеет политику индексирования, определяющую, как должны индексироваться элементы контейнера. Политика индексирования по умолчанию, задаваемая для только что созданных контейнеров, индексирует каждое свойство каждого элемента и применяет диапазонные индексы для любых строк или чисел. Это позволяет получить хорошую производительность запросов без необходимости думать об индексировании и управлении индексами.

В некоторых ситуациях полезно переопределить автоматическое поведение в соответствии с конкретными требованиями. Политику индексирования контейнера можно настроить, задав ее *режим индексирования*, а также включить или исключить *пути к свойствам*.

> [!NOTE]
> Метод обновления политик индексации, описанный в этой статье, применим только к API-интерфейсу SQL (Core) Azure Cosmos DB. Дополнительные сведения об индексировании в [API Azure Cosmos DB для MongoDB](mongodb-indexing.md)

## <a name="indexing-mode"></a>Режим индексирования

Azure Cosmos DB поддерживает два режима индексирования:

- **Целостность**. индекс обновляется синхронно по мере создания, обновления или удаления элементов. Это означает, что согласованность запросов чтения будет согласована, [настроенной для учетной записи](consistency-levels.md).
- **Нет**: индексирование в контейнере отключено. Это часто используется, когда контейнер используется в качестве чистого хранилища значений ключа без необходимости в вторичных индексах. Его также можно использовать для повышения производительности операций с массовыми операциями. После выполнения операций с массовыми операциями в режиме индексирования можно задать значение consistent, а затем отслеживать его с помощью [IndexTransformationProgress](how-to-manage-indexing-policy.md#dotnet-sdk) до завершения.

> [!NOTE]
> Azure Cosmos DB также поддерживает режим отложенной индексации. Отложенное индексирование выполняет обновления индекса с более низкоприоритетным уровнем, когда обработчик не выполняет никаких других действий. Это может привести к **несогласованным или неполным** результатам запроса. Если вы планируете запрашивать контейнер Cosmos, не выбирайте отложенное индексирование. Новые контейнеры не могут выбрать Отложенное индексирование. Чтобы запросить исключение, обратитесь в [службу поддержки Azure](https://portal.azure.com/?#blade/Microsoft_Azure_Support/HelpAndSupportBlade) (за исключением случаев, когда вы используете учетную запись Azure Cosmos в режиме без [сервера](serverless.md) , который не поддерживает Отложенное индексирование).

По умолчанию для политики индексирования задано значение `automatic` . Это достигается путем задания `automatic` свойству в политике индексирования значения `true` . Задание этого свойства `true` позволяет Azure CosmosDB автоматически индексировать документы по мере их написания.

## <a name="index-size"></a><a id="index-size"></a>Размер индекса

В базе данных Azure Cosmos DB общий использованный объем хранилища зависит от размера данных и размера индекса. Ниже приведены некоторые функции размера индекса.

* Размер индекса зависит от политики индексирования. Если все свойства индексируются, размер индекса может быть больше, чем размер данных.
* При удалении данных индексы сжимаются почти непрерывно. Однако при небольших операциях удаления данных вы можете не заметить немедленного уменьшения размера индекса.
* Размер индекса может временно увеличиваться при разбиении физических секций. Место в индексе освобождается после завершения разбиения секции.

## <a name="including-and-excluding-property-paths"></a><a id="include-exclude-paths"></a>Включение и исключение путей к свойствам

Пользовательская политика индексации может указывать пути к свойствам, которые явно включены или исключены из индексирования. Оптимизируя Количество индексируемых путей, можно значительно сократить задержку и ЕДИНИЦу оплаты операций записи. Эти пути определяются [методом, описанным в разделе Обзор индексирования](index-overview.md#from-trees-to-property-paths) со следующими дополнениями.

- путь, ведущий к скалярному значению (строке или номеру), заканчивается на `/?`
- элементы из массива обрабатываются вместе с помощью `/[]` нотации (а не и `/0` `/1` т. д.).
- `/*`подстановочный знак можно использовать для сопоставления с любыми элементами, расположенными под узлом

Снова выполнив тот же пример:

```
    {
        "locations": [
            { "country": "Germany", "city": "Berlin" },
            { "country": "France", "city": "Paris" }
        ],
        "headquarters": { "country": "Belgium", "employees": 250 }
        "exports": [
            { "city": "Moscow" },
            { "city": "Athens" }
        ]
    }
```

- `headquarters` `employees` путь:`/headquarters/employees/?`

- `locations` `country` путь`/locations/[]/country/?`

- путь к любому элементу `headquarters` в разделе `/headquarters/*`

Например, можно включить `/headquarters/employees/?` путь. Этот путь обеспечит индексирование свойства Employees, но не будет индексировать дополнительный вложенный код JSON в этом свойстве.

## <a name="includeexclude-strategy"></a>Стратегия включения и исключения

Любая политика индексации должна включать корневой путь `/*` как либо включенный, либо Исключенный путь.

- Включите корневой путь для выборочного исключения путей, которые не нужно индексировать. Это рекомендуемый подход, так как он позволяет Azure Cosmos DB заранее индексировать любое новое свойство, которое может быть добавлено в модель.
- Исключите корневой путь для выборочного включения путей, которые необходимо проиндексировать.

- Для путей с обычными символами, включающими буквенно-цифровые символы и символ _ (подчеркивание), не нужно заключать строку пути вокруг двойных кавычек (например, "/Пас/?"). Для путей с другими специальными символами необходимо экранировать строку пути, заключенную в двойные кавычки (например, "/ \" path-ABC \" /?"). Если в пути предполагается наличие специальных символов, можно избежать последовательного переключения всех путей в целях безопасности. Функционально, это не имеет никакой разницы при экранировании всех путей и только тех, которые имеют специальные символы.

- По `_etag` умолчанию свойство System исключено из индексирования, если только ETag не добавлен в включаемый путь для индексирования.

- Если режим индексирования установлен в значение **consistent**, системные свойства `id` и `_ts` будут автоматически индексироваться.

При включении и исключении путей можно столкнуться со следующими атрибутами:

- `kind` может иметь значение `range` или `hash` . Поддержка хэш-индексов ограничена фильтрами равенства. Функциональность индекса диапазона предоставляет все функции хэш-индексов, а также эффективные операции сортировки, фильтры диапазонов, системные функции. Мы всегда рекомендуем использовать индекс диапазона.

- `precision` число, определенное на уровне индекса для включенных путей. Значение указывает на `-1` максимальную точность. Рекомендуется всегда задавать для этого параметра значение `-1` .

- `dataType` может иметь значение `String` или `Number` . Указывает типы свойств JSON, которые будут индексироваться.

Если этот параметр не указан, эти свойства будут иметь следующие значения по умолчанию:

| **Имя свойства**     | **Значение по умолчанию** |
| ----------------------- | -------------------------------- |
| `kind`   | `range` |
| `precision`   | `-1`  |
| `dataType`    | `String` и `Number` |

В [этом разделе](how-to-manage-indexing-policy.md#indexing-policy-examples) приведены примеры политик индексации для включения и исключения путей.

## <a name="includeexclude-precedence"></a>Приоритет включения или исключения

Если включенные пути и исключенные пути конфликтуют, приоритет имеет более точный путь.

Ниже приведен пример:

**Включаемый путь**: `/food/ingredients/nutrition/*`

**Исключенный путь**: `/food/ingredients/*`

В этом случае включенный путь имеет приоритет над исключенным путем, так как он более точен. На основе этих путей все данные в `food/ingredients` пути или вложенные в них будут исключены из индекса. Исключением могут быть данные внутри включаемого пути: `/food/ingredients/nutrition/*` , который будет индексироваться.

Ниже приведены некоторые правила для приоритета включенных и исключаемых путей в Azure Cosmos DB.

- Более глубокие пути более точны, чем более узкие пути. Например: `/a/b/?` более точно, чем `/a/?` .

- `/?`Более точнее, чем `/*` . Например `/a/?` , более точнее `/a/*` , чем так, `/a/?` имеет приоритет.

- Путь `/*` должен содержать либо включенный путь, либо Исключенный путь.

## <a name="spatial-indexes"></a>Пространственные индексы

При определении пространственного пути в политике индексации необходимо определить, какой индекс ```type``` следует применить к этому пути. К пространственным индексам могут относиться следующие типы:

* Точка

* Многоугольник

* MultiPolygon

* LineString

По умолчанию Azure Cosmos DB не создает пространственные индексы. Если вы хотите использовать встроенные функции пространственного SQL, необходимо создать пространственный индекс для обязательных свойств. В [этом разделе](sql-query-geospatial-index.md) приведены примеры политик индексации для добавления пространственных индексов.

## <a name="composite-indexes"></a>Составные индексы

Для запросов, имеющих `ORDER BY` предложение с двумя или более свойствами, требуется составной индекс. Кроме того, можно определить составной индекс, чтобы повысить производительность многих запросов на равенство и диапазонов. По умолчанию составные индексы не определяются, поэтому при необходимости следует [добавлять составные индексы](how-to-manage-indexing-policy.md#composite-index) .

В отличие от включенных или исключенных путей, нельзя создать путь с `/*` подстановочным знаком. Каждый составной путь имеет неявную `/?` в конце пути, который не нужно указывать. Составные пути ведут к скалярному значению, и это единственное значение, включенное в составной индекс.

При определении составного индекса необходимо указать:

- Два или более пути свойств. Последовательность, в которой определяются пути к свойствам, имеет значение.

- Порядок (по возрастанию или по убыванию).

> [!NOTE]
> При добавлении составного индекса запрос будет использовать существующие индексы диапазона до завершения добавления нового составного индекса. Таким образом, при добавлении составного индекса вы можете не сразу приступить к улучшению производительности. Ход преобразования индекса можно отслеживать с [помощью одного из пакетов SDK](how-to-manage-indexing-policy.md).

### <a name="order-by-queries-on-multiple-properties"></a>УПОРЯДОЧИТЬ по запросам для нескольких свойств:

Следующие рекомендации используются при использовании составных индексов для запросов с `ORDER BY` предложением с двумя или более свойствами:

- Если пути составного индекса не соответствуют последовательности свойств в `ORDER BY` предложении, составной индекс не поддерживает запрос.

- Порядок составных путей индексов (по возрастанию или по убыванию) должен также совпадать с параметром `order` в `ORDER BY` предложении.

- Составной индекс также поддерживает `ORDER BY` предложение с противоположным порядком для всех путей.

Рассмотрим следующий пример, где составной индекс определяется для свойств Name, Age и _ts.

| **Составной индекс**     | **Образец `ORDER BY` запроса**      | **Поддерживается составным индексом?** |
| ----------------------- | -------------------------------- | -------------- |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c ORDER BY c.name ASC, c.age asc``` | ```Yes```            |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c ORDER BY c.age ASC, c.name asc```   | ```No```             |
| ```(name ASC, age ASC)```    | ```SELECT * FROM c ORDER BY c.name DESC, c.age DESC``` | ```Yes```            |
| ```(name ASC, age ASC)```     | ```SELECT * FROM c ORDER BY c.name ASC, c.age DESC``` | ```No```             |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c ORDER BY c.name ASC, c.age ASC, timestamp ASC``` | ```Yes```            |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c ORDER BY c.name ASC, c.age ASC``` | ```No```            |

Необходимо настроить политику индексирования, чтобы можно было обслуживать все необходимые `ORDER BY` запросы.

### <a name="queries-with-filters-on-multiple-properties"></a>запросы с фильтрами по нескольким свойствам.

Если запрос имеет фильтры по двум или более свойствам, может оказаться полезным создать составной индекс для этих свойств.

Например, рассмотрим следующий запрос с фильтром равенства и диапазоном.

```sql
SELECT *
FROM c
WHERE c.name = "John" AND c.age > 18
```

Этот запрос будет более эффективным, что займет меньше времени и потребляет меньше единиц запросов, если он способен использовать составной индекс в `(name ASC, age ASC)` .

Запросы с несколькими фильтрами диапазонов также можно оптимизировать с помощью составного индекса. Однако каждый отдельный составной индекс может оптимизировать только один фильтр диапазона. Фильтры диапазонов включают `>` , `<` ,, `<=` `>=` и `!=` . Фильтр диапазона должен быть определен последним в составном индексе.

Рассмотрим следующий запрос с фильтром равенства и двумя фильтрами диапазона:

```sql
SELECT *
FROM c
WHERE c.name = "John" AND c.age > 18 AND c._ts > 1612212188
```

Этот запрос будет более эффективным с составным индексом в `(name ASC, age ASC)` и `(name ASC, _ts ASC)` . Однако запрос не будет использовать составной индекс, `(age ASC, name ASC)` так как свойства с фильтрами равенства должны быть определены первыми в составном индексе. Два отдельных составных индекса являются обязательными, а не одним составным индексом, `(name ASC, age ASC, _ts ASC)` так как каждый составной индекс может оптимизировать только один фильтр диапазона.

При создании составных индексов для запросов с фильтрами для нескольких свойств используются следующие рекомендации.

- Выражения фильтра могут использовать несколько составных индексов.
- Свойства в фильтре запроса должны соответствовать значениям в составном индексе. Если свойство находится в составном индексе, но не включено в запрос в качестве фильтра, то запрос не будет использовать составной индекс.
- Если запрос содержит дополнительные свойства в фильтре, которые не были определены в составном индексе, то для оценки запроса будет использоваться сочетание составного индекса и индекса диапазона. Для этого потребуется меньше единиц запросов, чем при использовании индексов диапазона.
- Если свойство имеет фильтр диапазона (,, `>` `<` `<=` , `>=` или `!=` ), то это свойство должно быть определено последним в составном индексе. Если запрос содержит более одного фильтра диапазона, может оказаться полезным использовать несколько составных индексов.
- При создании составного индекса для оптимизации запросов с несколькими фильтрами `ORDER` составной индекс не будет оказывать влияния на результаты. Это необязательное свойство.

Рассмотрим следующие примеры, где составной индекс определяется по имени, возрасту и метке свойства.

| **Составной индекс**     | **Образец запроса**      | **Поддерживается составным индексом?** |
| ----------------------- | -------------------------------- | -------------- |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c WHERE c.name = "John" AND c.age = 18``` | ```Yes```            |
| ```(name ASC, age ASC)```   | ```SELECT * FROM c WHERE c.name = "John" AND c.age > 18```   | ```Yes```             |
| ```(name ASC, age ASC)```   | ```SELECT COUNT(1) FROM c WHERE c.name = "John" AND c.age > 18```   | ```Yes```             |
| ```(name DESC, age ASC)```    | ```SELECT * FROM c WHERE c.name = "John" AND c.age > 18``` | ```Yes```            |
| ```(name ASC, age ASC)```     | ```SELECT * FROM c WHERE c.name != "John" AND c.age > 18``` | ```No```             |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age = 18 AND c.timestamp > 123049923``` | ```Yes```            |
| ```(name ASC, age ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age < 18 AND c.timestamp = 123049923``` | ```No```            |
| ```(name ASC, age ASC) and (name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.name = "John" AND c.age < 18 AND c.timestamp > 123049923``` | ```Yes```            |

### <a name="queries-with-a-filter-and-order-by"></a>Запросы с фильтром и ORDER BY

Если запрос фильтрует одно или несколько свойств и имеет различные свойства в предложении ORDER BY, может быть полезно добавить свойства в фильтр в `ORDER BY` предложение.

Например, добавив свойства в фильтр в `ORDER BY` предложение, можно переписывать следующий запрос, чтобы использовать составной индекс:

Запрос с использованием индекса диапазона:

```sql
SELECT *
FROM c 
WHERE c.name = "John" 
ORDER BY c.timestamp
```

Запрос с использованием составного индекса:

```sql
SELECT * 
FROM c 
WHERE c.name = "John"
ORDER BY c.name, c.timestamp
```

Одни и те же оптимизации запросов могут быть обобщены для `ORDER BY` запросов с фильтрами, учитывая, что отдельные составные индексы могут поддерживать только один фильтр диапазона.

Запрос с использованием индекса диапазона:

```sql
SELECT * 
FROM c 
WHERE c.name = "John" AND c.age = 18 AND c.timestamp > 1611947901 
ORDER BY c.timestamp
```

Запрос с использованием составного индекса:

```sql
SELECT * 
FROM c 
WHERE c.name = "John" AND c.age = 18 AND c.timestamp > 1611947901 
ORDER BY c.name, c.age, c.timestamp
```

Кроме того, можно использовать составные индексы для оптимизации запросов с помощью системных функций и УПОРЯДОЧЕНия:

Запрос с использованием индекса диапазона:

```sql
SELECT * 
FROM c 
WHERE c.firstName = "John" AND Contains(c.lastName, "Smith", true) 
ORDER BY c.lastName
```

Запрос с использованием составного индекса:

```sql
SELECT * 
FROM c 
WHERE c.firstName = "John" AND Contains(c.lastName, "Smith", true) 
ORDER BY c.firstName, c.lastName
```

Следующие рекомендации используются при создании составных индексов для оптимизации запроса с помощью фильтра и `ORDER BY` предложения.

* Если не определить составной индекс для запроса с фильтром по одному свойству и отдельным `ORDER BY` предложением с другим свойством, запрос будет выполняться. Однако стоимость единицы запроса может быть сокращена с помощью составного индекса, особенно если свойство в `ORDER BY` предложении имеет большую кратность.
* Если запрос фильтрует свойства, они должны быть включены в `ORDER BY` предложение первыми.
* Если запрос фильтруется по нескольким свойствам, фильтры равенства должны быть первыми свойствами в `ORDER BY` предложении.
* Если запрос фильтруется по нескольким свойствам, то для составного индекса можно использовать не более одного фильтра диапазона или системной функции. Свойство, используемое в фильтре диапазона или системной функции, должно быть определено последним в составном индексе.
* Все вопросы, касающиеся создания составных индексов для `ORDER BY` запросов с несколькими свойствами, а также запросы с фильтрами по нескольким свойствам, по-прежнему применяются.


| **Составной индекс**                      | **Образец `ORDER BY` запроса**                                  | **Поддерживается составным индексом?** |
| ---------------------------------------- | ------------------------------------------------------------ | --------------------------------- |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.name ASC, c.timestamp ASC``` | `Yes` |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" AND c.timestamp > 1589840355 ORDER BY c.name ASC, c.timestamp ASC``` | `Yes` |
| ```(timestamp ASC, name ASC)```          | ```SELECT * FROM c WHERE c.timestamp > 1589840355 AND c.name = "John" ORDER BY c.timestamp ASC, c.name ASC``` | `No` |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp ASC, c.name ASC``` | `No`  |
| ```(name ASC, timestamp ASC)```          | ```SELECT * FROM c WHERE c.name = "John" ORDER BY c.timestamp ASC``` | ```No```   |
| ```(age ASC, name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.age = 18 and c.name = "John" ORDER BY c.age ASC, c.name ASC,c.timestamp ASC``` | `Yes` |
| ```(age ASC, name ASC, timestamp ASC)``` | ```SELECT * FROM c WHERE c.age = 18 and c.name = "John" ORDER BY c.timestamp ASC``` | `No` |

## <a name="index-transformationmodifying-the-indexing-policy"></a><преобразование индекса>изменение политики индексирования

Политику индексирования контейнера можно обновить в любое время с [помощью портал Azure или одного из поддерживаемых пакетов SDK](how-to-manage-indexing-policy.md). Обновление политики индексирования активирует преобразование старого индекса в новый, который выполняется в сети и на месте (поэтому дополнительное пространство для хранения данных во время операции не потребляется). Старая политика индексирования эффективно преобразуется в новую политику, не влияя на доступность записи, доступность чтения или пропускную способность, подготовленную в контейнере. Преобразование индекса — это асинхронная операция, а время, необходимое для выполнения, зависит от подготовленной пропускной способности, количества элементов и их размера.

> [!IMPORTANT]
> Преобразование «индекс» — это операция, использующая [единицы запросов](request-units.md). Единицы запросов, потребляемые преобразованием индекса, в настоящее время не взимается, если используются [бессерверные](serverless.md) контейнеры. Счета за эти единицы запроса будут выставляться после общедоступной доступности на сервере.

> [!NOTE]
> Ход преобразования индекса можно отслеживать с [помощью одного из пакетов SDK](how-to-manage-indexing-policy.md).

На запись доступности во время любых преобразований индекса не влияет. Преобразование «индекс» использует подготовленный метод отправки, но с более низким приоритетом, чем операции CRUD или запросы.

При добавлении нового индекса влияния на чтение доступности не возникает. Запросы будут использовать новые индексы только после завершения преобразования индекса. Во время преобразования индекса обработчик запросов будет продолжать использовать существующие индексы, поэтому во время преобразования индексирования вы научитесь выполнять аналогичные операции чтения до начала изменения индексирования. При добавлении новых индексов также возникает риск неполного или несоответствия результатов запроса.

При удалении индексов и немедленном выполнении запросов, использующих фильтрацию по удаленным индексам, не гарантируется согласованность или полнота результатов запроса. Если удалить несколько индексов и сделать это в одном изменении одной политики индексирования, то обработчик запросов будет выполнять согласованные и полные результаты в рамках преобразования «индекс». Однако при удалении индексов с помощью нескольких изменений политики индексирования обработчик запросов не будет предоставлять согласованные или полные результаты до завершения всех преобразований индекса. Большинство разработчиков не удаляют индексы, а затем сразу же пытаются выполнить запросы, использующие эти индексы, так что на практике такая ситуация маловероятно.

> [!NOTE]
> Там, где это возможно, всегда следует попытаться сгруппировать несколько изменений индексирования в одно изменение одной политики индексирования.

## <a name="indexing-policies-and-ttl"></a>Политики индексирования и TTL

Для использования [функции срока жизни (TTL)](time-to-live.md) требуется индексирование. Это означает следующее.

- невозможно активировать TTL для контейнера, для которого задан режим индексирования `none` ,
- невозможно задать для режима индексирования значение None в контейнере, где активирован TTL.

В сценариях, где не требуется индексировать свойства, но требуется TTL, можно использовать политику индексирования с режимом индексирования, для которого задано значение `consistent` , нет включенных путей и `/*` как единственный исключаемый путь.

## <a name="next-steps"></a>Следующие шаги

Дополнительные сведения об индексировании см. по следующим ссылкам:

- [Общие сведения об индексировании](index-overview.md)
- [Управление политикой индексирования](how-to-manage-indexing-policy.md)
