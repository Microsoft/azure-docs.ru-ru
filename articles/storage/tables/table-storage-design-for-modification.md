---
title: Создание табличного хранилища Azure для изменения данных | Документация Майкрософт
description: Проектирование таблиц для изменения данных в хранилище таблиц Azure. Оптимизируйте операции вставки, обновления и удаления. Обеспечьте согласованность хранимых сущностей.
services: storage
ms.service: storage
author: tamram
ms.author: tamram
ms.topic: article
ms.date: 04/23/2018
ms.subservice: tables
ms.openlocfilehash: 25785bc4b945f469e67f2a71eb6676940e091d56
ms.sourcegitcommit: 772eb9c6684dd4864e0ba507945a83e48b8c16f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "88236766"
---
# <a name="design-for-data-modification"></a>Разработка для изменения данных
В этой статье рассматриваются вопросы разработки для оптимизации операций вставки, обновления и удаления. В некоторых случаях будет необходимо тщательно проанализировать модели оптимизации запросов и модели оптимизации изменения данных. Действия выполняются так же, как в модели для реляционных баз данных (несмотря на то, что в реляционной базе данных существуют другие методы управления компромиссами при разработке). В разделе "Шаблоны для разработки таблиц" приводится описание шаблонов разработки для службы таблиц и рассматриваются некоторые компромиссные варианты. На практике вы увидите, что многие модели, оптимизированные для выполнения запросов к сущностям, также хорошо подходят для изменения сущностей.  

## <a name="optimize-the-performance-of-insert-update-and-delete-operations"></a>Оптимизация производительности операций вставки, обновления и удаления
Чтобы обновить или удалить сущность, ее необходимо определить с помощью значений **PartitionKey** и **RowKey**. В связи с этим при выборе значений **PartitionKey** и **RowKey** для изменения сущностей следует придерживаться тех же условий, которые действуют для поддержки точечных запросов. Это позволит максимально эффективно определять сущности. Следует исключить неэффективный просмотр раздела или таблицы для поиска сущности с целью обнаружения значений **PartitionKey** и **RowKey**, необходимых для ее обновления или удаления.  

Следующие шаблоны в разделе "Шаблоны для разработки таблиц" позволяют оптимизировать производительность операций вставки, обновления и удаления.  

* [Шаблон для удаления больших объемов сущностей](table-storage-design-patterns.md#high-volume-delete-pattern) — включение операции удаления больших объемов сущностей за счет сохранения всех сущностей для одновременного удаления в отдельной таблице. Удаление сущностей происходит при удалении таблицы.  
* [Шаблон для рядов данных](table-storage-design-patterns.md#data-series-pattern) — хранение целых рядов данных в одной сущности для сокращения количества выполняемых запросов.  
* [Шаблон для масштабных сущностей](table-storage-design-patterns.md#wide-entities-pattern) — использование нескольких физических сущностей для хранения логических сущностей с более чем 252 свойствами.  
* [Шаблон для сущностей больших размеров](table-storage-design-patterns.md#large-entities-pattern) — для хранения больших по объему значений свойств используйте хранилище больших двоичных объектов.  

## <a name="ensure-consistency-in-your-stored-entities"></a>Обеспечение согласованности хранимых сущностей
Другим фактором, который влияет на выбор ключей для оптимизации изменения данных, является обеспечение согласованности с помощью атомарных операций. Транзакции группы сущностей можно использовать только для работы с сущностями, хранящимися в одном разделе.  

Следующие шаблоны в разделе [Шаблоны для разработки таблиц](table-storage-design-patterns.md) предназначены для управления согласованностью.  

* [Шаблон вторичного индекса внутри раздела](table-storage-design-patterns.md#intra-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности с помощью различных значений **RowKey** (в одной секции) для обеспечения быстрого и эффективного поиска и альтернативных порядков сортировки с использованием различных значений **RowKey** .  
* [Шаблон вторичного индекса в разных разделах](table-storage-design-patterns.md#inter-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности с помощью различных значений RowKey в отдельных разделах или отдельных таблицах для выполнения быстрых и эффективных операций поиска и активации альтернативных порядков сортировки с помощью различных значений **RowKey**.  
* [Шаблон для согласованных транзакций](table-storage-design-patterns.md#eventually-consistent-transactions-pattern) — обеспечение согласованного поведения в рамках границ раздела или границ системы хранения с помощью запросов Azure.
* [Шаблон сущностей индекса](table-storage-design-patterns.md#index-entities-pattern) — поддержание сущностей индекса для обеспечения эффективного поиска, возвращающего списки сущностей.  
* [Шаблон денормализации](table-storage-design-patterns.md#denormalization-pattern) — объединение связанных данных в одной сущности для извлечения необходимых данных с помощью одного точечного запроса.  
* [Шаблон для рядов данных](table-storage-design-patterns.md#data-series-pattern) — хранение целых рядов данных в одной сущности для сокращения количества выполняемых запросов.  

Сведения о транзакциях группы сущностей см. в разделе [транзакции группы сущностей](table-storage-design.md#entity-group-transactions).  

## <a name="ensure-your-design-for-efficient-modifications-facilitates-efficient-queries"></a>Использование эффективных запросов в разработке для эффективных изменений
Во многих случаях разработка эффективных запросов способствует эффективным изменениям. Однако в каждом конкретном случае всегда следует проверять, так ли это. Некоторые шаблоны в разделе [Шаблоны для разработки таблиц](table-storage-design-patterns.md) позволяют явным образом сопоставить выгоды и недостатки процессов создания запросов и изменения сущностей. Вместе с этим всегда необходимо учитывать количество операций каждого типа.  

Следующие шаблоны в разделе [Шаблоны для разработки](table-storage-design-patterns.md) таблиц предназначены для определения компромиссных вариантов между разработкой для эффективных запросов и разработкой для эффективного изменения данных.  

* [Шаблон составного ключа](table-storage-design-patterns.md#compound-key-pattern) — использование составных значений **RowKey** для предоставления клиенту возможности выполнять поиск связанных данных с помощью одного точечного запроса.  
* [Шаблон для заключительного фрагмента журнала](table-storage-design-patterns.md#log-tail-pattern) — извлечение *n* сущностей, недавно добавленных в раздел, с помощью значения **RowKey** , выполняющего сортировку по дате и времени в обратном порядке.  
