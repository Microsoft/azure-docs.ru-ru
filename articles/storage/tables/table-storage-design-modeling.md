---
title: Моделирование отношений в структуре хранилища таблиц Azure | Документация Майкрософт
description: Изучите процесс моделирования при проектировании решения для хранения таблиц Azure. Узнайте о связях «один ко многим», «один к одному» и «наследование».
services: storage
ms.service: storage
author: tamram
ms.author: tamram
ms.topic: article
ms.date: 04/23/2018
ms.subservice: tables
ms.openlocfilehash: 3023b478ef7a4aaf6d9239e997bdf63282b56210
ms.sourcegitcommit: 772eb9c6684dd4864e0ba507945a83e48b8c16f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "88271198"
---
# <a name="modeling-relationships"></a>Моделирование отношений
В этой статье рассматривается процесс моделирования при разработке решений хранилища таблиц Azure.

Построение модели предметной области является одним из ключевых этапов при разработке комплексных систем. Как правило, процесс моделирования используется для определения сущностей и отношений между ними. Это позволяет понять направление бизнес-деятельности и представить структуру системы. В этом разделе рассматривается процедура преобразования некоторых распространенных типов отношений, присутствующих в моделях предметной области, в схемы для службы таблиц. Процесс сопоставления логической модели данных с физической моделью данных на базе NoSQL отличается от аналогичного процесса, используемого при проектировании реляционной базы данных. При разработке реляционных баз данных обычно предполагается наличие таких компонентов, как оптимизированный процесс нормализации данных для сведения к минимуму избыточности и возможность выполнения декларативных запросов, которая абстрагирует процесс реализации базы данных.  

## <a name="one-to-many-relationships"></a>Отношения «один-ко-многим»
Отношения "один-ко-многим" между бизнес-объектами являются распространенными. Например, в одном отделе работает много сотрудников. Существует несколько способов реализации отношений «один-ко-многим» в службе таблиц, каждый со своими преимуществами и недостатками, которые могут иметь определенное значение в конкретном сценарии.  

Рассмотрим пример с крупной международной компанией, имеющей десятки тысяч сущностей отделов и сотрудников, где в каждом отделе работает множество сотрудников, каждый из которых, в свою очередь, связан с одним конкретным отделом. Первый подход заключается в хранении отдельных сущностей отделов и сотрудников, как показано ниже.  


![Хранение отдельных сущностей отделов и сотрудников](media/storage-table-design-guide/storage-table-design-IMAGE01.png)

В этом примере демонстрируется явное отношение «один-ко-многим» между типами на основе значения **PartitionKey** . В каждом отделе может работать много сотрудников.  

В этом примере также показана сущность отдела и связанные сущности сотрудников в одном разделе. Для разных типов сущностей можно выбрать использование разных разделов, таблиц или даже учетных записей хранилища.  

В качестве альтернативного подхода выступает денормализация данных и хранение только сущностей сотрудников с денормализованными данными отдела, как показано в следующем примере. В данном случае денормализованный подход может оказаться не лучшим вариантом, если присутствуют требования к возможности изменения сведений о руководителе отдела, поскольку для этого придется обновлять каждого сотрудника отдела.  

![Сущность сотрудника](media/storage-table-design-guide/storage-table-design-IMAGE02.png)

Дополнительные сведения см. в разделе [Шаблон денормализации](table-storage-design-patterns.md#denormalization-pattern).  

В следующей таблице приводятся преимущества и недостатки каждого из описанных выше подходов для хранения сущностей сотрудников и отделов, связанных отношением «один-ко-многим». Следует также учитывать планируемую частоту выполнения различных операций. В некоторых случаях допускается использование схемы с ресурсоемкой операцией, если только эта операция выполняется редко.  

<table>
<tr>
<th>Подход</th>
<th>Плюсы</th>
<th>Минусы</th>
</tr>
<tr>
<td>Отдельные типы сущностей, один раздел, одна таблица</td>
<td>
<ul>
<li>Сущность отдела можно обновить с помощью одной операции.</li>
<li>Вы можете использовать транзакцию группы сущностей * (транзакции группы СУЩНОСТЕЙ) для обеспечения согласованности, если при обновлении, вставке или удалении сущности Employee необходимо изменить сущность Department. Например, в случае поддержки осведомленности о количестве сотрудников в каждом отделе.</li>
</ul>
</td>
<td>
<ul>
<li>Для некоторых действий на стороне клиента может потребоваться получить сущность как сотрудника, так и отдела.</li>
<li>Операции хранения выполняются в одном разделе. При значительных объемах транзакций это может привести к формированию активной области.</li>
<li>Транзакции группы сущностей нельзя использовать для перемещения сотрудника в другой отдел.</li>
</ul>
</td>
</tr>
<tr>
<td>Отдельные типы сущностей, разные разделы или таблицы, или учетные записи хранилища</td>
<td>
<ul>
<li>Сущность отдела или сущность сотрудника можно обновить с помощью одной операции.</li>
<li>При значительных объемах транзакций это может помочь распределить нагрузку по нескольким разделам.</li>
</ul>
</td>
<td>
<ul>
<li>Для некоторых действий на стороне клиента может потребоваться получить сущность как сотрудника, так и отдела.</li>
<li>Транзакции группы сущностей нельзя использовать для обеспечения согласованности при обновлении, вставке или удалении сотрудника или обновлении отдела. Например, для обновления количества сотрудников в сущности отдела.</li>
<li>Транзакции группы сущностей нельзя использовать для перемещения сотрудника в другой отдел.</li>
</ul>
</td>
</tr>
<tr>
<td>Денормализация в один тип сущности</td>
<td>
<ul>
<li>Все необходимые данные можно извлечь с помощью одного запроса.</li>
</ul>
</td>
<td>
<ul>
<li>Если требуется обновить сведения об отделе (будет необходимо обновить всех сотрудников в отделе), обеспечение согласованности может оказаться ресурсоемким процессом.</li>
</ul>
</td>
</tr>
</table>

* Дополнительные сведения см. в разделе [транзакции группы сущностей](table-storage-design.md#entity-group-transactions) .  


Выбор подходящего варианта и определение наиболее значимых преимуществ и недостатков зависит от конкретных сценариев в приложении. Например, как часто выполняется изменение сущностей отдела? Всем ли запросам к сотрудникам требуются дополнительные сведения об отделе? Насколько близко вы подошли к показателям ограничения масштабируемости в разделах или учетной записи хранения?  

## <a name="one-to-one-relationships"></a>Отношения «один-к-одному»
В модель предметной области могут входить отношения между сущностями «один-к-одному». Чтобы реализовать отношение «один-к-одному» в службе таблиц, необходимо выбрать способ привязки двух связанных сущностей, если потребуется извлечь их обе. Эта связь может быть либо неявной (на основе соглашения в значениях ключа), либо явной с сохранением связи в форме значений **PartitionKey** и **RowKey** в каждой сущности. Сведения о необходимости хранения связанных сущностей в одном разделе см. в разделе [Отношения "один-ко-многим"](#one-to-many-relationships).  

Есть также ряд аспектов, которые могут привести к реализации отношений "один-к-одному" в службе таблиц.  

* Обработка больших сущностей (Дополнительные сведения см. в разделе [шаблон крупных сущностей](table-storage-design-patterns.md#large-entities-pattern)).  
* Внедрение средств управления доступом (см. раздел "Управление доступом с помощью подписей общего доступа").  

## <a name="join-in-the-client"></a>Присоединение клиента
Несмотря на то, что в службе таблиц существуют возможности моделирования, не следует забывать две основные причины использования службы таблиц — масштабируемость и производительность. Если вы считаете, что моделируете много отношений, которые приводят к ухудшению производительности и масштабируемости решения, стоит подумать о необходимости ввода всех взаимосвязей между данными в структуру таблицы. Необходимые операции присоединения, выполненные клиентским приложением, позволят упростить структуру и улучшить масштабируемость и производительность решения.  

Например, данные, которые содержатся в небольших таблицах и меняются не часто, можно извлекать по мере необходимости и кэшировать на стороне клиента. Это позволит избежать повторяющихся циклические операций по извлечению одних и тех же данных. В примерах, рассмотренных в данном руководстве, количество отделов в небольшой организации, вероятно, будет невысоким с нечастыми изменениями. В таком случае оптимален вариант, когда клиентское приложение один раз загружает данные и кэширует их.  

## <a name="inheritance-relationships"></a>Отношения наследования
Если клиентское приложение использует набор классов, которые являются частью наследственной связи для представления бизнес-сущностей, эти сущности можно сохранить в службе таблиц. Например, в клиентском приложении может быть определен следующий набор классов, где класс **Person** является абстрактным.

![Абстрактный класс Person](media/storage-table-design-guide/storage-table-design-IMAGE03.png)

Экземпляры двух конкретных классов можно сохранить в службе таблиц с помощью одной таблицы Person с сущностями, которые выглядят следующим образом.  

![Таблица Person](media/storage-table-design-guide/storage-table-design-IMAGE04.png)

Дополнительные сведения о работе с несколькими типами сущностей в одной таблице в клиентском коде см. в разделе "Работа с разными типами сущностей" в этом руководстве. Там приводятся примеры определения типа сущности в клиентском коде.  


## <a name="next-steps"></a>Дальнейшие действия

- [Шаблоны проектирования таблиц](table-storage-design-patterns.md)
- [Разработка для запросов](table-storage-design-for-query.md)
- [Шифрование данных таблиц](table-storage-design-encrypt-data.md)
- [Разработка для изменения данных](table-storage-design-for-modification.md)
